<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>域名失效问题</title>
      <link href="/posts/62729/"/>
      <url>/posts/62729/</url>
      
        <content type="html"><![CDATA[<p>本地source文件添加一个文件：CNAME文件(不要任何的后缀)</p><p>下一次hexo d 就会传上去</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub如何取消域名绑定</title>
      <link href="/posts/14830/"/>
      <url>/posts/14830/</url>
      
        <content type="html"><![CDATA[<p>删除本地source下的CNAME和GitHub上的CNAME文件<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121716990.png"></p><p>清楚浏览器缓冲<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121715979.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo如何创建短的url</title>
      <link href="/posts/15258/"/>
      <url>/posts/15258/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/rozbo/hexo-abbrlink2">GitHub - rozbo/hexo-abbrlink2</a></p><p>安装插件→添加config信息</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. 0-1背包理论基础(二滚动数组)</title>
      <link href="/posts/39517/"/>
      <url>/posts/39517/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度分析</title>
      <link href="/posts/30256/"/>
      <url>/posts/30256/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。<br>估计程序运行时间：通常会估算算法的<strong>操作单元数量</strong>来代表程序消耗的时间</p><blockquote><p>这里默认CPU的每个单元运行消耗的时间都是相同的。</p></blockquote><p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p><h2 id="1-2-大O"><a href="#1-2-大O" class="headerlink" title="1.2 大O"></a>1.2 大O</h2><p><strong>大O用来表示上界的</strong>，它作为算法的最坏情况运行时间的上界</p><p>我们主要关心的还是一般情况下的数据形式。</p><p><strong>面试中说道算法的时间复杂度是多少，指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p><h2 id="1-3-不同数据规模的差异"><a href="#1-3-不同数据规模的差异" class="headerlink" title="1.3 不同数据规模的差异"></a>1.3 不同数据规模的差异</h2><p><img src="https://img-blog.csdnimg.cn/20200728191447384.png" alt="时间复杂度，不同数据规模的差异"></p><p><strong>我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p><p><strong>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n<sup>^2</sup>)平方阶 &lt; O(n<sup>^3</sup>)立方阶 &lt; O(2<sup>^n</sup>)指数阶</strong></p><p>但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了<br>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）</p><h2 id="1-4-O-logn-中的log是以什么为底？"><a href="#1-4-O-logn-中的log是以什么为底？" class="headerlink" title="1.4 O(logn)中的log是以什么为底？"></a>1.4 O(logn)中的log是以什么为底？</h2><p><strong>logn，也就是忽略底数的描述</strong>。也可以是以10为底n的对数，也可以是以20为底n的对数，等等<br><code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code>。<br>而以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121533152.png" alt="|500"></p><h1 id="2-常见的时间复杂度"><a href="#2-常见的时间复杂度" class="headerlink" title="2 常见的时间复杂度"></a>2 常见的时间复杂度</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121507462.png" alt="|600"></p><p>快速排序：O(nlogn)</p><h1 id="3-例子"><a href="#3-例子" class="headerlink" title="3 例子"></a>3 例子</h1><h2 id="3-1-找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。"><a href="#3-1-找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。" class="headerlink" title="3.1 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。"></a>3.1 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。</h2><p>先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。</p><p>那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。</p><h2 id="3-2-01背包"><a href="#3-2-01背包" class="headerlink" title="3.2 01背包"></a>3.2 01背包</h2><p>暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">关于时间复杂度，你不知道的都在这里！ | 代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 算法性能分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.0-1背包理论基础</title>
      <link href="/posts/8980/"/>
      <url>/posts/8980/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p><h1 id="1-01-背包"><a href="#1-01-背包" class="headerlink" title="1 01 背包"></a>1 01 背包</h1><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题|600"></p><p>原始可用暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><h1 id="2-二维dp数组01背包"><a href="#2-二维dp数组01背包" class="headerlink" title="2 二维dp数组01背包"></a>2 二维dp数组01背包</h1><p>背包最大重量为4。<br>|       | 重量 | 价值 |<br>| —– | —- | —- |<br>| 物品0 | 1    | 15   |<br>| 物品1 | 3    | 20   |<br>| 物品2 | 4    | 30   |<br>问背包能背的物品最大价值是多少？</p><ol><li> 确定dp数组以及下标的含义<br>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1|600"></li></ol><p>有两个方向推出来<code>dp[i][j]</code>，</p><ul><li>  <strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>、<blockquote><p>(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</p></blockquote></li><li>  <strong>放物品i</strong>：<code>dp[i - 1][j - weight[i]] + value[i]</code></li></ul><p>所以递归公式： </p><p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code><br><code>dp[i][j]</code> 是由左上方数值推导出来</p><ol start="3"><li> dp数组如何初始化<br>二维数组初始化第一行和第一列，<code>dp[i][j]</code> 是由左上方数值推导出来的，剩下的全都可以推出来</li></ol><p>第一列：背包容量为0，一个也装不了，总价值当然为0<br>第一行：物品0的重量为1，所以背包容量&gt;1都可以装物品0一个，所以价值是15<br><img src="https://img-blog.csdnimg.cn/20210110103109140.png" alt="动态规划-背包问题7|600"><br>其余未赋值的都保持默认0即可，反正最后都会被覆盖掉<br>[[vector]]</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化 dp</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(weight.size(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>    dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li> 确定遍历顺序<br>有两个遍历的维度：物品与背包重量</li></ol><p><strong>先遍历 物品还是先遍历背包重量都可以</strong></p><p><strong>先遍历物品更好理解</strong>，如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>先遍历背包</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li> 举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_2_wei_bag_problem1</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagweight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 二维数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    }<br><br>    <span class="hljs-comment">// weight数组的大小 就是物品个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>        }<br>    }<br><br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_2_wei_bag_problem1</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85">Fetching Title#x3pv</a></p><p>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术蛋老师(git)</title>
      <link href="/posts/29642/"/>
      <url>/posts/29642/</url>
      
        <content type="html"><![CDATA[<p>文章简介：git 怎么用</p><span id="more"></span><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121133310.png"></p><p>先用git clone 与文件夹创建联系<a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=871.798444">14:31</a><br>git remote add origin <a href="https://gitee.com/liuqingzheng/test.git">https://gitee.com/liuqingzheng/test.git</a> 添加远程仓库<br>git remote -v 查看本地仓库与哪些远程仓库有联系 <a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=914.211131">15:14</a></p><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Git工作流和核心原理 | GitHub基本操作 | VS Code里使用Git和关联GitHub_哔哩哔哩_bilibili</a><br>自用跳转连接：🈚️</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.不同的二叉搜索树</title>
      <link href="/posts/45809/"/>
      <url>/posts/45809/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——96.不同的二叉搜索树</p><span id="more"></span><h1 id="1-96-不同的二叉搜索树"><a href="#1-96-不同的二叉搜索树" class="headerlink" title="1 96.不同的二叉搜索树"></a>1 96.不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接</a></p><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121031374.png"></p><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>[[二叉搜索树]]</p><p>五部曲</p><ol><li> 确定dp数组（dp table）以及下标的含义</li></ol><p>**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。</p><ol start="2"><li>确定递推公式<br>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121051970.png"></li></ol><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量<br>所以是<strong>求和</strong><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121103402.png"></p><ol start="3"><li><p>dp数组如何初始化<br>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树<br>dp[0] = 1<br>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p></li><li><p> 确定遍历顺序<br>顺序遍历<br>dp[i] += dp[j - 1] * dp[i - j]可以看出，<strong>节点数为i的状态是依靠 i之前节点数的状态</strong>。</p></li><li><p> 举例推导dp数组<br>n为5时候的dp数组状态如图：</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"><br>[[vector]]</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){ <span class="hljs-comment">// 从3开始赋值,如果没有上面的if就会 i = 3  ，i &lt;= 1，就错了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++){<span class="hljs-comment">// j从第二个数开始才能划分左右部分，所以是1</span><br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Qf4y1K72t?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode96题 不同的二叉搜索树_哔哩哔哩_bilibili</a><br><a href="https://www.programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.整数拆分</title>
      <link href="/posts/5255/"/>
      <url>/posts/5255/</url>
      
        <content type="html"><![CDATA[<h1 id="1-343-整数拆分"><a href="#1-343-整数拆分" class="headerlink" title="1 343.整数拆分"></a>1 343.整数拆分</h1><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接</a></p><p>给定一个正整数&nbsp;n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><ul><li>  输入: 2</li><li>  输出: 1</li><li>  解释: 2 = 1 + 1, 1 × 1 = 1。</li></ul><p>示例&nbsp;2:</p><ul><li>  输入: 10</li><li>  输出: 36</li><li>  解释: 10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。</li><li>  说明: 你可以假设&nbsp;n&nbsp;不小于 2 且不大于 58。</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><h2 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h2><p>将数的拆分想象成块的切分<br>2,3不切分，因为切分来会变小<br>如果不用去写dp初始值，可以在转移方程里面再加上一个和j * i-j的最大值比较<br>两个for循环是标准的动归写法</p><ol><li>确定dp数组（dp table）以及下标的含义<br>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</li><li>确定递推公式<br>下面这样写需要提前定义2,3不可拆定义出来他们的dp值，因为他俩不用拆是最大<br>dp[i] = max({dp[i],dp[j] * dp[i-j] );<br>dp[i]是随着i的值在一直变化的，max 中有dp[i]就是保证，不断变化中的值取最高的那一个<br>j是切的位置，把一个数切成两部分，而这左右两部分又可以在切。也就是dp[j]，dp[i-j]，也是默认将一个数强制拆成4份以及4份以上了。</li></ol><p>或者这样，不用提前定义dp[2]，dp[3]<br>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));<br>3. dp的初始化<br>dp[0] dp[1]无意义，没法拆，所以不赋值。从dp[2] = 1开始，把dp[3] = 2。<br>2，3不用拆是最大的</p><h2 id="2-2-贪心算法"><a href="#2-2-贪心算法" class="headerlink" title="2.2 贪心算法"></a>2.2 贪心算法</h2><p>数学已证明过：<strong>每次拆成n个3，如果剩下是4，则保留4，然后相乘</strong><br>尽量切3，最后切2，2和3是最稳定最稳定不可拆分质数</p><blockquote><p>1，2，3不划分最大，一划分反而变小了</p></blockquote><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><h2 id="3-1-动态规划"><a href="#3-1-动态规划" class="headerlink" title="3.1 动态规划"></a>3.1 动态规划</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){ <span class="hljs-comment">// 应该从数字4开始，对应的下标是5 </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){ <span class="hljs-comment">// 切一半就行，另一半是对称的</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j*(i-j), j*dp[i-j])); <span class="hljs-comment">// 后一个max中是数的相乘 和 数和上一次的最优结果相乘</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 2，3不切分，要这样赋值下面才能通过</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]*dp[i-j]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果递归公式是 dp[i] = max(dp[i], dp[i - j] * dp[j]);，就一定要这么初始化。递推公式没毛病，但初始化解释不通！</p><p>虽然代码在初始位置有一个判断if (n &lt;= 3) return 1 * (n - 1);，保证n&lt;=3 结果是正确的，但代码后面又要给dp[1]赋值1 和 dp[2] 赋值 2，<strong>这其实就是自相矛盾的代码，违背了dp[i]的定义！</strong></p><p>我举这个例子，其实就说做题的严谨性，上面这个代码也可以AC，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112130227.png"><br>// 错了的原因是dp[1]是0，必须定义dp[1] = 1,另外还有其他的原因</p><h2 id="3-2-贪心"><a href="#3-2-贪心" class="headerlink" title="3.2 贪心"></a>3.2 贪心</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 要有 = 4的判断，不然4的没法输出</span><br>                <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;，<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">4</span>){<br>            result *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        }<br>        <span class="hljs-keyword">return</span> result * n;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112032423.png"></p><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Nt4y1D7gh?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">LeetCode每日打卡.343.整数拆分_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.不同路径 II</title>
      <link href="/posts/13413/"/>
      <url>/posts/13413/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——63. 不同路径 II</p><span id="more"></span><h1 id="1-63-不同路径-II"><a href="#1-63-不同路径-II" class="headerlink" title="1 63.不同路径 II"></a>1 63.不同路径 II</h1><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑<strong>网格中有障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20210111204901338.png"></p><p><strong>网格中的障碍物和空位置分别用 1 和 0 来表示。</strong></p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210111204939971.png"></p><ul><li>  输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</li><li>  输出：2 解释：</li><li>  3x3 网格的正中间有一个障碍物。</li><li>从左上角到右下角一共有 2 条不同的路径：<ol><li> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/20210111205857918.png"></p><ul><li>  输入：obstacleGrid = [[0,1],[0,0]]</li><li>  输出：1</li></ul><p>提示：</p><ul><li>  m ==&nbsp;obstacleGrid.length</li><li>  n ==&nbsp;obstacleGrid[i].length</li><li>  1 &lt;= m, n &lt;= 100</li><li>  obstacleGrid[i][j] 为 0 或 1</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>相比[[6.不同路径]]不同的是多了障碍，遇到障碍<code>dp[i][j]</code>保持0就可以了：表示过不去</p><p>两个地方需要跳过赋值</p><ol><li>初始值(第一行第一列)，跳过有障碍的地方在赋值</li><li>递推公式中(除了第一行第一列的)，跳过有障碍的地方在赋值</li></ol><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[j][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">0</span>){ <span class="hljs-comment">// if (obstacleGrid[i][j] == 1) continue;</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.不同路径</title>
      <link href="/posts/31702/"/>
      <url>/posts/31702/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——62.不同路径</p><span id="more"></span><h1 id="1-62-不同路径"><a href="#1-62-不同路径" class="headerlink" title="1 62.不同路径"></a>1 62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p><p>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png"></p><ul><li>  输入：m = 3, n = 7</li><li>  输出：28</li></ul><p>示例 2：</p><ul><li>  输入：m = 2, n = 3</li><li>  输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li> 向右 -&gt; 向右 -&gt; 向下</li><li> 向右 -&gt; 向下 -&gt; 向右</li><li> 向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>  输入：m = 7, n = 3</li><li>  输出：28</li></ul><p>示例 4：</p><ul><li>  输入：m = 3, n = 3</li><li>  输出：6</li></ul><p>提示：</p><ul><li>  1 &lt;= m, n &lt;= 100</li><li>  题目数据保证答案小于等于 2 * 10^9</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><h2 id="2-1-图论"><a href="#2-1-图论" class="headerlink" title="2.1 图论"></a>2.1 图论</h2><p>暂定</p><h2 id="2-2-数论"><a href="#2-2-数论" class="headerlink" title="2.2 数论"></a>2.2 数论</h2><p>暂定</p><h2 id="2-3-动态规划"><a href="#2-3-动态规划" class="headerlink" title="2.3 动态规划"></a>2.3 动态规划</h2><p>m✖️n：行✖️列<br>按照动规五部曲来分析：</p><ol><li>确定dp数组（dp table）以及下标的含义<br><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。</li><li>确定递推公式<br>机器人只能向下或向右移动<br>所以<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。(上面，左面)<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为只能从上面或者左面过来</li><li> dp数组的初始化<br>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。<br>所以初始化代码为：<figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure></li><li> 确定遍历顺序<br>这里要看一下递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套</li></ol><p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p><ol start="5"><li> 举例推导dp数组</li></ol><p>如图所示：<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[2][2] = dp[1][2] + dp[2][1]</code>，<code>dp[3][7] = dp[2][7] + dp[3][6]</code> 上面/左面<br><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><h2 id="3-1-二维数组解法，编译已通过"><a href="#3-1-二维数组解法，编译已通过" class="headerlink" title="3.1 二维数组解法，编译已通过"></a>3.1 二维数组解法，编译已通过</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){ <span class="hljs-comment">// 从(1,1)开始的</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>              dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>          }<br>      }<br>      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 因为下标从0开始，所以-1</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="3-2-一维数组暂定"><a href="#3-2-一维数组暂定" class="headerlink" title="3.2 一维数组暂定"></a>3.2 一维数组暂定</h2><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.使用最小花费爬楼梯</title>
      <link href="/posts/27967/"/>
      <url>/posts/27967/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解—— 746. 使用最小花费爬楼梯</p><span id="more"></span><h1 id="1-使用最小花费爬楼梯"><a href="#1-使用最小花费爬楼梯" class="headerlink" title="1 使用最小花费爬楼梯"></a>1 使用最小花费爬楼梯</h1><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接</a></p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值&nbsp;cost[i]（下标从 0 开始）。</p><p><strong>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</strong></p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例&nbsp;1：</p><p>输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 &nbsp;示例 2：</p><blockquote><p>第一次不要钱，爬上了15，支付15后可以爬一层到楼顶，那我从10开始支付10爬两层不是更好吗</p></blockquote><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>提示：</p><ul><li>  cost 的长度范围是 [2, 1000]。</li><li>  cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p><strong>注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong></p><p>动归五部曲</p><p><font color="#F36208">1.  确定dp数组以及下标的含义</font><br>**dp[i]的定义：到达第i个台阶所花费的最<br>少体力为dp[i]**。<br>注意这里认为是第一步一定是要花费：<br>    dp[0] = cost[0];<br>    dp[1] = cost[1];<br>    <strong>dp[2] = min(dp[0], dp[1]) + cost[2];</strong><br><font color="#F36208">2.  确定递推公式</font><br>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p><blockquote><p>一旦支付当前下边相应的体力值，就可向上爬一个或者两个楼梯</p></blockquote><p><strong>dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</strong><br>爬上台阶i，可能是从 i - 1 层，i-2层爬上来的，然后在离开台阶i 又在需要花费cost[i]<br><font color="#F36208">3. dp数组初始化</font><br>题目说：可以选择从下标为 0 或 1 的元素作为初始阶梯。<br>从下标0处离开需要cost[0]，下标1同理</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br></code></pre></td></tr></tbody></table></figure><p><font color="#F36208">4. 遍历顺序</font><br>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。<br><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。<br><font color="#F36208">5. 举例推导dp数组</font><br>| cost  | 10  | 15  | 20  |<br>| —– | — | — | — |<br>| dp[i] | 10  | 15  | 30  |<br>|       |     |     |     |<br><img src="https://img-blog.csdnimg.cn/2021010621363669.png" alt="746.使用最小花费爬楼梯"><br>为什么选择最后两位的最小值呢<br>?<br>最后两位支付该值都可以到下一层，假设所求是第N层的最小开销，只需要计算min(谁能到N层)，到了N层后又不到下一层，所以相当于最后一步不用花费，就停止到那了，不用+cost[i]</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++){<span class="hljs-comment">// 这里不用&lt;=，因为下标从0开始，取不到cost.size()||从第三个元素开始，下标是2</span><br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[cost.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>], dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1fq4y1T7Uo?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode-746.使用最小花费爬楼梯_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.爬楼梯</title>
      <link href="/posts/34749/"/>
      <url>/posts/34749/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——70. 爬楼梯</p><span id="more"></span><h1 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1 爬楼梯"></a>1 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。<strong>你有多少种不同的方法</strong>可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><ul><li>  输入： 2</li><li>  输出： 2</li><li>解释： 有两种方法可以爬到楼顶。<ul><li>  1 阶 + 1 阶</li><li>  2 阶</li></ul></li></ul><p>示例 2：</p><ul><li>  输入： 3</li><li>  输出： 3</li><li>解释： 有三种方法可以爬到楼顶。<ul><li>  1 阶 + 1 阶 + 1 阶</li><li>  1 阶 + 2 阶</li><li>  2 阶 + 1 阶</li></ul></li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。<br>    爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。<br>    第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。<br>    dp[3] = dp[2] + dp[1] = 2+1 =3</p><p>动归五部曲：</p><ol><li> 确定dp数组以及下标的含义<br>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li><li> 确定递推公式<br>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。<br>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么<br>dp[i] = dp[i - 1] + dp[i - 2] 。</li><li>dp数组如何初始化<br>不考虑dp[0]，dp[1] = 1， dp[2] = 2<blockquote><p>dp[0]没有意义，i从3 开始递推</p></blockquote></li><li> 确定遍历顺序<br>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</li><li> 举推导dp数组<br>举例当n为5的时候，dp table（dp数组）应该是这样的<br><img src="https://img-blog.csdnimg.cn/20210105202546299.png" alt="70.爬楼梯"><blockquote><p>本质就是斐波那契数列，就是没有讨论dp[0] 的情况</p></blockquote></li></ol><p>#面试<br>有的题解是把dp[0]初始化为1，然后遍历的时候i从2开始遍历，这样是可以解题的，然后强行解释一波dp[0]应该等于1的含义。<br>一个严谨的思考过程，应该是初始化dp[1] = 1，dp[2] = 2，然后i从3开始遍历，<br>这个可以是面试的一个小问题，考察候选人对dp[i]定义的理解程度。</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>优化一下空间复杂度</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">2</span>] + dp [<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">2</span>] = sum;<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>]; <br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-加强版爬楼梯"><a href="#4-加强版爬楼梯" class="headerlink" title="4 加强版爬楼梯"></a>4 加强版爬楼梯</h1><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 把m换成2，就可以AC爬楼梯这道题</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试，哈哈</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。</p><p>我在<a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html">通过一道面试题目，讲一讲递归算法的时间复杂度！</a><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html"></a><br>中，以我自己面试别人的真实经历，通过求x的n次方 这么简单的题目，就可以考察候选人对算法性能以及递归的理解深度，录友们可以看看，绝对有收获！</p><h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h1><p><a href="https://www.programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.斐波那契数</title>
      <link href="/posts/33325/"/>
      <url>/posts/33325/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode 题解 ——509. 斐波那契数</p><span id="more"></span><h1 id="1-509-斐波那契数"><a href="#1-509-斐波那契数" class="headerlink" title="1 509. 斐波那契数"></a>1 509. 斐波那契数</h1><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接</a></p><p>斐波那契数，通常用&nbsp;F(n) 表示，形成的序列称为 斐波那契数列 。该数列由&nbsp;0 和 1 开始，<strong>后面的每一项数字都是前面两项数字的和</strong>。也就是： F(0) = 0，F(1)&nbsp;= 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1：</p><ul><li>  输入：2</li><li>  输出：1</li><li>  解释：F(2) = F(1) + F(0) = 1 + 0 = 1</li></ul><p>示例 2：</p><ul><li>  输入：3</li><li>  输出：2</li><li>  解释：F(3) = F(2) + F(1) = 1 + 1 = 2</li></ul><p>示例 3：</p><ul><li>  输入：4</li><li>  输出：3</li><li>  解释：F(4) = F(3) + F(2) = 2 + 1 = 3</li></ul><p>提示：</p><ul><li>  0 &lt;= n &lt;= 30</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li> 确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li> 确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><ol start="3"><li> dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li> 确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li> 举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 因为下标从0开始，要总长度所以+1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++){ <span class="hljs-comment">// 是≤，要把n也算上，因为最后输出的是n</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<span class="hljs-comment">// vector的返回和使用都要用[]</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=9fc19dba-4edb-4f3d-8d7e-22b7c2462fc7">obsidian</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.动态规划理论基础</title>
      <link href="/posts/31294/"/>
      <url>/posts/31294/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p>动态规划，英文：Dynamic Programming，简称DP<br><strong>动态规划中每一个状态一定是由上一个状态推导出来的</strong>，贪心是局部最优推导全局最优</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><h1 id="1-动态规划解题步骤"><a href="#1-动态规划解题步骤" class="headerlink" title="1 动态规划解题步骤"></a>1 动态规划解题步骤</h1><ol><li> 确定dp数组（dp table）以及下标的含义</li><li> 确定递推公式</li><li> dp数组如何初始化</li><li> 确定遍历顺序</li><li> 举例推导dp数组</li></ol><p><strong>一些情况是递推公式决定了dp数组要如何初始化！</strong></p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。<br>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。<br><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><h2 id="1-1-debug"><a href="#1-1-debug" class="headerlink" title="1.1 debug"></a>1.1 debug</h2><p><strong>如果代码写出来了，一直AC不了，灵魂三问：</strong></p><ol><li> 这道题目我举例推导状态转移公式了么？</li><li> 我打印dp数组的日志了么？</li><li> 打印出来了dp数组和我想的一样么？</li></ol><p>哈哈，专治各种代码写出来了但AC不了的疑难杂症。</p><h1 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2 参考资料"></a>2 参考资料</h1><p><a href="https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">代码随想录</a><br>自用跳转连接：🈚️</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24.监控二叉树</title>
      <link href="/posts/43575/"/>
      <url>/posts/43575/</url>
      
        <content type="html"><![CDATA[<p>文章简介：968.监控二叉树</p><span id="more"></span><h1 id="1-968-监控二叉树"><a href="#1-968-监控二叉树" class="headerlink" title="1 968.监控二叉树"></a>1 968.监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20201229175736596.png"></p><ul><li>  输入：[0,0,null,0,0]</li><li>  输出：1</li><li>  解释：如图所示，一台摄像头足以监控所有节点。</li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/2020122917584449.png"></p><ul><li>  输入：[0,0,null,0,null,0,null,null,0]</li><li>  输出：2</li><li>  解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</li></ul><p>提示：</p><ul><li>  给定树的节点数的范围是 [1, 1000]。</li><li>  <strong>每个节点的值都是 0</strong>。</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>为什么不从头结点开始看起呢，为啥要从叶子节点看呢<br>?<br>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。<br><strong>局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，<br>整体最优：全部摄像头数量所用最少！</strong></p><p>大体思路就是：从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点</p><p>每个节点可能有几种状态：<br>有如下三种：</p><ul><li>  该节点无覆盖</li><li>  本节点有摄像头</li><li>  本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>  0：该节点无覆盖</li><li>  1：本节点有摄像头</li><li>  2：本节点有覆盖</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051425661.png"></p><h1 id="3-参考资料"><a href="#3-参考资料" class="headerlink" title="3 参考资料"></a>3 参考资料</h1><p><a href="https://www.programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转连接：🈚️</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验设计</title>
      <link href="/posts/65372/"/>
      <url>/posts/65372/</url>
      
        <content type="html"><![CDATA[<p>镁合金设置温度分布<br>挤压角度：100°，110，120，130，140</p><blockquote><p>110， 120 的圆盘成形效果最好，140的圆棒成形效果最好<br>因为110°的倾角小</p></blockquote><p>![[实验设计 2022-07-09 16.42.40.excalidraw|600]]</p><p>华南理工的统一认证账号是哪个啊<br>我现在有16个镁合金圆棒<br>7月份的实验</p><ul><li><p>控制角度变温度</p><ul><li>110°挤压块性能最好 100°→400°的做7个</li><li>120°挤压块同理7个</li><li>在做一个无加热的，对比实验，主要是拍照片</li><li>综上测出性能最好的角度和温度，确定好最合适的温度</li></ul></li><li><p>控制温度变角度</p><ul><li>先确定一个最合适的温度</li><li>在用该温度做其他挤压块的角度 (5个：100°→140°)</li></ul></li></ul><hr><p>试验温度为室温和100, 150, 200, 250, 300, 350, 400 ℃<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[1]</span></a></sup><br>200°时，得到最好的性能</p><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/F62253DC-5296-4BB8-A7BF-97F9BD2553CF">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23.买卖股票的最佳时机含手续费</title>
      <link href="/posts/9689/"/>
      <url>/posts/9689/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>    力扣题解：714. 买卖股票的最佳时机含手续费</p><span id="more"></span><h1 id="1-买卖股票的最佳时机含手续费"><a href="#1-买卖股票的最佳时机含手续费" class="headerlink" title="1 买卖股票的最佳时机含手续费"></a>1 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接</a></p><p>给定一个整数数组&nbsp;prices，其中第&nbsp;i&nbsp;个元素代表了第&nbsp;i&nbsp;天的股票价格 ；非负整数&nbsp;fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。<strong>如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</strong></p><p><strong>返回获得利润的最大值。</strong></p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><blockquote><p>相当于买入和卖出</p></blockquote><p>示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8</p><p>解释: 能够达到的最大利润: 在此处买入&nbsp;prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润:&nbsp;((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p><p>注意:</p><ul><li>  0 &lt; prices.length &lt;= 50000.</li><li>  0 &lt; prices[i] &lt; 50000.</li><li>  0 &lt;= fee &lt; 50000.</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><h2 id="2-1-6-买卖股票的最佳时机II"><a href="#2-1-6-买卖股票的最佳时机II" class="headerlink" title="2.1 [[6. 买卖股票的最佳时机II]]"></a>2.1 [[6. 买卖股票的最佳时机II]]</h2><p>![[6. 买卖股票的最佳时机II#2 思路]]<br>与 6的区别是多了个手续费<br>有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。<br>用贪心策略，就是最低值买，最高值（减去手续费还盈利）就卖。</p><p>找到两个点</p><ul><li>  买入日期：其实很好想，遇到更低点就记录一下。</li><li>  卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li></ul><p>做收获利润操作的时候其实有三种情况：</p><ul><li>  情况一：收获利润的这一天并不是收获利润区间里的最后一天（<strong>不是真正的卖出，相当于持有股票</strong>），所以后面要继续收获利润。</li><li>  情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>  情况三：不作操作，保持原有状态（买入，卖出，不买不卖）<h3 id="2-1-1-思路总结"><a href="#2-1-1-思路总结" class="headerlink" title="2.1.1 思路总结"></a>2.1.1 思路总结</h3></li></ul><ol><li>不断的寻找最低点，在最低点时买入</li><li>寻找有利润的时候买入，更新下一次的买入位置在循环卖出</li><li>对所有利润加和</li></ol><h2 id="2-2-断点调试"><a href="#2-2-断点调试" class="headerlink" title="2.2 断点调试"></a>2.2 断点调试</h2><p><a href="file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4">23.买卖股票的最佳时机含手续费</a></p><p><a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=10.471542">00:10</a> 情况三：现在的价格不是最低的，并且卖出的话亏本</p><p><a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=28.795416">00:28</a><br>#疑问 #已解决<br>为什么要minPrice = prices[i]- fee呢，如果去掉了- fee 则结果不对<br><del>因为在该下标处已经交过了一次手续费，不需要在交了？？？</del></p><p>输入：prices = [1,3,7,5,10,3], fee = 3<br>输出：6<br>相当于：1时买入，10时卖出(10-1-3 = 6)<br>并不是：1时买入，7时卖出，5时买入，10时卖出(7-1-3  +  10 - 5 -3 = 5)<br>minprice = price[i] - fee  有正利润就假装卖了，先收集利润，- fee 的作用是如果后边的还有利润更高的，则这次其实是不卖的<br>eg：7时有正利润的先收集起来(7-1-3=3)<br>但此时的minPrice = 7-3  =&nbsp;4， 4是后边的最小的，接下来的利润是10-4-3= 3<br>总利润就是3+3 = 6，而不是像上边计算的5，这个作用就是，看似在7处卖了，实际没卖，最后是在10的位置卖的</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =&nbsp;<span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];<br>            <span class="hljs-keyword">if</span> (prices[i] &gt; minPrice &amp;&amp; prices[i] - minPrice - fee &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (prices[i] - minPrice - fee &gt; <span class="hljs-number">0</span>){<br>                result += prices[i] -minPrice - fee;<br>                minPrice = prices[i] - fee; <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-知识点"><a href="#4-知识点" class="headerlink" title="4 知识点"></a>4 知识点</h1><p>[[continue]]</p><h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22.单调递增的数字</title>
      <link href="/posts/17411/"/>
      <url>/posts/17411/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>    力扣题解： 738.单调递增的数字</p><span id="more"></span><h1 id="1-738-单调递增的数字"><a href="#1-738-单调递增的数字" class="headerlink" title="1 738.单调递增的数字"></a>1 738.单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接</a></p><p>给定一个非负整数&nbsp;N，找出小于或等于&nbsp;N&nbsp;的最大的<strong>整数</strong>，同时这个整数需要满足其<strong>各个位数上</strong>的数字是单调递增。</p><p>（当且仅当每<strong>个相邻位数上的数字&nbsp;x&nbsp;和&nbsp;y&nbsp;满足&nbsp;x &lt;= y</strong>&nbsp;时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>  输入: N = 10</li><li>  输出: 9</li></ul><p>示例 2:</p><ul><li>  输入: N = 1234</li><li>  输出: 1234</li></ul><p>示例 3:</p><ul><li>  输入: N = 332</li><li>  输出: 299</li></ul><p>说明: N&nbsp;是在&nbsp;[0, 10^9]&nbsp;范围内的一个整数。</p><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>找≤ N，的最大单增的整数<br>如果不递增，就把除最后一位每一位都减1，这样保证了减过数比原数小。然后在把除了第一个位(因为第一个位最大不能变，变了会使得比原来的数大)，后边的位数全部令为9，这样就得到了最大的整数。<br>代码：一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9</p><p>例如<br>332 → 222→299<br>753 → 643 → 699</p><h2 id="2-1-断点调试"><a href="#2-1-断点调试" class="headerlink" title="2.1 断点调试"></a>2.1 断点调试</h2><p><a href="file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl).mp4">22.单调递增的数字(carl:332).mp4</a><br><a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=7.519521">00:07</a> 前一个数大于后一个数则让前一个数减1</p><blockquote><p>从后往前遍历，for (i = num.size () - 1; i &gt; 0; i–) [[for 循环]]</p></blockquote><p>flag至少是1，因为i 不会取到0。这样就报证了至少从第二个2数开始赋9，直到到最后一个数</p><p><a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=10.337641">00:10</a> 只需要减1的原因是：让他的每一个位都比原来的数小，在把除了第一个位(因为第一个位最大)，后边的位数全部令为9，这样就得到了最大的整数</p><p><a href="file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl:1234).mp4">22.单调递增的数字(carl/1234)</a><br>    1234 本身都是递增的，所以第一个for循环会跳过，第二for循环也不会执行</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        string strNum = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>() ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--){<br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>]&gt; strNum[i]){<br>                flag = i;<br>                strNum[i<span class="hljs-number">-1</span>]--;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++){<br>            strNum[i] = <span class="hljs-string">'9'</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span> (strNum);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>stoi函数 #flashcards/代码随想录<br>?<br>将数字字符串转为数字：”2147482” → 2147482</p><!--SR:!2022-07-07,3,250--><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">代码随想录</a><br>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=49dde99d-8015-4224-9c0b-96d9d0dae41a">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>材料内部结构</title>
      <link href="/posts/65236/"/>
      <url>/posts/65236/</url>
      
        <content type="html"><![CDATA[<p>滑移性能最好的晶格为：面心立方 &gt; 体心立方 &gt; 密排六方 </p><blockquote><p>(塑性性能指标)</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206281433535.png"></p><blockquote><p>BCC是体心立方，上边写错了</p></blockquote><p>面心立方材料：铝（Al）、铜（Cu）、镍（Ni）、金（Au）、银（Ag）、γ-铁（γ-Fe,912℃~1394℃)</p><p>密排六方材料：Mg， Zn，铍<br>镁合金等密排六方晶格金属在 250~400℃之间成形,密排六方(hcp)金属滑移系少,主要靠孪生变形</p><p>V体：Fe Cr Mo</p><blockquote><p>V体是什么，等查一查</p></blockquote><p>自用跳转连接：<a href="marginnote3app://note/D9087A24-CEF0-4136-B1D1-42F789B404D2">黄珍媛老师</a>，<a href="marginnote3app://note/40F63EDC-2FA9-46FE-BC55-141C72946015">夏琴香老师讲塑性变形</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=b9ec2231-bc80-4831-9b86-5e112ada3bfb">ob</a>，<a href="http://localhost:4000/2022/06/28/ke-yan/cai-liao-nei-bu-jie-gou/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代制造工程</title>
      <link href="/posts/64386/"/>
      <url>/posts/64386/</url>
      
        <content type="html"><![CDATA[<p>[[现代制造工程–周驰]]</p><p><strong>2022-06-29(后记)：</strong></p><p><strong>简答题</strong>：5 * 5  =25</p><ol><li><p>电火花的原理是什么，不可缺少什么，适用于什么材料。</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291624610.png" alt="|600"></li></ol></li><li><p>化学沉积和物理沉积的定义与区别</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291626815.png" alt="|600"></li></ol></li><li><p>画个六点定位原理图</p></li><li><p>坐标变换(周驰作业题)</p></li><li><p>金属材料加热发生的变化(答5点)</p></li></ol><p><strong>辨析题</strong>：15+15 = 30</p><ol><li><p>从“生产规模，资源配置，生产技术”三方面来说现代制造工程的发展</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291622155.png" alt="|600"></li></ol></li><li><p>金属塑性成形的两种方式，冷塑性对金属材料内部和性能的影响</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291623008.png" alt="|600"></li></ol></li></ol><p>其余的都是选择(20个 1.5分)和判断(15个 15分)</p><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>notion函数详解</title>
      <link href="/posts/49277/"/>
      <url>/posts/49277/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.csdn.net/tags/NtzaggysMDE2OTctYmxvZwO0O0OO0O0O.html">notion多条件formula - CSDN</a></p><h1 id="1-一、属性（列名-properties）"><a href="#1-一、属性（列名-properties）" class="headerlink" title="1 一、属性（列名-properties）"></a>1 一、属性（列名-properties）</h1><ol><li>prop(“属性”) 返回每个条目的“属性值”，点击即可用对应的格式插入到公式中。</li><li>公式中的四种方式 四 种 格 式 { 数 字 日 期 字 符 串 复 选 框 四种格式\begin{cases} 数字 &amp; \ 日期 &amp; \字符串 &amp;\复选框 &amp; \end{cases} 四种格式⎩⎪⎪⎪⎨⎪⎪⎪⎧​数字日期字符串复选框​​</li></ol><p>floor((prop(“小时”) + prop(“分钟”) / 60) * 100) / 100</p><h1 id="2-二、常量（constants）"><a href="#2-二、常量（constants）" class="headerlink" title="2 二、常量（constants）"></a>2 二、常量（constants）</h1><p>常 量 { e 自 然 对 数 的 底 数 p i 圆 周 率 t r u e 真 f l a s e 假 常量\begin{cases} e &amp;自然对数的底数 \ pi &amp;圆周率 \true &amp;真\flase &amp;假 \end{cases} 常量⎩⎪⎪⎪⎨⎪⎪⎪⎧​epitrueflase​自然对数的底数圆周率真假​</p><h1 id="3-三、基本运算"><a href="#3-三、基本运算" class="headerlink" title="3 三、基本运算"></a>3 三、基本运算</h1><ol><li>if语法（“<code>if</code>”）：进行条件判断，在两个选项（要为同一格式）中选择一个。 语法：<ul><li>  <code>boolean?value:value</code></li><li>  <code>if(boolean,value,value)</code></li></ul> 补充：在”boolean”不能填写0或者1；value中，true（真）为1，false（假）为0；</li><li>加法（”<code>+</code>“或”<code>add</code>“）：把两个数字或字符串相加，并返回它们的值 语法：<ul><li>  <code>value+value</code></li><li>  <code>add(value,value)</code></li></ul> 说明：value可以是数字或字符串，为字符串时要加上双引号</li><li>减法（”<code>-</code>“或“<code>subtract</code>”）：将两个数字相减，并返回它们的值 语法：<ul><li>  <code>number-number</code></li><li>  <code>subtract(number,number)</code></li></ul></li><li>乘法（”<code>*</code>“或“<code>multiply</code>”）：将两个数字相乘，并返回它们的值 语法：<ul><li>  <code>number*number</code></li><li>  <code>multiply(number,number)</code></li></ul></li><li>除法（”<code>/</code> “或”<code>divide</code>“）：将两个数字相乘，并返回他们的值 语法：<ul><li>  <code>number/number</code></li><li>  <code>divide(number,number)</code></li></ul></li><li>绝对值（”<code>abs</code>“）：返回数的绝对值 语法：<code>abs(number)</code></li><li>求余运算（”<code>%</code>“或”<code>mod</code>“）：把两个数进行求余运算，并返回它们的值 语法：<ul><li>  <code>number%number</code></li><li>  <code>mod(number,number)</code></li></ul></li><li>”四舍五入“（”<code>round</code>“）：对数字进行”四舍五入“ 语法：<code>round(number)</code> 说明：默认情况下只保留整数。要保留n位小数时，应使用 r o u n d ( n u m b e r ∗ 1 0 n ) / 1 0 n round(number*10^n)/10^n round(number∗10n)/10n</li><li>一元负数（”<code>unaryminus</code>“或“<code>-</code>”）：对一个数进行取它的负数 语法： <code>-number</code> <code>unaryminus(number)</code> 如：-3==unaryminus(3)</li><li> 一元加号（“<code>+</code>”或“<code>unaryPlus</code>”）：将参数转化为数字。</li></ol><pre><code class="hljs">语法：`+value``unaryPlus(value)`补充：可以将true转化为1，false转化为0</code></pre><h1 id="4-四、关系逻辑判断"><a href="#4-四、关系逻辑判断" class="headerlink" title="4 四、关系逻辑判断"></a>4 四、关系逻辑判断</h1><ol><li>关系判断<ul><li>  大于 &gt;</li><li>  小于 &lt;</li><li>  等于 ==</li><li>  大于等于 &gt;=</li><li>  小于等于 &lt;=</li><li>  不等于 !=</li></ul></li><li>逻辑判断<ul><li>逻辑“<code>非</code>”：对逻辑参数进行否定  语法：  <code>not boolean</code>  <code>not (boolean)</code></li><li>逻辑“<code>与</code>”：对逻辑参数进行“与”运算，<code>“一假全假”</code>  语法：  <code>boolean and boolean</code>  <code>and(boolean,boolean)</code></li><li>逻辑“或”：对逻辑参数进行“或”运算，<code>“一真全真”</code>  语法：  <code>boolean or boolean</code>  <code>or(boolean,boolean)</code></li></ul></li></ol><h1 id="5-五、字符串函数"><a href="#5-五、字符串函数" class="headerlink" title="5 五、字符串函数"></a>5 五、字符串函数</h1><ol><li>连接函数（“<code>concat</code>”）：将字符串进行连接 语法： <code>concat(text...)</code> <code>text+text+...</code></li><li>插符函数（“<code>join</code>”）：插入字符函数，在其余叁数之间插入第一个参数并返回它们的连接字符串 语法：<code>join(text...)</code> 例如：join(“-“,“a”,“b”,“c”)==“a-b-c”</li><li>切片函数（”<code>slice</code>“）：从字符串中提取子字符串（包括开头索引，不包括结尾索引[start,end)） 语法：<ul><li>  <code>slice(text,number)</code></li><li>  <code>slice(text,number1,number2)</code></li></ul> 说明:只有一个数字时，就是从这个索引数字开始到结束；当有两个数字时（第二个数要大于第一个数，不然不会显示），从字符串中提取子字符串，包含开头索引，不包含结束索引。 注意：字符串的索引值是从0开始的</li><li>长度函数（”<code>length</code>“）：返回字符串的长度，返回值是一个数值。 语法：<code>length(text)</code></li><li>转化函数（”<code>format</code>“）：将其他格式的参数转化为字符串。 语法：<code>format(value)</code></li><li>转化函数（”<code>toNumber</code>“）：将其他格式的参数转化数字 语法：<code>toNumber(value)</code> 说明：<ul><li>  可以把字符串类型转化为数字，如：”123”到数字123</li><li>  可以把日期类型转化时间戳，Jan 18, 2021 7:28 PM→1610969340000</li><li>  可以把复选框类型转化为数字，true为1，false为0</li><li>  也可以把数字类型转化为数字</li></ul></li><li>包含判断函数（”<code>contains</code>“）：包含判断函数，返回一个boolean值， 语法：<code>contains(text1,text2)</code> 说明：如果text1中包含text2，则返回true；反之，返回false</li><li>替代函数：<ul><li>“<code>replace</code>”：用新值替换正则表达式的第一个匹配项  语法：<code>replace(number/text/boolean,text1,text2)</code>  说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</li><li>“<code>replaceAll</code>”：用新值代替正则表达式的所有匹配项  语法：<code>replaceAll(number/text/boolean,text1,text2)</code>  说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</li></ul></li><li>检验函数（“<code>test</code>”）：判断一个字符串是否与正则表达式匹配，返回一个boolean值 语法：<code>test(number/text/boolean,text)</code></li><li> “验空”函数（”<code>empty</code>“）：判断一个值是否为空</li></ol><pre><code class="hljs">语法：`empty(number/text/boolean/date)`说明：默认情况下，数字为0表示空，字符串以""表示空值，boolean值以false表示空值</code></pre><h1 id="6-六、数学函数"><a href="#6-六、数学函数" class="headerlink" title="6 六、数学函数"></a>6 六、数学函数</h1><ol><li>绝对值函数（“<code>abs</code>”)：返回一个数的绝对值 语法：<code>abs(number)</code></li><li>开算术平方根运算（”<code>sqrt</code>“）：返回一个数的算术平方根 语法：<code>sqrt(number)</code> 说明：number要为非负数</li><li>开立方根（”<code>cbrt</code>“)：返回一个数的立方根 语法：<code>cbrt(number)</code></li><li>幂次运算（”<code>^</code>“或”<code>pow</code>“）：将两个数字进行指数运算，并返回它们的值 语法：<ul><li>  <code>number^number</code></li><li>  <code>pow(number,number)</code></li></ul> 补充: 自然指数运算（”<code>exp</code>“）：返回e^x的值，其中x为参数，e为常数 语法：<code>exp(number)</code></li><li>对数运算：notion目前只支持三种对数运算 三 种 对 数 运 算 { l n ( n u m b e r ) 返 回 一 个 数 的 自 然 对 数 l o g 10 ( n u m b e r ) 返 回 这 个 数 以 10 为 底 对 数 的 值 l o g 2 ( n u m b e r ) 返 回 这 个 数 以 2 为 底 对 数 的 值 三种对数运算\begin{cases}ln(number) &amp;返回一个数的自然对数\log_{10}(number)&amp;返回这个数以10为底对数的值\log_2(number) &amp;返回这个数以2为底对数的值\end{cases} 三种对数运算⎩⎪⎨⎪⎧​ln(number)log10​(number)log2​(number)​返回一个数的自然对数返回这个数以10为底对数的值返回这个数以2为底对数的值​</li><li>向上取整函数（“<code>ceil</code>”）：返回大于或等于这个数字的最小整数 语法：<code>ceil(number)</code></li><li>向下取整函数（“<code>floor</code>”）：返回小于或等于这个数字的最大整数 语法：<code>floor(number)</code></li><li>最大/小值函数<ul><li>最大值函数（“<code>max</code>”）：返回数的最大值  语法：<code>max(number1,number2,...)</code></li><li>最小值函数（“<code>min</code>”）：返回数的最小值  语法：<code>min(number1,number2,...)</code></li></ul></li><li>符号函数（“<code>sign</code>”）：返回数的符号，指明数的符号是为正、负或零 语法：<code>sign(number)</code> 说明：数字为正时，返回1；数字为负时，返回-1；数字为0时，返回0</li></ol><h1 id="7-七、日期函数"><a href="#7-七、日期函数" class="headerlink" title="7 七、日期函数"></a>7 七、日期函数</h1><ol><li>返回时间差函数（<code>dateBetween</code>）：返回两个日期之间的时间差，返回值是一个数字。 语法：<code>dateBetween(date,date,text)</code> 说明：<code>date</code>表示日期；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。 t e x t 的 取 值 类 型 { “ y e a r s “ 表 示 以 “ 年 ” 为 基 本 单 位 “ q u a r t e r s “ 表 示 以 “ 季 ” 为 基 本 单 位 “ m o n t h s “ 表 示 以 “ 月 “ 为 基 本 单 位 “ w e e k s “ 表 示 以 “ 周 ” 为 基 本 单 位 “ d a y s “ 表 示 以 “ 天 ” 为 基 本 单 位 “ h o u r s “ 表 示 以 “ 小 时 ” 为 基 本 单 位 “ m i n u t e s “ 表 示 以 “ 分 钟 ” 为 基 本 单 位 “ s e c o n d s “ 表 示 以 “ 秒 ” 为 基 本 单 位 “ m i l l i s e c o n d “ 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}”years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月”为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​”years””quarters””months””weeks””days””hours””minutes””seconds””millisecond”​表示以“年”为基本单位表示以“季”为基本单位表示以“月”为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</li><li>获取当前日期函数（<code>now</code>):返回当前的日期和时间 语法：<code>now()</code></li><li>日期范围开始函数（“<code>start</code>”）：返回一个日期范围的开始 语法：<code>start(date)</code></li><li>日期范围结束函数（“<code>end</code>”）：返回一个日期范围的结束 语法：<code>end(date)</code></li><li>日期到时间戳函数（“<code>timestamp</code>”）：返回来自Unix毫秒时间戳的整数，对应于自1970年1月1日起的毫秒数，返回值是<code>数值</code> 语法：<code>timestamp(date)</code> 说明：把日期格式的<code>日期转化</code>为数值类型的<code>时间戳</code></li><li>时间戳到日期函数（“<code>fromTimestamp</code>”）：返回由Unix毫秒时间戳构建的日期，对应于自1970年1月1日起的毫秒数，返回值是<code>日期</code> 语法：<code>fromTimestamp(number)</code> 说明：把数值类型的<code>时间戳转化为日期</code>类型的日期</li><li>增加日期判据（argument）函数（“<code>dateAdd</code>”）：增加到日期，最后一个是单位判据 语法：<code>dateAdd(date,number,text)</code> 说明：<code>date</code>表示日期；number表示日期差；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。 t e x t 的 取 值 类 型 { “ y e a r s “ 表 示 以 “ 年 ” 为 基 本 单 位 “ q u a r t e r s “ 表 示 以 “ 季 ” 为 基 本 单 位 “ m o n t h s “ 表 示 以 “ 月 “ 为 基 本 单 位 “ w e e k s “ 表 示 以 “ 周 ” 为 基 本 单 位 “ d a y s “ 表 示 以 “ 天 ” 为 基 本 单 位 “ h o u r s “ 表 示 以 “ 小 时 ” 为 基 本 单 位 “ m i n u t e s “ 表 示 以 “ 分 钟 ” 为 基 本 单 位 “ s e c o n d s “ 表 示 以 “ 秒 ” 为 基 本 单 位 “ m i l l i s e c o n d “ 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}”years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月”为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​”years””quarters””months””weeks””days””hours””minutes””seconds””millisecond”​表示以“年”为基本单位表示以“季”为基本单位表示以“月”为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</li><li>减少日期的日期函数（<code>“dateSubtract</code>”）：减少日期的日期，最后一个是判据 语法：<code>dateSubtract(date,number,text)</code> 说明：类似上面的dateAdd函数。</li><li>设置日期格式函数（“<code>formatDate</code>”）：使用“时刻”标准时间格式字符串，设置日期格式，返回的是一个<code>字符串</code> 语法：<code>formatDate(date,text)</code> 例子： <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MMMM D YYYY, HH:mm"</span>) == March <span class="hljs-number">30</span> <span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"YYYY/MM/DD, HH:mm"</span>) == <span class="hljs-number">2010</span>/<span class="hljs-number">03</span>/<span class="hljs-number">30</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MM/DD/YYYY, HH:mm"</span>) == <span class="hljs-number">03</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"HH:mm A"</span>) == <span class="hljs-number">12</span>:<span class="hljs-number">00</span> PM<br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"M/D/YY"</span>) == <span class="hljs-number">3</span>/<span class="hljs-number">30</span>/<span class="hljs-number">10</span><br></code></pre></td></tr></tbody></table></figure></li><li>返回”给定日期“所用单位函数下的数字<br>所 用 的 单 位 函 数 { 分 钟 函 数 （ m i n u t e ） { 返 回 一 个 0 到 59 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 分 钟 数 语 法 ： m i n u t e ( d a t e ) 小 时 函 数 （ h o u r ） { 返 回 一 个 0 到 23 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 小 时 数 语 法 ： h o u r ( d a t e ) 星 期 函 数 （ d a y ） { 返 回 一 个 0 到 6 之 间 的 整 数 ， 对 应 于 给 定 的 日 期 。 0 代 表 星 期 日 ， 1 代 表 星 期 一 等 等 语 法 ： d a y ( d a t e ) 日 期 函 数 （ d a t e ） { 返 回 一 个 1 到 31 之 间 的 整 数 , 对 应 于 给 定 日 期 语 法 ： d a t e ( d a t e ) 月 函 数 （ m o n t h ） { 返 回 一 个 0 到 11 之 间 的 整 数 ， 0 对 应 于 1 月 ， 1 对 应 于 2 月 等 等 语 法 ： m o n t h ( d a t e ) 年 份 函 数 （ y e a r ） { 返 回 给 定 日 期 的 年 份 语 法 ： y e a r ( d a t e ) 所用的单位函数\begin{cases} 分钟函数（minute）\begin{cases}返回一个0到59之间的整数，对应于给定日期的分钟数\语法：minute(date)\end{cases}\ 小时函数（hour）\begin{cases}返回一个0到23之间的整数，对应于给定日期的小时数\语法：hour(date)\end{cases}\ 星期函数（day）\begin{cases}返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等\语法：day(date)\end{cases}\ 日期函数（date）\begin{cases}返回一个1到31之间的整数,对应于给定日期\语法：date(date)\end{cases}\ 月函数（month）\begin{cases}返回一个0到11之间的整数，0对应于1月，1对应于2月等等\语法：month(date)\end{cases}\ 年份函数（year）\begin{cases}返回给定日期的年份\语法：year(date)\\end{cases} \end{cases} 所用的单位函数⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​分钟函数（minute）{返回一个0到59之间的整数，对应于给定日期的分钟数语法：minute(date)​小时函数（hour）{返回一个0到23之间的整数，对应于给定日期的小时数语法：hour(date)​星期函数（day）{返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等语法：day(date)​日期函数（date）{返回一个1到31之间的整数,对应于给定日期语法：date(date)​月函数（month）{返回一个0到11之间的整数，0对应于1月，1对应于2月等等语法：month(date)​年份函数（year）{返回给定日期的年份语法：year(date)</li></ol><h1 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8 参考资料"></a>8 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> notion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> notion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obsidian 插件</title>
      <link href="/posts/42381/"/>
      <url>/posts/42381/</url>
      
        <content type="html"><![CDATA[<h1 id="1-media-插件"><a href="#1-media-插件" class="headerlink" title="1 media 插件"></a>1 media 插件</h1><p>本地视频打时间戳：<br>前边+file:// ，第三个”/“是users的,然后在阅读视图中打开，之后可以自动打时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221318976.png" alt="|600"></p><p>不在阅读视图中打开会自动跳转到默认应用打开，这样无法加时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221319732.png" alt="|600"></p><h1 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2 参考资料"></a>2 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> obsidian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语口语</title>
      <link href="/posts/13436/"/>
      <url>/posts/13436/</url>
      
        <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/899591b0dea9484cb76d44a26c1c4c61">英语口语考试周主题</a></p><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=d3049095-bb89-43d6-872f-f36158106173">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fluid写文章好用的代码</title>
      <link href="/posts/15457/"/>
      <url>/posts/15457/</url>
      
        <content type="html"><![CDATA[<p>网站嵌套<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid">[1]</span></a></sup></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"topFrame"</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"yes"</span>  <span class="hljs-attr">noresize</span>=<span class="hljs-string">"noresize"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"topFrame"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>tag插件</p><iframe src="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6" width="100%" height="1000" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe><hr><p><strong>参考资料</strong>：</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/posts/fluid-write/#iframe-%E9%A1%B5%E9%9D%A2%E9%95%B6%E5%A5%97">搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优化</title>
      <link href="/posts/37878/"/>
      <url>/posts/37878/</url>
      
        <content type="html"><![CDATA[<blockquote><p>红色为重点</p></blockquote><p>考试范围：<br>第二章的单纯形法不考</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507551.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507026.png" alt="|600"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507616.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171506250.png" alt="|600"></div></div></div><p>动态规划求解：<a href="https://www.bilibili.com/video/BV1DL4y1G7mp?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化理论与方法-动态规划2_哔哩哔哩_bilibili</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222221137.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227555.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227315.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222228222.png)<br><br></code></pre></td></tr></tbody></table></figure><p>总复习：<a href="https://www.bilibili.com/video/BV1AF411z7hg/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化计算方法计算题复习_哔哩哔哩_bilibili</a></p><hr><p>2022-06-24(后记)：</p><ol><li>实际问题求标准型的问题：把目标函数写出来，约束条件写出来就行</li><li>黄金分割法：但是略微有点不一样，函数值算出来是负的。没关系仍然采用，谁的函数值就删其区间的策略</li><li>K-T条件：常规题</li><li>内点罚函数：注意一下把约束条件化为标准型：&lt;=0</li><li> 哈密顿法：书上13-3原题，初始条件变了一点，加粗的看不懂(x(0) = 0，<strong>t<sub>f</sub> = 2，x1(0) + x2(0) =&nbsp;5</strong> )</li><li>共轭梯度法：共有三种方法可以解(牛顿法，最速下降法，共轭梯度法)，但是题目要求共轭梯度法 </li><li>遗传算法：要求精确到0.01，简单是初始只有两个变量x1，x2。<ol><li>注意一点：适度函数中的常数要取f(x1)，f(x2)的最大值。本题中x1，x2取负数才是最大值，我写错了</li></ol></li><li>动态规化求线性规化：要求<strong>顺序法</strong>解，逆序法不给分，老师专门在考前1分钟强调。(<font color="#C32E94">15分</font>)</li><li>A* 算法：画格子，只有<font color="#C32E94">5分</font></li><li>神经网络：先由m求W，给了初始的V<sup>T</sup>。求更新状态，求对应的E<ol><li>求W，W12=m1的第一行 * 第二行 + m2的第一行 * 第二行。w13同理……</li><li>求V<sup>T</sup>，更新几，V乘上对应的W列 - θ<sub>i</sub>，没有θ就当成0。如果结果 &gt;= 0 取1，&lt; 0 取0。更新几号只写那个数。其他的初始V<sup>T</sup>照抄<ol><li>如果是二分图的，更新完的话，如果正数和负数的个数不相等的话，还要在随机找一个数变一下。然后使正负的个数相等</li></ol></li></ol></li></ol><blockquote><p>未标注的只有10分</p></blockquote><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p>自用跳转链接：<a href="http://localhost:4000/2022/06/17/zui-you-hua/">blog</a>，<a href="obsidian://advanced-uri?vault=Documents&amp;uid=a70cadd5-066a-4186-a092-69cf233c1b6e">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>退火</title>
      <link href="/posts/16303/"/>
      <url>/posts/16303/</url>
      
        <content type="html"><![CDATA[<h1 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h1><p><strong>是否退火</strong>：能够直接挤出就没必要退火，硬度低，比如纯铝，就没必要退火<br><strong>目的：</strong><br>    提高成形后表面质量，<strong>提高它的塑性</strong>，便于改善成形效果，减少表面缺陷<br>    退火主要是去应力，使材料组织回到初始状态，这样能保证挤压前每个工件的组织都一样<br>    让晶粒均匀，能够好观察以后的梯度样貌<br><strong>成形要求</strong>：表面无缺陷，形状规整，就和松青挤出的纯铜差不多就行</p><h1 id="2-AZ13B镁合金-退火"><a href="#2-AZ13B镁合金-退火" class="headerlink" title="2 AZ13B镁合金 退火"></a>2 AZ13B镁合金 退火</h1><p><img src="https://s1.vika.cn/space/2022/06/15/07272ec877d24b698c8944d6a1296f0b" alt="|600"><br>150 ℃-240 min 退火后只有部分区域发生了再结晶(这不行)<br>在 300℃退火处理后,晶粒尺寸比较稳定,由平均晶粒尺寸为9.1μm 的再结晶组织组成</p><p>较高的温度(300℃)能够改善镁合金的塑性<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="margin">[1]</span></a></sup>。<br>AZ31B 镁合金轧制态板材经 300 ℃退火 60 min 后伸长率最高,为 27.3%。<br><img src="https://s1.vika.cn/space/2022/06/15/b41108bd01ba4924a6f8e98e64d285c6" alt="|600"></p><p><img src="https://s1.vika.cn/space/2022/06/15/d56b14c8de0348a292f42e2572ea922e" alt="|600"></p><h2 id="2-1-镁合金退火总结"><a href="#2-1-镁合金退火总结" class="headerlink" title="2.1 镁合金退火总结"></a>2.1 镁合金退火总结</h2><p>退火温度升至 300℃, 保温 60min，退火后炉内冷却取出</p><p>将锻态镁合金在350°C、2h的条件下进行再结晶退火<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网">[2]</span></a></sup></p><p>退火处理工艺及参数为：加热温度为260°C，保温15min， 升温速率取 5°C/min，随炉冷却后取出工件<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金表面滚压强化研究 - 中国知网">[3]</span></a></sup></p><p>镁合金板材<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[4]</span></a></sup>：将A Z 3 1 B镁合金板分别在2 0 0, 3 0 0, 4 0 0 ℃下保温1 0m i n,<br>未 热 处 理 A Z 3 1 B镁 合 金 板的显微组 织 主 要 由 大 小 不 均 匀 的 等 轴 晶 粒 组 成, 晶粒 尺 寸 为1 0<del>4 0μm, 形 成 的β析 出 相 (M g 1 7 A l 1 2相) 较少[ 1 4]; 2 0 0 ℃热 处 理 后 的 显 微 组 织 变 化不大, 等轴晶粒尺寸仍为1 0</del>4 0μm, 析出相的 分布也 没 有 明 显 变 化; 当 热 处 理 温 度 达 到 3 0 0, 4 0 0 ℃时, 镁 合 金 板 的 显 微 组 织 发 生 了 明 显 的 变化, 主要表现为大尺寸晶粒的数量明显增 多, 晶 粒的最大尺寸达到了5 0μm, 且析出相的分布更加弥散。对比可知, 2 0 0 ℃为 A Z 3 1 B镁 合 金 板 较 为 理想的加热 温 度, 该 温 度 下 能 够 较 好 地 保 持 细 小 的显微组织。</p><blockquote><p>这个好像是先退火200,300,400后，在挤压后的晶相<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207042001235.png"></p></blockquote><h1 id="3-19号楼马弗炉加热操作"><a href="#3-19号楼马弗炉加热操作" class="headerlink" title="3 19号楼马弗炉加热操作"></a>3 19号楼马弗炉加热操作</h1><h2 id="3-1-操作文档"><a href="#3-1-操作文档" class="headerlink" title="3.1 操作文档"></a>3.1 操作文档</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017876.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017391.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162018849.png" alt="|600"></div></div></div><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/78EE4419-7316-4B0F-9104-116415CFBD95">margin</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021900755.nh&amp;uniplatform=NZKPT&amp;v=5Rx9z0dEkJU4WzR6pCnp0XWyhQb8xRZ5iMRPNdPJBPVDo9CF-RagrxkNh-MQaLMa">AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021155229.nh&amp;uniplatform=NZKPT&amp;v=us7-K1qgCpj5f5QN9eOdchJ9P2om_2zkT5iLqRdK25tWa_Bp7kcv2OYETpRo6scL">AZ31B镁合金表面滚压强化研究 - 中国知网</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="marginnote3app://note/5D3F197F-7FDC-42A0-8C97-2618192A9CC2">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20.合并区间</title>
      <link href="/posts/14697/"/>
      <url>/posts/14697/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>    力扣题解： 56. 合并区间</p><span id="more"></span><h1 id="1-56-合并区间"><a href="#1-56-合并区间" class="headerlink" title="1 56. 合并区间"></a>1 56. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">力扣题目链接</a></p><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>  输入: intervals = [ [1,3],[2,6],[8,10],[15,18] ]</li><li>  输出: [ [1,6],[8,10],[15,18] ]</li><li>  解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><p>示例&nbsp;2:</p><ul><li>  输入: intervals = [ [1,4],[4,5] ]</li><li>  输出: [ [1,5] ]</li><li>  解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li><li>  注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</li></ul><p>提示：</p><ul><li>  intervals[ i ]  [0] &lt;= intervals[ i ]  [ 1 ]</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>左边界排序后<br>局部最优：每次合并都取<strong>最大的右边界</strong>，这样就可以合并更多的区间了<br>整体最优：合并所有重叠的区间。<br>排序后：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，一定有重叠(包含或者交集)！</p><blockquote><p>第二个数组的头如果小于第一个数组的尾，那么一定有重复<br><img src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p></blockquote><h2 id="2-1-排序"><a href="#2-1-排序" class="headerlink" title="2.1 排序"></a>2.1 排序</h2><p>按左边界排序</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br></code></pre></td></tr></tbody></table></figure><h2 id="2-2-判断是否重叠-合并区间"><a href="#2-2-判断是否重叠-合并区间" class="headerlink" title="2.2 判断是否重叠 +合并区间"></a>2.2 判断是否重叠 +合并区间</h2><h3 id="2-2-1-是否重叠"><a href="#2-2-1-是否重叠" class="headerlink" title="2.2.1 是否重叠"></a>2.2.1 是否重叠</h3><p>for循环中判断重叠<br>第二个数组的头小于第一个数组的尾即为重叠<br><code>intervals[i][0] &lt;= intervals[i - 1][1]</code><br>定义出来两个数组的头和尾，这样下边写的更简洁</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下标从1开始，因为要比较：intervals[i][0] &lt;= intervals[i - 1][1]</span><br><span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始区间的左边界</span><br><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];   <span class="hljs-comment">// 初始区间的右边界</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2-2-2-合并区间"><a href="#2-2-2-合并区间" class="headerlink" title="2.2.2 合并区间"></a>2.2.2 合并区间</h3><p>用[[while 循环]]合并区间：while循环是if 和 for 循环的结合体<br>比较第一个数组和第二数组的尾部谁更大，更新数组的尾部就行<br>同时要控制i的增加，如果合并了，那么进行一次i++, 出去while 循环后，for又进行一次i++，这样就控制了跳过了合并区间👉🏻[[20.合并区间#^hcnuf7]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 比较第一个数组和第二数组的尾部</span><br></code></pre></td></tr></tbody></table></figure><p>整体代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) { <span class="hljs-comment">// 判断重叠</span><br>          <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    <span class="hljs-comment">// 初始为i-1区间的左边界</span><br>          <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];      <span class="hljs-comment">// 初始i-1区间的右边界</span><br>          <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end) { <span class="hljs-comment">// 合并区间</span><br>              end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 不断更新右区间</span><br>              <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 最后一个区间也合并了</span><br>              i++;                                <span class="hljs-comment">// 继续合并下一个区间</span><br>          }<br></code></pre></td></tr></tbody></table></figure><h2 id="2-3-放入result结果集"><a href="#2-3-放入result结果集" class="headerlink" title="2.3 放入result结果集"></a>2.3 放入result结果集</h2><p>取合并区间的头和尾作为一个新的数组加入到result数组中，<code>result.push_back({start, end});</code><br>如果没有合并就把原数组加入result</p><p><strong>注意</strong>：<br>还要单独判断最后一个数组是否合并了，如果合并了，正常加入就如result就行<br>如果没合并要单独的把最后一个数组加入result</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><h2 id="3-1-代码随想录断点调试"><a href="#3-1-代码随想录断点调试" class="headerlink" title="3.1 代码随想录断点调试"></a>3.1 代码随想录断点调试</h2><p>carl<br><a href="file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/20.合并区间(carl).mp4">20.合并区间(carl).mp4</a><br>    <a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=19.133532">00:19</a> ：i++<br>        如果合并了第二区间，那么自然i不能从第二个区间在开始，要从第三个位置开始，while循环中有个i++，到了for循环中还有个i++, i到时候等于3，就跳过了合并的区间在开始<br>    <a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=29.228653">00:29</a>：此时i 等于3，从合并区间的下个区间在开始进行 ^hcnuf7</p><h2 id="3-2-carl-自写"><a href="#3-2-carl-自写" class="headerlink" title="3.2 carl 自写"></a>3.2 carl 自写</h2><p>编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 只比较左位置，所以不用二维数组</span><br>    }<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) {<br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<span class="hljs-comment">// 此时result为空</span><br>        <span class="hljs-type">int</span> length = intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不要定义在for循环中</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++){<br>            <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end){ <span class="hljs-comment">// 不要忘记=，“=”是头尾相等</span><br>                end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;<br>                i++;<br>            }<br>            result.<span class="hljs-built_in">push_back</span> ({start,end}); <span class="hljs-comment">// 如果没合并就是单独的，如果合并了也更新了。</span><br>                                            <span class="hljs-comment">// 每一次的循环都在加入result数组，所以在for循环中</span><br>        }<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>) {<br>            result.<span class="hljs-built_in">push_back</span>({intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]});<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><sub>自用跳转链接</sub>：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=88f96891-7092-4c04-a067-349995d05800">ob</a>，<a href="http://localhost:4000/2022/06/16/20.he-bing-qu-jian/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notion函数公式</title>
      <link href="/posts/11772/"/>
      <url>/posts/11772/</url>
      
        <content type="html"><![CDATA[<p>notion函数公式</p><h1 id="1-时间公式"><a href="#1-时间公式" class="headerlink" title="1 时间公式"></a>1 时间公式</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">开始的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>))<br>结束的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))<br><br>开始的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br>结束的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br><br><br>相减的分钟数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))<br>相减的小时数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)))<br><br>小时+分钟：<br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span> <br><br><br><span class="hljs-comment">//不借位</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//借位</span><br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span><br><br><br><span class="hljs-comment">//时间计算总函数：已通过</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) + <span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>)<br><br><span class="hljs-comment">//时间范围改造函数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)))+ <span class="hljs-string">"h"</span> + format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))) +<span class="hljs-string">"m"</span> , <span class="hljs-string">"0"</span>)<br></code></pre></td></tr></tbody></table></figure><p>时间范围</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><span class="hljs-comment">//不借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><br><span class="hljs-comment">//借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br></code></pre></td></tr></tbody></table></figure><p>写notion公式的心得：把零件找出来，在组装</p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> notion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> notion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
      <link href="/posts/12294/"/>
      <url>/posts/12294/</url>
      
        <content type="html"><![CDATA[<p>#flashcards/代码随想录/知识点<br>c++中 - ‘0’ 以及 -‘a’ 的相减操作解释<br>?</p><h1 id="1-将数字字符转为整形变量"><a href="#1-将数字字符转为整形变量" class="headerlink" title="1 将数字字符转为整形变量"></a>1 将数字字符转为整形变量</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将str 字符串"1234"里的各个数字字符转成整型，存入整型数组x：</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"1234"</span>;<br><span class="hljs-type">int</span> x[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++) x[i] = str[i] - <span class="hljs-string">'0'</span>; <br></code></pre></td></tr></tbody></table></figure><blockquote><p>数字字符减去‘0’就得到了该数字。减去字符0，也就是减去0的ASCII码值48。</p></blockquote><h1 id="2-将字母由小写转为大写"><a href="#2-将字母由小写转为大写" class="headerlink" title="2 将字母由小写转为大写"></a>2 将字母由小写转为大写</h1><p>字母字符- ‘a’得到 该字母下的下标</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 把字符串中字母，小写变大写</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"aBcxYz"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(str); i++)<br><span class="hljs-keyword">if</span> (str[i] &gt;=<span class="hljs-string">'a'</span> &amp;&amp; str[i] &lt;=<span class="hljs-string">'z'</span>) str[i] = str[i] -<span class="hljs-string">'a'</span> + <span class="hljs-string">'A'</span>;<br></code></pre></td></tr></tbody></table></figure><h2 id="2-1-取到字母字符对应的数字：a→0，b→1…"><a href="#2-1-取到字母字符对应的数字：a→0，b→1…" class="headerlink" title="2.1 取到字母字符对应的数字：a→0，b→1…."></a>2.1 取到字母字符对应的数字：a→0，b→1….</h2><p>原理：a - ‘a’ = 0, b - ‘a’ = 1 …..</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<br>S = <span class="hljs-string">"ababcbacadefegdehijhklij"</span><span class="hljs-comment">// S[0] - 'a'= 0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) { <br>            hash[S[i] - <span class="hljs-string">'a'</span>] = i; <span class="hljs-comment">//</span><br>        }<br></code></pre></td></tr></tbody></table></figure><p>[[19.划分字母区间#^dhg2oc]]<br><a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835">01:03</a><br>    S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>    将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - ‘a’=&nbsp;S[6] - ‘a’ = 0 </p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>while 循环</title>
      <link href="/posts/36387/"/>
      <url>/posts/36387/</url>
      
        <content type="html"><![CDATA[<p>while循环是if 和 for 循环的结合体，<br>只要在while循环中增加跳出语句就行</p><p>while(i){i++}</p><p>if(){<br>for()<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
      <link href="/posts/12295/"/>
      <url>/posts/12295/</url>
      
        <content type="html"><![CDATA[<p>执行continue 函数相当于又调到了函数的开头<a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=4.619299">00:04</a><br>作用：能够控制for循环中，跳过一些代码段，然后又使i不断前进<br><a href="file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4">23.买卖股票的最佳时机含手续费</a></p><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19.划分字母区间</title>
      <link href="/posts/22082/"/>
      <url>/posts/22082/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>    力扣题解：763.划分字母区间</p><span id="more"></span><h1 id="1-763-划分字母区间"><a href="#1-763-划分字母区间" class="headerlink" title="1 763.划分字母区间"></a>1 763.划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">力扣题目链接</a></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><ul><li>  输入：S = “ababcbacadefegdehijhklij”</li><li>  输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</li></ul><p>提示：</p><ul><li>  S的长度在[1, 500]之间。</li><li>  S只包含小写字母 ‘a’ 到 ‘z’ 。</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>总共分为两步：</p><ul><li>  统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点<br><img src="https://img-blog.csdnimg.cn/20201222191924417.png" alt="763.划分字母区间|900"><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><h2 id="3-1-carl断点调试"><a href="#3-1-carl断点调试" class="headerlink" title="3.1 carl断点调试"></a>3.1 carl断点调试</h2><a href="file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/19.划分字母区间(carl).mp4">19.划分字母区间(carl).MP4</a><br>  以后可以监听几个变量：S[i]，right - left +1<br>  [[c++中 - ‘0’ 以及 -‘a’ 的相减操作解释]]<br>  S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>  <a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=12.709769">00:12</a> <pre><code class="hljs">  S = "a==b==abcbacadefegdehijhklij"，相当于将b对应1，这个数存在了hash里  hash[S[1] - 'a'] =&nbsp;1，即hash[2] = 1</code></pre>  <a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835">01:03</a> <pre><code class="hljs">  S = "==**a**==babcbac==**a**==defegdehijhklij"  将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - 'a'=&nbsp;S[9] - 'a' = 0 (第一个区间)</code></pre>  <a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=70.392045">01:10</a> <pre><code class="hljs">  此使 right = max(0, 8)，之道i 到下标8才会进入if 循环语句，它在下标8之前一直在比较有没有比8更大值，有的话说明第一个分割点更远</code></pre>  <a href="file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=113.069755">01:53</a><pre><code class="hljs">  到达第一分割点下标8(i =&nbsp;8)处，开始push_back结果，并且更新下一个区间  right  - left + 1  = 8-0+1= 9 第一个区间相当于：尾 - 头 + 1  下个区间要在更新一下头即left = i+1 =&nbsp;9  </code></pre></li></ul><h3 id="3-1-1-代码"><a href="#3-1-1-代码" class="headerlink" title="3.1.1 代码"></a>3.1.1 代码</h3><p>自写 编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>{<br>       <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<span class="hljs-comment">// 数组初始化必须是列表，不能是单纯的0</span><br>       <span class="hljs-comment">//int hash[S.size()] = {0}; // S.size 可变动的，错误：可变大小的对象可能未初始化</span><br><br>       <span class="hljs-comment">//hash数组中写入每个字母的所对应的最远下标值</span><br>       <span class="hljs-comment">//因每个字母的S[i] - 'a'是不变的，所以可以一直更新最远下标</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           hash[S[i] - <span class="hljs-string">'a'</span>] = i;<br>       }<br>       <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>       vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// vector 能够不断往里加数据</span><br>       <span class="hljs-comment">// 不断的找分割区间</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           right = <span class="hljs-built_in">max</span> (right, hash[S[i] - <span class="hljs-string">'a'</span>]); <span class="hljs-comment">// 确定区间的尾部 不是hash[i], 是每个字母对应的最远下标</span><br>           <span class="hljs-keyword">if</span>(i == right){<br>               result.<span class="hljs-built_in">push_back</span>(right - left +<span class="hljs-number">1</span>); <span class="hljs-comment">// 返回是字符串的长度所以+1</span><br>               left = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新下一个区间头部，现在i是上一区间的尾，所以下个头部为 i+1</span><br>           }<br>       }<br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=13b04b05-d8f9-4a57-a909-3b6b3af97825">ob</a>，<a href="http://localhost:4000/2022/06/15/19.hua-fen-zi-mu-qu-jian/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切割材料+制样</title>
      <link href="/posts/47598/"/>
      <url>/posts/47598/</url>
      
        <content type="html"><![CDATA[<h1 id="1-切割"><a href="#1-切割" class="headerlink" title="1 切割"></a>1 切割</h1><p>切割圆棒和圆盘分离处12mm范围内，<br><img src="https://s1.vika.cn/space/2022/06/14/2d7ff49ea0c8442ab6e80f41c0f30a32" width="500" height="500"></p><h1 id="2-制样"><a href="#2-制样" class="headerlink" title="2 制样"></a>2 制样</h1><p>第一次溶液做点稀点：一次性杯子，倒4分之一的水(配套粉的)，4勺粉。搅拌至拉丝<br>倒到模具当中，先倒一点(3分之一)，然后用镊子在把材料拿起在压下去</p><blockquote><p>主要让切割材料底下溶液渗透均匀<br><img src="https://s1.vika.cn/space/2022/06/14/7139d0510c9e43e2a3bcc0b7816cfbe8" alt="|400"></p></blockquote><p>第二次溶液做点稠点：一次性杯子，倒3分之一的水(配套粉的)，7勺粉。搅拌至拉丝<br>这次把模具倒满</p><hr><p>跳转回ob：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=0a90dfa0-acef-4bf3-bb8b-0b72eb035933">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PPT技巧-文字高亮</title>
      <link href="/posts/36733/"/>
      <url>/posts/36733/</url>
      
        <content type="html"><![CDATA[<p>注意事项：</p><p>按住Shift 用来垂直或水平移动<br>如果上下两个文字没有在同一位置，无法实现文字滚动效果</p><hr><p>参考资料：<br><a href="https://www.bilibili.com/video/BV1pv4y1G7Qp/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">keynote 教程 有手就行系列 024 苹果发布会分解教学_哔哩哔哩_bilibili</a></p><hr><p>下一篇：[[切割材料+制样]]</p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自然辩证法考试重点</title>
      <link href="/posts/60394/"/>
      <url>/posts/60394/</url>
      
        <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/832c73b10a1849e49262e0d8eb1b505b">自然辩证法重点-notion.</a></p><p><a href="https://skinny-girl-067.notion.site/de438994556a4d8fb3c7aa7cbdec36d9">考前速记+考后整理.</a></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>六级考试时间安排</title>
      <link href="/posts/35757/"/>
      <url>/posts/35757/</url>
      
        <content type="html"><![CDATA[<p>正式时间：15.00-17.25<br>报道时间：14.20</p><p>15.00前：发答题卡</p><p>15.00-15.10：开始发卷子</p><p>15.10-15.40：开始让动笔写作文👉 30分钟</p><p>15.40-16.10：听力👉 30分钟</p><p>16.10-16.15：暂停5分钟收答题卡1(作文和听力)</p><p>16.15-17.25：余下时间写卷至结束</p><p>下一篇：[[自然辩证法考试重点]]</p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 六级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由hexo clean 问题引发的一些学习感想</title>
      <link href="/posts/19528/"/>
      <url>/posts/19528/</url>
      
        <content type="html"><![CDATA[<p>hexo 上传文章的固定流程：</p><p><code>hexo clean</code> → <code>hexo  g</code> → <code>hexo  s</code> → <code>hexo  d</code></p><p>其实网上看了很多人这样写，但我一直把<code>hexo clean</code> 写成 <code>hexo c</code>。其实系统也一直都有在报错，但我从来都没有关注。因为终端窗口小，没能显示出来上边的错误信息，下面一堆英文的也不想看。每次都当成了顺利执行了。自己还沾沾自喜的觉得<code>hexo c</code> 写也可以，网上没人说自己发现了新大陆了。<br><img src="https://s1.vika.cn/space/2022/06/11/9106c9ae345a4543a36819fd0351132c" alt="|600"><br>后来在用hexo写文章的时候，换主主题总是有些问题(见下图)，自己困扰了很多天，每天拿出来很多时间来尝试解决问题，但都无果。其实就是因为没有用hexo clean 清除缓存导致的<br><img src="https://s1.vika.cn/space/2022/06/11/d2d6e3f8df354e7cad5a8cfa1b5d2983" alt="|800"></p><p>我为什么一直固执写 <code>hexo c</code> 呢，<br>我认为有以下方面原因：</p><ol><li><strong>自以为是</strong>。觉得很多都可以简写，那这个命令应该也可以。自己试了试看到终端输出信息了。就觉得可以了，但其实根本没认真看出来的信息</li><li><strong>嫌麻烦</strong>。觉得是英文的，根本静不下来心去看。</li></ol><p>希望以后在这两方面加强自己</p><p>下一篇：[[六级考试时间安排]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 学习感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研材料总结</title>
      <link href="/posts/52144/"/>
      <url>/posts/52144/</url>
      
        <content type="html"><![CDATA[<p>硬度单位<br>洛氏硬度：HR；布氏硬度：HB；维氏硬度：HV</p><p>自用<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="ob">[2]</span></a></sup></p><h1 id="1-镁合金"><a href="#1-镁合金" class="headerlink" title="1 镁合金"></a>1 镁合金</h1><h2 id="1-1-硬度"><a href="#1-1-硬度" class="headerlink" title="1.1 硬度"></a>1.1 硬度</h2><p>镁合金型号：<strong>AZ31B(HR70)</strong> AZ61 AZ91  ZK60 WE40<br>镁合金的hv：45~75不等</p><p>纯铜：HB85，50~65HV<br>纯铝：HB28<br>7075铝合金：退火后的HV140</p><p><strong>硬度低于纯铜的材料：</strong><br><strong>纯铜</strong>：HB：85，HV：50~65<br>    退火(软)铜硬度为：50HV</p><p>304不锈钢：<br>淘宝：硬度在HBW85左右(淘宝)<br>网上：HB187，HRB90，HV200</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207041914021.png"></p><h1 id="2-模具材料硬度"><a href="#2-模具材料硬度" class="headerlink" title="2 模具材料硬度"></a>2 模具材料硬度</h1><p>skh51 热处理淬火后硬度可以达到64HRC</p><p>skd11 热处理后硬度58~60HRC</p><h1 id="3-退火"><a href="#3-退火" class="headerlink" title="3 [[退火]]"></a>3 [[退火]]</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:2" class="footnote-text"><span><a href="obsidian://advanced-uri?vault=Documents&amp;uid=c94962a5-c07b-4fe5-b5c1-4d72c4fb033a">ob</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18.无重叠区间</title>
      <link href="/posts/34584/"/>
      <url>/posts/34584/</url>
      
        <content type="html"><![CDATA[<p>文章简介：<br>力扣题解：435. 无重叠区间</p><span id="more"></span><h1 id="1-无重叠区间"><a href="#1-无重叠区间" class="headerlink" title="1 无重叠区间"></a>1 无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">力扣题目链接</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><blockquote><p>返回需要移除的区间个数(交叉区间 = 总个数-非交叉区间的个数)</p></blockquote><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><ul><li>  输入: [ [1,2], [2,3], [3,4], [1,3] ]</li><li>  输出: 1</li><li>  解释: 移除 [1,3] 后，剩下的区间没有重叠。</li></ul><p>示例 2:</p><ul><li>  输入: [ [1,2], [1,2], [1,2] ]</li><li>  输出: 2</li><li>  解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</li></ul><p>示例 3:</p><ul><li>  输入: [ [1,2], [2,3] ]</li><li>  输出: 0</li><li>  解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p><strong>按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>从左向右遍历，优先选择右边界小的数组(因为右边界越小，留给下一个区间的空间就越大)</p><blockquote><p><img src="https://s1.vika.cn/space/2022/06/10/6830dccb02804260a38ac29d8641f9f8" alt="|600"></p></blockquote><p><strong>局部最优</strong>：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。<br><strong>全局最优</strong>：选取最多的非交叉区间。<br><img src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间|600"></p><blockquote><p>选择1就把2，3pass了，选择4就把5pass了</p></blockquote><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><h2 id="3-1-carl"><a href="#3-1-carl" class="headerlink" title="3.1 carl"></a>3.1 carl</h2><h3 id="3-1-1-解法1"><a href="#3-1-1-解法1" class="headerlink" title="3.1.1 解法1"></a>3.1.1 解法1</h3><p>自写代码已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<span class="hljs-comment">// 按右边界排序</span><br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">//记录非交叉区间的个数</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录第一个区间的尾部</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(end &lt;= intervals[i][<span class="hljs-number">0</span>]){<span class="hljs-comment">// 如果头尾没有重合，即不重叠</span><br>                end = intervals[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新end为下一个没有重合的尾部，不断for循环在</span><br>                count++;<span class="hljs-comment">// 记录不重合的个数</span><br>            }<br>        } <br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count; <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="3-1-2-解法2：利用-17-用最少数量的箭引爆气球"><a href="#3-1-2-解法2：利用-17-用最少数量的箭引爆气球" class="headerlink" title="3.1.2 解法2：利用[[17.用最少数量的箭引爆气球]]"></a>3.1.2 解法2：利用[[17.用最少数量的箭引爆气球]]</h3><p>弓箭的数量就相当于是<strong>非交叉区间</strong>的数量(因为交叉区间可以用一支箭射爆)，<br>只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1]，[1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间左边界从大到小排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) { <span class="hljs-comment">// 需要要把&gt; 改成 &gt;= 就可以了</span><br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {<br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1Uh41117SZ?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode  Python版每日一题（20201231）：435. 无重叠区间（想想罗志祥会怎么做）哔哩哔哩_bilibili</a></p><p>自用跳转连接：<a class="btn" href="http://localhost:4000/2022/06/10/18.wu-chong-die-qu-jian/" title="title">blog</a> <a class="btn" href="obsidian://advanced-uri?vault=Documents&amp;uid=6ef3123b-213a-456b-adba-e26f4a9b2215" title="title">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.用最少数量的箭引爆气球</title>
      <link href="/posts/2006/"/>
      <url>/posts/2006/</url>
      
        <content type="html"><![CDATA[<p><strong>文章简介</strong>：<br>    力扣题解：452用最少数量的箭引爆气球</p><span id="more"></span><h1 id="1-452用最少数量的箭引爆气球"><a href="#1-452用最少数量的箭引爆气球" class="headerlink" title="1 452用最少数量的箭引爆气球"></a>1 452用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 &nbsp;xstart&nbsp;≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，<strong>返回引爆所有气球所必须射出的最小弓箭数。</strong></p><p>示例 1：</p><ul><li>  输入：points = [ [10,16],[2,8],[1,6],[7,12] ]</li><li>  输出：2</li><li>  解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li></ul><p>示例 2：</p><ul><li>  输入：points = [ [1,2],[3,4],[5,6],[7,8] ]</li><li>  输出：4</li></ul><p>示例 3：</p><ul><li>  输入：points = [ [1,2],[2,3],[3,4],[4,5] ]</li><li>  输出：2</li></ul><p>示例 4：</p><ul><li>  输入：points = [ [1,2] ]</li><li>  输出：1</li></ul><p>示例 5：</p><ul><li>  输入：points = [ [2,3],[2,3] ]</li><li>  输出：1</li></ul><p>提示：</p><ul><li>  0 &lt;= points.length &lt;= 10^4</li><li>  points[i].length == 2</li><li>  -2^31 &lt;= xstart &lt;&nbsp;xend &lt;= 2^31 - 1</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><h2 id="2-1-b站参考视频及笔记"><a href="#2-1-b站参考视频及笔记" class="headerlink" title="2.1 b站参考视频及笔记"></a>2.1 b站参考视频及笔记</h2><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br><img src="https://s1.vika.cn/space/2022/06/10/3141cfabb0c94275b7edf999b4b5197f"></p><p>从这里开始看即可</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=544.080526">09:04</a></p><p>先按左端点先排好序<br>不用管左端点，<strong>只关心右端点就行</strong>，因为只在右端点射击就行了<br>记录射击区间为第一个数组区间：[一左，一右]，<strong>其实只关心右端点就行了</strong></p><p>如果第二个数组的<strong>左端点</strong>==小于==第一个数组的<strong>右端点</strong>(两个数组有重叠部分)<br>说明第二个数组在射击区间内，同时将射击区间更新为：[二左，一右] (重叠部分)，右端点无变化</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=617.733348">10:17</a><br>如果第二数组的右端点==小于==第一个数组的右端点 (说明要缩小射击区间)<br>射击区间为：[一左，二右]</p><p>如果第二数组的左端点大于第一个数组的<strong>右端点</strong>(两个数组<strong>没有</strong>重叠部分)，箭数+1(需要另一支箭才可以射完)<br>更新射击区间为：[二左，二右] (第二个数组区间)</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=765.508572">12:45代码结果</a></p><h2 id="2-2-代码随想录"><a href="#2-2-代码随想录" class="headerlink" title="2.2 代码随想录"></a>2.2 代码随想录</h2><p><strong>局部最优</strong>：当气球出现重叠，一起射，所用弓箭最少。</p><p><strong>全局最优</strong>：把所有气球射爆所用弓箭最少。</p><blockquote><p>按照气球的起始位置排序，从前向后遍历气球数组，靠左尽可能让气球重复，重复的用一个箭射</p></blockquote><p><strong>如果气球重叠了，重叠气球中最小右边界， 之前的区间一定需要一个弓箭</strong></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，<br>气球3的<strong>左边界大于</strong>了第一组重叠气球的<strong>最小右边界</strong>，所以再需要一支箭来射气球3了。</p><blockquote><p>此时箭数+1</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="https://img-blog.csdnimg.cn/20201123101929791.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title class_">Solution</span>&nbsp;{<br><br><span class="hljs-keyword">private</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">static</span>&nbsp;<span class="hljs-type">bool</span>&nbsp;<span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;a,&nbsp;<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;b)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;a[<span class="hljs-number">0</span>]&nbsp;&lt;&nbsp;b[<span class="hljs-number">0</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span class="hljs-keyword">public</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">int</span>&nbsp;<span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;&nbsp;points)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points.<span class="hljs-built_in">size</span>()&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-number">0</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),&nbsp;points.<span class="hljs-built_in">end</span>(),&nbsp;cmp);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">int</span>&nbsp;result&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;<span class="hljs-comment">//&nbsp;points&nbsp;不为空至少需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-type">int</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;i&nbsp;&lt;&nbsp;points.<span class="hljs-built_in">size</span>();&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points[i][<span class="hljs-number">0</span>]&nbsp;&gt;&nbsp;points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1不挨着，注意这里不是&gt;=</span><br><span class="hljs-comment">//points: {{1, 6}, {2, 8}, {7, 12}, {10, 16}} if (points[i][0] &gt; points[i - 1][1])</span><br><span class="hljs-comment">//eg：points[1][0] &gt; points[0][1]：第二个元素的第0号位置 &gt;第一个元素的第1号位置 2&gt;6 (if 语句跳过)看图更容易懂</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result++;&nbsp;<span class="hljs-comment">//&nbsp;需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span>&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1挨着</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points[i][<span class="hljs-number">1</span>]&nbsp;=&nbsp;<span class="hljs-built_in">min</span>(points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],&nbsp;points[i][<span class="hljs-number">1</span>]);&nbsp;<span class="hljs-comment">//&nbsp;更新重叠气球最小右边界</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;result;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>图解<br><img src="https://s1.vika.cn/space/2022/06/10/a494349688e74c7ebe4ce80e4b26d1bc" alt="|700"></p><h2 id="3-1-自写编译已通过-b站三天动画版"><a href="#3-1-自写编译已通过-b站三天动画版" class="headerlink" title="3.1 自写编译已通过(b站三天动画版)"></a>3.1 自写编译已通过(b站三天动画版)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rarrow = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 射击区间的右端点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= rarrow){ <span class="hljs-comment">// 有重叠部分，这里必须小于等于因为也要找到挨着但不重叠的，最后是用射击右端点来判别的</span><br>                <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">1</span>] &lt; rarrow){ <span class="hljs-comment">// 如果第二数组的右端点比第一个数组的右端点小，就缩小射击区间</span><br>                rarrow = points[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新右端点</span><br>                }<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                rarrow = points[i][<span class="hljs-number">1</span>];<br>                arrow ++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> arrow;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="3-2-自写编译已通过-carl-推荐"><a href="#3-2-自写编译已通过-carl-推荐" class="headerlink" title="3.2 自写编译已通过(carl) 推荐"></a>3.2 自写编译已通过(carl) 推荐</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">// 有气球至少需要一个箭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>        <span class="hljs-comment">// 如果有重叠或者挨着就可以用一支箭射爆(因为射爆的区间是大区间，重叠的是子区间),右边界就是射爆的位置</span><br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]){<span class="hljs-comment">// 2的左边界比1的右边界小说明重叠了</span><br>                    points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span> (points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新右边界与(变成重叠区间)，与下一个比,看下一个的位置是否在重叠区间内，不在则需要另外的箭</span><br>                }<br><br>            <span class="hljs-keyword">else</span> arrow++;<br>            } <br><br><br>            <span class="hljs-keyword">return</span> arrow;<br>            <br>        }<br>   <br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h1><p><a href="https://www.programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=ae2b0ee3-99ee-4a44-906e-5a2a66bf5f40">ob</a>，<a href="http://localhost:4000/2022/06/10/17.yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BAB</title>
      <link href="/posts/29968/"/>
      <url>/posts/29968/</url>
      
        <content type="html"><![CDATA[<p>BetterAndBetter手势操作助记<br>右键按压手势<br>![[BAB手势 2022-06-09 17.21.49.excalidraw]]</p><h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1 参考资料"></a>1 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=2254a3a7-a5e7-412b-88d2-f1a712755b28">ob</a>，<a href="http://localhost:4000/2022/06/09/bab/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.根据身高重建队列</title>
      <link href="/posts/21392/"/>
      <url>/posts/21392/</url>
      
        <content type="html"><![CDATA[<h1 id="1-406-根据身高重建队列"><a href="#1-406-根据身高重建队列" class="headerlink" title="1 406.根据身高重建队列"></a>1 406.根据身高重建队列</h1><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">力扣题目链接</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><ul><li>  输入：people = [ [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] ]</li><li>  输出：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]</li><li>解释：<ul><li>  编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</li><li>  编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</li><li>  编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</li><li>  编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>  编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</li><li>  编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>  因此 [ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ] 是重新构造后的队列。</li></ul></li></ul><p>示例 2：</p><ul><li>  输入：people = [ [6,0],[5,0],[4,0],[3,2],[2,2],[1,4] ]</li><li>  输出：[ [4,0],[5,0],[2,2],[3,2],[1,4],[6,0] ]</li></ul><p>提示：</p><ul><li>  1 &lt;= people.length &lt;= 2000</li><li>  0 &lt;= hi &lt;= 10^6</li><li>  0 &lt;= ki &lt; people.length</li></ul><p>题目数据确保队列可以被重建</p><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。<br><strong>如果两个维度一起考虑一定会顾此失彼</strong></p><p>先按身高h来排序(从大到小)，身高相同的k小的站前面<br>在按k的大小进行<strong>插入</strong>操作，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。<br><img src="https://img-blog.csdnimg.cn/20201216201851982.png" alt="406.根据身高重建队列|800"><br>插入的过程：</p><ul><li>  插入[7,0]：[ [7,0] ]// 插入0下标</li><li>  插入[7,1]：[ [7,0],[7,1] ]// 插入1下标</li><li>  插入[6,1]：[ [7,0],[6,1],[7,1] ]// 插入1下标</li><li>  插入[5,0]：[ [5,0],[7,0],[6,1],[7,1] ]// 插入0下标</li><li>  插入[5,2]：[ [5,0],[7,0],[5,2],[6,1],[7,1] ]// 插入2下标</li><li>  插入[4,4]：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]// 插入4下标</li></ul><p>如果先按k来排序，会发现k的排列不符合条件，身高也不符合条件，两个维度一个也没确定下来</p><p>在按照身高从大到小排序后：<br><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong><br><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><h3 id="2-1-1-关联知识点"><a href="#2-1-1-关联知识点" class="headerlink" title="2.1.1 关联知识点"></a>2.1.1 关联知识点</h3><p>[[vector]]，[[sort函数]]，[[insert函数]]</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>[[14.根据身高重建队列(carl链表).mp4]]<br>[[14.根据身高重建队列(carl vector).mp4]]<br>[[14.根据身高重建队列(carl 排序).mp4]]</p><p>vector的代码看懂了</p><p>排序完的people： [ [7,0], [7,1], [6,1], [5,0], [5,2]，[4,4] ]<br><code>people[i][1]</code>：eg <code>people[2][1]</code>=1：第二元素的第一个位置的值即{7, 1}中的1</p><p>自写,编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 没看懂，看视频：传进来的是数组eg[7,0]</span><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people){<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要放到for循环里边</span><br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 要插入的是que里，不要成people.begin()</span><br>        }<br>        <span class="hljs-keyword">return</span> que;<br>      }   <br>};<br><br></code></pre></td></tr></tbody></table></figure><p>链表的代码没看懂  #疑问</p><p>[[科研材料总结]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>begin,end</title>
      <link href="/posts/18356/"/>
      <url>/posts/18356/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>};<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);<br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);<br></code></pre></td></tr></tbody></table></figure><p>begin函数返回指向数组的<strong>首元素的指针</strong>，end函数返回指向数组<strong>尾元素的下一个位置的指针</strong>，<br>这两个函数都被定义在iterator的头文件中。使用begin和end函数就可以很好地处理数组中的元素</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insert函数</title>
      <link href="/posts/44424/"/>
      <url>/posts/44424/</url>
      
        <content type="html"><![CDATA[<h1 id="1-在字符串中插入"><a href="#1-在字符串中插入" class="headerlink" title="1 在字符串中插入"></a>1 在字符串中插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"All that exists is what's ahead."</span>)</span></span>;<br>    string a, b;<br>    a = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-string">"sky"</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串sky</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">//输出All skythat exists is what's ahead.</span><br> <br>    str = <span class="hljs-string">"All that exists is what's ahead."</span>;<br>    b = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">'x'</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串5个字符x</span><br>    cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//输出 All xxxxxthat exists is what's ahead.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-在数组下标处插入"><a href="#2-在数组下标处插入" class="headerlink" title="2 在数组下标处插入"></a>2 在数组下标处插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 在下标position处插入people[i]</span><br></code></pre></td></tr></tbody></table></figure><p>[[begin,end]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/posts/54708/"/>
      <url>/posts/54708/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用法"><a href="#1-用法" class="headerlink" title="1 用法"></a>1 用法</h1><h2 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h2><p><strong>一维数组的初始化</strong> </p><ol><li><code>vector&lt;int&gt; a(10)</code>; 默认是0</li><li><code>vector&lt;int&gt; a(10,1)</code>;(10个变量每个为1)</li><li><code>vector&lt;int&gt; a(b)</code>; //用b向量来创建a向量，整体复制性赋值</li><li><code>vector&lt;int&gt; a(b.begin(),b.begin+3)</code>; //定义了a值为b中第0个到第2个（共3个）元素</li><li>int b[7]={1,2,3,4,5,9,8}; <code>vector&lt;int&gt; a(b,b+7);</code> //从数组中获得初值</li></ol><p><strong>二维数组的初始化</strong><br>初始化为0，0可变其他数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; vec(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (col,<span class="hljs-number">0</span>));<br></code></pre></td></tr></tbody></table></figure><p>返回值和使用时：必须用 dp[ i ]，不能用dp(i)</p><h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h1><p>普通数组 int a [10]，一旦定义了就不能改变了，这个数组最多只能放10个元素了<br>动态数组vector，不用关心初始的大小，可以随意的添加数据</p><p><strong>vector的底层实现也是普通数组</strong>。</p><p>vector的大小有两个维度一个是size一个是capicity，<br>size就是我们平时用来遍历vector时候用的，例如：<code>for (int i = 0; i &lt; vec.size(); i++)</code><br>而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size<br>当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴露的size其实仅仅是+1而已，剩下的位置还是空闲的</p><p>C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上，然后在释放原数组内存。<br>eg：<br>原vector中的size和capicity相同都是3，初始化为1 2 3，此时要push_back一个元素4。<br>那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存，<br><strong>注意图中底层数组的内存起始地址已经变了</strong>。<br><img src="https://img-blog.csdnimg.cn/20201218185902217.png" alt="vector原理|800"></p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2)了，甚至可能拷贝好几次，就不止O(n^2)了。</p><p>解决办法：可以采用链表来进行插入操作<br>    eg：<code>vector&lt;vector&lt;int&gt;&gt; que：[[7,0],[7,1]]</code> →<code>list&lt;vector&lt;int&gt;&gt; que：[7,0]→[7,1]</code></p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><p><a href="https://blog.csdn.net/wkq0825/article/details/82255984?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165701148116781683956725%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165701148116781683956725&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82255984-null-null.142%5Ev30%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=vector+c+++%E7%94%A8%E6%B3%95&amp;spm=1018.2226.3001.4187">C++ vector的用法（整理）_一个幽默且帅气的程序员的博客-CSDN博客_c++ vector</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.分发糖果</title>
      <link href="/posts/43465/"/>
      <url>/posts/43465/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分发糖果"><a href="#1-分发糖果" class="headerlink" title="1 分发糖果"></a>1 分发糖果</h1><p><a href="https://leetcode-cn.com/problems/candy/">力扣题目链接</a></p><p>老师想给孩子们分发糖果，有 N&nbsp;个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>  每个孩子至少分配到 1 个糖果。</li><li>  相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例&nbsp;1:</p><ul><li>  输入: [1,0,2]</li><li>  输出: 5</li><li>  解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</li></ul><p>示例&nbsp;2:</p><ul><li>  输入: [1,2,2]</li><li>  输出: 4</li><li>  解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>先比较每一个孩子的右边或者左边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>rate：评分；candyVec：糖果个数</p><p><strong>右边</strong>：从前往后遍历<br>局部最优：如果右比左大，右边孩子就多一个糖果。<br>全局最优：总体中评分高的右孩子比左孩子多一个糖果<br><img src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果|700"><br><strong>左边</strong>：从后往前遍历<br>局部最优：如果左比右大，左边孩子就多一个糖果。<br>全局最优：总体中评分高的左孩子比右孩子多一个糖果<br>#flashcards/代码随想录<br>为什么不能从前往后遍历<br>?<br>因为如果继续从前向后遍历，就无法利用上一次得出的candyVec的数组了</p><!--SR:!2022-07-31,27,250--><p>eg：<br><img src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1|700"><br>如果是图中这样的话，就没必要用max函数了啊 #疑问 </p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>自写代码已通过，没有用max函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span></span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>] &gt; ratings[i]) {<br>            candyVec[i+<span class="hljs-number">1</span>] = candyVec[i]+<span class="hljs-number">1</span>;<br>            }<br>       }<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- ) { <span class="hljs-comment">// 从倒数第二位置开始比</span><br>        <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]){<br>            candyVec[i] = candyVec[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            }<br>       }<br>       <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : candyVec) result += a; <span class="hljs-comment">// 分号后边只需要变量名就行</span><br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>参考资料<br>[[for 循环]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.柠檬水找零</title>
      <link href="/posts/52728/"/>
      <url>/posts/52728/</url>
      
        <content type="html"><![CDATA[<h1 id="1-860-柠檬水找零"><a href="#1-860-柠檬水找零" class="headerlink" title="1 860.柠檬水找零"></a>1 860.柠檬水找零</h1><p><a href="https://leetcode-cn.com/problems/lemonade-change/">力扣题目链接</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;5&nbsp;美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回&nbsp;true&nbsp;，否则返回 false&nbsp;。</p><p>示例 1：</p><ul><li>  输入：[5,5,5,10,20]</li><li>  输出：true</li><li>解释：<ul><li>  前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</li><li>  第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</li><li>  第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</li><li>  由于所有客户都得到了正确的找零，所以我们输出 true。</li></ul></li></ul><p>示例 2：</p><ul><li>  输入：[5,5,10]</li><li>  输出：true</li></ul><p>示例 3：</p><ul><li>  输入：[10,10]</li><li>  输出：false</li></ul><p>示例 4：</p><ul><li>  输入：[5,5,10,10,20]</li><li>  输出：false</li><li>解释：<ul><li>  前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</li><li>  对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</li><li>  对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</li><li>  由于不是每位顾客都得到了正确的找零，所以答案是 false。</li></ul></li></ul><p>提示：</p><ul><li>  0 &lt;= bills.length &lt;= 10000</li><li>  bills[i]&nbsp;不是&nbsp;5&nbsp;就是&nbsp;10&nbsp;或是&nbsp;20</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>有如下三种情况：</p><ul><li>  情况一：账单是5，直接收下。</li><li>  情况二：账单是10，消耗一个5，增加一个10</li><li>  情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5<br>用新型for循环 for (int bill : bills)，逐一对元素进行判断就行[[for 循环]]</li></ul><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？<br><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>局部最优：逐一对元素进行判断<br>全局最优：完成全部账单的找零</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>自写，已编译成功</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>{<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>, twenty = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) { <span class="hljs-comment">// 顺序遍历数组,先从第一个元素开始</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>){<br>                five ++;<br>            }<br>            <span class="hljs-comment">// else return false; 不需要这行代码因为5肯定能收</span><br><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>){<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span>) {<br>                    five--;<br>                    ten++;<br>                }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>            }<br><br>            <span class="hljs-keyword">if</span>(bill == <span class="hljs-number">20</span>){<br>                <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>){<br>                    ten--;<br>                    five--;<br>                }<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( five &gt;= <span class="hljs-number">3</span>){ <span class="hljs-comment">// 一定要用else if 下边也用else，这样这三个函数才能成为整体</span><br>                    five -= <span class="hljs-number">3</span>;<br>                }<br>                <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放在整体for循环外</span><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for 循环</title>
      <link href="/posts/28967/"/>
      <url>/posts/28967/</url>
      
        <content type="html"><![CDATA[<p><a href="obsidian://advanced-uri?vault=Documents&amp;uid=e21b2a82-20a3-4f7e-981e-d83e6df620a5">ob</a></p><h1 id="1-遍历函数"><a href="#1-遍历函数" class="headerlink" title="1 遍历函数"></a>1 遍历函数</h1><p>操作到最后一个元素时不会取到最后一个下标的后一位(也就是长度)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){<br>         result += <span class="hljs-built_in">max</span>(prices[i+<span class="hljs-number">1</span>] - prices[i],<span class="hljs-number">0</span>);<span class="hljs-comment">// 用!=更好</span><br>     }<br></code></pre></td></tr></tbody></table></figure><p>从后往前遍历：<code>for (int i = num.size () - 1; i &gt; 0; i--)</code> 这个操作不了第一个元素(下标0)</p><p>从前往后遍历：<code>for(int i = 0 ; i &lt; num.size(); i++)</code>，</p><h1 id="2-数组求和"><a href="#2-数组求和" class="headerlink" title="2 数组求和"></a>2 数组求和</h1><p>for (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体<br>应用：对数组求和<br>    从第一个元素开始操作</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A是数组，for循环对数组求和</span><br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A)  result += a; <span class="hljs-comment">// a没有特殊的意义，只是指明循环变量的类型，“:”后只需数组名即可</span><br></code></pre></td></tr></tbody></table></figure><p>#flashcards/代码随想录<br>n%2 == 1什么意思<br>?<br>n%2就是对n求：n除以2后的余数，这里余数只有两种情况就是0或者是1<br>eg：5%2=1</p><!--SR:!2022-08-01,28,250-->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯铝的性能指标</title>
      <link href="/posts/25410/"/>
      <url>/posts/25410/</url>
      
        <content type="html"><![CDATA[<p><a href="marginnote3app://note/3AE993AE-E623-4E05-BDD8-A7A400FEE1A2">margin</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=1eb5db61-b344-4a33-a07a-7a34f51a00d0">ob</a></p><h1 id="1-梯度结构纯铝的形貌"><a href="#1-梯度结构纯铝的形貌" class="headerlink" title="1 梯度结构纯铝的形貌"></a>1 梯度结构纯铝的形貌</h1><h2 id="1-1-成形效果"><a href="#1-1-成形效果" class="headerlink" title="1.1 成形效果"></a>1.1 成形效果</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs col">![](https://s1.vika.cn/space/2022/06/02/bca77150b3084c549a77bf090cb2ce2e)<br>挤出长度跟出口厚度成反比<br><br>![](https://s1.vika.cn/space/2022/06/02/6b18b35cc90944fcb6872a47dc51dec5)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="1-2-原始纯铝与梯度纯铝的微观组织"><a href="#1-2-原始纯铝与梯度纯铝的微观组织" class="headerlink" title="1.2 原始纯铝与梯度纯铝的微观组织"></a>1.2 原始纯铝与梯度纯铝的微观组织</h2><p><img src="https://s1.vika.cn/space/2022/06/02/e1b9812b60f64c419b2299c54afa3da3" alt="|600"><br><img src="https://s1.vika.cn/space/2022/06/02/a666e2c8fa314ef4b4be704418324067" alt="|600"><br>B侧细化 A侧基本没变，成梯度材料</p><h2 id="1-3-微观组织演变机制"><a href="#1-3-微观组织演变机制" class="headerlink" title="1.3 微观组织演变机制"></a>1.3 微观组织演变机制</h2><p><img src="https://s1.vika.cn/space/2022/06/02/bdf90acd645c4bd490a1c54d6111f285" alt="|600"></p><h1 id="2-梯度结构纯铝的力学性能"><a href="#2-梯度结构纯铝的力学性能" class="headerlink" title="2 梯度结构纯铝的力学性能"></a>2 梯度结构纯铝的力学性能</h1><h2 id="2-1-梯度结构纯铝的硬度梯度"><a href="#2-1-梯度结构纯铝的硬度梯度" class="headerlink" title="2.1 梯度结构纯铝的硬度梯度"></a>2.1 梯度结构纯铝的硬度梯度</h2><p>原材料32HV，梯度材料44HV<br>B测最高，到A测减少，因为晶粒细化，但靠近A侧硬度平稳且有所提升，是产生了材料硬化<br>金属材料的硬度与其晶粒大小成反比,即<strong>晶粒越细,材料的硬度越高</strong><br><img src="https://s1.vika.cn/space/2022/06/02/d74d109525504da5b0b60ac6c71974c2" alt="|600"></p><h2 id="2-2-梯度结构纯铝的拉伸性能"><a href="#2-2-梯度结构纯铝的拉伸性能" class="headerlink" title="2.2 梯度结构纯铝的拉伸性能"></a>2.2 梯度结构纯铝的拉伸性能</h2><p>梯度材料拉伸强度达到了160MPa，是原件的一倍多<br><img src="https://s1.vika.cn/space/2022/06/02/6591bb51508e4f82bf050a2253d22844" alt="|600"><br>随着厚度的增加, 梯度样品的抗拉强度逐渐下降,而延展性逐渐增强</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://s1.vika.cn/space/2022/06/02/9d767470c48f4318941bd9b40ca940a4)<br><br>![](https://s1.vika.cn/space/2022/06/02/f98676a6b6414cb4bb655c06d5ecbcb3)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="2-3-拉伸断口分析"><a href="#2-3-拉伸断口分析" class="headerlink" title="2.3 拉伸断口分析"></a>2.3 拉伸断口分析</h2><p>人们希望韧性断裂，而不是脆性断裂。通过观察端口来进行分析</p><p>怎么分析端口是韧性断裂还是塑性断裂<br>?<br>韧窝的尺寸越大,材料的塑性越好，韧窝的尺寸大小也不均匀,既有 10 μm 左右的大韧窝,也有 2 μm 左右的小韧窝,这是由于在拉伸变形过程中,小韧窝不断拉长、聚合成大韧窝,同时也有小韧窝不断萌生</p><p>纯铝原材料的拉伸断口呈现出典型的韧性断裂特征是<strong>韧性断裂</strong></p><p><img src="https://s1.vika.cn/space/2022/06/02/9434e67a2f554ef2a718b05c74d585b1" alt="|600"><br>梯度材料纯铝也是<strong>韧性断裂</strong>，韧窝也主要分布在纤维区和剪切唇的部分区域<br><img src="https://s1.vika.cn/space/2022/06/02/a99078324c754506acf4df4755369ad6" alt="|600"></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料性能 </tag>
            
            <tag> 塑性流动挤出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/4/"/>
      <url>/posts/4/</url>
      
        <content type="html"><![CDATA[<p>sort函数默认从小到大排列，如需自定义需要额外写个函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b); <span class="hljs-comment">// 返回绝对值大的</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="1-应用"><a href="#1-应用" class="headerlink" title="1 应用"></a>1 应用</h1><h2 id="1-1-按照绝对值从大到小排列，"><a href="#1-1-按照绝对值从大到小排列，" class="headerlink" title="1.1 按照绝对值从大到小排列，"></a>1.1 按照绝对值从大到小排列，</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br></code></pre></td></tr></tbody></table></figure><h2 id="1-2-从大到小排列：-14-根据身高重建队列"><a href="#1-2-从大到小排列：-14-根据身高重建队列" class="headerlink" title="1.2 从大到小排列：[[14.根据身高重建队列]]"></a>1.2 从大到小排列：[[14.根据身高重建队列]]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 身高从大到小排（身高相同k小的站前面）</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br></code></pre></td></tr></tbody></table></figure><p>bool 值好像是规定的 #疑问 </p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 第三个参数不用出入参数这是规则</span><br></code></pre></td></tr></tbody></table></figure><p>[[static 关键字]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/3/"/>
      <url>/posts/3/</url>
      
        <content type="html"><![CDATA[<hr><p>dg-home: true<br>dg-publish: true</p><hr><h1 id="1-1005-K次取反后最大化的数组和"><a href="#1-1005-K次取反后最大化的数组和" class="headerlink" title="1 1005.K次取反后最大化的数组和"></a>1 1005.K次取反后最大化的数组和</h1><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接</a></p><p>1131</p><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i&nbsp;并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p>示例 1：</p><ul><li>  输入：A = [4,2,3], K = 1</li><li>  输出：5</li><li>  解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</li></ul><p>示例 2：</p><ul><li>  输入：A = [3,-1,0,2], K = 3</li><li>  输出：6</li><li>  解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。</li></ul><p>示例 3：</p><ul><li>  输入：A = [2,-3,-1,5,-4], K = 2</li><li>  输出：13</li><li>  解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。</li></ul><p>提示：</p><ul><li>  1 &lt;= A.length &lt;= 10000</li><li>  1 &lt;= K &lt;= 10000</li><li>  -100 &lt;= A[i] &lt;= 100</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>局部最优：让绝对值大的负数变成正数<br>整体最优：整个数组求和变最大</p><p>如果将负数都转变为正数了，K依然大于0，就把绝对值最小的数变为负数</p><p>本题的解题步骤为：</p><ul><li>  第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li><li>  第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完<ul><li>如果k是偶数则相当于没有变，因为可以对一个数重复两次操作</li><li>如果是奇数，只需要操作一个数，剩下的就是偶数也不用管了<ul><li>即<code>if (K % 2 == 1) A[A.size() - 1] *= -1;</code></li></ul></li></ul></li><li>  第四步：求和</li></ul><p>相关知识点<br>    [[sort函数]]<br>    [[for 循环]]</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>自写：编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);    <br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span></span>{<br>    <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 第一步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i != A.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// 第二步</span><br>        <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>){<br>            A[i] *= <span class="hljs-number">-1</span>;<br>            K--;<br>        }<br>    }<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){ <span class="hljs-comment">// 第三步</span><br>            A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;<br>        }<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a; <span class="hljs-comment">// 注意是小a(A中的每个元素)</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6. 买卖股票的最佳时机II</title>
      <link href="/posts/38547/"/>
      <url>/posts/38547/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>    力扣题解：</p><span id="more"></span><h1 id="1-122-买卖股票的最佳时机II"><a href="#1-122-买卖股票的最佳时机II" class="headerlink" title="1 122.买卖股票的最佳时机II"></a>1 122.买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接</a></p><p>给定一个数组，它的第&nbsp;i 个元素是一支<strong>给定股票</strong>第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><ul><li>  输入: [7,1,5,3,6,4]</li><li>  输出: 7</li><li>  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</li></ul><p>示例 2:</p><ul><li>  输入: [1,2,3,4,5]</li><li>  输出: 4</li><li>  解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</li></ul><p>示例&nbsp;3:</p><ul><li>  输入: [7,6,4,3,1]</li><li>  输出: 0</li><li>  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</li></ul><p>提示：</p><ul><li>  1 &lt;= prices.length &lt;= 3 * 10 ^ 4</li><li>  0 &lt;= prices[i] &lt;= 10 ^ 4</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p><strong>最终利润是可以分解的</strong>，<strong>把利润分解为每天为单位的维度</strong><br>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。<br>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。 </p><p><strong>把整体利润拆为每天的利润</strong><br>每天的利润序列：(prices[i] - prices[i - 1])+…..+(prices[1] - prices[0])<br><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II|650"><br>第一天没利润，利润表比股票价格表少一位 </p><p>局部最优：求得每天的正利润， </p><p>全局最优：求和每天的正利润 </p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h1><p>[[for 循环]]</p><p>编译已通过 </p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != prices.<span class="hljs-built_in">size</span>(); i++){<br>            result += <span class="hljs-built_in">max</span>(prices[i+<span class="hljs-number">1</span>] - prices[i],<span class="hljs-number">0</span>);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static 关键字</title>
      <link href="/posts/37179/"/>
      <url>/posts/37179/</url>
      
        <content type="html"><![CDATA[<p>static 关键字有三种用法</p><ol><li>static 修饰局部变量 → 静态局部变量<ol><li>改变局部变量的生命周期，下次使用该局部变量是上次使用完后的值，而不是初始值</li></ol></li><li>static 修饰全局变量 →静态全局变量<ol><li>只能在本文件内使用，不能在其他文件中访问，extern外边声明也不行(无static时默认是可以被外部访问的)</li></ol></li><li>static 修饰函数 →静态函数<ol><li>只能在本文件中<strong>调用</strong>，同2</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.摆动序列</title>
      <link href="/posts/74/"/>
      <url>/posts/74/</url>
      
        <content type="html"><![CDATA[<h1 id="1-摆动序列"><a href="#1-摆动序列" class="headerlink" title="1 摆动序列"></a>1 摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">力扣题目链接</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如，&nbsp;[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)&nbsp;是正负交替出现的。相反, [1,4,7,2,5]&nbsp;和&nbsp;[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><ul><li>  输入: [1,7,4,9,2,5]</li><li>  输出: 6</li><li>  解释: 整个序列均为摆动序列。</li></ul><p>示例 2:</p><ul><li>  输入: [1,17,5,10,13,15,10,5,16,8]</li><li>  输出: 7</li><li>  解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例 3:</p><ul><li>  输入: [1,2,3,4,5,6,7,8,9]</li><li>  输出: 2<blockquote><p>后一个数减前一个数的值，正负交替</p></blockquote></li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p><img src="https://s1.vika.cn/space/2022/05/28/1af591dff4b846a3999e21e948dd6e70"></p><p>局部最优：变成没有坡度的峰<br>整体最优：尽可能有最多的<strong>没有坡度的峰</strong></p><p>最左面和最右面的峰值不好统计<br>可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0</p><p>定义变量：<br>左坡度：preDiff &gt;= 0 或者preDiff &lt;= 0也行，(等于0是最左面的情况)<br>右坡度：curDiff &lt; 0 或者cur &gt;0,<br>result：统计百度序列的个数</p><blockquote><p>反正左坡度和右坡度需要异号，并且左坡度可以 = 0；<br><img src="https://s1.vika.cn/space/2022/05/28/f1551bf99b894ba08967e7dd87387603"></p></blockquote><p>result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p><blockquote><p>问：这样话直接把result初始为2不行吗？<br>   答：要用到前一对和后一对的差值。只有有两个数就可以有这两个差值，所以nums.size() &lt;= 1 即可返回</p></blockquote><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span>( nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 长度不超过1</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right =&nbsp;<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){ <span class="hljs-comment">// 这样写更好</span><br>            right =&nbsp;nums[i] - nums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt;= <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span> &amp;&amp; left &gt;= <span class="hljs-number">0</span>){ <span class="hljs-comment">// 两边要异号啊</span><br>                result++;<br>                left = right;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心</strong>。<br>有什么方法想到贪心→多做</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brew安装</title>
      <link href="/posts/4339/"/>
      <url>/posts/4339/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.vika.cn/space/2022/05/28/0b3ffbfe5ad64d388d02bceff24ab6a0"></p><p>用官网安装出现以下错误：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">curl: (<span class="hljs-number">7</span>) Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> raw.githubusercontent.com port <span class="hljs-number">443</span>: <span class="hljs-keyword">Connection</span> refused<br></code></pre></td></tr></tbody></table></figure><p>原因是：<strong>github 的一些域名的 DNS 解析被污染</strong>，导致DNS 解析过程无法通过域名取得正确的IP地址</p><p>换成国内下载地址即可</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>zsh -c <span class="hljs-string">"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"</span><br></code></pre></td></tr></tbody></table></figure><p>根据终端反应输入即可，过程中有中文提示</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac下软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 生成ssh密钥</title>
      <link href="/posts/18965/"/>
      <url>/posts/18965/</url>
      
        <content type="html"><![CDATA[<p>linux命令<br>查看密钥是否生成：ls -l ~/.ssh</p><p>生成密钥：ssh-keygen&nbsp;-t&nbsp;rsa (一路回车)</p><p>密钥所在目录：<br>cd ~/.ssh</p><p>私钥：id_rsa<br>公钥：id_rsa.pub </p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.分发饼干</title>
      <link href="/posts/42003/"/>
      <url>/posts/42003/</url>
      
        <content type="html"><![CDATA[<h1 id="1-455-分发饼干"><a href="#1-455-分发饼干" class="headerlink" title="1 455.分发饼干"></a>1 455.分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">力扣题目链接</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值&nbsp;**g[i]**，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <strong>s[j]</strong>&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例&nbsp;1:</p><ul><li>  输入: g = [1,2,3], s = [1,1]</li><li>  输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</li></ul><p>示例&nbsp;2:</p><ul><li>  输入: g = [1,2], s = [1,2,3]</li><li>  输出: 2</li><li>  解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</li></ul><p>提示：</p><ul><li>  1 &lt;= g.length &lt;= 3 * 10^4</li><li>  0 &lt;= s.length &lt;= 3 * 10^4</li><li>  1 &lt;= g[i], s[j] &lt;=&nbsp;2^31 - 1</li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>局部最优：大饼干喂给胃口大的孩子(尽量充分利用饼干)<br>全局最优：喂饱尽可能多的小孩</p><p>将饼干数组和小孩数组拍个序<br><strong>从后向前遍历</strong>，即大饼干满足胃口的大孩子，<strong>并</strong>统计满足小孩数量<br><img src="https://s1.vika.cn/space/2022/05/27/1c68ab105c2d4666a72ac61ebbca6600" alt="|700"><br>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><h1 id="3-力扣代码"><a href="#3-力扣代码" class="headerlink" title="3 力扣代码"></a>3 力扣代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 饼干数组的最后一个元素</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计孩子的数</span><br>        <span class="hljs-comment">//因为想从后往前遍历对比，所以用i-- ，而不用i++，g.size() - 1是孩子数组的最后一个元素，</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>  ; i--){ <span class="hljs-comment">// ”=“号为对比到最后一个孩子 </span><br>            <span class="hljs-keyword">if</span> (index  &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]){<br>                result++;<br>                index--;<br>            }<br>        } <br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/1/"/>
      <url>/posts/1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-贪心算法的题目大纲"><a href="#1-贪心算法的题目大纲" class="headerlink" title="1 贪心算法的题目大纲"></a>1 贪心算法的题目大纲</h1><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"></p><h1 id="2-什么是贪心算法"><a href="#2-什么是贪心算法" class="headerlink" title="2 什么是贪心算法"></a>2 什么是贪心算法</h1><p>局部最优推出全局最优<br>eg：一堆钱里只能拿10张，如何拿到最大。每一次都拿的最大(局部最优)→总共拿的最大(全局最优)</p><h1 id="3-什么时候用贪心算法"><a href="#3-什么时候用贪心算法" class="headerlink" title="3 什么时候用贪心算法"></a>3 什么时候用贪心算法</h1><p>看到题目时，感受到能够：<strong>局部最优→全局最优，且想不到反例</strong>。就试一试贪心.<br>感觉贪心算法更看直觉能不能用</p><h1 id="4-贪心算法的套路"><a href="#4-贪心算法的套路" class="headerlink" title="4 贪心算法的套路"></a>4 贪心算法的套路</h1><ol><li>将总问题划分为子问题</li><li>找到合适的最优解法</li><li>对子问题进行最优求解</li><li>将子问题堆积成总问题</li></ol><p>实际上解题没有这么细，因为贪心算法还与其他知识联合在一起</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21.解数独</title>
      <link href="/posts/5566/"/>
      <url>/posts/5566/</url>
      
        <content type="html"><![CDATA[<p>N皇后是每一行找一个位置放皇后<br>数独是<strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法</strong></p><p>void backtracking(参数) {<br>        startIndex：控制下一层的起始位置<br>            去重(从下一层的第一个位置开始：backtracking(…., i+1))<br>            排列问题不用startIndex<br>        used[]：去重(从下一层的起始位置开始：backtracking(…., 0))<br>    if (终止条件) {<br>        存放结果;<br>    return;<br>        要取树上所有节点时不要加return<br>    }<br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    }<br> }</p><h1 id="1-回溯三部曲"><a href="#1-回溯三部曲" class="headerlink" title="1 回溯三部曲"></a>1 回溯三部曲</h1><p>定义一些变量</p><h2 id="1-1-确定回溯函数参数返回值"><a href="#1-1-确定回溯函数参数返回值" class="headerlink" title="1.1 确定回溯函数参数返回值"></a>1.1 确定回溯函数参数返回值</h2><p>数独和N皇后的返回值用bool值</p><h2 id="1-2-终止条件-存放结果-return"><a href="#1-2-终止条件-存放结果-return" class="headerlink" title="1.2 终止条件, 存放结果, return"></a>1.2 终止条件, 存放结果, return</h2><p>不需要终止条件，等数填满了，棋盘自然终止</p><h2 id="1-3-单层搜索过程"><a href="#1-3-单层搜索过程" class="headerlink" title="1.3 单层搜索过程"></a>1.3 单层搜索过程</h2><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><h3 id="1-3-1-判断棋盘是否合法"><a href="#1-3-1-判断棋盘是否合法" class="headerlink" title="1.3.1 判断棋盘是否合法"></a>1.3.1 判断棋盘是否合法</h3><p>判断棋盘是否合法有如下三个维度：</p><ul><li>  同行是否重复</li><li>  同列是否重复</li><li>  9宫格里是否重复</li></ul><p>#flashcards/代码随想录 #疑问<br>二维数组的行数与列数<br>?<br>int array[2]  [3]；二行三列<br>    int row = array.size();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行数&nbsp;&nbsp;&nbsp;<br>    int col = array[0].size();  列数</p><!--SR:!2022-08-02,29,250-->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手</title>
      <link href="/posts/61990/"/>
      <url>/posts/61990/</url>
      
        <content type="html"><![CDATA[<p>三次握手的目的是保证双方互相之间建立了连接<br>三次握手发生在客户端连接的时候，当调用connect()函数时，底层会通过TCP协议进行三次握手。</p><p>seq：序号<br>ACK：标志位<br>    ack(AcK)：确认序号，只有当 ACK=1 时确认序号才有用<br>TCP是用字节流传输，会为每个字节分配一个序号 </p><h1 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1 三次握手"></a>1 三次握手</h1><p>时序图<br><img src="https://s1.vika.cn/space/2022/05/26/9e8848db48ec40d2a865d364ed1dfe16"></p><p>牛客总结<br>    第一次握手：<br>    1.客户端将SYN标志位置为1，向服务端请求建立连接，<br>    2.生成一个随机(<font color="#F36208">其实是有固定算法的</font>)的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小）<br>    第二次握手：<br>    1.服务端将<font color="#F36208">标志位</font><font color="#F36208">ACK</font>置为1，接收客户端的连接。<br>        并且回发一个确认序号：ack=客户端的序号 +  数据长度+ SYN/FIN（按一个字节算）<br>    2.服务器端会向客户端发起连接请求：SYN=1<br>    3.服务器会生成一个随机序号(<font color="#F36208">其实是有固定算法的</font>)：seq = K<br>    第三次握手：<br>    1.客户单应答服务器的连接请求：ACK=1<br>    2.客户端回复收到了服务器端的数据：ack=服务端的序号 +数据长度 + SYN/FIN（按一个字节算）<br>自己总结<br>    <font color="#F36208">    第一次握手：客户端发起连接</font><br>        1.客户端将标志位SYN置位1，表示向服务端请求连接。2.并且根据算法生成一个客户端序号cseq：J<br>    <font color="#F36208">    第二次握手：服务端回复请求，发起连接</font><br>        1.服务端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 客户端的序号(J) + 数据字节个数 + SYN/FIN(算一个字节)<br>        3.服务端将标志位SYN置位1，表示向客户端请求连接。4.并且根据算法生成一个服务端序号sseq：K<br>    <font color="#F36208">    第三次握手：客户端回复请求</font><br>        1.客户端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 服务端的序号(K) + 数据字节个数 + SYN/FIN(算一个字节)  </p><p>第一次握手(客户端→服务端)：客户端请求连接<br>    客户端与服务端还没有建立连接，不能发数据<br>第二次握手(客户端←服务端)：服务端同意连接+请求与客户端连接<br>第三次握手(客户端→服务端)：客户端同意连接<br>    此时客户端已经和服务端已经建立了连接，这次客户端的握手已经可以携带数据了<br>之后服务端与客户端都互相建立了连接，可以互相自由通信</p><h2 id="1-1-三次握手实例"><a href="#1-1-三次握手实例" class="headerlink" title="1.1 三次握手实例"></a>1.1 三次握手实例</h2><p><img src="https://s1.vika.cn/space/2022/05/26/e1cbc619a8b445c5a3cb9282c0d21c21"></p><h2 id="1-2-为什么不能两次握手"><a href="#1-2-为什么不能两次握手" class="headerlink" title="1.2 为什么不能两次握手"></a>1.2 为什么不能两次握手</h2><p>因为要确保客户端能<font color="#C32E94">收发</font>消息，服务端能<font color="#C32E94">收发</font>消息，3次握手正好少一次都不行<br><img src="https://s1.vika.cn/space/2022/05/26/7f7c22713cf345368d2778005723b9b1"></p><p>四次握手也是可以的，服务端的ACK和SYN连在一起发了，拆开发就是四次握手<br>保证可靠连接的最小次数是三次握手</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/2/"/>
      <url>/posts/2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第51题-N皇后"><a href="#1-第51题-N皇后" class="headerlink" title="1 第51题. N皇后"></a>1 第51题. N皇后</h1><p><a href="https://leetcode-cn.com/problems/n-queens/">力扣题目链接</a></p><p>n&nbsp;皇后问题 研究的是如何将 n&nbsp;个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的&nbsp;n&nbsp;皇后问题 的解决方案。</p><p>每一种解法包含一个不同的&nbsp;n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例 1：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211020232201.png"></p><ul><li>  输入：n = 4</li><li>  输出：[ [“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”] ]</li><li>  解释：如上图所示，4 皇后问题存在两个不同的解法。</li></ul><p>示例 2：</p><ul><li>  输入：n = 1</li><li>  输出：[ [“Q”] ]</li></ul><p>皇后们的约束条件：</p><ol><li> 不能同行</li><li> 不能同列</li><li> 不能同斜线</li></ol><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h1><p>好吧</p><p>![[20.N皇后 2022-05-25 10.54.39.excalidraw]]</p><p>回溯的过程到底是什么样的，录视频 ，找一个简单的题录视频吧 #疑问<br>    目前看来是回溯到代码随想录那种图的第二层然后在往下走吧</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
