<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机中的乱序执行</title>
      <link href="/posts/45791/"/>
      <url>/posts/45791/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br>2022/10/20🌵source/_posts/👨🏻‍💻code/C++/C++基础/计算机中的乱序执行.md : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C 与 C++的内存分配方式</title>
      <link href="/posts/48215/"/>
      <url>/posts/48215/</url>
      
        <content type="html"><![CDATA[<p>![[进程的地址空间分布.excalidraw]]</p><h1 id="1-从静态存储区域分配"><a class="markdownIt-Anchor" href="#1-从静态存储区域分配"></a> 1 从静态存储区域分配</h1><p>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，如全局变量，static 变量。</p><h1 id="2-在栈上创建"><a class="markdownIt-Anchor" href="#2-在栈上创建"></a> 2 在栈上创建</h1><p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。<br>栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><h1 id="3-从堆上分配动态内存分配"><a class="markdownIt-Anchor" href="#3-从堆上分配动态内存分配"></a> 3 从堆上分配（动态内存分配）</h1><p>程序在运行的时候用malloc或new申请任意多少的内存，程序员负责在何时用free或delete释放内存。动态内存的生存期自己决定，使用非常灵活。</p><blockquote><p>[!tip] 还不如用智能指针, 省心呢</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br>2022/10/20🌵C 与 C++的内存分配方式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程的地址空间分布</title>
      <link href="/posts/10783/"/>
      <url>/posts/10783/</url>
      
        <content type="html"><![CDATA[<p>![[进程的地址空间分布.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br>2022/10/20🌵进程的地址空间分布 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试题目</title>
      <link href="/posts/15105/"/>
      <url>/posts/15105/</url>
      
        <content type="html"><![CDATA[<h1 id="1-以下为windowsnt32位c程序请计算下面sizeof的值"><a class="markdownIt-Anchor" href="#1-以下为windowsnt32位c程序请计算下面sizeof的值"></a> 1 以下为WindowsNT32位C++程序，请计算下面sizeof的值</h1><p>‌‌‌　　![[测试题目 2022-10-20 21.21.54.excalidraw]]</p><h1 id="2-分析运行下面的-test-函数会有什么样的结果"><a class="markdownIt-Anchor" href="#2-分析运行下面的-test-函数会有什么样的结果"></a> 2 分析运行下面的 Test 函数会有什么样的结果</h1><p>‌‌‌　　![[测试题目 2022-10-20 21.29.08.excalidraw]]</p><h1 id="3-margin-5-按照下面描述的要求写程序"><a class="markdownIt-Anchor" href="#3-margin-5-按照下面描述的要求写程序"></a> 3 <a href="marginnote3app://note/01314AD5-74D6-4B28-87DC-D66E4468EA26">margin: 5、按照下面描述的要求写程序</a></h1><blockquote><p>不想看</p></blockquote><h1 id="4-进程的地址空间分布"><a class="markdownIt-Anchor" href="#4-进程的地址空间分布"></a> 4 [[进程的地址空间分布]]</h1><h1 id="5-c-与-c的内存分配方式"><a class="markdownIt-Anchor" href="#5-c-与-c的内存分配方式"></a> 5 [[C 与 C++的内存分配方式]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br><a href="marginnote3app://note/FCA58332-0A24-428C-8279-6E04E253D12A">margin: 测试题目</a></p><p>2022/10/20🌵测试题目 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存泄露</title>
      <link href="/posts/20746/"/>
      <url>/posts/20746/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是内存泄露"><a class="markdownIt-Anchor" href="#1-什么是内存泄露"></a> 1 什么是内存泄露？</h1><p>内存泄漏 (memory leak) 是指由于疏忽或错误造成了<strong>程序未能释放掉不再使用的内存</strong>的情况。<br>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><p>可以使用Valgrind,mtrace进行内存泄漏检查。</p><p>什么操作会导致内存泄露？<br>指针指向改变，未释放动态分配内存。</p><h1 id="2-内存泄漏的分类"><a class="markdownIt-Anchor" href="#2-内存泄漏的分类"></a> 2 内存泄漏的分类</h1><p>(1) 堆内存泄漏 (Heap leak)<br>对内存指的是程序运行中根据需要分配通过 malloc,realloc new 等从堆中分配的一块内存，再是完成后必须通过调用对应的 free 或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生 Heap Leak.</p><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::内存泄露.md"--><p>(2) 系统资源泄露 (Resource Leak) ::<br>主要指程序使用系统分配的资源比如 Bitmap,handle,SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p><!-- basicblock-end --><p>(3) 没有将基类的析构函数定义为虚函数<br>当基类指针指向子类对象时，<strong>如果基类的析构函数不是virtual,那么子类的析构函数将不会被调用</strong>，子类的资源没有正确是释放，因此造成内存泄露。</p><h1 id="3-如何防止内存泄露"><a class="markdownIt-Anchor" href="#3-如何防止内存泄露"></a> 3 如何防止内存泄露？</h1><ul><li><p>将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；</p></li><li><p><a href="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">使用智能指针</a></p></li></ul><h1 id="4-构造函数析构函数要设为虚函数吗为什么"><a class="markdownIt-Anchor" href="#4-构造函数析构函数要设为虚函数吗为什么"></a> 4 构造函数，析构函数要设为虚函数吗，为什么？</h1><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::内存泄露.md"--><h2 id="41-构造函数"><a class="markdownIt-Anchor" href="#41-构造函数"></a> 4.1 构造函数::</h2><!-- basicblock-end --><blockquote><p>[!question] 设计模式中抽象构造函数就是虚函数啊<br>构造函数不需要，没有意义。虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。要创建一个对象，你需要知道对象的完整信息。特别是，你需要知道你想要创建的确切类型。因此，构造函数不应该被定义为虚函数。</p></blockquote><h2 id="42-析构函数"><a class="markdownIt-Anchor" href="#42-析构函数"></a> 4.2 析构函数</h2><p>析构函数需要。当派生类对象中有内存需要回收时，如果析构函数不是虚函数，不会触发动态绑定，只会调用基类析构函数，导致派生类资源无法释放，造成内存泄漏。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br>2022/10/20🌵内存泄露 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串函数</title>
      <link href="/posts/6626/"/>
      <url>/posts/6626/</url>
      
        <content type="html"><![CDATA[<h1 id="1-strcpy"><a class="markdownIt-Anchor" href="#1-strcpy"></a> 1 strcpy()</h1><p>把从 strsrc 地址开始且含有 <code>\O</code> 结束符的字符串, 复制到以 strdest 开始的地址空间，<br>返回值的类型为 char*</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strcpy</span> <span class="hljs-params">( <span class="hljs-type">char</span> *strDest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> strSrc)</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::字符串函数.md"--><h2 id="11-实现内存拷贝函数"><a class="markdownIt-Anchor" href="#11-实现内存拷贝函数"></a> 1.1 实现内存拷贝函数::</h2><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strcpy</span> <span class="hljs-params">( <span class="hljs-type">char</span> *strDest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> strSrc)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">assert</span> <span class="hljs-params">( (strDest != <span class="hljs-literal">NULL</span>) &amp;&amp; (strsrc!= <span class="hljs-literal">NULL</span>) )</span></span>;<br><span class="hljs-type">char</span> *address = strDest <br><span class="hljs-keyword">while</span>( (*strDest++ = *strSrc++) != <span class="hljs-string">'\0'</span>) ;<br><span class="hljs-keyword">return</span> address;<br><br></code></pre></td></tr></tbody></table></figure><p>‌‌‌<br>![[字符串函数 2022-10-20 21.46.36.excalidraw]]</p><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::字符串函数.md"--><h2 id="12-假如考虑-dst-和-src-内存重叠的情况strcpy-该怎么实现"><a class="markdownIt-Anchor" href="#12-假如考虑-dst-和-src-内存重叠的情况strcpy-该怎么实现"></a> 1.2 假如考虑 dst 和 src 内存重叠的情况，strcpy 该怎么实现::</h2><!-- basicblock-end --><p><a href="marginnote3app://note/B3CCC4DA-EBFC-40FB-8E82-2126D75E1395">margin: 假如考虑dst和src内存重叠的情况,strcpy该怎么实现</a><br>‌‌‌![[字符串函数 2022-10-20 21.56.10.excalidraw]]</p><h1 id="2-strlen"><a class="markdownIt-Anchor" href="#2-strlen"></a> 2 strlen ()</h1><p>计算给定字符串的长度。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">strlen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!principle]-<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210202046126.png" alt=""></p></blockquote><h1 id="3-strcat"><a class="markdownIt-Anchor" href="#3-strcat"></a> 3 strcat ()</h1><p>作用是把 src 所指字符串添加到 dest 结尾处。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> * dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> src)</span></span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!principle]-<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210202049202.png" alt=""></p></blockquote><h1 id="4-strcmp"><a class="markdownIt-Anchor" href="#4-strcmp"></a> 4 strcmp ()</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//strcmp的实现</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> str1,<span class="hljs-type">const</span> <span class="hljs-type">char</span> str2)</span>{<br>比较两个字符串设这两个字符串为 str1,str2, <br>若 str1 == str2, 则返回零<br>若 str1 &lt; str2, 则返回负数<br>若 str1 &gt; str2, 则返回正<br><br><br><br>assert(str1 &amp;str2); <br><span class="hljs-comment">//找到首个不相等的字符</span><br><span class="hljs-keyword">while</span>(*str1 &amp;&amp; *str2 &amp;&amp; (*str1 == *str2)) { <br>        str1++;<br>        str2++; <br>    }<br><span class="hljs-keyword">return</span> *str1 -*str2; <br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录:: <a href="marginnote3app://note/56EA588D-C1FA-4C28-8B3A-C621894541E4">margin: C++内存模型</a><br>2022/10/20🌵字符串操作函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++内存模型</title>
      <link href="/posts/57131/"/>
      <url>/posts/57131/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字符串函数"><a class="markdownIt-Anchor" href="#1-字符串函数"></a> 1 [[字符串函数]]</h1><h1 id="2-内存泄露"><a class="markdownIt-Anchor" href="#2-内存泄露"></a> 2 [[内存泄露]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br>2022/10/20🌵C++内存模型 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++强制类型转换</title>
      <link href="/posts/2120/"/>
      <url>/posts/2120/</url>
      
        <content type="html"><![CDATA[<p>关键字：static_cast、dynamic_.cast、reinterpret_cast 和 const_.cast</p><blockquote><p>[!summary]<br>上行转换：把派生类的指针或引用转换成基类表示<br>下行转换：把基类的指针或引用转换为派生类表示</p></blockquote><h1 id="1-static_cast"><a class="markdownIt-Anchor" href="#1-static_cast"></a> 1 static_cast</h1><p>![[C++强制类型转换 excalidraw]]</p><p>没有运行时类型检查来保证转换的安全性</p><p>用于低风险的转换： 基本类型<br>高风险转换：指针，引用…</p><p>进行上行转换是安全的<br>进行下行转换，由于没有动态类型检查，所以是不安全的。</p><p>使用：</p><ol><li>用于基本数据类型之间的转换，如把 int 转换成 char。</li><li>把任何类型的表达式转换成 void 类型。</li></ol><h1 id="2-dynamic_cast"><a class="markdownIt-Anchor" href="#2-dynamic_cast"></a> 2 dynamic_cast</h1><p>在进行下行转换时，dynamic_.cast具有类型检查（信息在虚函数中）的功能，比static_cast更安全。<br>转换后必须是类的指针、引用或者 void*, 基类要有虚函数，可以交叉转换。</p><p>dynamic 本身只能用于存在虚函数的父子关系的强制类型转换；<br>对于指针，转换失败则返回 nullptr,<br>对于引用，转换失败会抛出异常。</p><h1 id="3-reinterpret_cast"><a class="markdownIt-Anchor" href="#3-reinterpret_cast"></a> 3 reinterpret_cast</h1><p>可以将整型转换为指针，也可以把指针转换为数组；可以在指针和引用里进行肆无忌惮的转换，平台移植性比价差。</p><h1 id="4-const-cast"><a class="markdownIt-Anchor" href="#4-const-cast"></a> 4 const cast</h1><p>常量指针转换为非常量指针，并且仍然指向原来的对象。常量引用被转换为非常量引用，并且仍然指向原来的对象。去掉类型的 const 或 volatile 属性。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br>2022/10/20🌵C++强制类型转换 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/posts/47719/"/>
      <url>/posts/47719/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分类"><a class="markdownIt-Anchor" href="#1-分类"></a> 1 分类</h1><p>智能指针是为了解决动态分配内存导致内存泄露和多次释放同一内存所提出的，C11 标准中放在 <code>&lt;memory&gt;</code> 头文件。<br>包括：独占指针，共享指针，弱指针</p><p>c++中为什么要有智能指针<br>‌‌‌<br>![[智能指针 2022-10-20 17.17.29.excalidraw]]</p><h2 id="11-unique_ptrunique_ptrexcalidraw"><a class="markdownIt-Anchor" href="#11-unique_ptrunique_ptrexcalidraw"></a> 1.1 unique_ptr‌![[unique_ptr.excalidraw]]</h2><p>1、unique_ptr"唯一"拥有其所指对象<br>同一时刻只能有一个 unique_ptr 指向给定对象，离开作用域时，若其指向对象，则将其所指对象销毁（默认 delete<br>)<br>2、定义 unique_ptr 时<br>需要将其绑定到一个 new /make_unique 返回的指针上</p><p>3、unique_ptr 不支持普通的拷贝和赋值（因为拥有指向的对象）<br>但是可以拷贝和赋值一个将要被销毁的 unique_ptr; 可以通过 move /  (❓或者 release reset) 将指针所有权从一个（非 const) unique_ptr 转移到另一个 unique。</p><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::智能指针.md"--><h2 id="12-shared_ptr"><a class="markdownIt-Anchor" href="#12-shared_ptr"></a> 1.2 shared_ptr::</h2><!-- basicblock-end --><p>顾名思义 共享指针可以被共享 不像唯一指针 共享指针可以被多个所有者共享这意味着你可以将一个原始指针分配给多个所有者</p><p>![[shared_ptr.excalidraw]]</p><p>1、shared_ptr的实现机制是在拷贝构造时使用同一份引用计数<br>(1)一个模板指针<code>T*ptr</code> 指向实际的对象<br>(2)<strong>❓一个引用次数必须 new 出来的</strong>，不然会多个 shared_ptr 里面会有不同的引用次数而导致多次 delete<br>上面用的是： make_shared<br>(3)重载<code>operator*</code>和operator-&gt; 使得能像指针一样使用shared_ptr<br>(4)重载copy constructor 使其引用次数加一（拷贝构造函数）<br>(5)重载operatora=(赋值运算符) 如果原来的shared ptri已经有对象，则让其引用次数减一并判断引用是否为零（是否调用delete),然后将新的对象引用次数加一<br>(6)重载析构函数使引用次数减一并判断引用是否为零；（是否调用delete)</p><p>2、线程安全问题<br>(1)同一个shared_ptr被多个线程"读"是安全的；<br>(2)同一个shared_ptr被多个线程"写"是不安全的；<br>证明：在多个线程中同时对一个shared_ptr循环执行两遍swap。shared_ptr的swap函数的作用就是和另外一个shared_ptr交换引用对象和引用计数，是写操作。执行两遍swap之后，shared_ptr引用的对象的值应该不变<br>(3)共享引用计数的不同的shared_ptri被多个线程"写"是安全的。</p><h2 id="13-weak_ptr"><a class="markdownIt-Anchor" href="#13-weak_ptr"></a> 1.3 weak_ptr</h2><p>1、weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况，<br>但 weak_ptr 没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>2、和 shared_ptr 指向相同内存 shared_ptr 析构之后内存释放，<br>在使用之前使用函数 Iock () 检查 weak_ptr 是否为空指针。</p><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::智能指针.md"--><p>那个视频里没听懂::</p><!-- basicblock-end --><p>![[weak_ptr.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录:: <a href="https://www.bilibili.com/video/BV123411T747/?spm_id_from=333.788.recommend_more_video.4&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++智能指针初学者20分钟入门[搬运自油管#code_beauty]_哔哩哔哩_bilibili</a><br>2022/10/20🌵智能指针 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口的实现</title>
      <link href="/posts/48213/"/>
      <url>/posts/48213/</url>
      
        <content type="html"><![CDATA[<p>接口描述了类的行为和功能，而不需要完成类的特定实现；<br><strong>C++接口是使用抽象类来实现的</strong></p><p>1、类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用"=0”来指定的。<br>2、设计抽象类（通常称为 ABC) 的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 案例： 计算面积</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> { <br><span class="hljs-keyword">public</span>: <br><span class="hljs-comment">//提供接口框架的纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setwidth</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> </span><br><span class="hljs-function">    </span>{ <br>        width w; <br>    } <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> </span><br><span class="hljs-function">    </span>{ <br>        height h; <br>    } <br>    <span class="hljs-keyword">protected</span>: <br>        <span class="hljs-type">int</span> width; <br>        <span class="hljs-type">int</span> height; <br>};<br><span class="hljs-comment">//派生类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写</span><br>        <span class="hljs-keyword">return</span> (width * height); <br>    } <br>}; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span> : <span class="hljs-keyword">public</span> Shape {<br><span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{ <br>    <span class="hljs-keyword">return</span> (width height)/<span class="hljs-number">2</span>; <br>    } <br>};<br><br><br><span class="hljs-comment">// 主函数</span><br>Rectangle Rect; <span class="hljs-comment">// 正方形</span><br>Triangle Tri; <span class="hljs-comment">// 三角形</span><br><br>Rect.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">5</span>); <br>Rect.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">7</span>); <br>Rect.<span class="hljs-built_in">getArea</span>(); <span class="hljs-comment">//35 </span><br><br>Tri.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">5</span>); <br>Tri.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">7</span>); <br>Tri.<span class="hljs-built_in">getArea</span>(); <span class="hljs-comment">//17</span><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start  --> <p>#历史记录::<br>2022/10/20🌵抽象类与接口的实现 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.子集II</title>
      <link href="/posts/15381/"/>
      <url>/posts/15381/</url>
      
        <content type="html"><![CDATA[<h1 id="1-90子集ii"><a class="markdownIt-Anchor" href="#1-90子集ii"></a> 1 90.子集II</h1><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接</a></p><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：<strong>解集不能包含重复的子集。</strong><br>示例:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">-   输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>-   输出: [ [<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [] ]<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>![[13.子集II 2022-10-20 11.19.12.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1，通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        result.<span class="hljs-built_in">push_back</span>(path);<span class="hljs-comment">// 每次都要收集结点</span><br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-comment">// 💡在同一个树层手上去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; startIndex){ <span class="hljs-comment">// ❗️不是&gt;0，因为每次的起始位置不一样;也可以这样写：if (i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1] )</span><br>                <span class="hljs-keyword">if</span>(nums[i] == nums[i <span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>; <br>            }<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            <br>        }<br>    }<br>    <br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// ❗️去重需要先排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^3c5r8l</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsMTYdlMRYsnTbWppwVya8k"  --> <p>#历史记录::<br>2022/10/20🌵13.子集II : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. 子集问题</title>
      <link href="/posts/36387/"/>
      <url>/posts/36387/</url>
      
        <content type="html"><![CDATA[<h1 id="1-子集"><a class="markdownIt-Anchor" href="#1-子集"></a> 1 子集</h1><p><a href="https://leetcode.cn/problems/subsets/">力扣题目链接</a></p><p>给定一组不含重复元素的整数数组&nbsp;nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">示例: 输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 输出: [ [<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">1</span>], &nbsp; [<span class="hljs-number">2</span>], &nbsp; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], &nbsp; [] ]<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>求子集问题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a>和<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a>又不一样了。</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong><br>有同学问了，什么时候for可以从0开始呢？<br>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。 ^isql7c</p><p>以示例中<code>nums = [1,2,3]</code>为例把求子集抽象为树型结构，如下：</p><p>![[11. 子集问题 2022-10-20 10.37.58.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= nums.<span class="hljs-built_in">size</span>()) { <span class="hljs-comment">// 终止条件可以不加</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整棵树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从i+1开始的。</p><blockquote><p>[!bug]<br>![[11. 子集问题 2022-10-20 11.05.19.excalidraw]]</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs8NGIsFeeXukAZDZMDW95r"  --> <p>#历史记录::<br>2022/10/20🌵11. 子集问题 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>final</title>
      <link href="/posts/62558/"/>
      <url>/posts/62558/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/4ba9bea12264">https://www.jianshu.com/p/4ba9bea12264</a></p><p>讲讲为什么要使用 static 和 final，</p><p>static可以保证在一个线程未使用其他同步机制的情况下总是可以读到一个类的静态变量的初始<br>值</p><p>final修饰的变量值不会改变。但是在多线程的环境中，它还会保证两点，1. 其他线<br>程所看到的final字段必然是初始化完毕的。 2. final修饰的变量不会被程序重排序。</p><p>static 保证了变量的初始值，final 保证了不被 JIT 编译器重排序。对于一个单例模式来说，它所在的类在被引用的时候，static 会保证它被初始化完毕，且是所有线程所见的初始化，final 保证了实例初始化过程的顺寻性。两者结合保证了这个实例创建的唯一性。讲讲为什么要使用 static 和 final</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRQQVndw0YJcAy7bLAkC0g"  --> <p>#历史记录::<br>2022/10/19🌵final : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 创建型模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>套接字函数</title>
      <link href="/posts/24218/"/>
      <url>/posts/24218/</url>
      
        <content type="html"><![CDATA[<h1 id="1-套接字函数"><a class="markdownIt-Anchor" href="#1-套接字函数"></a> 1 套接字函数</h1><h2 id="11-socket"><a class="markdownIt-Anchor" href="#11-socket"></a> 1.1 socket</h2><p>![[socket API]]</p><h2 id="12-bind"><a class="markdownIt-Anchor" href="#12-bind"></a> 1.2 [[bind]]</h2><h2 id="13-listen"><a class="markdownIt-Anchor" href="#13-listen"></a> 1.3 listen</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;    <span class="hljs-comment">// /proc/sys/net/core/somaxconn(能够连接的最大数所在的文档目录)     </span><br>- 功能:监听这个socket上的连接    <br>- 参数:        <br>    - - sockfd : 通过socket()函数得到的文件描述符        <br>    - - backlog : 未连接的和已经连接的和的最大值, <span class="hljs-number">5</span><br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="14-accpet"><a class="markdownIt-Anchor" href="#14-accpet"></a> 1.4 accpet</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;     <br>- 功能:接收客户端连接,默认是一个阻塞的函数,阻塞等待客户端连接     <br>- 参数:             <br>    - - sockfd : 用于监听的文件描述符            <br>    - - addr : 传出参数,记录了连接成功后客户端的地址信息(ip,port)             <br>    - - addrlen : 指定第二个参数的对应的内存大小    <br>- 返回值:            <br>    -  成功 :用于通信的文件描述符            <br>    -  失败 : <span class="hljs-number">-1</span><br><br></code></pre></td></tr></tbody></table></figure><p>socklen_t：就是整数类型，跟int类型</p><h2 id="15-connect"><a class="markdownIt-Anchor" href="#15-connect"></a> 1.5 connect</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>; <br>    - 功能: 客户端连接服务器    <br>    - 参数:             <br>        - sockfd : 用于通信的文件描述符            <br>        - addr : 客户端要连接的服务器的地址信息            <br>        - addrlen : 第二个参数的内存大小    <br>    - 返回值:成功 <span class="hljs-number">0</span>, 失败 <span class="hljs-number">-1</span> <br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;   <span class="hljs-comment">// 写数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;          <span class="hljs-comment">// 读数据</span><br><br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsCnFBsDEfv249MNnBn3Fxl"  --> <p>#历史记录::<br>2022/10/19🌵套接字函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bind</title>
      <link href="/posts/12261/"/>
      <url>/posts/12261/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>; <span class="hljs-comment">// socket命名    </span><br>- 功能:绑定,将fd 和本地的IP + 端口进行绑定    <br>- 参数:             <br>    - - sockfd : 通过socket函数得到的文件描述符            <br>    - - addr : 需要绑定的socket地址,这个地址封装了ip和端口号的信息            <br>    - - addrlen : 第二个参数结构体占的内存大小<br>    测试<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsklyxDVPfPLqv2GiUKGZn0"  --> <p>#历史记录::<br>2022/10/19🌵bind : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.复原 IP 地址</title>
      <link href="/posts/33042/"/>
      <url>/posts/33042/</url>
      
        <content type="html"><![CDATA[<h1 id="1-93复原ip地址"><a class="markdownIt-Anchor" href="#1-93复原ip地址"></a> 1 93.复原IP地址</h1><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接</a></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个<strong>整数</strong>（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>：<br><br>-   输入：s = <span class="hljs-string">"25525511135"</span><br>-   输出：[<span class="hljs-string">"255.255.11.135"</span>,<span class="hljs-string">"255.255.111.35"</span>]<br><br>示例 <span class="hljs-number">2</span>：<br><br>-   输入：s = <span class="hljs-string">"0000"</span><br>-   输出：[<span class="hljs-string">"0.0.0.0"</span>]<br><br>示例 <span class="hljs-number">3</span>：<br><br>-   输入：s = <span class="hljs-string">"1111"</span><br>-   输出：[<span class="hljs-string">"1.1.1.1"</span>]<br><br>示例 <span class="hljs-number">4</span>：<br><br>-   输入：s = <span class="hljs-string">"010010"</span><br>-   输出：[<span class="hljs-string">"0.10.0.10"</span>,<span class="hljs-string">"0.100.1.0"</span>]<br><br>示例 <span class="hljs-number">5</span>：<br><br>-   输入：s = <span class="hljs-string">"101023"</span><br>-   输出：[<span class="hljs-string">"1.0.10.23"</span>,<span class="hljs-string">"1.0.102.3"</span>,<span class="hljs-string">"10.1.0.23"</span>,<span class="hljs-string">"10.10.2.3"</span>,<span class="hljs-string">"101.0.2.3"</span>]<br><br>提示：<br><br>-   <span class="hljs-number">0</span> &lt;= s.length &lt;= <span class="hljs-number">3000</span><br>-   s 仅由数字组成<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，</p><p>![[10.复原 IP 地址 2022-10-19 09.58.13.excalidraw]]</p><h2 id="21-回溯三部曲"><a class="markdownIt-Anchor" href="#21-回溯三部曲"></a> 2.1 回溯三部曲</h2><p>回溯其实就是横向遍历，纵向递归的组合。</p><ul><li>递归参数</li></ul><p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a></p><p>startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。<br>本题我们还需要一个变量pointNum，记录添加逗点的数量。<br>所以代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; result;<span class="hljs-comment">// 记录结果</span><br><span class="hljs-comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span> {<br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p>终止条件和<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a>情况就不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。</p><p>pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。<br>然后验证一下第四段是否合法，如果合法就加入到结果集里<br>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) { <span class="hljs-comment">// 逗点数量为3时，分隔结束</span><br>    <span class="hljs-comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>        result.<span class="hljs-built_in">push_back</span>(s);<br>    }<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的逻辑</li></ul><p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a>中已经讲过在循环遍历中如何截取子串。</p><p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中 <code>[startIndex, i]</code> 这个区间就是截取的子串，需要判断这个子串是否合法。<br>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。<br>如果不合法就结束本层循环，如图中剪掉的分支：</p><p>然后就是递归和回溯的过程：<br>递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量pointNum 要 +1。<br>回溯的时候，就将刚刚加入的分隔符<code>.</code> 删掉就可以了，pointNum也要-1。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.size(); i++) {<br>    <span class="hljs-keyword">if</span> (isValid(s, startIndex, i)) { <span class="hljs-comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span><br>        s.insert(s.begin() + i + <span class="hljs-number">1</span> , <span class="hljs-string">'.'</span>);  <span class="hljs-comment">// 在i的后面插入一个逗点</span><br>        pointNum++;<br>        backtracking(s, i + <span class="hljs-number">2</span>, pointNum);   <span class="hljs-comment">// 插入逗点之后下一个子串的起始位置为i+2</span><br>        pointNum--;                         <span class="hljs-comment">// 回溯</span><br>        s.erase(s.begin() + i + <span class="hljs-number">1</span>);         <span class="hljs-comment">// 回溯删掉逗点</span><br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不合法，直接结束本层循环</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="22-判断子串是否合法"><a class="markdownIt-Anchor" href="#22-判断子串是否合法"></a> 2.2 判断子串是否合法</h2><p>最后就是在写一个判断段位是否是有效段位了。</p><p>主要考虑到如下三点：</p><ul><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ul><p>代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {<br>    <span class="hljs-keyword">if</span> (start &gt; end) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (s[start] == <span class="hljs-string">'0'</span> &amp;&amp; start != end) { <span class="hljs-comment">// 0开头的数字不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) {<br>        <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-string">'9'</span> || s[i] &lt; <span class="hljs-string">'0'</span>) { <span class="hljs-comment">// 遇到非数字字符不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">'0'</span>);<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) { <span class="hljs-comment">// 如果大于255了不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>回溯算法模板：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> {<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsKiXJfuhrFs5Bqkz8LA4nD" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::10.复原 IP 地址.md"--><p>不懂</p><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt;ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(string&amp; s,<span class="hljs-type">int</span> cnt,<span class="hljs-type">int</span> index,string&amp; str)</span></span>{<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> || index==s.<span class="hljs-built_in">size</span>() ){<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> &amp;&amp; index==s.<span class="hljs-built_in">size</span>())<br>                ans.<span class="hljs-built_in">push_back</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>));<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++){<br>            <span class="hljs-keyword">if</span>(index+i&gt;s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(s[index]==<span class="hljs-string">'0'</span> &amp;&amp; i!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span> &amp;&amp; s.<span class="hljs-built_in">substr</span>(index,i)&gt;<span class="hljs-string">"255"</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// ❓能直接比较吗</span><br>            str+=s.<span class="hljs-built_in">substr</span>(index,i);<br>            str.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">'.'</span>);<br>            <span class="hljs-built_in">backtrace</span>(s,cnt+<span class="hljs-number">1</span>,index+i,str);<br>            str = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,str.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>);<br>        }<br>    }<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>{<br>        string str =<span class="hljs-string">""</span>;<br>        <span class="hljs-built_in">backtrace</span>(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,str);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>V1: 未通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span></span>{<br>        <span class="hljs-keyword">if</span>(pointNum == <span class="hljs-number">3</span>){<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)){<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i)){<br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">'.'</span>);<br>                <span class="hljs-built_in">backtracking</span>(s, i+<span class="hljs-number">2</span>, pointNum++);<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>);<br><br>            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">if</span>(start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">'0'</span> &amp;&amp; start != end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//0开头的数字不合法</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end; i++){<br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">'9'</span> || s[i] &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">'0'</span>);<br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span> || s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsc9cRkdPWZYtXBJubKQ8Bg"  --> <p>#历史记录::<br>2022/10/19🌵10.复原 IP 地址 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>socket API</title>
      <link href="/posts/61849/"/>
      <url>/posts/61849/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span>  <span class="hljs-comment">// 包含了这个头文件,上面两个就可以省略</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;     <br>- 功能:创建一个套接字    <br>-        - 参数:         <br>            - domain: 协议族            <br>                - AF_INET : ipv4 <br>                - AF_INET6 : ipv6             <br>                - AF_UNIX, AF_LOCAL : 本地套接字通信(进程间通信)         <br>            - type: 通信过程中使用的协议类型            <br>                - SOCK_STREAM : 流式协议            <br>                - SOCK_DGRAM  : 报式协议       <br>            - protocol : 具体的一个协议。一般写<span class="hljs-number">0</span>             <br>                - SOCK_STREAM : 流式协议默认使用 TCP             <br>                - SOCK_DGRAM  : 报式协议默认使用 UDP         <br>          - 返回值:            <br>             - 成功:返回文件描述符,操作的就是内核缓冲区。<br>             - 失败:<span class="hljs-number">-1</span><br><span class="hljs-comment">// </span><br>- example <span class="hljs-title function_">socket</span><span class="hljs-params">(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsx2iCnBjqj6vx1dM0NpCj6"  --> <p>#历史记录::<br>2022/10/18🌵socket API : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 通信流程</title>
      <link href="/posts/2368/"/>
      <url>/posts/2368/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论</h1><blockquote><p>[!summary] TCP 和 UDP  -&gt; 传输层的协议<br>UDP: 用户数据报协议, 面向无连接, 可以单播, 多播, 广播, 面向数据报, 不可靠</p></blockquote><p>TCP: 传输控制协议, 面向连接的, 可靠的, 基于字节流, 仅支持<strong>单播传输</strong><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210182124220.png" alt=""></p><h1 id="2-tcp-通信的流程"><a class="markdownIt-Anchor" href="#2-tcp-通信的流程"></a> 2 TCP 通信的流程</h1><blockquote><p>[!example]<br>![[TCP 通信流程.excalidraw]]</p></blockquote><h2 id="21-套接字函数"><a class="markdownIt-Anchor" href="#21-套接字函数"></a> 2.1 [[套接字函数]]</h2><h1 id="3-tcp通信代码案例"><a class="markdownIt-Anchor" href="#3-tcp通信代码案例"></a> 3 [[TCP通信代码案例]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsaD42SDJDMOtSLlKp97zNB"  --> <p>#历史记录::<br>2022/10/18🌵TCP 通信流程 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>open函数</title>
      <link href="/posts/51479/"/>
      <url>/posts/51479/</url>
      
        <content type="html"><![CDATA[<h1 id="1-功能"><a class="markdownIt-Anchor" href="#1-功能"></a> 1 功能</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// open 函数的声明</span><br><span class="hljs-comment">// 打开一个已经存在的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><br><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></tbody></table></figure><p>为什么要有三个头文件？<br>函数的申明在 <code>fcntl.h</code> 头文件里，<code>flags</code> 在Linux系统中定义为一个宏放在其他的头文件里。</p><p>为什么可以有两个同名的 <code>open</code> 函数？<br>C语言没有函数重载，通过可变参数 <code>mode_t mode</code> 实现同名函数的效果。</p><h1 id="2-api"><a class="markdownIt-Anchor" href="#2-api"></a> 2 API</h1><h2 id="21-open函数"><a class="markdownIt-Anchor" href="#21-open函数"></a> 2.1 open函数：</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// open 函数的声明</span><br><span class="hljs-comment">// 打开一个已经存在的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br>参数：<br>- pathname：要打开的文件路径<br>- flags：对文件的操作权限设置还有其他设置<br>- O_RDONLY：只读<br>- O_WRONLY：只写<br>- O_RDWR：可读可写<br>这三个设置是互斥的(必选项)<br>返回值：返回一个新的文件描述符，如果调用失败，返回 <span class="hljs-number">-1</span> ，系统会把错误号赋值给errno<br>errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号<br>perror：查看具体的错误<br>- example <span class="hljs-type">int</span> fd = open(<span class="hljs-string">" /dev/null"</span>，O_RDWR)；返回值是一个文件描述符<br><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-type">int</span> open(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode);<br></code></pre></td></tr></tbody></table></figure><h2 id="22-close-函数说明文档-man-2-close"><a class="markdownIt-Anchor" href="#22-close-函数说明文档-man-2-close"></a> 2.2 close 函数（说明文档 <code>man 2 close</code> ）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsBwYtWCv5jsLoXcGsA0aDN" --> <h2 id="23-案例"><a class="markdownIt-Anchor" href="#23-案例"></a> 2.3 案例::</h2><!-- basicblock-end --><p>查找 <code>a.txt</code> 文件，找不到文件，文件描述符返回 -1，用 <code>perror</code> 打印错误描述，关闭文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// open.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>  <span class="hljs-comment">// 打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"a.txt"</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>    }<br>    <span class="hljs-comment">// 关闭</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译 <code>open.c</code> 文件 <code>gcc open.c -o open</code> ，执行输出错误描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">open: No such file or directory<br></code></pre></td></tr></tbody></table></figure><h1 id="3-open-创建新文-不用它新建"><a class="markdownIt-Anchor" href="#3-open-创建新文-不用它新建"></a> 3 open 创建新文 (不用它新建)</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// open 函数的声明</span><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br>参数：<br>- pathname：要打开的文件路径<br>- flags：对文件的操作权限设置还有其他设置<br>- 必选项：O_RDONLY，O_WRONLY，O_RDWR，这三个设置是互斥的<br>- 可选项：O_CREAT 文件不存在，创建新文件<br>      - mode：八进制的数，表示用户对创建出的新的文件的操作权限，比如：<span class="hljs-number">0775</span><br>      最终的权限是：mode &amp; ~umask<br>      umask -&gt; <span class="hljs-number">0002</span>, ~umaske = <span class="hljs-number">0777</span><span class="hljs-number">-0002</span> = <span class="hljs-number">0775</span><br>      <span class="hljs-number">0777</span>-&gt; <span class="hljs-number">111111111</span><br>      &amp; <span class="hljs-number">0775</span>-&gt; <span class="hljs-number">111111101</span><br>      ---------------------<br>       <span class="hljs-number">111111101</span>-&gt; <span class="hljs-number">0775</span><br>      按位与：<span class="hljs-number">0</span> 和任何数都为 <span class="hljs-number">0</span><br>      umask 的作用是抹去某些权限，umask 可以自己设计<br>返回值：返回一个新的文件描述符，如果调用失败，返回 <span class="hljs-number">-1</span> ，系统会把错误号赋值给errno<br>errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号<br>perror：查看具体的错误<br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// create.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>  <span class="hljs-comment">// 创建一个新的文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"create.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>    }<br>    <span class="hljs-comment">// 关闭</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译 <code>create.c</code> 文件 <code>gcc create.c -o create</code> ，创建了新文件 <code>create.txt</code> 。</p><p>查看权限，<code>ll create.txt</code> 。</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rwxr-xr-x<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>4月  <span class="hljs-number"> 3 </span>14:49 create.txt<br></code></pre></td></tr></tbody></table></figure><p><code>-rwxr-xr-x</code> 对应 0775 权限。</p><p>open 函数中的 flags 为什么用按位或 <code>|</code> 来连接？</p><p>flags函数是一个int类型的数据，占4个字节，32位；</p><p>flags 32个位，每一位就是一个标志位。用 <code>|</code> 相当于把后一个 flag加到前一个flag上。</p><h1 id="4-其他知识"><a class="markdownIt-Anchor" href="#4-其他知识"></a> 4 其他知识</h1><p>centOS安装manpages</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">yum -y install man-pages<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">man <span class="hljs-number">2</span> open<br><span class="hljs-comment">// 第二章是Linux系统函数说明文档，open 在第二章查找</span><br><span class="hljs-comment">// 第三章是标准C库说明文档</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174431.png" alt="image-20220403111757618|600"></p><p>查看返回值</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">/<span class="hljs-keyword">return</span> value<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174505.png" alt="image-20220403113343555|700"></p><h2 id="41-perror-函数说明文档-man-3-perror"><a class="markdownIt-Anchor" href="#41-perror-函数说明文档-man-3-perror"></a> 4.1 perror 函数（说明文档 <code>man 3 perror</code> ）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>; <br>作用：打印 errno 对应的错误描述<br>s 参数：用户描述，比如 hello，最终输出的内容是 hello:xxx(实际的错误描述)<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsNGo7g0yv5w1mhRAopsfdA"  --> <p>#历史记录::<br>2022/10/18🌵open函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件描述符</title>
      <link href="/posts/30559/"/>
      <url>/posts/30559/</url>
      
        <content type="html"><![CDATA[<p>![[文件描述符.excalidraw]]</p><p>对可执行文件进行读取或写的操作，可执行程序运行起来后，操作系统会生成一个进程，在对应的文件比如 english.txt ，进行读取或写入等操作，用标准 C 的 IO 文件库去操作，fopen 打开文件，调用 fread 读取数据，或者调用 fwrite 写入数据，<strong>为什么在程序当中用 fopen 打开文件后，调用 fread ，或者调用 fwrite ，它就能够去找到磁盘上的 english.txt 文件，对它进行操作呢？</strong></p><p>因为它里面有文件描述符，调用 fopen 函数，会返回一个 <code>FILE * fp</code> 文件指针，这个文件指针里就封装了文件描述符，</p><p>用 fclose 关闭文件描述符的时候，这个文件描述符就会被释放，被释放后就可以重新去使用，如果文件描述符被占用，它需要到文件描述符表里找一个最小的没有被占用的，文件描述符去使用。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsB9xFivKh9pT0dtEE0x1YB"  --> <p>#历史记录::<br>2022/10/18🌵文件描述符 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>read函数和write函数</title>
      <link href="/posts/49161/"/>
      <url>/posts/49161/</url>
      
        <content type="html"><![CDATA[<h1 id="1-api"><a class="markdownIt-Anchor" href="#1-api"></a> 1 API</h1><p>查看说明文档</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">man <span class="hljs-number">2</span> read<br>man <span class="hljs-number">2</span> write<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// read 函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br>参数：<br>      - fd: 文件描述符，open 得到的，通过这个文件描述符操作某个文件<br>        - buf: 需要读取数据存放的地方，数组的地址（传出参数）<br>        - count: 指定的数组的大小<br>    返回值：<br>        - 成功: <br>          &gt; <span class="hljs-number">0</span>: 返回实际的读取到的字节数<br>            = <span class="hljs-number">0</span>: 文件已经读取完了<br>        - 失败: <span class="hljs-number">-1</span> ，并且设置 errno<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// write 函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br>参数：<br>      - fd: 文件描述符，open 得到的，通过这个文件描述符操作某个文件<br>        - buf: 要往磁盘写入的数据<br>        - count: 要写的数据的实际的大小<br>    返回值：<br>        - 成功: 实际写入的字节数<br>        - 失败: <span class="hljs-number">-1</span> ，并且设置 errno<br></code></pre></td></tr></tbody></table></figure><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例</h1><p>文件拷贝：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// copyfile.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 1. 通过 open 打开 english.txt 文件</span><br>    <span class="hljs-type">int</span> srcfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"english.txt"</span>, O_RDONLY);  <span class="hljs-comment">// 源文件的文件描述符</span><br>    <span class="hljs-keyword">if</span> (srcfd == <span class="hljs-number">-1</span>){<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 2. 创建一个心的文件（拷贝文件）</span><br>    <span class="hljs-type">int</span> destfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"cpy.txt"</span>, O_WRONLY | O_CREAT, <span class="hljs-number">0664</span>); <span class="hljs-comment">// 目标文件的描述符</span><br>    <span class="hljs-keyword">if</span> (destfd == <span class="hljs-number">-1</span>){<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 3. 频繁的读写操作 </span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((len = <span class="hljs-built_in">read</span>(srcfd, buf, <span class="hljs-built_in">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">write</span>(destfd, buf, len);<br>    }<br><br>    <span class="hljs-comment">// 4. 关闭文件</span><br>    <span class="hljs-built_in">close</span>(destfd);<br>    <span class="hljs-built_in">close</span>(srcfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs0ROCqozgb3GI26vbP9plE"  --> <p>#历史记录::<br>2022/10/18🌵read函数和write函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UML</title>
      <link href="/posts/46375/"/>
      <url>/posts/46375/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!example] <a href="https://www.bilibili.com/video/BV1P741127u7?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=471.443684">07:51</a><br>![[UML 外国小哥.excalidraw]]</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsU9I0J1ZYIUOJ9fSHeZMUm"  --> <p>#历史记录:: <a href="https://www.bilibili.com/video/BV1P741127u7?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">UML Class Diagram Tutorial（视频字幕一体）_哔哩哔哩_bilibili</a></p><p>2022/10/16🌵UML : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 面向对象原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UDP</title>
      <link href="/posts/11300/"/>
      <url>/posts/11300/</url>
      
        <content type="html"><![CDATA[<h1 id="1-udp-通信"><a class="markdownIt-Anchor" href="#1-udp-通信"></a> 1 UDP 通信::</h1><blockquote><p>[!example]-<br>![[UDP 2022-10-11 20.29.05.excalidraw]]</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *dest_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br>- 参数:<br>- sockfd : 通信的fd<br>- buf : 要发送的数据<br>- len : 发送数据的长度<br>- flags : <span class="hljs-number">0</span><br>- dest_addr : 通信的另外一端的地址信息(💡要把信息传回去)<br>- addrlen : 地址的内存大小<br>- 返回值:<br>- 成功返回接收的数据个数<br>- 失败返回<span class="hljs-number">-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                        <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br>- 参数:<br>- sockfd : 通信的fd<br>- buf : 接收数据的数组<br>- len : 数组的大小<br>- flags : <span class="hljs-number">0</span><br>- src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="hljs-literal">NULL</span><br>- addrlen : 地址的内存大小<br>- 返回值:<br>- 成功返回接收的数据个数<br>- 失败返回<span class="hljs-number">-1</span><br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-广播"><a class="markdownIt-Anchor" href="#2-广播"></a> 2 广播::</h1><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的 IP 地址，这个 IP 中子网内主机标志部分的二进制全部为 1。<br>192.168.10.<strong>255</strong>: 主机标志</p><ul><li><strong>a.只能在局域网中使用。</strong></li><li>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210181518222.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置广播属性的函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> optlen)</span>;<br>- sockfd : 文件描述符<br>        - level : SOL_SOCKET<br>        - optname : SO_BROADCAST<br>        - optval : <span class="hljs-type">int</span>类型的值，为<span class="hljs-number">1</span>表示允许广播<br>        - optlen : optval的大小<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>‌‌‌![[UDP 通信案例.excalidraw]]</p></blockquote><h1 id="3-组播-多播"><a class="markdownIt-Anchor" href="#3-组播-多播"></a> 3 组播 (多播)</h1><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。<br>单播和广播是寻址方案的两个极端 (要么单个要么全部)，多播则意在两者之间提供一种折中方案。<br>多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。</p><p>a.组播既可以用于局域网，也可以用于广域网<br>b.客户端需要加入多播组，才能接收到多播的数据</p><p>![[UDP 2022-10-18 17.14.30.excalidraw]]<br>相比广播:<br>服务端增加多播的属性<br>客户端加入多播</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval,<span class="hljs-type">socklen_t</span> optlen)</span></span>;<br><br>    <span class="hljs-comment">// 服务器设置多播的信息，外出接口</span><br>    - level : IPPROTO_IP<br>    - optname : IP_MULTICAST_IF <span class="hljs-comment">// 多播</span><br>    - optval : <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span><br><span class="hljs-comment">// 客户端加入到多播组:</span><br>    - level : IPPROTO_IP<br>    - optname : IP_ADD_MEMBERSHIP - optval : <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ip_mreq</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ip_mreq</span><br>{<br>    <span class="hljs-comment">/* IP multicast address of group. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> imr_multiaddr; <span class="hljs-comment">// 组播的IP地址</span><br>    <span class="hljs-comment">/* Local IP address of interface.  */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> imr_interface;<span class="hljs-comment">// 本地的IP地址</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> <span class="hljs-type">in_addr_t</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span><br>{<br>    <span class="hljs-type">in_addr_t</span> s_addr;<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs5rq3hvi0Z0cGlqk8xrPfL"  --> <p>#历史记录::<br>2022/10/11🌵UDP : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>epoll</title>
      <link href="/posts/3465/"/>
      <url>/posts/3465/</url>
      
        <content type="html"><![CDATA[<h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1 原理::</h1><!-- basicblock-end --> <blockquote><p>[!example]-  原理<br>![[epoll 与 select  .excalidraw]]<br>![[epoll 原理流程图.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsrIkU5kkDXgPJ4upMFlX31" --> <h1 id="2-epoll-操作函数"><a class="markdownIt-Anchor" href="#2-epoll-操作函数"></a> 2 epoll 操作函数::</h1><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-comment">/*  epoll_create: </span><br><span class="hljs-comment">建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，</span><br><span class="hljs-comment">一个是需要检 测的文件描述符的信息(红黑树)</span><br><span class="hljs-comment">一个是就绪列表，存放检测到数据发送改变的文件描述符信息(双向 链表)。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br>- 参数:<br>size : 随便写一个数，必须大于<span class="hljs-number">0</span><br>目前没有意义了, 所以随便写一个数(改进过后就不用 size 了, 以前底层实现是哈希表, 现在是红黑树)。<br>- 返回值:<br><span class="hljs-number">-1</span> : 失败<br>&gt;<span class="hljs-number">0</span> : 文件描述符，操作epoll实例的<br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// epoll_ctl: 对epoll实例进行管理:添加文件描述符信息，删除信息，修改信息</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;<br>- 参数:<br>- epfd : epoll实例对应的文件描述符<br>- op : 要进行什么操作 <br>- EPOLL_CTL_ADD: 添加 (添加到红黑树中)<br>- EPOLL_CTL_MOD: 修改 <br>- EPOLL_CTL_DEL: 删除<br>- fd : 要检测的文件描述符<br>- event : 检测文件描述符什么事情<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> {<br>    <span class="hljs-type">uint32_t</span>     events; <span class="hljs-comment">// 检测的事件  /* Epoll events */</span><br>    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">// 用户的一些数据信息 /* User data variable */</span><br>};<br>常见的Epoll检测事件:<br>- EPOLLIN <span class="hljs-comment">// 检测读事件</span><br>    - EPOLLOUT<br>    - EPOLLERR<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span> { <span class="hljs-comment">// union 下边数据只有一个会有用</span><br>    <span class="hljs-type">void</span>        *ptr;<br>    <span class="hljs-type">int</span>          fd; <span class="hljs-comment">// 只用这个就行</span><br>    <span class="hljs-type">uint32_t</span>     u32;<br>    <span class="hljs-type">uint64_t</span>     u64;<br>} <span class="hljs-type">epoll_data_t</span>;<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// epoll_wait: 检测函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br>- 参数:<br>- epfd : epoll实例对应的文件描述符<br>- events : 传出参数，保存了发送了变化的文件描述符的信息 (结构数组大小)<br>- maxevents : 第二个参数结构体数组的大小<br>- timeout : 阻塞时间<br>-  <span class="hljs-number">0</span> : 不阻塞<br>- <span class="hljs-number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞 <br>- &gt;<span class="hljs-number">0</span> : 阻塞的时长(毫秒)<br>- 返回值:<br>- 成功，返回发送变化的文件描述符的个数 (&gt; <span class="hljs-number">0</span>) <br>- 失败 <span class="hljs-number">-1</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs6VQ8QsEABPtSsfDzmhMKv" --> <h1 id="3-案例"><a class="markdownIt-Anchor" href="#3-案例"></a> 3 案例::</h1><!-- basicblock-end --><h2 id="31-epollc"><a class="markdownIt-Anchor" href="#31-epollc"></a> 3.1 epoll.c</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br># <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> saddr;<br>    saddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-built_in">bind</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-built_in">sizeof</span>(saddr));<br><br>    <span class="hljs-comment">// 监听</span><br>    <span class="hljs-built_in">listen</span>(lfd, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 调用epoll_create()创建一个epoll实例</span><br>    <span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中: 💡即 rbr(红黑树)</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> epev;<br>    epev.events = EPOLLIN;<br>    epev.data.fd = lfd;<br>    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> epevs[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br><span class="hljs-comment">// 调用 epoll_wait 来检测实例</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epfd, epevs, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<span class="hljs-comment">// 有改变的文件描述符直接传出到 epevs 中</span><br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">"epoll_wait"</span>);<span class="hljs-comment">// 抛出异常</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<span class="hljs-comment">// 退出</span><br>        }<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ret = %d\n"</span>, ret);<span class="hljs-comment">// 有几个事件发生改变了</span><br><span class="hljs-comment">// 遍历改变事件的数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++) {<br><br>            <span class="hljs-type">int</span> curfd = epevs[i].data.fd;<br><br>            <span class="hljs-keyword">if</span>(curfd == lfd) {<br>                <span class="hljs-comment">// 监听的文件描述符有数据达到，有客户端连接</span><br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">accept</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>                epev.events = EPOLLIN | EPOLLOUT; <span class="hljs-comment">// 💡如果是监听两种事件, 要根据不同的事件进行不同的处理, 如下边的continue</span><br>                epev.data.fd = cfd;<br>                <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">if</span>(epevs[i].events &amp; EPOLLOUT) {<br>                    <span class="hljs-keyword">continue</span>;<br>                }   <br>                <span class="hljs-comment">// 有数据到达，需要通信</span><br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(curfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">"read"</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 说明对方关闭连接了</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client closed...\n"</span>);<br>                    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 删除</span><br>                    <span class="hljs-built_in">close</span>(curfd);<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, buf);<br>                    <span class="hljs-built_in">write</span>(curfd, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>);<br>                }<br><br>            }<br><br>        }<br>    }<br><br>    <span class="hljs-built_in">close</span>(lfd);<br>    <span class="hljs-built_in">close</span>(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="32-clientc"><a class="markdownIt-Anchor" href="#32-clientc"></a> 3.2 client.c</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">seraddr</span>;</span><br>    inet_pton(AF_INET, <span class="hljs-string">"127.0.0.1"</span>, &amp;seraddr.sin_addr.s_addr);<br>    seraddr.sin_family = AF_INET;<br>    seraddr.sin_port = htons(<span class="hljs-number">9999</span>);<br><br>    <span class="hljs-comment">// 连接服务器</span><br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;seraddr, <span class="hljs-keyword">sizeof</span>(seraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">char</span> sendBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-built_in">sprintf</span>(sendBuf, <span class="hljs-string">"send data %d"</span>, num++);<br>        write(fd, sendBuf, <span class="hljs-built_in">strlen</span>(sendBuf) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 接收</span><br>        <span class="hljs-type">int</span> len = read(fd, sendBuf, <span class="hljs-keyword">sizeof</span>(sendBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, sendBuf);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器已经断开连接...\n"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// sleep(1); // 睡眠一秒, 很难检测两个事件 所以下边改小了</span><br>        usleep(<span class="hljs-number">1000</span>);<br>    }<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsqE5ATwry3LVR1AyeslTWm" --> <h1 id="4-epoll-的工作模式"><a class="markdownIt-Anchor" href="#4-epoll-的工作模式"></a> 4 Epoll 的工作模式::</h1><!-- basicblock-end --><h2 id="41-lt-模式-水平触发"><a class="markdownIt-Anchor" href="#41-lt-模式-水平触发"></a> 4.1 LT 模式 (水平触发)</h2><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br>读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>a.用户不读数据，数据一直在缓冲区，epoll 会一直通知<br>b.用户只读了一部分数据，epoll会通知<br>c.缓冲区的数据读完了，不通知</p><p>LT(level - triggered)是缺省(默认)的工作方式，并且同时支持 block 和 no-block socket(阻塞与非阻塞)。<br>在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操 作。<br>如果你不作任何操作，内核还是会继续通知你的。<br>- example 如果传出数组还有数据, 你没读完, 还会继续通知你</p><h2 id="42-et-模式边沿触发"><a class="markdownIt-Anchor" href="#42-et-模式边沿触发"></a> 4.2 ET 模式(边沿触发)</h2><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br>读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了<br>b.用户只读了一部分数据，epoll不通知<br>c.缓冲区的数据读完了，不通知</p><blockquote><p>[!tip] 因为只通知一次, 所以用 while 循环一直把缓冲区的数据的读完</p></blockquote><p>ET(edge - triggered)是高速工作方式，只支持 no-block socket (非阻塞)。<br>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。<br>但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成 未就绪)，内核不会发送更多的通知(only once)。<br>- example 传出数组有数据, 但只通知你一次.<br>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。<br>epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄(文件描述符)的阻塞读/阻塞写 操作把处理多个文件描述符的任务饿死</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> {</span><br>    <span class="hljs-type">uint32_t</span>     events; <span class="hljs-comment">/* Epoll events */</span><br>    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">/* User data variable */</span><br>    <br>};<br>常见的Epoll检测事件: <br>- EPOLLIN<br>    - EPOLLOUT<br>    - EPOLLERR<br>    - EPOLLET <span class="hljs-comment">// 设置 ET 模式 : 要添加这个时间</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]- 水平触发与边沿触发<br>![[水平触发与边沿触发 .excalidraw]]</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYvE2yum5AopHJw1RvV7Ak" deck = "👨🏻‍💻code::项目::webserver::4 Linux网络编程::epoll 简单原理.md" --> <p>#历史记录::<br>2022/10/10🌵epoll 简单原理 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.6 项目整体流程代码实现</title>
      <link href="/posts/12028/"/>
      <url>/posts/12028/</url>
      
        <content type="html"><![CDATA[<h1 id="1-有限状态机"><a class="markdownIt-Anchor" href="#1-有限状态机"></a> 1 有限状态机</h1><p>逻辑单元内部的一种高效编程方法:有限状态机(finite state machine)。<br>测试<br>有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">STATE_MACHINE</span>( Package _pack )<br>{<br>    PackageType _type = _pack.<span class="hljs-built_in">GetType</span>();<br>    <span class="hljs-keyword">switch</span>( _type )<br>    {<br>    <span class="hljs-keyword">case</span> type_A:<br>    <span class="hljs-built_in">process_package_A</span>( _pack );<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> type_B:<br>    <span class="hljs-built_in">process_package_B</span>( _pack );<br>    <span class="hljs-keyword">break</span>;<br>} <br>}<br><br><br></code></pre></td></tr></tbody></table></figure><p>这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。<br>状态之间的转移是需要状态机内部驱动，如下代码:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">STATE_MACHINE</span>()<br>{<br>State cur_State = type_A;<br><span class="hljs-keyword">while</span>( cur_State != type_C )<br>{<br><br>    Package _pack = <span class="hljs-built_in">getNewPackage</span>();<br>    <span class="hljs-keyword">switch</span>( cur_State )<br>    {<br>    <span class="hljs-keyword">case</span> type_A:<br>    <span class="hljs-built_in">process_package_state_A</span>( _pack );<br>    cur_State = type_B;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> type_B:<br>    <span class="hljs-built_in">process_package_state_B</span>( _pack );<br>    cur_State = type_C;<br>    <span class="hljs-keyword">break</span>;<br>} <br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>该状态机包含三种状态:type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状 态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过 getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据 包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一 趟循环时，它将执行新的状态对应的逻辑。</p><h1 id="2-epolloneshot事件"><a class="markdownIt-Anchor" href="#2-epolloneshot事件"></a> 2 EPOLLONESHOT事件</h1><blockquote><p>[!summary] 即使可以使用 ET 模式<br>边缘触发模式(ET 模式): 有数据到来了,没有读完前, 是不会触发的<br>水平触发模式: 一有数据到来, 就会触发</p></blockquote><p>一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个 问题。<br>比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读(EPOLLIN 再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。<br>于 是就出现了两个线程同时操作一个 socket 的局面。<br><strong>一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。</strong></p><p>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异 常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事 件。</p><p>这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思 考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进 而让其他工作线程有机会继续处理这个 socket。</p><h1 id="3-服务器压力测试"><a class="markdownIt-Anchor" href="#3-服务器压力测试"></a> 3 服务器压力测试</h1><p>Webbench 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发。</p><pre><code class="hljs">测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。展示服务器的两项内容:每秒钟响应请求数和每秒钟传输数据量。</code></pre><p>基本原理:Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的 结果通过pipe 告诉父进程，父进程做最终的统计结果。<br>测试示例</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">webbench -c <span class="hljs-number">1000</span>  -t  <span class="hljs-number">30</span>   http:<span class="hljs-comment">//192.168.110.129:10000/index.html</span><br><br>参数:  <br>-c 表示客户端数<br>-t 表示时间<br></code></pre></td></tr></tbody></table></figure><h1 id="4-代码"><a class="markdownIt-Anchor" href="#4-代码"></a> 4 代码</h1><p>http_conn.cpp</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"http_conn.h"</span> <span class="hljs-comment">// 导入头文件</span></span><br><br><span class="hljs-comment">// 定义HTTP响应的一些状态信息</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ok_200_title = <span class="hljs-string">"OK"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_400_title = <span class="hljs-string">"Bad Request"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_400_form = <span class="hljs-string">"Your request has bad syntax or is inherently impossible to satisfy.\n"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_403_title = <span class="hljs-string">"Forbidden"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_403_form = <span class="hljs-string">"You do not have permission to get file from this server.\n"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_404_title = <span class="hljs-string">"Not Found"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_404_form = <span class="hljs-string">"The requested file was not found on this server.\n"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_500_title = <span class="hljs-string">"Internal Error"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_500_form = <span class="hljs-string">"There was an unusual problem serving the requested file.\n"</span>;<br><br><span class="hljs-comment">// 网站的根目录</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* doc_root = <span class="hljs-string">"/home/nowcoder/webserver/resources"</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-type">int</span> fd )</span> </span>{<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>}<br><br><span class="hljs-comment">// 向epoll中添加需要监听的文件描述符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> one_shot )</span> </span>{<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLRDHUP;<br>    <span class="hljs-keyword">if</span>(one_shot) <br>    {<br>        <span class="hljs-comment">// 防止同一个通信被不同的线程处理</span><br>        event.events |= EPOLLONESHOT;<br>    }<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-comment">// 设置文件描述符非阻塞</span><br>    <span class="hljs-built_in">setnonblocking</span>(fd);  <br>}<br><br><span class="hljs-comment">// 从epoll中移除监听的文件描述符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removefd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd )</span> </span>{<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_DEL, fd, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">close</span>(fd);<br>}<br><br><span class="hljs-comment">// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ev)</span> </span>{<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );<br>}<br><br><span class="hljs-comment">// 所有的客户数</span><br><span class="hljs-type">int</span> http_conn::m_user_count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的</span><br><span class="hljs-type">int</span> http_conn::m_epollfd = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 关闭连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::close_conn</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span>(m_sockfd != <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">removefd</span>(m_epollfd, m_sockfd);<br>        m_sockfd = <span class="hljs-number">-1</span>;<br>        m_user_count--; <span class="hljs-comment">// 关闭一个连接，将客户总数量-1</span><br>    }<br>}<br><br><span class="hljs-comment">// 初始化连接,外部调用初始化套接字地址</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::init</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> sockaddr_in&amp; addr)</span></span>{<br>    m_sockfd = sockfd;<br>    m_address = addr;<br>    <br>    <span class="hljs-comment">// 端口复用</span><br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>( m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in">sizeof</span>( reuse ) );<br>    <span class="hljs-built_in">addfd</span>( m_epollfd, sockfd, <span class="hljs-literal">true</span> );<br>    m_user_count++;<br>    <span class="hljs-built_in">init</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><br>    bytes_to_send = <span class="hljs-number">0</span>;<br>    bytes_have_send = <span class="hljs-number">0</span>;<br><br>    m_check_state = CHECK_STATE_REQUESTLINE;    <span class="hljs-comment">// 初始状态为检查请求行</span><br>    m_linger = <span class="hljs-literal">false</span>;       <span class="hljs-comment">// 默认不保持链接  Connection : keep-alive保持连接</span><br><br>    m_method = GET;         <span class="hljs-comment">// 默认请求方式为GET</span><br>    m_url = <span class="hljs-number">0</span>;              <br>    m_version = <span class="hljs-number">0</span>;<br>    m_content_length = <span class="hljs-number">0</span>;<br>    m_host = <span class="hljs-number">0</span>;<br>    m_start_line = <span class="hljs-number">0</span>;<br>    m_checked_idx = <span class="hljs-number">0</span>;<br>    m_read_idx = <span class="hljs-number">0</span>;<br>    m_write_idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">bzero</span>(m_read_buf, READ_BUFFER_SIZE);<br>    <span class="hljs-built_in">bzero</span>(m_write_buf, READ_BUFFER_SIZE);<br>    <span class="hljs-built_in">bzero</span>(m_real_file, FILENAME_LEN);<br>}<br><br><span class="hljs-comment">// 循环读取客户数据，直到无数据可读或者对方关闭连接</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::read</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span>( m_read_idx &gt;= READ_BUFFER_SIZE ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-type">int</span> bytes_read = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br>        <span class="hljs-comment">// 从m_read_buf + m_read_idx索引出开始保存数据，大小是READ_BUFFER_SIZE - m_read_idx</span><br>        bytes_read = <span class="hljs-built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, <br>        READ_BUFFER_SIZE - m_read_idx, <span class="hljs-number">0</span> );<br>        <span class="hljs-keyword">if</span> (bytes_read == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-keyword">if</span>( errno == EAGAIN || errno == EWOULDBLOCK ) {<br>                <span class="hljs-comment">// 没有数据</span><br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_read == <span class="hljs-number">0</span>) {   <span class="hljs-comment">// 对方关闭连接</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        m_read_idx += bytes_read;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 解析一行，判断依据\r\n</span><br><span class="hljs-function">http_conn::LINE_STATUS <span class="hljs-title">http_conn::parse_line</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">char</span> temp;<br>    <span class="hljs-keyword">for</span> ( ; m_checked_idx &lt; m_read_idx; ++m_checked_idx ) {<br>        temp = m_read_buf[ m_checked_idx ];<br>        <span class="hljs-keyword">if</span> ( temp == <span class="hljs-string">'\r'</span> ) {<br>            <span class="hljs-keyword">if</span> ( ( m_checked_idx + <span class="hljs-number">1</span> ) == m_read_idx ) {<br>                <span class="hljs-keyword">return</span> LINE_OPEN;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( m_read_buf[ m_checked_idx + <span class="hljs-number">1</span> ] == <span class="hljs-string">'\n'</span> ) {<br>                m_read_buf[ m_checked_idx++ ] = <span class="hljs-string">'\0'</span>;<br>                m_read_buf[ m_checked_idx++ ] = <span class="hljs-string">'\0'</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            }<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( temp == <span class="hljs-string">'\n'</span> )  {<br>            <span class="hljs-keyword">if</span>( ( m_checked_idx &gt; <span class="hljs-number">1</span>) &amp;&amp; ( m_read_buf[ m_checked_idx - <span class="hljs-number">1</span> ] == <span class="hljs-string">'\r'</span> ) ) {<br>                m_read_buf[ m_checked_idx<span class="hljs-number">-1</span> ] = <span class="hljs-string">'\0'</span>;<br>                m_read_buf[ m_checked_idx++ ] = <span class="hljs-string">'\0'</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            }<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> LINE_OPEN;<br>}<br><br><span class="hljs-comment">// 解析HTTP请求行，获得请求方法，目标URL,以及HTTP版本号</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::parse_request_line</span><span class="hljs-params">(<span class="hljs-type">char</span>* text)</span> </span>{<br>    <span class="hljs-comment">// GET /index.html HTTP/1.1</span><br>    m_url = <span class="hljs-built_in">strpbrk</span>(text, <span class="hljs-string">" \t"</span>); <span class="hljs-comment">// 判断第二个参数中的字符哪个在text中最先出现</span><br>    <span class="hljs-keyword">if</span> (! m_url) { <br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    <span class="hljs-comment">// GET\0/index.html HTTP/1.1</span><br>    *m_url++ = <span class="hljs-string">'\0'</span>;    <span class="hljs-comment">// 置位空字符，字符串结束符</span><br>    <span class="hljs-type">char</span>* method = text;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>(method, <span class="hljs-string">"GET"</span>) == <span class="hljs-number">0</span> ) { <span class="hljs-comment">// 忽略大小写比较</span><br>        m_method = GET;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    <span class="hljs-comment">// /index.html HTTP/1.1</span><br>    <span class="hljs-comment">// 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</span><br>    m_version = <span class="hljs-built_in">strpbrk</span>( m_url, <span class="hljs-string">" \t"</span> );<br>    <span class="hljs-keyword">if</span> (!m_version) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    *m_version++ = <span class="hljs-string">'\0'</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>( m_version, <span class="hljs-string">"HTTP/1.1"</span>) != <span class="hljs-number">0</span> ) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * http://192.168.110.129:10000/index.html</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(m_url, <span class="hljs-string">"http://"</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span> ) {   <br>        m_url += <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span><br>        m_url = <span class="hljs-built_in">strchr</span>( m_url, <span class="hljs-string">'/'</span> );<br>    }<br>    <span class="hljs-keyword">if</span> ( !m_url || m_url[<span class="hljs-number">0</span>] != <span class="hljs-string">'/'</span> ) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    m_check_state = CHECK_STATE_HEADER; <span class="hljs-comment">// 检查状态变成检查头</span><br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 解析HTTP请求的一个头部信息</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::parse_headers</span><span class="hljs-params">(<span class="hljs-type">char</span>* text)</span> </span>{   <br>    <span class="hljs-comment">// 遇到空行，表示头部字段解析完毕</span><br>    <span class="hljs-keyword">if</span>( text[<span class="hljs-number">0</span>] == <span class="hljs-string">'\0'</span> ) {<br>        <span class="hljs-comment">// 如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，</span><br>        <span class="hljs-comment">// 状态机转移到CHECK_STATE_CONTENT状态</span><br>        <span class="hljs-keyword">if</span> ( m_content_length != <span class="hljs-number">0</span> ) {<br>            m_check_state = CHECK_STATE_CONTENT;<br>            <span class="hljs-keyword">return</span> NO_REQUEST;<br>        }<br>        <span class="hljs-comment">// 否则说明我们已经得到了一个完整的HTTP请求</span><br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( text, <span class="hljs-string">"Connection:"</span>, <span class="hljs-number">11</span> ) == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 处理Connection 头部字段  Connection: keep-alive</span><br>        text += <span class="hljs-number">11</span>;<br>        text += <span class="hljs-built_in">strspn</span>( text, <span class="hljs-string">" \t"</span> );<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>( text, <span class="hljs-string">"keep-alive"</span> ) == <span class="hljs-number">0</span> ) {<br>            m_linger = <span class="hljs-literal">true</span>;<br>        }<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( text, <span class="hljs-string">"Content-Length:"</span>, <span class="hljs-number">15</span> ) == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 处理Content-Length头部字段</span><br>        text += <span class="hljs-number">15</span>;<br>        text += <span class="hljs-built_in">strspn</span>( text, <span class="hljs-string">" \t"</span> );<br>        m_content_length = <span class="hljs-built_in">atol</span>(text);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( text, <span class="hljs-string">"Host:"</span>, <span class="hljs-number">5</span> ) == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 处理Host头部字段</span><br>        text += <span class="hljs-number">5</span>;<br>        text += <span class="hljs-built_in">strspn</span>( text, <span class="hljs-string">" \t"</span> );<br>        m_host = text;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"oop! unknow header %s\n"</span>, text );<br>    }<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 我们没有真正解析HTTP请求的消息体，只是判断它是否被完整的读入了</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::parse_content</span><span class="hljs-params">( <span class="hljs-type">char</span>* text )</span> </span>{<br>    <span class="hljs-keyword">if</span> ( m_read_idx &gt;= ( m_content_length + m_checked_idx ) )<br>    {<br>        text[ m_content_length ] = <span class="hljs-string">'\0'</span>;<br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    }<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 主状态机，解析请求</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::process_read</span><span class="hljs-params">()</span> </span>{<br>    LINE_STATUS line_status = LINE_OK;<br>    HTTP_CODE ret = NO_REQUEST;<br>    <span class="hljs-type">char</span>* text = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK))<br>                || ((line_status = <span class="hljs-built_in">parse_line</span>()) == LINE_OK)) {<br>        <span class="hljs-comment">// 获取一行数据</span><br>        text = <span class="hljs-built_in">get_line</span>();<br>        m_start_line = m_checked_idx;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"got 1 http line: %s\n"</span>, text );<br><br>        <span class="hljs-keyword">switch</span> ( m_check_state ) {<br>            <span class="hljs-keyword">case</span> CHECK_STATE_REQUESTLINE: {<br>                ret = <span class="hljs-built_in">parse_request_line</span>( text );<br>                <span class="hljs-keyword">if</span> ( ret == BAD_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                }<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">case</span> CHECK_STATE_HEADER: {<br>                ret = <span class="hljs-built_in">parse_headers</span>( text );<br>                <span class="hljs-keyword">if</span> ( ret == BAD_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ret == GET_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">do_request</span>();<br>                }<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">case</span> CHECK_STATE_CONTENT: {<br>                ret = <span class="hljs-built_in">parse_content</span>( text );<br>                <span class="hljs-keyword">if</span> ( ret == GET_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">do_request</span>();<br>                }<br>                line_status = LINE_OPEN;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">default</span>: {<br>                <span class="hljs-keyword">return</span> INTERNAL_ERROR;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，</span><br><span class="hljs-comment">// 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其</span><br><span class="hljs-comment">// 映射到内存地址m_file_address处，并告诉调用者获取文件成功</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::do_request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// "/home/nowcoder/webserver/resources"</span><br>    <span class="hljs-built_in">strcpy</span>( m_real_file, doc_root );<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>( doc_root );<br>    <span class="hljs-built_in">strncpy</span>( m_real_file + len, m_url, FILENAME_LEN - len - <span class="hljs-number">1</span> );<br>    <span class="hljs-comment">// 获取m_real_file文件的相关的状态信息，-1失败，0成功</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">stat</span>( m_real_file, &amp;m_file_stat ) &lt; <span class="hljs-number">0</span> ) {<br>        <span class="hljs-keyword">return</span> NO_RESOURCE;<br>    }<br><br>    <span class="hljs-comment">// 判断访问权限</span><br>    <span class="hljs-keyword">if</span> ( ! ( m_file_stat.st_mode &amp; S_IROTH ) ) {<br>        <span class="hljs-keyword">return</span> FORBIDDEN_REQUEST;<br>    }<br><br>    <span class="hljs-comment">// 判断是否是目录</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">S_ISDIR</span>( m_file_stat.st_mode ) ) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br><br>    <span class="hljs-comment">// 以只读方式打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>( m_real_file, O_RDONLY );<br>    <span class="hljs-comment">// 创建内存映射</span><br>    m_file_address = ( <span class="hljs-type">char</span>* )<span class="hljs-built_in">mmap</span>( <span class="hljs-number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">close</span>( fd );<br>    <span class="hljs-keyword">return</span> FILE_REQUEST;<br>}<br><br><span class="hljs-comment">// 对内存映射区执行munmap操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::unmap</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span>( m_file_address )<br>    {<br>        <span class="hljs-built_in">munmap</span>( m_file_address, m_file_stat.st_size );<br>        m_file_address = <span class="hljs-number">0</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 写HTTP响应</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::write</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> ( bytes_to_send == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 将要发送的字节为0，这一次响应结束。</span><br>        <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLIN ); <br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-comment">// 分散写</span><br>        temp = <span class="hljs-built_in">writev</span>(m_sockfd, m_iv, m_iv_count);<br>        <span class="hljs-keyword">if</span> ( temp &lt;= <span class="hljs-number">-1</span> ) {<br>            <span class="hljs-comment">// 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，</span><br>            <span class="hljs-comment">// 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。</span><br>            <span class="hljs-keyword">if</span>( errno == EAGAIN ) {<br>                <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT );<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-built_in">unmap</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br><br>        bytes_have_send += temp;<br>        bytes_to_send -= temp;<br><br>        <span class="hljs-keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="hljs-number">0</span>].iov_len)<br>        {<br>            m_iv[<span class="hljs-number">0</span>].iov_len = <span class="hljs-number">0</span>;<br>            m_iv[<span class="hljs-number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);<br>            m_iv[<span class="hljs-number">1</span>].iov_len = bytes_to_send;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            m_iv[<span class="hljs-number">0</span>].iov_base = m_write_buf + bytes_have_send;<br>            m_iv[<span class="hljs-number">0</span>].iov_len = m_iv[<span class="hljs-number">0</span>].iov_len - temp;<br>        }<br><br>        <span class="hljs-keyword">if</span> (bytes_to_send &lt;= <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-comment">// 没有数据要发送了</span><br>            <span class="hljs-built_in">unmap</span>();<br>            <span class="hljs-built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN);<br><br>            <span class="hljs-keyword">if</span> (m_linger)<br>            {<br>                <span class="hljs-built_in">init</span>();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-keyword">else</span><br>            {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>    }<br><br>    <br>}<br><br><span class="hljs-comment">// 往写缓冲中写入待发送的数据</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_response</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ... )</span> </span>{<br>    <span class="hljs-keyword">if</span>( m_write_idx &gt;= WRITE_BUFFER_SIZE ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    va_list arg_list;<br>    <span class="hljs-built_in">va_start</span>( arg_list, format );<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">vsnprintf</span>( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="hljs-number">1</span> - m_write_idx, format, arg_list );<br>    <span class="hljs-keyword">if</span>( len &gt;= ( WRITE_BUFFER_SIZE - <span class="hljs-number">1</span> - m_write_idx ) ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    m_write_idx += len;<br>    <span class="hljs-built_in">va_end</span>( arg_list );<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_status_line</span><span class="hljs-params">( <span class="hljs-type">int</span> status, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title )</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"%s %d %s\r\n"</span>, <span class="hljs-string">"HTTP/1.1"</span>, status, title );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> content_len)</span> </span>{<br>    <span class="hljs-built_in">add_content_length</span>(content_len);<br>    <span class="hljs-built_in">add_content_type</span>();<br>    <span class="hljs-built_in">add_linger</span>();<br>    <span class="hljs-built_in">add_blank_line</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_content_length</span><span class="hljs-params">(<span class="hljs-type">int</span> content_len)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"Content-Length: %d\r\n"</span>, content_len );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_linger</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"Connection: %s\r\n"</span>, ( m_linger == <span class="hljs-literal">true</span> ) ? <span class="hljs-string">"keep-alive"</span> : <span class="hljs-string">"close"</span> );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_blank_line</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"%s"</span>, <span class="hljs-string">"\r\n"</span> );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_content</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span>* content )</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"%s"</span>, content );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_content_type</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">"Content-Type:%s\r\n"</span>, <span class="hljs-string">"text/html"</span>);<br>}<br><br><span class="hljs-comment">// 根据服务器处理HTTP请求的结果，决定返回给客户端的内容</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::process_write</span><span class="hljs-params">(HTTP_CODE ret)</span> </span>{<br>    <span class="hljs-keyword">switch</span> (ret)<br>    {<br>        <span class="hljs-keyword">case</span> INTERNAL_ERROR:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">500</span>, error_500_title );<br>            <span class="hljs-built_in">add_headers</span>( <span class="hljs-built_in">strlen</span>( error_500_form ) );<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_500_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BAD_REQUEST:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">400</span>, error_400_title );<br>            <span class="hljs-built_in">add_headers</span>( <span class="hljs-built_in">strlen</span>( error_400_form ) );<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_400_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> NO_RESOURCE:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">404</span>, error_404_title );<br>            <span class="hljs-built_in">add_headers</span>( <span class="hljs-built_in">strlen</span>( error_404_form ) );<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_404_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FORBIDDEN_REQUEST:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">403</span>, error_403_title );<br>            <span class="hljs-built_in">add_headers</span>(<span class="hljs-built_in">strlen</span>( error_403_form));<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_403_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FILE_REQUEST:<br>            <span class="hljs-built_in">add_status_line</span>(<span class="hljs-number">200</span>, ok_200_title );<br>            <span class="hljs-built_in">add_headers</span>(m_file_stat.st_size);<br>            m_iv[ <span class="hljs-number">0</span> ].iov_base = m_write_buf;<br>            m_iv[ <span class="hljs-number">0</span> ].iov_len = m_write_idx;<br>            m_iv[ <span class="hljs-number">1</span> ].iov_base = m_file_address;<br>            m_iv[ <span class="hljs-number">1</span> ].iov_len = m_file_stat.st_size;<br>            m_iv_count = <span class="hljs-number">2</span>;<br><br>            bytes_to_send = m_write_idx + m_file_stat.st_size;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br>    m_iv[ <span class="hljs-number">0</span> ].iov_base = m_write_buf;<br>    m_iv[ <span class="hljs-number">0</span> ].iov_len = m_write_idx;<br>    m_iv_count = <span class="hljs-number">1</span>;<br>    bytes_to_send = m_write_idx;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::process</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 解析HTTP请求</span><br>    HTTP_CODE read_ret = <span class="hljs-built_in">process_read</span>();<br>    <span class="hljs-keyword">if</span> ( read_ret == NO_REQUEST ) {<br>        <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLIN );<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 生成响应</span><br>    <span class="hljs-type">bool</span> write_ret = <span class="hljs-built_in">process_write</span>( read_ret );<br>    <span class="hljs-keyword">if</span> ( !write_ret ) {<br>        <span class="hljs-built_in">close_conn</span>();<br>    }<br>    <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);<br>}<br></code></pre></td></tr></tbody></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span><span class="hljs-comment">// 网络相关, 导入这个上面两个不用导了</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span> <span class="hljs-comment">// 文件描述符</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-comment">// 同步的类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"locker.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threadpool.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"http_conn.h"</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FD 65536   <span class="hljs-comment">// 最大的文件描述符个数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 10000  <span class="hljs-comment">// 一次可以监听的最大的事件数量</span></span><br><br><span class="hljs-comment">// 添加文件描述符 到 epoll 中</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> one_shot )</span></span>;<span class="hljs-comment">// 声明成外部的, 写到 http_conn 中</span><br><span class="hljs-comment">// 从 epoll 删除文件描述符</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">removefd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd )</span></span>;<br><span class="hljs-comment">// 修改文件活述符</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">modfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ev)</span></span>;<br><br><span class="hljs-comment">// 添加信号捕捉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addsig</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span>( handler )(<span class="hljs-type">int</span>))</span></span>{<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> sa;<br>    <span class="hljs-built_in">memset</span>( &amp;sa, <span class="hljs-string">'\0'</span>, <span class="hljs-built_in">sizeof</span>( sa ) ); <span class="hljs-comment">// 清空 sa</span><br>    sa.sa_handler = handler;<span class="hljs-comment">// 用我们传递进来的handler</span><br>    <span class="hljs-built_in">sigfillset</span>( &amp;sa.sa_mask );<span class="hljs-comment">// 设置临时阻塞的信号集</span><br>    <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">sigaction</span>( sig, &amp;sa, <span class="hljs-literal">NULL</span> ) != <span class="hljs-number">-1</span> );<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[] )</span> </span>{<br>    <br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">1</span> ) { <span class="hljs-comment">// ,没有端口号</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"usage: %s port_number\n"</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-comment">// 获取端口号, atoi: 转化成整数</span><br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">1</span>] );<br>    <span class="hljs-comment">// 对 SIGPIE 信号处理: 忽略它</span><br>    <span class="hljs-built_in">addsig</span>( SIGPIPE, SIG_IGN );<br>    <span class="hljs-comment">// 创建线程池，初始化线程池</span><br>    <span class="hljs-comment">// http_conn 是处理任务的类</span><br>    threadpool&lt; http_conn &gt;* pool = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">try</span> {<br>        pool = <span class="hljs-keyword">new</span> threadpool&lt;http_conn&gt;;<br>    } <span class="hljs-built_in">catch</span>( ... ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-comment">// 创建一个数组用于保存所有客户端的信息</span><br>    http_conn* users = <span class="hljs-keyword">new</span> http_conn[ MAX_FD ];<span class="hljs-comment">// MAX_FD: 宏定义(在上边)</span><br>    <span class="hljs-comment">// 创建监听的套接字</span><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    address.sin_addr.s_addr = INADDR_ANY;<br>    address.sin_family = AF_INET;<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port ); <span class="hljs-comment">// 大端小端转换字节序</span><br><br>    <span class="hljs-comment">// 设置端口复用 在绑定之前设置</span><br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in">sizeof</span>( reuse ) );<br><br>    <span class="hljs-comment">// 绑定</span><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( <span class="hljs-keyword">struct</span> sockaddr* )&amp;address, <span class="hljs-built_in">sizeof</span>( address ) );<br>    <br>    <span class="hljs-comment">// 监听</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br><br>    <span class="hljs-comment">// 创建epoll对象，和事件数组，添加</span><br>    epoll_event events[ MAX_EVENT_NUMBER ]; <span class="hljs-comment">//  [宏定义] : 最大可以监听的个数</span><br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">5</span> );<br><br>    <span class="hljs-comment">// 将监听的文件描述符添加到epoll对象中</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, listenfd, <span class="hljs-literal">false</span> );<br>    http_conn::m_epollfd = epollfd;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br>        <br>        <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span> );<br>        <br>        <span class="hljs-keyword">if</span> ( ( number &lt; <span class="hljs-number">0</span> ) &amp;&amp; ( errno != EINTR ) ) {<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">"epoll failure\n"</span> );<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++ ) {<br>            <br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>            <br>            <span class="hljs-keyword">if</span>( sockfd == listenfd ) {<br>                <br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>                <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>( client_address );<br>                <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( <span class="hljs-keyword">struct</span> sockaddr* )&amp;client_address, &amp;client_addrlength );<br>                <br>                <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> ) {<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"errno is: %d\n"</span>, errno );<br>                    <span class="hljs-keyword">continue</span>;<br>                } <br><br>                <span class="hljs-keyword">if</span>( http_conn::m_user_count &gt;= MAX_FD ) {<br>                    <span class="hljs-built_in">close</span>(connfd);<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                users[connfd].<span class="hljs-built_in">init</span>( connfd, client_address);<br><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; ( EPOLLRDHUP | EPOLLHUP | EPOLLERR ) ) {<br><br>                users[sockfd].<span class="hljs-built_in">close_conn</span>();<br><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN) {<br><br>                <span class="hljs-keyword">if</span>(users[sockfd].<span class="hljs-built_in">read</span>()) {<br>                    pool-&gt;<span class="hljs-built_in">append</span>(users + sockfd);<br>                } <span class="hljs-keyword">else</span> {<br>                    users[sockfd].<span class="hljs-built_in">close_conn</span>();<br>                }<br><br>            }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; EPOLLOUT ) {<br><br>                <span class="hljs-keyword">if</span>( !users[sockfd].<span class="hljs-built_in">write</span>() ) {<br>                    users[sockfd].<span class="hljs-built_in">close_conn</span>();<br>                }<br><br>            }<br>        }<br>    }<br>    <br>    <span class="hljs-built_in">close</span>( epollfd );<br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">delete</span> [] users;<br>    <span class="hljs-keyword">delete</span> pool;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRqHai9rjyzxK3vO20JNy5" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.6 项目整体流程代码实现.md" --> <p>#历史记录::<br>2022/10/10🌵5.6 项目整体流程代码实现 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The formation mechanism, mechanical properties and thermal stability of</title>
      <link href="/posts/5144/"/>
      <url>/posts/5144/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObstmNYf60hbpvlbrY5BBIKL" deck = "👨🏻‍🎓科研::论文学习::The formation mechanism, mechanical properties and thermal stability of.md" --> <p>#历史记录::<br>2022/10/9🌵’The formation mechanism, mechanical properties and thermal stability of’ : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
          <category> 论文学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. 多表查询</title>
      <link href="/posts/5516/"/>
      <url>/posts/5516/</url>
      
        <content type="html"><![CDATA[<p>我们之前在讲解SQL语句的时候,讲解了DQL语句,也就是数据查询语句,但是之前讲解的查询都是单表查询,而本章节我们要学习的则是多表查询操作,主要从以下几个方面进行讲解。::</p><!-- basicblock-end --><h2 id="01-数据准备"><a class="markdownIt-Anchor" href="#01-数据准备"></a> 0.1 数据准备</h2><p>1). 删除之前 emp, dept表的测试数据<br>2). 执行如下脚本,创建emp表与dept表并插入测试数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- 创建dept表,并插入数据<br>create table dept(     <br>id   int auto_increment comment 'ID' primary key,<br>name varchar(50) not null comment '部门名称' )comment '部门表'; <br><br>INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部');<br><br><br>-- 创建emp表,并插入数据<br>create table emp(     <br>id  int auto_increment comment 'ID' primary key,<br>name varchar(50) not null comment '姓名',     <br>age  int comment '年龄',     <br>job varchar(20) comment '职位',     <br>salary int comment '薪资',    <br>entrydate date comment '入职时间',     <br>managerid int comment '直属领导ID',     <br>dept_id int comment '部门ID' <br>)comment '员工表';<br><br>-- 添加外键<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);<br>INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id)<br>VALUES             <br>(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),             <br>(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),             <br>(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),             <br>(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),             <br>(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),             <br>(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),             <br>(7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),            <br>(8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),             <br>(9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),             <br>(10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),             <br>(11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),             <br>(12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),             <br>(13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),             <br>(14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),             <br>(15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),             <br>(16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),             <br>(17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);<br><br><br><br></code></pre></td></tr></tbody></table></figure><pre><code class="hljs">dept表共6条记录,emp表共17条记录。</code></pre><!-- basicblock-start oid="Obs5jJI2XSF86UxAkYwgQEbE" --> <h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述::</h1><!-- basicblock-end --><p><strong>多表查询就是指从多张表中查询数据。</strong><br>原来查询单表数据,执行的SQL形式为:select * from emp;<br>那么我们要执行多表查询,就只需要使用逗号分隔多张表即可,如: select * from emp , dept ; 具体的执行结果如下:</p><blockquote><p>[!example]- 笛卡尔积<br>![[笛卡尔积.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obs9pzzKwkHDnW6SFWiqwAg5" --> <h1 id="2-多表关系"><a class="markdownIt-Anchor" href="#2-多表关系"></a> 2 多表关系::</h1><blockquote><p>2022/10/08: ⏱0-34, 感觉时间都花在了弄图上边, 调格式上了</p></blockquote><!-- basicblock-end --><p>由于业务之间相互关联,所以各个表结构之间也存在着各种联系,基本上分为三种:</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><blockquote><p>[!example]-<br>![[5.1 多表关系 2022-10-08 20.14.43.excalidraw]]</p></blockquote><p>用到的代码<br>create table student_course(<br>id int auto_increment comment ‘主键’ primary key,<br>studentid int not null comment ‘学生ID’,<br>courseid  int not null comment ‘课程ID’,<br>constraint fk_courseid foreign key (courseid) references course (id),<br>constraint fk_studentid foreign key (studentid) references student (id)<br>)comment ‘学生课程中间表’;</p><!-- basicblock-start oid="Obsxh6hLLAl5lpkpAzsYbPOT" --> <h1 id="3-分类"><a class="markdownIt-Anchor" href="#3-分类"></a> 3 分类::</h1><!-- basicblock-end --><ul><li>连接查询<ul><li>内连接:相当于查询A、B交集部分数据</li><li>外连接:</li><li>左外连接:查询左表所有数据,以及两张表交集部分数据</li><li>右外连接:查询右表所有数据,以及两张表交集部分数据</li><li>自连接:当前表与自身的连接查询,自连接必须使用表别名</li></ul></li><li>子查询</li></ul><!-- basicblock-start oid="ObsJsY39bMq3maKLKjNFE1xL" --> <h2 id="31-内连接"><a class="markdownIt-Anchor" href="#31-内连接"></a> 3.1 内连接::</h2><!-- basicblock-end --><p>内连接查询的是两张表交集部分的数据</p><p>内连接的语法分为两种: 隐式内连接、显式内连接</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">1). 隐式内连接<br>SELECT  字段列表   FROM   表1 , 表2   WHERE   条件 ... ;<br><br><br>2). 显式内连接<br>SELECT  字段列表   FROM   表1  [ INNER ]  JOIN 表2  ON  连接条件 ... ; -- inner 可以省略<br><br>-- 说明<br>相当于多了几个关键字显示的说明他们连接了<br>隐式只是没有关键字, 也连接了<br><br>-- 💡统一用显式连接, 因为可以和外连接保持一致<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>![[5. 多表查询 2022-10-08 21.45.28.excalidraw]]</p></blockquote><p>多表查询和起别名联立使用<br>表的别名:</p><ol><li>tablea as 别名1 , tableb as 别名2 ;  /💡as 可以省略</li><li>tablea 别名1 , tableb 别名2 ;</li></ol><blockquote><p>[!tip] 一旦为表起了别名,就不能再使用表名来指定对应的字段了,此时只能够使用别名来指定字段。</p></blockquote><!-- basicblock-start oid="ObsbnzRwEGow4zlkoaxIesmf" --> <h2 id="32-外连接"><a class="markdownIt-Anchor" href="#32-外连接"></a> 3.2 外连接::</h2><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210082212714.png" alt="|500"></p><p>外连接分为两种,分别是:左外连接 和 右外连接。<br>1). 左外连接</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT  字段列表   FROM   表1  LEFT  [ OUTER ]  JOIN 表2  ON  条件 ... ;<br><br>-- 案例查询emp表的所有数据, 和对应的部门信息<br>select e.*, d.name from emp e left join dept d on e.dept_id = d.id;<br></code></pre></td></tr></tbody></table></figure><p><strong>左外连接相当于查询表1(左表)的所有数据</strong>,当然也包含表1和表2交集部分的数据。</p><p>2). 右外连接</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT  字段列表   FROM   表1  RIGHT  [ OUTER ]  JOIN 表2  ON  条件 ... ;<br><br>-- 查询dept表的所有数据, 和对应的员工信息(右外连接)<br>select e.*, d.name from emp e right join dept d on e.dept_id = d.id;<br>select d.*, e.* from dept d left  join emp e on e.dept_id = d.id;<br><br><br></code></pre></td></tr></tbody></table></figure><p><strong>右外连接相当于查询表2(右表)的所有数据</strong>,当然也包含表1和表2交集部分的数据。</p><blockquote><p>[!example]-<br>![[外连接.excalidraw]]</p></blockquote><blockquote><p>[!tip]<br>注意事项:  左外连接和右外连接是可以相互替换的,只需要调整在连接查询时SQL中,表结构的先后顺序就可以了。<br>而我们在日常开发使用时,<strong>更偏向于左外连接</strong>。</p></blockquote><!-- basicblock-start oid="ObsRlpyhmGYW4D4lbLGhTRtz" --> <h2 id="33-自连接"><a class="markdownIt-Anchor" href="#33-自连接"></a> 3.3 自连接::</h2><!-- basicblock-end --><h3 id="331-自连接查询"><a class="markdownIt-Anchor" href="#331-自连接查询"></a> 3.3.1 自连接查询</h3><p>自连接查询,顾名思义,就是自己连接自己,也就是把一张表连接查询多次。</p><p>语法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT  字段列表   FROM   表A   别名A   JOIN  表A    别名B   ON  条件 ... ;<br></code></pre></td></tr></tbody></table></figure><p>而对于自连接查询,可以是内连接查询,也可以是外连接查询。</p><blockquote><p>[!example]-<br>![[5. 多表查询 2022-10-09 20.23.21.excalidraw]]</p></blockquote><blockquote><p>[!tip]  注意事项:<br>在自连接查询中,必须要为表起别名,要不然我们不清楚所指定的条件、返回的字段,到底是哪一张表的字段。</p></blockquote><h3 id="332-联合查询"><a class="markdownIt-Anchor" href="#332-联合查询"></a> 3.3.2 联合查询</h3><p>对于union查询,就是把多次查询的结果合并起来,形成一个新的查询结果集。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT  字段列表   FROM   表A  ...  <br>UNION [ ALL ] <br>SELECT  字段列表  FROM   表B  ....;<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!tip]<br>对于联合查询的多张表的列数必须保持一致,字段类型也需要保持一致。<br>union all 会将全部的数据直接合并在一起,union 会对合并之后的数据去重。<br>如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union al1联合查询时，将会报错。</p></blockquote><blockquote><p>[!example]-<br>![[5. 多表查询 2022-10-09 20.42.15.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obsur8Pwpz1zDWswxu0WuwcZ" --> <h2 id="34-子查询"><a class="markdownIt-Anchor" href="#34-子查询"></a> 3.4 子查询::</h2><!-- basicblock-end --><p>SQL语句中嵌套SELECT语句,称为嵌套查询,又称子查询。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT  *  FROM   t1   WHERE  column1 =  ( SELECT  column1  FROM  t2 );<br></code></pre></td></tr></tbody></table></figure><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个</p><blockquote><p>[!summary] 分类<br>根据子查询结果不同,分为:<br>A. 标量子查询(子查询结果为单个值)<br>B. 列子查询(子查询结果为一列)<br>C. 行子查询(子查询结果为一行)<br>D. 表子查询(子查询结果为多行多列)</p></blockquote><p>根据子查询位置,分为:<br>A. WHERE之后<br>B. FROM之后<br>C. SELECT之后</p><h3 id="341-标量子查询"><a class="markdownIt-Anchor" href="#341-标量子查询"></a> 3.4.1 标量子查询</h3><p>子查询返回的结果是单个值(数字、字符串、日期等),最简单的形式,这种子查询称为标量子查询。<br>常用的操作符:=  &lt;&gt;  &gt;   &gt;=   &lt;  &lt;=</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- A. 查询 "销售部" 的所有员工信息<br>完成这个需求时,我们可以将需求分解为两步: <br><br>1. 查询 "销售部" 部门ID<br>select id from dept where name = '销售部';<br><br>2. 根据 "销售部" 部门ID, 查询员工信息<br>select * from emp where dept_id = (select id from dept where name = '销售部');<br><br>-- B. 查询在 "方东白" 入职之后的员工信息<br>完成这个需求时,我们可以将需求分解为两步: <br><br>1. 查询 方东白 的入职日期<br>select entrydate from emp where name = '方东白'; <br><br>1. 查询指定入职日期之后入职的员工信息<br>select * from emp where entrydate &gt; (select entrydate from emp where name = '方东白');<br><br><br><br></code></pre></td></tr></tbody></table></figure><h3 id="342-列子查询"><a class="markdownIt-Anchor" href="#342-列子查询"></a> 3.4.2 列子查询</h3><p>子查询返回的结果是一列(可以是多行),这种子查询称为列子查询。<br>常用的操作符:IN 、NOT IN 、 ANY 、SOME 、 ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部和市场部的所有员工信息<br>1. 查询 "销售部" 和 "市场部" 的部门ID<br>2. 根据部门ID, 查询员工信息<br><br>select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');<br><br>-- 查询比财务部所有人工资都高的员工信息<br>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部'));<br><br>-- 查询比研发部任意一人工资高的员工信息<br>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部'));<br></code></pre></td></tr></tbody></table></figure><h3 id="343-行子查询"><a class="markdownIt-Anchor" href="#343-行子查询"></a> 3.4.3 行子查询</h3><p>返回的结果是一行（可以是多列）。<br>常用操作符：=, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与'张无忌'的薪资及直属领导 相同的员工信息<br>1. 查询 "张无忌" 的薪资及直属领导<br>2. 查询与 "张无忌" 的薪资及直属领导相同的员工信息 ;<br><br>select salary, managerid from emp where name = '张无忌';<br>select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');<br><br><br><br><br></code></pre></td></tr></tbody></table></figure><h3 id="344-表子查询"><a class="markdownIt-Anchor" href="#344-表子查询"></a> 3.4.4 表子查询</h3><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">A. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息<br>1. 查询 "鹿杖客" , "宋远桥" 的职位和薪资<br>2. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息<br><br><br>select job, salary from emp where name = '鹿杖客' or name = '宋远桥';<br>select * from emp where (job,salary) in ( select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );<br><br><br><br>B. 查询入职日期是 "2006-01-01" 之后的员工信息 , 及其部门信息<br>分解为两步执行: <br>1. 入职日期是 "2006-01-01" 之后的员工信息<br>2. 查询这部分员工, 对应的部门信息;<br>select * from emp where entrydate &gt; '2006-01-01';<br>select e.*, d.* from (select * from emp where entrydate &gt; '2006-01-01') e left join dept d on e.dept_id = d.id ;<br><br><br><br><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsKoFz2LyD20rQpsImLWiV4" --> <h1 id="4-多表查询案例"><a class="markdownIt-Anchor" href="#4-多表查询案例"></a> 4 多表查询案例::</h1><!-- basicblock-end --><p>数据环境准备:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">create table salgrade(     <br>grade int,     <br>losal int,     <br>hisal int ) comment '薪资等级表'; <br><br>insert into salgrade values (1,0,3000); <br>insert into salgrade values (2,3001,5000); <br>insert into salgrade values (3,5001,8000); <br>insert into salgrade values (4,8001,10000); <br>insert into salgrade values (5,10001,15000); <br>insert into salgrade values (6,15001,20000); <br>insert into salgrade values (7,20001,25000); <br>insert into salgrade values (8,25001,30000);<br></code></pre></td></tr></tbody></table></figure><p>在这个案例中,我们主要运用上面所讲解的多表查询的语法,完成以下的12个需求即可,而这里主要涉及到的表就三张:emp员工表、dept部门表、salgrade薪资等级表 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>1). 查询员工的姓名、年龄、职位、部门信息 (隐式内连接) <br>表: emp , dept <br>连接条件: emp.dept_id = dept.id<br>select e.name , e.age , e.job , d.name from emp e, dept d where e.dept_id = d.id; <br><br><br>2). 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息(显式内连接) -- 简化一下查所有所有的字段<br>表: emp , dept <br>连接条件: emp.dept_id = dept.id<br>select * from emp e join dept d on e.dept_id = d.id where e.age &lt; 30; # ❗️on 后边得是e.dept_id = d.id, 否则会有笛卡尔积<br><br><br>3). 查询拥有员工的部门ID、部门名称<br>表: emp , dept <br>连接条件: emp.dept_id = dept.id<br>select distinct  d.id, d.name from emp e, dept d where e.dept_id = d.id; # ❗️没有 distinct 接会出现重复的部门<br><br><br>4). 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接) <br>select e.*, d.name from emp e left join dept d on e.dept_id = d.id where e.age &gt; 40 ;<br><br><br>5). 查询所有员工的工资等级<br>表: emp , salgrade <br>连接条件 : # 大于最小值 ,小于最大值<br>- emp.salary &gt;= salgrade.losal and emp.salary &lt;= salgrade.hisal <br>- emp.salary between salgrade.losal and salgrade.hisal -- 用这个<br>-- 方式一<br>select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;<br>-- 方式二<br>select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary between s.losal and s.hisal;<br><br><br><br><br>6). 查询 "研发部" 所有员工的信息及 工资等级表<br>: emp , salgrade , dept <br>连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id <br>查询条件 : dept.name = '研发部'<br><br>-- 多重 and 条件<br>select e.* , s.grade from emp e, dept d, salgrade s where e.dept_id = d.id and (e.salary between s.losal and s.hisal) and d.name = '研发部';<br><br><br><br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsvUtPcJ5UrJg8tIeyD2QRv" deck = "👨🏻‍💻code::MySQL::基础篇::5. 多表查询.md" --> <p>#历史记录:: <a href="marginnote3app://note/6625B823-D7ED-4B49-B3AF-373D711D018B">margin: 多表查询</a><br>2022/10/8🌵5. 多表查询 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. 约束</title>
      <link href="/posts/7394/"/>
      <url>/posts/7394/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述::</h1><!-- basicblock-end --><p>概念: 约束是作用于表中字段上的规则,用于限制存储在表中的数据。<br>目的: 保证数据库中数据的正确、有效性和完整性。</p><p>分类：</p><table><thead><tr><th>约束</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>非空约束</td><td>NOT NULL</td><td>限制该字段的数据不能为null</td></tr><tr><td>唯一约束</td><td>UNIQUE</td><td>保证该字段的所有数据都是唯一、不重复的</td></tr><tr><td>主键约束</td><td>PRIMARY KEY</td><td>主键是一行数据的唯一标识，要求非空且唯一      <strong>自增：AUTO_INCREMENT</strong></td></tr><tr><td>默认约束</td><td>DEFAULT</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td></tr><tr><td>检查约束</td><td>CHECK</td><td>保证字段值满足某一个条件</td></tr><tr><td>外键约束</td><td>FOREIGN KEY</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td></tr></tbody></table><blockquote><p>[!cite] 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p></blockquote><h2 id="11-常用约束"><a class="markdownIt-Anchor" href="#11-常用约束"></a> 1.1 常用约束</h2><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>id int primary key auto_increment,<br>name varchar(10) not null unique,<br>age int check(age &gt; 0 &amp;&amp; age &lt; 120),<br>status char(1) default '1',<br>gender char(1)<br>);<br><br></code></pre></td></tr></tbody></table></figure><p>在为字段添加约束时,我们只需要在字段之后加上约束的关键字即可,需要关注其语法。我们执行上面的SQL把表结构创建完成,然后接下来,就可以通过一组数据进行测试,从而验证一下,约束是否可以生效。</p><p>通过图形化界面来创建表结构时,又该如何来指定约束呢?<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081620473.png" alt=""></p><!-- basicblock-start oid="ObsQCW67DGtvevyv31XBl7qf" --> <h1 id="2-外键约束"><a class="markdownIt-Anchor" href="#2-外键约束"></a> 2 外键约束::</h1><!-- basicblock-end --><p>外键:用来让两张表的数据之间建立连接,从而保证数据的一致性和完整性。</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081623336.png" alt=""></p><p>添加外键：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型,<br>...<br>[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)<br>);<br><br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);<br><br>-- 例子<br>create table student_course(<br>constraint fk_studentid foreign key (studentid) references student (id) <br>)comment '学生课程中间表';<br><br>alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);<br></code></pre></td></tr></tbody></table></figure><p>删除外键：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;<br><br>-- 案例<br>alter table emp drop foreign key fk_emp_dept_id;<br><br></code></pre></td></tr></tbody></table></figure><p>![[外键约束.excalidraw]]</p><!-- basicblock-start oid="ObsOh61UzzMtXyccxWKf8vyh" --> <h1 id="3-删除更新行为"><a class="markdownIt-Anchor" href="#3-删除更新行为"></a> 3 删除/更新行为::</h1><blockquote><p>2022/10/08⏱0-44</p></blockquote><!-- basicblock-end --><p>添加了外键之后,再删除父表数据时产生的约束行为,我们就称为删除/更新行为。具体的删除/更新行为有以下几种:</p><table><thead><tr><th>行为</th><th>说明</th><th></th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td><td>默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td><td>默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td><td></td></tr><tr><td>SET NULL</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td><td></td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td><td></td></tr></tbody></table><p>怎么在表格中换行</p><blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081759671.png" alt="|700"></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">更改删除/更新行为：<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;<br><br>-- 例子<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade ;<br><br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update set null on delete set null ;<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]- cascade, set null<br>由于NO ACTION 是默认行为,我们前面语法演示的时候,已经测试过了,就不再演示了,这里我们再演示其他的两种行为:CASCADE、SET NULL。<br>![[4. 约束 2022-10-08 17.34.27.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obsyt1m2LDA7YYCaSa9CyqVF" --> <h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结::</h1><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsFNToqDZ3IcPFgTPYaQJa1" deck = "👨🏻‍💻code::MySQL::基础篇::4. 约束.md" --> <p>#历史记录:: <a href="marginnote3app://note/ED900578-977B-4CA9-B9C2-666A5E4687EC">margin: 约束</a><br>2022/10/8🌵4. 约束 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 函数</title>
      <link href="/posts/62444/"/>
      <url>/posts/62444/</url>
      
        <content type="html"><![CDATA[<h2 id="01-函数类型"><a class="markdownIt-Anchor" href="#01-函数类型"></a> 0.1 函数类型::</h2><!-- basicblock-end --><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><p>我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可</p><!-- basicblock-start oid="ObsKSH7ufFoInhssMhmdqMW7" --> <h1 id="1-字符串函数"><a class="markdownIt-Anchor" href="#1-字符串函数"></a> 1 字符串函数::</h1><!-- basicblock-end --><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr><tr><td>REPLACE(column, source, replace)</td><td>替换字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br><br><br>A.concat:字符串拼接<br>select concat('Hello',' MySQL'); <br><br>B.lower :全部转小写<br>select lower('Hello');<br><br>C.upper :全部转大写<br>select upper('Hello');<br><br>D. lpad :左填充<br>select lpad('01',5,'-'); # 结果: ---01<br><br>E.rpad:右填充<br>select rpad('01',5,'-');# 结果: 01--- <br><br>F.trim:去除空格<br>select trim('HelloMySQL'); <br><br>G.substring:截取子字符串<br>select substring('Hello MysQL',1,5);<br><br><br><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-  由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。<br>![[函数 2022-10-07 18.10.44.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsDtGNTSJ0yZVyjGc2bGFAV" --> <h1 id="2-数值函数"><a class="markdownIt-Anchor" href="#2-数值函数"></a> 2 数值函数::</h1><!-- basicblock-end --><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数 含小数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>A. ceil：向上取整<br>select ceil(1.1);<br><br>B. floor：向下取整<br>select floor (1.9)；<br><br>C. mod：取模<br>select mod (7, 4);<br><br>D. rand：获取随机数: 0-1<br>select rand();<br><br>E. ROUND(x, y) | 求参数x的四舍五入值，💡保留y位小数<br>select round (2.344, 2)；<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]- 案例：通过数据库的函数，生成一个六位数的随机验证码。<br>![[函数 2022-10-07 18.55.42.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsmaWB98mahsbm9WAJ90ZmE" --> <h1 id="3-日期函数"><a class="markdownIt-Anchor" href="#3-日期函数"></a> 3 日期函数::</h1><!-- basicblock-end --><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 例子<br>A. curdate:当前日期<br>select curdate();<br><br>B. curtime：当前时间<br>select curtime()；<br><br>C. now：当前日期和时间<br>select now()；<br><br>D. YEAR, MONTH, DAY: 当前年、月、日<br>select YEAR (now());<br>select MONTH (now());<br>select DAY (now());<br><br>E. date_add：增加指定的时间间隔<br>select date add (now(), INTERVAL 70 YEAR ); # 显示推迟后的时间<br><br>F. datediff：获取两个日期相差的天数<br>select datediff( '2021-10-01', '2021-12-01');<br><br><br><br>-- 案例<br>查询所有员工的入职天数,并根据入职天数倒序排序。<br>思路: 入职天数,就是通过当前日期 - 入职日期,所以需要使用datediff函数来完成。<br>select name, datediff(curdate(), entrydate) as 'entrydays' from emp order by entrydays desc;<br><br><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs5veD2X1nBfsnfJh348rSI" --> <h1 id="4-流程函数"><a class="markdownIt-Anchor" href="#4-流程函数"></a> 4 流程函数::</h1><!-- basicblock-end --><p>流程函数也是很常用的一类函数,可以在SQL语句中实现条件筛选,从而提高语句的效率。</p><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- A. if<br>select if(false, 'Ok', 'Error');# 返回 error<br><br>-- B. ifnull<br>select ifnull('Ok','Default'); # 返回 ok<br>select ifnull('','Default'); # 返回' '<br>select ifnull(null,'Default');# 返回 default<br><br>-- C. case when then else end<br>需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----&gt; 一线城市 , 其他 ----&gt; 二线城市)<br>select     <br>name,     <br>( case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end ) as '工作地址' <br>from emp;<br><br><br><br></code></pre></td></tr></tbody></table></figure><p>案例: 判定分数等级</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>create table score(     <br>id int comment 'ID',     <br>name varchar(20) comment '姓名',     <br>math int comment '数学',     <br>english int comment '英语',     <br>chinese int comment '语文' ) comment '学员成绩表'; <br><br>insert into score(id, name, math, english, chinese) <br>VALUES (1, 'Tom', 67, 88, 95 ), (2, 'Rose' , 23, 66, 90),(3, 'Jack', 56, 98, 76);<br><br>-- 案例: 判定分数等级<br>select     <br>id,     <br>name,     <br>(case when math &gt;= 85 then '优秀' when math &gt;=60 then '及格' else '不及格' end ) '数学',     <br>(case when english &gt;= 85 then '优秀' when english &gt;=60 then '及格' else '不及格' end ) '英语',     <br>(case when chinese &gt;= 85 then '优秀' when chinese &gt;=60 then '及格' else '不及格' end ) '语文' <br>from score;<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081543332.png" alt="|500"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2TzjfwTbXfSo9jbzy7fBR" deck = "👨🏻‍💻code::MySQL::基础篇::函数.md" --> <p>#历史记录:: <a href="marginnote3app://note/C3962258-9992-4B8D-9965-7F23B17EC41A">margin: 函数</a><br>2022/10/7🌵函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.4 DCL</title>
      <link href="/posts/23010/"/>
      <url>/posts/23010/</url>
      
        <content type="html"><![CDATA[<p>DCL英文全称是Data Control Language(数据控制语言),用来管理数据库用户、控制数据库的访问权限。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210071618311.png" alt="|700"></p><!-- basicblock-start oid="ObsBHctd7XgA0ZLsIHxOySkU" --> <h1 id="1-管理用户"><a class="markdownIt-Anchor" href="#1-管理用户"></a> 1 管理用户::</h1><!-- basicblock-end --><ol><li>查询用户:</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from mysql.user;<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210071622457.png" alt="|900"><br>Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问,是不可以远程访问的。<br>User代表的是访问该数据库的用户名。<br><strong>在MySQL中需要通过Host和User来唯一标识一个用户。</strong></p><ol start="2"><li>创建用户</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">CREATE USER '用户名' @ '主机名' IDENTIFIED BY '密码'; # 💡这个密码是你自己设置的密码<br><br>-- 1. 创建用户test，只能在当前主机localhost访问<br>create user 'test' @ 'localhost' identified by '123456';<br><br>-- 创建用户test，能在任意主机访问<br>create user 'test' @ '%' identified by '123456';<br>create user 'test' identified by '123456'; # 如果不加 '@', 默认是在任意主机<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>修改用户密码</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">ALTER USER '用户名' @ '主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ; # with 后边的是字符串, 不是原来的密码<br><br>-- 2. 修改密码<br>alter user 'test' @ 'localhost' identified with mysql_native_password by '1234'; # 💡这里不是存在隐患吗<br><br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>删除用户</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">DROP USER '用户名' @ '主机名' ;<br><br>-- 3. 删除用户<br>drop user 'test' @ 'localhost';<br></code></pre></td></tr></tbody></table></figure><p>注意事项：</p><ul><li>在MySQL中需要通过<strong>用户名@主机名</strong>的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。</li><li>这类SQL开发人员操作的比较少，主要是DBA ( Database Administrator数据库管理员）使用。</li></ul><blockquote><p>[!example]- 案例<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210071651852.png" alt=""></p></blockquote><!-- basicblock-start oid="ObswVUY5N9oojOyOXRxRuds6" --> <h1 id="2-权限控制"><a class="markdownIt-Anchor" href="#2-权限控制"></a> 2 权限控制::</h1><!-- basicblock-end --><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>更多权限请看<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html">权限一览表</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>查询权限：<br>SHOW GRANTS FOR '用户名' @ '主机名';<br><br>授予权限：<br>GRANT 权限列表 ON 数据库名.表名 TO '用户名' @ '主机名';<br><br>撤销权限：<br>REVOKE 权限列表 ON 数据库名.表名 FROM '用户名' @ '主机名';<br><br>-- 案例<br>A. 查询 'heima'@ '%' 用户的权限<br>show grants for 'heima'@ '%';<br><br>B. 授予 'heima'@ '%' 用户itcast数据库所有表的所有操作权限<br>grant all on itcast.* to 'heima'@ '%'; <br><br>C. 撤销 'heima'@ '%' 用户的itcast数据库的所有权限 <br>revoke all on itcast.* from 'heima'@ '%';<br><br></code></pre></td></tr></tbody></table></figure><p>案例</p><blockquote><p>[!summary] 注意事项</p><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">grant all on ithema.* to 'heima' @ '%';<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsEVXdfMXT7sGVSvYUoNpzO" deck = "👨🏻‍💻code::MySQL::基础篇::DCL.md" tag = "文件 deck" --> <p>#历史记录:: <a href="marginnote3app://note/C72940C3-99B5-407B-BC9A-A9CCDC328330">margin: DCL</a><br>2022/10/7🌵DCL : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.3 DQL</title>
      <link href="/posts/14697/"/>
      <url>/posts/14697/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><p>DQL英文全称是Data Query Language(数据查询语言),数据查询语言,用来查询数据库中表的记录。</p><p><strong>查询关键字: SELECT</strong></p><p>在一个正常的业务系统中,查询操作的频次是要远高于增删改的,当我们去访问企业官网、电商网站, 在这些网站中我们所看到的数据,实际都是需要从数据库中查询并展示的。而且在查询的过程中,可能还会涉及到条件、排序、分页等操作。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210070122175.png" alt="|500"></p><p>我们先来完成如下数据准备工作:<br>![[DQL 2022-10-07 01.44.53.excalidraw]]</p><!-- basicblock-start oid="ObsmTlFpONTSrFV2gxpEZK7b" --> <h1 id="2-基本语法"><a class="markdownIt-Anchor" href="#2-基本语法"></a> 2 基本语法::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT<br>字段列表<br>FROM<br>表名列表<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></tbody></table></figure><p>我们在讲解这部分内容的时候，会将上面的完整语法进行拆分，分为以下几个部分：</p><ul><li>基本查询（不带任何条件）</li><li>条件查询(where)</li><li>聚合函数(count、 max、 min、 avg、 sum)</li><li>分组查询 (group by)</li><li>排序查询 (order by)</li><li>分页查询 (limit)</li></ul><h2 id="21-基础查询"><a class="markdownIt-Anchor" href="#21-基础查询"></a> 2.1 基础查询</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">查询多个字段：<br>SELECT 字段1, 字段2, 字段3, ... FROM 表名;<br><br>SELECT * FROM 表名;<br>这个命令也可以直接查看表. 相当于双击表名<br>注意 : * 号代表查询所有字段,在实际开发中尽量少用(不直观、影响效率)<br><br><br>-- 案例<br>A. 查询指定字段 name, workno, age并返回<br>select name,workno,age from emp;<br><br>B. 查询返回所有字段<br>select * from emp;<br>select id ,workno,name,gender,age,idcard,workaddress,entrydate from emp; <br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">设置别名：<br>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;<br>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; # as 可以省略<br><br>-- <br>C. 查询所有员工的工作地址,起别名<br>select workaddress as '工作地址' from emp; # 将 workaddress 表头改名为 工作地址 <br>-- as可以省略<br>select workaddress '工作地址' from emp;<br><br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">去除重复记录：<br>SELECT DISTINCT 字段列表 FROM 表名;<br>-- <br>D. 查询公司员工的上班地址有哪些(不要重复)<br>select distinct workaddress '工作地址' from emp;<br><br></code></pre></td></tr></tbody></table></figure><h2 id="22-条件查询"><a class="markdownIt-Anchor" href="#22-条件查询"></a> 2.2 条件查询</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">语法：<br>SELECT 字段列表 FROM 表名 WHERE 条件列表;<br></code></pre></td></tr></tbody></table></figure><p>条件列表</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 ||</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 年龄等于30<br>select * from employee where age = 30;<br>-- 年龄小于30<br>select * from employee where age &lt; 30;<br>-- 小于等于<br>select * from employee where age &lt;= 30;<br>-- 💡没有身份证<br>select * from employee where idcard is null or idcard = '';<br>-- 有身份证<br>select * from employee where idcard;<br>select * from employee where idcard is not null;<br>-- 不等于<br>select * from employee where age != 30;<br>-- 💡年龄在20到30之间<br>select * from employee where age between 20 and 30;<br>select * from employee where age &gt;= 20 &amp;&amp; age &lt;= 30;<br>-- 下面语句不报错，但查不到任何信息<br>select * from employee where age between 30 and 20;<br>-- 性别为女且年龄小于30<br>select * from employee where age &lt; 30 and gender = '女';<br>-- 💡年龄等于25或30或35<br>select * from employee where age = 25 or age = 30 or age = 35;<br>select * from employee where age in (25, 30, 35);<br>-- 💡姓名为两个字<br>select * from employee where name like '__';<br>-- 💡身份证最后为X<br>select * from employee where idcard like '%X';<br></code></pre></td></tr></tbody></table></figure><h2 id="23-聚合查询聚合函数"><a class="markdownIt-Anchor" href="#23-聚合查询聚合函数"></a> 2.3 聚合查询(聚合函数)</h2><p><strong>定义: 将一列数据作为一个整体,进行纵向计算 。</strong></p><p>常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">语法：<br>SELECT 聚合函数(字段列表) FROM 表名;<br>-- 注意 : NULL值是不参与所有聚合函数运算的<br><br>-- count：<br><br>SELECT count(id) from emp where workaddress = '北京';-- 统计所有北京id的个数<br>select count(*) from emp; -- 统计的是总记录数<br>select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数<br><br>对于count聚合函数,统计符合条件的总记录数,还可以通过 count(数字/字符串)的形式进行统计查询,比如: <br>select count(1) from emp;<br>对于count(*) 、count(字段)、 count(1) 的具体原理,我们在进阶篇中SQL优化部分会详细讲解,此处大家只需要知道如何使用即可。<br><br>-- max(min, avg同理)<br>统计该企业员工的最大年龄<br>select max(age) from emp;<br><br>-- sum:<br>统计西安地区员工的年龄之和<br>select sum(age) from emp where workaddress = '西安';<br><br></code></pre></td></tr></tbody></table></figure><h2 id="24-分组查询"><a class="markdownIt-Anchor" href="#24-分组查询"></a> 2.4 分组查询</h2><p>分组通常和聚合一起使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">语法：<br>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]- 案例<br>![[DQL 2022-10-07 02.43.47.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsAFulek30agKeIv1dOd1Ny" --> <p>where与having区别::</p><ul><li>执行时机不同:<ul><li>where是分组之前进行过滤,不满足where条件,不参与分组;💡where 是前提</li><li>而having是分组之后对结果进行过滤。</li></ul></li><li>判断条件不同:<ul><li>where不能对聚合函数进行判断,而having可以。</li></ul></li></ul><!-- basicblock-end --><blockquote><p>[!tip]<br>![[DQL 2022-10-07 02.59.44.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obsx03wDUvDEnWDoItJOZ7Pe" --> <h2 id="25-排序查询"><a class="markdownIt-Anchor" href="#25-排序查询"></a> 2.5 排序查询::</h2><p>排序在日常开发中是非常常见的一个操作,有升序排序,也有降序排序。<br>eg: 淘宝价格排序</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"># 语法<br>SELECT  字段列表  FROM   表名  ORDER  BY  字段1  排序方式1 , 字段2  排序方式2 ;<br># 排序方式<br>ASC : 升序(默认值) <br>DESC: 降序<br># 注意事项: <br>• 如果是升序, 可以不指定排序方式ASC ;  <br>• 如果是多字段排序,当第一个字段值相同时,才会根据第二个字段进行排序 ;<br><br><br>-- 案例<br>根据年龄对公司的员工进行升序排序<br>select * from emp order by age asc; <br>select * from emp order by age;<br><br><br>根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序<br>select * from emp order by age asc , entrydate desc;<br><br><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obsqfr0rzmpvORolDToWT60z" --> <h2 id="26-分页查询"><a class="markdownIt-Anchor" href="#26-分页查询"></a> 2.6 分页查询::</h2><!-- basicblock-end --><p>分页操作在业务系统开发时,也是非常常见的一个功能,我们在网站中看到的各种各样的分页条,后台都需要借助于数据库的分页操作。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210071508398.png" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"># 语法: 💡能够限制查询数<br>SELECT  字段列表  FROM   表名  LIMIT  起始索引, 查询记录数 ;<br># 注意事项:  <br>• 起始索引从0开始,起始索引 = (查询页码 - 1)* 每页显示记录数。# 相当于按记录数来起始<br>• 分页查询是数据库的方言,不同的数据库有不同的实现,MySQL中是LIMIT。<br>• 如果查询的是第一页数据,起始索引可以省略,直接简写为 limit 10。<br><br>-- 案例<br>A. 查询第1页员工数据, 每页展示10条记录<br>select * from emp limit 0,10; <br>select * from emp limit 10;<br><br><br>B. 查询第2页员工数据, 每页展示10条记录 --------&gt; (页码-1)*页展示记录数 = 1 * 10 <br># 💡相当于按记录数来起始: 第一页有 10 条记录, 从第二页开始查, 就是从记录数 10 开始查<br>select * from emp limit 10,10;<br><br><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObskIkHplz73dK7EUtpoKEjy" --> <h1 id="3-总案例"><a class="markdownIt-Anchor" href="#3-总案例"></a> 3 总案例::</h1><!-- basicblock-end --><blockquote><p>[!example]-<br>![[DQL 2022-10-07 15.36.01.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsoJKtlaO7cvK1kw4H9puqc" --> <h1 id="4-执行顺序"><a class="markdownIt-Anchor" href="#4-执行顺序"></a> 4 执行顺序::</h1><!-- basicblock-end --><p>![[DQL 2022-10-07 15.48.57.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsCelZnX9SL1a3qahScdRDo" deck = "👨🏻‍💻code::MySQL::基础篇::DQL.md" --> <p>#历史记录:: <a href="marginnote3app://note/EEC18942-1567-4B4E-AE11-3CD513BFBE88">margin: DQL</a><br>2022/10/7🌵DQL : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.2 DML</title>
      <link href="/posts/14676/"/>
      <url>/posts/14676/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!summary] DML<br>英文全称是Data Manipulation Language(数据操作语言），用来对数据库中表的数据记录进行增、删、改操作。</p></blockquote><ul><li>添加数据（INSERT)</li><li>修改数据 (UPDATE)</li><li>删除数据（DELETE)</li></ul><!-- basicblock-start oid="ObsSzVypfmDOr4iQmq0T5uV6" --> <h1 id="1-添加数据"><a class="markdownIt-Anchor" href="#1-添加数据"></a> 1 添加数据::</h1><!-- basicblock-end --><p>注意事项：<br>插入数据时，指定的字段顺序需要与值的顺序是—一对应的。<br><strong>字符串和日期型数据应该包含在引号中。</strong><br>插入的数据大小，应该在字段的规定范围内。</p><h2 id="11-给指定字段添加数据"><a class="markdownIt-Anchor" href="#11-给指定字段添加数据"></a> 1.1 给指定字段添加数据：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">INSERT INTO 表名 (字段名1, 字段名2, ...)  VALUES (值1, 值2, ...);<br>-- <br>insert into employee(id,workno,name,gender,age,idcard,entrydate) values(1,'1','Itcast','男',10,'123456789012345678','2000-01-01');<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>![[DML 2022-10-06 00.31.52.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obs7vkqGj6BjNM7ZXOd8u542" --> <p>插入数据完成之后,我们有两种方式,查询数据库的数据::<br>方式一: 在左侧的表名上双击,就可以查看这张表的数据。</p><p>方式二: 可以直接一条查询数据的SQL语句, 语句如下:<br>select * from employee;</p><blockquote><p>[!example]-<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210070048690.png" alt=""></p></blockquote><!-- basicblock-end --><h2 id="12-给全部字段添加数据"><a class="markdownIt-Anchor" href="#12-给全部字段添加数据"></a> 1.2 给全部字段添加数据：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">INSERT INTO 表名 VALUES (值1, 值2, ...);<br><br>案例:插入数据到employee表,具体的SQL如下:<br>insert into employee values(2,'2','张无忌','男',18,'123456789012345670','2005-0101'); # 不需要()中的字段了<br><br></code></pre></td></tr></tbody></table></figure><h2 id="13-批量添加数据"><a class="markdownIt-Anchor" href="#13-批量添加数据"></a> 1.3 批量添加数据：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">批量添加给制定字段<br>INSERT INTO 表名 (字段名1, 字段名2, ...)  VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;<br>批量添加给全部字段<br>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;<br><br>案例:批量插入数据到employee表,具体的SQL如下:<br>insert into employee values<br>(3,'3','韦一笑','男',38,'123456789012345670','2005-0101'),<br>(4,'4','赵敏','女',18,'123456789012345670','2005-01-01');<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs8cyQf2o4QM3YCJiUxOTOY" --> <h1 id="2-修改和删除数据"><a class="markdownIt-Anchor" href="#2-修改和删除数据"></a> 2 修改和删除数据::</h1><!-- basicblock-end --><h2 id="21-修改"><a class="markdownIt-Anchor" href="#21-修改"></a> 2.1 修改</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">修改数据：<br>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];<br><br>-- 案例<br>-- 修改id为1的数据, 将name修改为小昭, gender修改为 女<br>update employee set name = '小昭' , gender = '女' where id = 1;<br><br>-- 将所有的员工入职日期修改为 2008-01-01<br>update employee set entrydate = '2008-01-01';<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!summary] 注意事项:  修改语句的条件可以有,也可以没有,如果没有条件,则会修改整张表的所有数据。</p></blockquote><h2 id="22-删除"><a class="markdownIt-Anchor" href="#22-删除"></a> 2.2 删除</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">删除数据：<br>DELETE FROM 表名 [ WHERE 条件 ];<br><br>1. 删除gender为女的员工<br>delete from employee where gender = '女';<br>2. 删除所有员工<br>delete from employee;<br><br></code></pre></td></tr></tbody></table></figure><p>注意事项:</p><ul><li>DELETE 语句的条件可以有,也可以没有,如果没有条件,则会删除整张表的所有数据。</li></ul><ul><li>&amp; DELETE 语句不能删除某一个字段的值(可以使用UPDATE,将该字段值置为NULL即可)。</li><li>当进行删除全部数据操作时,datagrip会提示我们,询问是否确认删除,我们直接点击Execute即可。</li><li>drop table if exists employee; 这条语句也行<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210070119528.png" alt="|900"></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2SZz0uCEihdZdGnNfEkXe" deck = "👨🏻‍💻code::MySQL::基础篇::DML.md" --> <p>#历史记录:: <a href="marginnote3app://note/2D1CA3EB-60E9-4BA1-92C6-AB4674C7D92D">margin: DML</a><br>2022/10/5🌵DML : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 图形化操作工具</title>
      <link href="/posts/30270/"/>
      <url>/posts/30270/</url>
      
        <content type="html"><![CDATA[<p>data grip</p><p><a href="marginnote3app://note/5FA7E791-08D2-4EF2-A742-AB7884CFF7CB">margin: 2.4 图形化界面工具</a></p><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=11&amp;spm_id_from=pageDriver&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">11. 基础-SQL-图形化界面工具DataGrip_哔哩哔哩_bilibili</a></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsi2gVkNNr6eS7FWSW1PDay" deck = "👨🏻‍💻code::MySQL::基础篇::MySQL 图形化操作工具.md" --> <p>#历史记录::<br>2022/10/5🌵MySQL 图形化操作工具 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DDL-表操作-修改&amp;删除</title>
      <link href="/posts/26414/"/>
      <url>/posts/26414/</url>
      
        <content type="html"><![CDATA[<h1 id="1-添加字段"><a class="markdownIt-Anchor" href="#1-添加字段"></a> 1 添加字段::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];<br>案例：<br>为emp表增加一个新的字段 呢称 : 为nickname，类型为varchar(20)<br>alter table emp ADD nickname varchar (20) COMMENT，呢称，；<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsEPYP6en8so87Bb2o3YYnq" --> <!-- basicblock-start oid="ObsEPYP6en8so87Bb2o3YYnq" --> <h1 id="2-修改数据类型"><a class="markdownIt-Anchor" href="#2-修改数据类型"></a> 2 修改数据类型::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改数据类型：<br>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs4Qhv8cRddg7YOgtRrXpXt" --> <h1 id="3-修改字段和字段类型"><a class="markdownIt-Anchor" href="#3-修改字段和字段类型"></a> 3 修改字段和字段类型::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>修改字段名和字段类型：<br>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];<br>#<br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br>alter table emp change nickname username varchar(30) COMMENT '昵称';<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsEx6mhl6Nih38kQhXu9QZW" --> <h1 id="4-删除字段"><a class="markdownIt-Anchor" href="#4-删除字段"></a> 4 删除字段::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">删除字段：<br>ALTER TABLE 表名 DROP 字段名;<br><br># eg: 将emp表的字段username删除<br>ALTER TABLE emp DROP username;<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObslYiVBRubh2Xu4AcKHHsWR" --> <h1 id="5-修改表名"><a class="markdownIt-Anchor" href="#5-修改表名"></a> 5 修改表名::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改表名:<br>ALTER TABLE 表名 RENAME TO 新表名<br><br>将emp表的表名修改为 employee<br>ALTER TABLE emp RENAME TO employee;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsdtkXxi394Beuu4GDjvoFZ" --> <h1 id="6-删除表"><a class="markdownIt-Anchor" href="#6-删除表"></a> 6 删除表::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>1️⃣删除表：<br>DROP TABLE [IF EXISTS] 表名;<br>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作（如果不加该参数项，删除一张不存在的表，执行将会报错）。<br>案例：<br>如果tb_user表存在，则删除tb_user表<br><br>-- <br>2️⃣删除表，并重新创建该表：<br>TRUNCATE TABLE 表名;<br><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!tip] 注意: 在删除表的时候,表中的全部数据也都会被删除。</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRggLLZfhMOUfXK3sobeh5" deck = "👨🏻‍💻code::MySQL::基础篇::DDL-表操作-修改&删除.md" --> <p>#历史记录::<br>2022/10/5🌵DDL-表操作-修改&amp;删除 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DDL-表操作 - 数据类型及案例</title>
      <link href="/posts/56597/"/>
      <url>/posts/56597/</url>
      
        <content type="html"><![CDATA[<p>MySQL中的数据类型有很多,主要分为三类:数值类型、字符串类型、日期时间类型。</p><!-- basicblock-start oid="ObsV1tJOlEWjOZFU9KuxKF5E" --> <h1 id="1-数值型"><a class="markdownIt-Anchor" href="#1-数值型"></a> 1 数值型::</h1><!-- basicblock-end --><p>![[表操作-数值类型.excalidraw]]</p><!-- basicblock-start oid="Obs9FCdm1BRgvwo3ijuMKtyi" --> <h1 id="2-字符串类型"><a class="markdownIt-Anchor" href="#2-字符串类型"></a> 2 字符串类型::</h1><!-- basicblock-end --><p>![[表操作-字符串类型.excalidraw]]</p><!-- basicblock-start oid="ObsQCAj6WFSDP2zXKXK3YpES" --> <h1 id="3-日期时间类型"><a class="markdownIt-Anchor" href="#3-日期时间类型"></a> 3 日期时间类型::</h1><!-- basicblock-end --><p>![[表操作-日期时间类型.excalidraw]]</p><!-- basicblock-start oid="Obsq5ot6Un6FchfJzaDCHOWU" --> <h1 id="4-表操作-案例"><a class="markdownIt-Anchor" href="#4-表操作-案例"></a> 4 表操作-案例::</h1><!-- basicblock-end --> ^voh3gu<p>![[表操作 - 数据类型及案例 2022-10-05 21.24.45.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZX7NTl4oh0tX2XVxpa9Ou" deck = "👨🏻‍💻code::MySQL::基础篇::表操作 - 数据类型及案例.md" --> <p>#历史记录::<a href="marginnote3app://note/2C94BB82-06C3-46AA-8B87-716BE2DB0177">margin: 表操作-数据类型</a></p><p>2022/10/5🌵表操作 - 数据类型及案例 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.1 DDL</title>
      <link href="/posts/26898/"/>
      <url>/posts/26898/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!summary] DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</p></blockquote><!-- basicblock-start oid="Obs6fFAKH8lvhhpaeHmbYfkV" --> <h1 id="1-数据库操作"><a class="markdownIt-Anchor" href="#1-数据库操作"></a> 1 数据库操作::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询所有数据库：<br>SHOW DATABASES;: 中间有一个空格<br><br>查询当前使用的数据库：<br>SELECT DATABASE();<br><br>创建数据库：<br>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];<br><br>删除数据库：<br>DROP DATABASE [ IF EXISTS ] 数据库名;<br># drop database test;🌵drop database if exists test;<br><br>使用(切换)数据库：<br>USE 数据库名;<br></code></pre></td></tr></tbody></table></figure><h2 id="11-创建数据库"><a class="markdownIt-Anchor" href="#11-创建数据库"></a> 1.1 创建数据库：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs MySQl">CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];<br><br>-- eg:<br><br>- create database test;<br>- create database if not exists test; <br>- create database test default charset utf8mb4;<br>不推荐使用 UTF8 字符集<br>因为UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsRRkazYjRl96V95qa6PPNe" --> <h1 id="2-表操作"><a class="markdownIt-Anchor" href="#2-表操作"></a> 2 表操作 ::</h1><!-- basicblock-end --><blockquote><p>[!example]- DDL表操作案例.<br>![[DDL表操作 案例.excalidraw]]</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询当前数据库所有表：<br>SHOW TABLES;<br># use sys; show tables; // 查看系统数据库的所有表<br><br>查询表结构：💡内容没有那个详细<br>DESC 表名;<br><br>查询指定表的建表语句: 💡内容详细<br>SHOW CREATE TABLE 表名;<br></code></pre></td></tr></tbody></table></figure><p>创建表：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段1 字段1类型 [COMMENT 字段1注释],# 中括号内代表可选参数<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br></code></pre></td></tr></tbody></table></figure><p><strong>最后一个字段后面没有逗号</strong></p><h2 id="21-ddl-表操作-数据类型及案例"><a class="markdownIt-Anchor" href="#21-ddl-表操作-数据类型及案例"></a> 2.1 [[DDL-表操作 - 数据类型及案例]]</h2><h2 id="22-ddl-表操作-修改删除"><a class="markdownIt-Anchor" href="#22-ddl-表操作-修改删除"></a> 2.2 [[DDL-表操作-修改&amp;删除]]</h2><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsudejHcETZsM9AaCMqkhJf" deck = "👨🏻‍💻code::MySQL::基础篇::DDL.md" --> <p>#历史记录::<br>2022/10/5🌵DDL : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2. SQL通用语法及分类</title>
      <link href="/posts/34318/"/>
      <url>/posts/34318/</url>
      
        <content type="html"><![CDATA[<h1 id="1-sql通用语句"><a class="markdownIt-Anchor" href="#1-sql通用语句"></a> 1 SQL通用语句::</h1><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释：<br>单行注释：–注释内容 或＃注释内容(MySQL特有）<br>多行注释：<code>/*注释内容*/</code></li></ol><!-- basicblock-end --><!-- basicblock-start oid="ObsMSURpGzRBpaCc3MzzNkDe" --> <h1 id="2-sql-分类"><a class="markdownIt-Anchor" href="#2-sql-分类"></a> 2 SQL 分类::</h1><ul><li>[[2.1 DDL]]: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>[[2.2 DML]]: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>[[2.3 DQL]]: 数据查询语言，用来查询数据库中表的记录</li><li>[[2.4 DCL]]: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><blockquote><p>[!cite]<br>DDL: Data <strong>Definition</strong> Language<br>DML:  Data <strong>Manipulation</strong> Language<br>DOL:  Data <strong>Query</strong> Language<br>DCL:  Data <strong>Control</strong> Language</p></blockquote><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyzEnmazQgB5WqxrI0IPlx" deck = "👨🏻‍💻code::MySQL::基础篇::SQL通用语法及分类.md" --> <p>#历史记录::<br>2022/10/5🌵SQL通用语法及分类 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 安装与配置</title>
      <link href="/posts/11270/"/>
      <url>/posts/11270/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1N64y1s7fw/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">软件安装｜macOS下超详细的MySQL安装_哔哩哔哩_bilibili</a></p><h1 id="1-下载"><a class="markdownIt-Anchor" href="#1-下载"></a> 1 下载</h1><p>去官网下 arm64 版本<br>下完按照提示下一步下一步就行</p><h1 id="2-配置"><a class="markdownIt-Anchor" href="#2-配置"></a> 2 配置</h1><!-- basicblock-start oid="ObstNeeUBUyW9KUUemQInMli" --> <p><a href="https://www.bilibili.com/video/BV1N64y1s7fw/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=213.693476">03:33</a>添加环境变量::</p><p>在 .bash_profile文件中</p><p>目的是让 MySQL 的命令能够在任意路径下的终端下使用, 如果不添加环境变量只能在 MySQL 安装目录下的终端下使用<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210051716228.png" alt=""></p><!-- basicblock-end --><!-- basicblock-start oid="ObsuQtl7k0szWEO5xa12fv3h" --> <p><a href="https://www.bilibili.com/video/BV1N64y1s7fw/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=335.373534">05:35</a><br>使环境变量中的命令变得长期生效, 如果不配置的话, 关机后再开机还要运行一遍: source .bash_profile<br>::<br>配置 .zshrc 文件<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210051713212.png" alt=""></p><blockquote><p>[!bug] 发现 添加这条命令后, 终端的命令用不了了, 我还是删了</p></blockquote><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsoljPDRz9JABikOh9QF4Es" deck = "👨🏻‍💻code::MySQL::基础篇::MySQL 安装与配置.md" --> <p>#历史记录::<br>2022/10/5🌵MySQL 安装与配置 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>完整笔记</title>
      <link href="/posts/60667/"/>
      <url>/posts/60667/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础篇"><a class="markdownIt-Anchor" href="#1-基础篇"></a> 1 基础篇</h1><h2 id="11-通用语法及分类"><a class="markdownIt-Anchor" href="#11-通用语法及分类"></a> 1.1 通用语法及分类</h2><ul><li><p>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</p></li><li><p>DML: 数据操作语言，用来对数据库表中的数据进行增删改</p></li><li><p>DQL: 数据查询语言，用来查询数据库中表的记录</p></li><li><p>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</p></li></ul><h3 id="111-ddl数据定义语言"><a class="markdownIt-Anchor" href="#111-ddl数据定义语言"></a> 1.1.1 DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="1111-数据库操作"><a class="markdownIt-Anchor" href="#1111-数据库操作"></a> 1.1.1.1 数据库操作</h4><p>查询所有数据库: <code>SHOW DATABASES;</code> 查询当前数据库： <code>SELECT DATABASE();</code> 创建数据库： <code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code> 删除数据库: <code>DROP DATABASE [ IF EXISTS ] 数据库名;</code> 使用数据库： <code>USE 数据库名;</code></p><h5 id="11111-注意事项"><a class="markdownIt-Anchor" href="#11111-注意事项"></a> 1.1.1.1.1 注意事项</h5><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h4 id="1112-表操作"><a class="markdownIt-Anchor" href="#1112-表操作"></a> 1.1.1.2 表操作</h4><p>查询当前数据库所有表： <code>SHOW TABLES;</code> 查询表结构： <code>DESC 表名;</code> 查询指定表的建表语句： <code>SHOW CREATE TABLE 表名;</code></p><p>创建表：</p><p>CREATE TABLE 表名(<br>字段1 字段1类型 [COMMENT 字段1注释],<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>…<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];</p><p>所有的要用英文的格式 <strong>最后一个字段后面没有逗号</strong></p><p>添加字段： <code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code> 例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';</code></p><p>修改数据类型： <code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p><p>修改字段名和字段类型： <code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></p><p>例：将emp表的nickname字段修改为username，类型为varchar(30) <code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称';</code></p><p>删除字段： <code>ALTER TABLE 表名 DROP 字段名;</code></p><p>修改表名： <code>ALTER TABLE 表名 RENAME TO 新表名</code></p><p>删除表： <code>DROP TABLE [IF EXISTS] 表名;</code></p><p>删除表，并重新创建该表： <code>TRUNCATE TABLE 表名;</code></p><h3 id="112-dml数据操作语言"><a class="markdownIt-Anchor" href="#112-dml数据操作语言"></a> 1.1.2 DML（数据操作语言）</h3><h4 id="1121-添加数据"><a class="markdownIt-Anchor" href="#1121-添加数据"></a> 1.1.2.1 添加数据</h4><p>指定字段： <code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code> 全部字段： <code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p><p>批量添加数据： <code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code> <code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p><h5 id="11211-注意事项"><a class="markdownIt-Anchor" href="#11211-注意事项"></a> 1.1.2.1.1 注意事项</h5><ul><li><p>字符串和日期类型数据应该包含在引号中</p></li><li><p>插入的数据大小应该在字段的规定范围内</p></li></ul><h4 id="1122-更新和删除数据"><a class="markdownIt-Anchor" href="#1122-更新和删除数据"></a> 1.1.2.2 更新和删除数据</h4><p>修改数据： <code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code> 例： <code>UPDATE emp SET name = 'Jack' WHERE id = 1;</code></p><p>删除数据： <code>DELETE FROM 表名 [ WHERE 条件 ];</code></p><h3 id="113-dql数据查询语言"><a class="markdownIt-Anchor" href="#113-dql数据查询语言"></a> 1.1.3 DQL（数据查询语言）</h3><p>语法：</p><p>SELECT<br>字段列表<br>FROM<br>表名字段<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后的条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数</p><h4 id="1131-基础查询"><a class="markdownIt-Anchor" href="#1131-基础查询"></a> 1.1.3.1 基础查询</h4><p>查询多个字段： <code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code> <code>SELECT * FROM 表名;</code></p><p>设置别名： <code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code> <code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p><p>去除重复记录： <code>SELECT DISTINCT 字段列表 FROM 表名;</code></p><p>转义： <code>SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'</code> / 之后的_不作为通配符</p><h4 id="1132-条件查询"><a class="markdownIt-Anchor" href="#1132-条件查询"></a> 1.1.3.2 条件查询</h4><p>语法： <code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></p><p>条件：</p><p>比较运算符</p><p>功能</p><blockquote></blockquote><p>大于</p><blockquote><p>=</p></blockquote><p>大于等于</p><p>&lt;</p><p>小于</p><p>&lt;=</p><p>小于等于</p><p>=</p><p>等于</p><p>&lt;&gt; 或 !=</p><p>不等于</p><p>BETWEEN … AND …</p><p>在某个范围内（含最小、最大值）</p><p>IN(…)</p><p>在in之后的列表中的值，多选一</p><p>LIKE 占位符</p><p>模糊匹配（_匹配单个字符，%匹配任意个字符）</p><p>IS NULL</p><p>是NULL</p><p>逻辑运算符</p><p>功能</p><p>AND 或 &amp;&amp;</p><p>并且（多个条件同时成立）</p><p>OR 或 ||</p><p>或者（多个条件任意一个成立）</p><p>NOT 或 !</p><p>非，不是</p><p>例子：</p><p>– 年龄等于30<br>select * from employee where age = 30;<br>– 年龄小于30<br>select * from employee where age &lt; 30;<br>– 小于等于<br>select * from employee where age &lt;= 30;<br>– 没有身份证<br>select * from employee where idcard is null or idcard = ‘’;<br>– 有身份证<br>select * from employee where idcard;<br>select * from employee where idcard is not null;<br>– 不等于<br>select * from employee where age != 30;<br>– 年龄在20到30之间<br>select * from employee where age between 20 and 30;<br>select * from employee where age &gt;= 20 and age &lt;= 30;<br>– 下面语句不报错，但查不到任何信息<br>select * from employee where age between 30 and 20;<br>– 性别为女且年龄小于30<br>select * from employee where age &lt; 30 and gender = ‘女’;<br>– 年龄等于25或30或35<br>select * from employee where age = 25 or age = 30 or age = 35;<br>select * from employee where age in (25, 30, 35);<br>– 姓名为两个字<br>select * from employee where name like ‘__’;<br>– 身份证最后为X<br>select * from employee where idcard like ‘%X’;</p><h4 id="1133-聚合查询聚合函数"><a class="markdownIt-Anchor" href="#1133-聚合查询聚合函数"></a> 1.1.3.3 聚合查询（聚合函数）</h4><p>常见聚合函数：</p><p>函数</p><p>功能</p><p>count</p><p>统计数量</p><p>max</p><p>最大值</p><p>min</p><p>最小值</p><p>avg</p><p>平均值</p><p>sum</p><p>求和</p><p>语法： <code>SELECT 聚合函数(字段列表) FROM 表名;</code> 例： <code>SELECT count(id) from employee where workaddress = "广东省";</code></p><h4 id="1134-分组查询"><a class="markdownIt-Anchor" href="#1134-分组查询"></a> 1.1.3.4 分组查询</h4><p>语法： <code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></p><p>where 和 having 的区别：</p><ul><li><p>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</p></li><li><p>判断条件不同：where不能对聚合函数进行判断，而having可以。</p></li></ul><p>例子：</p><p>– 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）<br>select count(<em>) from employee group by gender;<br>– 根据性别分组，统计男性和女性数量<br>select gender, count(</em>) from employee group by gender;<br>– 根据性别分组，统计男性和女性的平均年龄<br>select gender, avg(age) from employee group by gender;<br>– 年龄小于45，并根据工作地址分组<br>select workaddress, count(<em>) from employee where age &lt; 45 group by workaddress;<br>– 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址<br>select workaddress, count(</em>) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;</p><h5 id="11341-注意事项"><a class="markdownIt-Anchor" href="#11341-注意事项"></a> 1.1.3.4.1 注意事项</h5><ul><li><p>执行顺序：where &gt; 聚合函数 &gt; having</p></li><li><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</p></li></ul><h4 id="1135-排序查询"><a class="markdownIt-Anchor" href="#1135-排序查询"></a> 1.1.3.5 排序查询</h4><p>语法： <code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></p><p>排序方式：</p><ul><li><p>ASC: 升序（默认）</p></li><li><p>DESC: 降序</p></li></ul><p>例子：</p><p>– 根据年龄升序排序<br>SELECT * FROM employee ORDER BY age ASC;<br>SELECT * FROM employee ORDER BY age;<br>– 两字段排序，根据年龄升序排序，入职时间降序排序(如果年龄相同那么就按这个)<br>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;</p><h5 id="11351-注意事项"><a class="markdownIt-Anchor" href="#11351-注意事项"></a> 1.1.3.5.1 注意事项</h5><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h4 id="1136-分页查询"><a class="markdownIt-Anchor" href="#1136-分页查询"></a> 1.1.3.6 分页查询</h4><p>语法： <code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></p><p>例子：</p><p>– 查询第一页数据，展示10条<br>SELECT * FROM employee LIMIT 0, 10;<br>– 查询第二页<br>SELECT * FROM employee LIMIT 10, 10;</p><h5 id="11361-注意事项"><a class="markdownIt-Anchor" href="#11361-注意事项"></a> 1.1.3.6.1 注意事项</h5><ul><li><p>起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数</p></li><li><p>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</p></li><li><p>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</p></li></ul><h4 id="1137-dql执行顺序"><a class="markdownIt-Anchor" href="#1137-dql执行顺序"></a> 1.1.3.7 DQL执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h3 id="114-dcl"><a class="markdownIt-Anchor" href="#114-dcl"></a> 1.1.4 DCL</h3><h4 id="1141-管理用户"><a class="markdownIt-Anchor" href="#1141-管理用户"></a> 1.1.4.1 管理用户</h4><p>查询用户：</p><p>USER mysql;<br>SELECT * FROM user;</p><p>创建用户: <code>CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';</code></p><p>修改用户密码： <code>ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';</code></p><p>删除用户： <code>DROP USER '用户名'@'主机名';</code></p><p>例子：</p><p>– 创建用户test，只能在当前主机localhost访问<br>create user ‘test’@‘localhost’ identified by ‘123456’;<br>– 创建用户test，能在任意主机访问<br>create user ‘test’@’%’ identified by ‘123456’;<br>create user ‘test’ identified by ‘123456’;<br>– 修改密码<br>alter user ‘test’@‘localhost’ identified with mysql_native_password by ‘1234’;<br>– 删除用户<br>drop user ‘test’@‘localhost’;</p><h5 id="11411-注意事项"><a class="markdownIt-Anchor" href="#11411-注意事项"></a> 1.1.4.1.1 注意事项</h5><ul><li>主机名可以使用 % 通配</li></ul><h4 id="1142-权限控制"><a class="markdownIt-Anchor" href="#1142-权限控制"></a> 1.1.4.2 权限控制</h4><p>常用权限：</p><p>权限</p><p>说明</p><p>ALL, ALL PRIVILEGES</p><p>所有权限</p><p>SELECT</p><p>查询数据</p><p>INSERT</p><p>插入数据</p><p>UPDATE</p><p>修改数据</p><p>DELETE</p><p>删除数据</p><p>ALTER</p><p>修改表</p><p>DROP</p><p>删除数据库/表/视图</p><p>CREATE</p><p>创建数据库/表</p><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><p>查询权限： <code>SHOW GRANTS FOR '用户名'@'主机名';</code></p><p>授予权限： <code>GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';</code></p><p>撤销权限： <code>REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';</code></p><h5 id="11421-注意事项"><a class="markdownIt-Anchor" href="#11421-注意事项"></a> 1.1.4.2.1 注意事项</h5><ul><li><p>多个权限用逗号分隔</p></li><li><p>授权时，数据库名和表名可以用 * 进行通配，代表所有</p></li></ul><h2 id="12-函数"><a class="markdownIt-Anchor" href="#12-函数"></a> 1.2 函数</h2><p>函数 是指一段可以直接被另外一段程序调用的程序或代码。</p><ul><li><p>字符串函数</p></li><li><p>数值函数</p></li><li><p>日期函数</p></li><li><p>流程函数</p></li></ul><h3 id="121-字符串函数"><a class="markdownIt-Anchor" href="#121-字符串函数"></a> 1.2.1 字符串函数</h3><p>常用函数：</p><p>函数</p><p>功能</p><p>CONCAT(s1, s2, …, sn)</p><p>字符串拼接，将s1, s2, …, sn拼接成一个字符串</p><p>LOWER(str)</p><p>将字符串全部转为小写</p><p>UPPER(str)</p><p>将字符串全部转为大写</p><p>LPAD(str, n, pad)</p><p>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</p><p>RPAD(str, n, pad)</p><p>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</p><p>TRIM(str)</p><p>去掉字符串头部和尾部的空格</p><p>SUBSTRING(str, start, len)</p><p>返回从字符串str从start位置起的len个长度的字符串</p><p>使用示例：</p><p>– 拼接<br>SELECT CONCAT(‘Hello’, ‘World’);<br>– 小写<br>SELECT LOWER(‘Hello’);<br>– 大写<br>SELECT UPPER(‘Hello’);<br>– 左填充<br>SELECT LPAD(‘01’, 5, ‘-’);<br>– 右填充<br>SELECT RPAD(‘01’, 5, ‘-’);<br>– 去除空格<br>SELECT TRIM(’ Hello World ');<br>– 切片（起始索引为1）<br>SELECT SUBSTRING(‘Hello World’, 1, 5);</p><h3 id="122-数值函数"><a class="markdownIt-Anchor" href="#122-数值函数"></a> 1.2.2 数值函数</h3><p>常见函数：</p><p>函数</p><p>功能</p><p>CEIL(x)</p><p>向上取整</p><p>FLOOR(x)</p><p>向下取整</p><p>MOD(x, y)</p><p>返回x/y的模</p><p>RAND()</p><p>返回0~1内的随机数</p><p>ROUND(x, y)</p><p>求参数x的四舍五入值，保留y位小数</p><h3 id="123-日期函数"><a class="markdownIt-Anchor" href="#123-日期函数"></a> 1.2.3 日期函数</h3><p>常用函数：</p><p>函数</p><p>功能</p><p>CURDATE()</p><p>返回当前日期</p><p>CURTIME()</p><p>返回当前时间</p><p>NOW()</p><p>返回当前日期和时间</p><p>YEAR(date)</p><p>获取指定date的年份</p><p>MONTH(date)</p><p>获取指定date的月份</p><p>DAY(date)</p><p>获取指定date的日期</p><p>DATE_ADD(date, INTERVAL expr type)</p><p>返回一个日期/时间值加上一个时间间隔expr后的时间值</p><p>DATEDIFF(date1, date2)</p><p>返回起始时间date1和结束时间date2之间的天数</p><p>例子：</p><p>– DATE_ADD<br>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</p><h3 id="124-流程函数"><a class="markdownIt-Anchor" href="#124-流程函数"></a> 1.2.4 流程函数</h3><p>常用函数：</p><p>函数</p><p>功能</p><p>IF(value, t, f)</p><p>如果value为true，则返回t，否则返回f</p><p>IFNULL(value1, value2)</p><p>如果value1不为空，返回value1，否则返回value2</p><p>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</p><p>如果val1为true，返回res1，… 否则返回default默认值</p><p>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</p><p>如果expr的值等于val1，返回res1，… 否则返回default默认值</p><p>例子：</p><p>select<br>name,<br>(case when age &gt; 30 then ‘中年’ else ‘青年’ end)<br>from employee;<br>select<br>name,<br>(case workaddress when ‘北京市’ then ‘一线城市’ when ‘上海市’ then ‘一线城市’ else ‘二线城市’ end) as ‘工作地址’<br>from employee;</p><h2 id="13-约束"><a class="markdownIt-Anchor" href="#13-约束"></a> 1.3 约束</h2><ol><li><p>概念：约束是用来作用于表中字段上的规则，用于限制存储在表中的数据。</p></li><li><p>目的：保证数据库中的数据的正确、有效性和完整性</p></li></ol><p>分类：</p><p>约束</p><p>描述</p><p>关键字</p><p>非空约束</p><p>限制该字段的数据不能为null</p><p>NOT NULL</p><p>唯一约束</p><p>保证该字段的所有数据都是唯一、不重复的</p><p>UNIQUE</p><p>主键约束</p><p>主键是一行数据的唯一标识，要求非空且唯一</p><p>PRIMARY KEY</p><p>默认约束</p><p>保存数据时，如果未指定该字段的值，则采用默认值</p><p>DEFAULT</p><p>检查约束（8.0.1版本后）</p><p>保证字段值满足某一个条件</p><p>CHECK</p><p>外键约束</p><p>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</p><p>FOREIGN KEY</p><p>约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p><h3 id="131-常用约束"><a class="markdownIt-Anchor" href="#131-常用约束"></a> 1.3.1 常用约束</h3><p>约束条件</p><p>关键字</p><p>主键</p><p>PRIMARY KEY</p><p>自动增长</p><p>AUTO_INCREMENT</p><p>不为空</p><p>NOT NULL</p><p>唯一</p><p>UNIQUE</p><p>逻辑条件</p><p>CHECK</p><p>默认值</p><p>DEFAULT</p><p>例子：</p><p>create table user(<br>id int primary key auto_increment,<br>name varchar(10) not null unique,<br>age int check(age &gt; 0 and age &lt; 120),<br>status char(1) default ‘1’,<br>gender char(1)<br>);</p><h3 id="132-外键约束"><a class="markdownIt-Anchor" href="#132-外键约束"></a> 1.3.2 外键约束</h3><p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p>添加外键：</p><p>CREATE TABLE 表名(<br>字段名 字段类型,<br>…<br>[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)<br>); &nbsp;<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);<br>​<br>– 例子 &nbsp;<br>alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);</p><p>删除外键： <code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="1321-删除更新行为"><a class="markdownIt-Anchor" href="#1321-删除更新行为"></a> 1.3.2.1 删除/更新行为</h4><p>行为</p><p>说明</p><p>NO ACTION</p><p>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</p><p>RESTRICT</p><p>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</p><p>CASCADE</p><p>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</p><p>SET NULL</p><p>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</p><p>SET DEFAULT</p><p>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</p><p>更改删除/更新行为： <code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p><h2 id="14-多表查询"><a class="markdownIt-Anchor" href="#14-多表查询"></a> 1.4 多表查询</h2><h3 id="141-多表关系"><a class="markdownIt-Anchor" href="#141-多表关系"></a> 1.4.1 多表关系</h3><ul><li><p>一对多（多对一）</p></li><li><p>多对多</p></li><li><p>一对一</p></li></ul><h4 id="1411-一对多"><a class="markdownIt-Anchor" href="#1411-一对多"></a> 1.4.1.1 一对多</h4><p>案例：部门与员工 关系：一个部门对应多个员工，一个员工对应一个部门 实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="1412-多对多"><a class="markdownIt-Anchor" href="#1412-多对多"></a> 1.4.1.2 多对多</h4><p>案例：学生与课程 关系：一个学生可以选多门课程，一门课程也可以供多个学生选修 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="1413-一对一"><a class="markdownIt-Anchor" href="#1413-一对一"></a> 1.4.1.3 一对一</h4><p>案例：用户与用户详情 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="142-查询"><a class="markdownIt-Anchor" href="#142-查询"></a> 1.4.2 查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）： <code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积： <code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="143-内连接查询"><a class="markdownIt-Anchor" href="#143-内连接查询"></a> 1.4.3 内连接查询</h3><p>内连接查询的是两张表交集的部分</p><p>隐式内连接： <code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接： <code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><p>– 查询员工姓名，及关联的部门的名称<br>– 隐式<br>select <a href="http://e.name">e.name</a>, <a href="http://d.name">d.name</a> from employee as e, dept as d where e.dept = <a href="http://d.id">d.id</a>;<br>– 显式<br>select <a href="http://e.name">e.name</a>, <a href="http://d.name">d.name</a> from employee as e inner join dept as d on e.dept = <a href="http://d.id">d.id</a>;</p><h3 id="144-外连接查询"><a class="markdownIt-Anchor" href="#144-外连接查询"></a> 1.4.4 外连接查询</h3><p>左外连接： 查询左表所有数据，以及两张表交集部分数据 <code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code> 相当于查询表1的所有数据，包含表1和表2交集部分数据</p><p>右外连接： 查询右表所有数据，以及两张表交集部分数据 <code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p><p>例子：</p><p>– 左<br>select e.<em>, <a href="http://d.name">d.name</a> from employee as e left outer join dept as d on e.dept = <a href="http://d.id">d.id</a>; &nbsp;<br>select <a href="http://d.name">d.name</a>, e.</em> from dept d left outer join emp e on e.dept = <a href="http://d.id">d.id</a>; &nbsp;– 这条语句与下面的语句效果一样 &nbsp;<br>– 右<br>select <a href="http://d.name">d.name</a>, e.* from employee as e right outer join dept as d on e.dept = <a href="http://d.id">d.id</a>;</p><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="145-自连接查询"><a class="markdownIt-Anchor" href="#145-自连接查询"></a> 1.4.5 自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法： <code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><p>– 查询员工及其所属领导的名字<br>select <a href="http://a.name">a.name</a>, <a href="http://b.name">b.name</a> from employee a, employee b where a.manager = <a href="http://b.id">b.id</a>;<br>– 没有领导的也查询出来<br>select <a href="http://a.name">a.name</a>, <a href="http://b.name">b.name</a> from employee a left join employee b on a.manager = <a href="http://b.id">b.id</a>;</p><h3 id="146-联合查询-union-union-all"><a class="markdownIt-Anchor" href="#146-联合查询-union-union-all"></a> 1.4.6 联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><p>SELECT 字段列表 FROM 表A …<br>UNION [ALL]<br>SELECT 字段列表 FROM 表B …</p><h4 id="1461-注意事项"><a class="markdownIt-Anchor" href="#1461-注意事项"></a> 1.4.6.1 注意事项</h4><ul><li><p>UNION ALL 会有重复结果，UNION 不会</p></li><li><p>联合查询比使用or效率高，不会使索引失效</p></li></ul><h3 id="147-子查询"><a class="markdownIt-Anchor" href="#147-子查询"></a> 1.4.7 子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。 <code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code> <strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li><p>标量子查询（子查询结果为单个值）</p></li><li><p>列子查询（子查询结果为一列）</p></li><li><p>行子查询（子查询结果为一行）</p></li><li><p>表子查询（子查询结果为多行多列）</p></li></ul><p>根据子查询位置可分为：</p><ul><li><p>WHERE 之后</p></li><li><p>FROM 之后</p></li><li><p>SELECT 之后</p></li></ul><h4 id="1471-标量子查询"><a class="markdownIt-Anchor" href="#1471-标量子查询"></a> 1.4.7.1 标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。 常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p><p>例子：</p><p>– 查询销售部所有员工<br>select id from dept where name = ‘销售部’;<br>– 根据销售部部门ID，查询员工信息<br>select * from employee where dept = 4;<br>– 合并（子查询） &nbsp;<br>select * from employee where dept = (select id from dept where name = ‘销售部’); &nbsp;<br>​<br>– 查询xxx入职之后的员工信息 &nbsp;<br>select * from employee where entrydate &gt; (select entrydate from employee where name = ‘xxx’);</p><h4 id="1472-列子查询"><a class="markdownIt-Anchor" href="#1472-列子查询"></a> 1.4.7.2 列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><p>操作符</p><p>描述</p><p>IN</p><p>在指定的集合范围内，多选一</p><p>NOT IN</p><p>不在指定的集合范围内</p><p>ANY</p><p>子查询返回列表中，有任意一个满足即可</p><p>SOME</p><p>与ANY等同，使用SOME的地方都可以使用ANY</p><p>ALL</p><p>子查询返回列表的所有值都必须满足</p><p>例子：</p><p>– 查询销售部和市场部的所有员工信息<br>select * from employee where dept in (select id from dept where name = ‘销售部’ or name = ‘市场部’);<br>– 查询比财务部所有人工资都高的员工信息<br>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = ‘财务部’));<br>– 查询比研发部任意一人工资高的员工信息<br>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = ‘研发部’));</p><h4 id="1473-行子查询"><a class="markdownIt-Anchor" href="#1473-行子查询"></a> 1.4.7.3 行子查询</h4><p>返回的结果是一行（可以是多列）。 常用操作符：=, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><p>– 查询与xxx的薪资及直属领导相同的员工信息<br>select * from employee where (salary, manager) = (12500, 1);<br>select * from employee where (salary, manager) = (select salary, manager from employee where name = ‘xxx’);</p><h4 id="1474-表子查询"><a class="markdownIt-Anchor" href="#1474-表子查询"></a> 1.4.7.4 表子查询</h4><p>返回的结果是多行多列 常用操作符：IN</p><p>例子：</p><p>– 查询与xxx1，xxx2的职位和薪资相同的员工<br>select * from employee where (job, salary) in (select job, salary from employee where name = ‘xxx1’ or name = ‘xxx2’);<br>– 查询入职日期是2006-01-01之后的员工，及其部门信息<br>select e.<em>, d.</em> from (select * from employee where entrydate &gt; ‘2006-01-01’) as e left join dept as d on e.dept = <a href="http://d.id">d.id</a>;</p><h2 id="15-事务"><a class="markdownIt-Anchor" href="#15-事务"></a> 1.5 事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><p>– 1. 查询张三账户余额<br>select * from account where name = ‘张三’;<br>– 2. 将张三账户余额-1000<br>update account set money = money - 1000 where name = ‘张三’;<br>– 此语句出错后张三钱减少但是李四钱没有增加<br>模拟sql语句错误<br>– 3. 将李四账户余额+1000<br>update account set money = money + 1000 where name = ‘李四’;<br>​<br>– 查看事务提交方式<br>SELECT @@AUTOCOMMIT;<br>– 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效<br>SET @@AUTOCOMMIT = 0;<br>– 提交事务<br>COMMIT;<br>– 回滚事务<br>ROLLBACK;<br>​<br>– 设置手动提交后上面代码改为：<br>select * from account where name = ‘张三’; &nbsp;<br>update account set money = money - 1000 where name = ‘张三’; &nbsp;<br>update account set money = money + 1000 where name = ‘李四’; &nbsp;<br>commit;</p><p>操作方式二：</p><p>开启事务： <code>START TRANSACTION 或 BEGIN TRANSACTION;</code> 提交事务： <code>COMMIT;</code> 回滚事务： <code>ROLLBACK;</code></p><p>操作实例：</p><p>start transaction;<br>select * from account where name = ‘张三’;<br>update account set money = money - 1000 where name = ‘张三’;<br>update account set money = money + 1000 where name = ‘李四’;<br>commit;</p><p>开启事务后，只有手动提交才会改变数据库中的数据。</p><h3 id="151-四大特性acid"><a class="markdownIt-Anchor" href="#151-四大特性acid"></a> 1.5.1 四大特性ACID</h3><ul><li><p>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</p></li><li><p>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</p></li><li><p>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</p></li><li><p>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p></li></ul><h3 id="152-并发事务"><a class="markdownIt-Anchor" href="#152-并发事务"></a> 1.5.2 并发事务</h3><p>问题</p><p>描述</p><p>脏读</p><p>一个事务读到另一个事务还没提交的数据</p><p>不可重复读</p><p>一个事务先后读取同一条记录，但两次读取的数据不同</p><p>幻读</p><p>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</p><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a></p></blockquote><p>并发事务隔离级别：</p><p>隔离级别</p><p>脏读</p><p>不可重复读</p><p>幻读</p><p>Read uncommitted</p><p>√</p><p>√</p><p>√</p><p>Read committed</p><p>×</p><p>√</p><p>√</p><p>Repeatable Read(默认)</p><p>×</p><p>×</p><p>√</p><p>Serializable</p><p>×</p><p>×</p><p>×</p><ul><li><p>√表示在当前隔离级别下该问题会出现</p></li><li><p>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</p></li></ul><p>查看事务隔离级别： <code>SELECT @@TRANSACTION_ISOLATION;</code> 设置事务隔离级别： <code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };</code> SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="2-进阶篇"><a class="markdownIt-Anchor" href="#2-进阶篇"></a> 2 进阶篇</h1><h2 id="21-存储引擎"><a class="markdownIt-Anchor" href="#21-存储引擎"></a> 2.1 存储引擎</h2><p>MySQL体系结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"> <img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。 默认存储引擎是InnoDB。</p><p>相关操作：</p><p>– 查询建表语句<br>show create table account;<br>– 建表时指定存储引擎<br>CREATE TABLE 表名(<br>…<br>) ENGINE=INNODB;<br>– 查看当前数据库支持的存储引擎<br>show engines;</p><h3 id="211-innodb"><a class="markdownIt-Anchor" href="#211-innodb"></a> 2.1.1 InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li><p>DML 操作遵循 ACID 模型，支持<strong>事务</strong></p></li><li><p><strong>行级锁</strong>，提高并发访问性能</p></li><li><p>支持<strong>外键</strong>约束，保证数据的完整性和正确性</p></li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量： <code>show variables like 'innodb_file_per_table';</code></p><p>从idb文件提取表结构数据： （在cmd运行） <code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构： <img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h3 id="212-myisam"><a class="markdownIt-Anchor" href="#212-myisam"></a> 2.1.2 MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li><p>不支持事务，不支持外键</p></li><li><p>支持表锁，不支持行锁</p></li><li><p>访问速度快</p></li></ul><p>文件：</p><ul><li><p>xxx.sdi: 存储表结构信息</p></li><li><p>xxx.MYD: 存储数据</p></li><li><p>xxx.MYI: 存储索引</p></li></ul><h3 id="213-memory"><a class="markdownIt-Anchor" href="#213-memory"></a> 2.1.3 Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li><p>存放在内存中，速度快</p></li><li><p>hash索引（默认）</p></li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="214-存储引擎特点"><a class="markdownIt-Anchor" href="#214-存储引擎特点"></a> 2.1.4 存储引擎特点</h3><p>特点</p><p>InnoDB</p><p>MyISAM</p><p>Memory</p><p>存储限制</p><p>64TB</p><p>有</p><p>有</p><p>事务安全</p><p>支持</p><ul><li></li><li></li></ul><p>锁机制</p><p>行锁</p><p>表锁</p><p>表锁</p><p>B+tree索引</p><p>支持</p><p>支持</p><p>支持</p><p>Hash索引</p><ul><li></li><li></li></ul><p>支持</p><p>全文索引</p><p>支持（5.6版本之后）</p><p>支持</p><ul><li></li></ul><p>空间使用</p><p>高</p><p>低</p><p>N/A</p><p>内存使用</p><p>高</p><p>低</p><p>中等</p><p>批量插入速度</p><p>低</p><p>高</p><p>高</p><p>支持外键</p><p>支持</p><ul><li></li><li></li></ul><h3 id="215-存储引擎的选择"><a class="markdownIt-Anchor" href="#215-存储引擎的选择"></a> 2.1.5 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li><p>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</p></li><li><p>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</p></li><li><p>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</p></li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="22-性能分析"><a class="markdownIt-Anchor" href="#22-性能分析"></a> 2.2 性能分析</h2><h3 id="221-查看执行频次"><a class="markdownIt-Anchor" href="#221-查看执行频次"></a> 2.2.1 查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次： <code>SHOW GLOBAL STATUS LIKE 'Com_______';</code> 或者 <code>SHOW SESSION STATUS LIKE 'Com_______';</code> 例：<code>show global status like 'Com_______'</code></p><h3 id="222-慢查询日志"><a class="markdownIt-Anchor" href="#222-慢查询日志"></a> 2.2.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。 MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log=1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2 更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p><p>查看慢查询日志开关状态： <code>show variables like 'slow_query_log';</code></p><h3 id="223-profile"><a class="markdownIt-Anchor" href="#223-profile"></a> 2.2.3 profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作： <code>SELECT @@have_profiling;</code> profiling 默认关闭，可以通过set语句在session/global级别开启 profiling： <code>SET profiling = 1;</code> 查看所有语句的耗时： <code>show profiles;</code> 查看指定query_id的SQL语句各个阶段的耗时： <code>show profile for query query_id;</code> 查看指定query_id的SQL语句CPU的使用情况 <code>show profile cpu for query query_id;</code></p><h3 id="224-explain"><a class="markdownIt-Anchor" href="#224-explain"></a> 2.2.4 explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。 语法： # 直接在select语句之前加上关键字 explain / desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li><p>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</p></li><li><p>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</p></li><li><p>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</p></li><li><p>possible_key：可能应用在这张表上的索引，一个或多个</p></li><li><p>Key：实际使用的索引，如果为 NULL，则没有使用索引</p></li><li><p>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</p></li><li><p>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</p></li><li><p>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</p></li></ul><h2 id="23-索引"><a class="markdownIt-Anchor" href="#23-索引"></a> 2.3 索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li><p>提高数据检索效率，降低数据库的IO成本</p></li><li><p>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</p></li></ul><p>缺点：</p><ul><li><p>索引列也是要占用空间的</p></li><li><p>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</p></li></ul><h3 id="231-索引结构"><a class="markdownIt-Anchor" href="#231-索引结构"></a> 2.3.1 索引结构</h3><p>索引结构</p><p>描述</p><p>B+Tree</p><p>最常见的索引类型，大部分引擎都支持B+树索引</p><p>Hash</p><p>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</p><p>R-Tree(空间索引)</p><p>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</p><p>Full-Text(全文索引)</p><p>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</p><p>索引</p><p>InnoDB</p><p>MyISAM</p><p>Memory</p><p>B+Tree索引</p><p>支持</p><p>支持</p><p>支持</p><p>Hash索引</p><p>不支持</p><p>不支持</p><p>支持</p><p>R-Tree索引</p><p>不支持</p><p>支持</p><p>不支持</p><p>Full-text</p><p>5.6版本后支持</p><p>支持</p><p>不支持</p><h4 id="2311-b-tree"><a class="markdownIt-Anchor" href="#2311-b-tree"></a> 2.3.1.1 B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树形成链表的缺点可以用红黑树来解决： <img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"> 红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。 B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a> 演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="2312-btree"><a class="markdownIt-Anchor" href="#2312-btree"></a> 2.3.1.2 B+Tree</h4><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li><p>所有的数据都会出现在叶子节点</p></li><li><p>叶子节点形成一个单向链表</p></li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="2313-hash"><a class="markdownIt-Anchor" href="#2313-hash"></a> 2.3.1.3 Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。 如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li><p>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</p></li><li><p>无法利用索引完成排序操作</p></li><li><p>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</p></li></ul><p>存储引擎支持：</p><ul><li><p>Memory</p></li><li><p>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</p></li></ul><h4 id="2314-面试题"><a class="markdownIt-Anchor" href="#2314-面试题"></a> 2.3.1.4 面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li><p>相对于二叉树，层级更少，搜索效率高</p></li><li><p>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</p></li><li><p>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</p></li></ul><h3 id="232-索引分类"><a class="markdownIt-Anchor" href="#232-索引分类"></a> 2.3.2 索引分类</h3><p>分类</p><p>含义</p><p>特点</p><p>关键字</p><p>主键索引</p><p>针对于表中主键创建的索引</p><p>默认自动创建，只能有一个</p><p>PRIMARY</p><p>唯一索引</p><p>避免同一个表中某数据列中的值重复</p><p>可以有多个</p><p>UNIQUE</p><p>常规索引</p><p>快速定位特定数据</p><p>可以有多个</p><p>全文索引</p><p>全文索引查找的是文本中的关键词，而不是比较索引中的值</p><p>可以有多个</p><p>FULLTEXT</p><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><p>分类</p><p>含义</p><p>特点</p><p>聚集索引(Clustered Index)</p><p>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</p><p>必须有，而且只有一个</p><p>二级索引(Secondary Index)</p><p>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</p><p>可以存在多个</p><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"> <img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li><p>如果存在主键，主键索引就是聚集索引</p></li><li><p>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</p></li><li><p>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</p></li></ul><h4 id="2321-思考题"><a class="markdownIt-Anchor" href="#2321-思考题"></a> 2.3.2.1 思考题</h4><ol><li>以下 SQL 语句，哪个执行效率高？为什么？</li></ol><p>select * from user where id = 10;<br>select * from user where name = ‘Arm’;<br>– 备注：id为主键，name字段创建的有索引</p><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><ol start="2"><li>InnoDB 主键索引的 B+Tree 高度为多少？</li></ol><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8. 可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>； 如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="233-语法"><a class="markdownIt-Anchor" href="#233-语法"></a> 2.3.3 语法</h3><p>创建索引： <code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code> 如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引： <code>SHOW INDEX FROM table_name;</code></p><p>删除索引： <code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><p>– name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>– phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>– 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br>– 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br>​<br>– 删除索引 &nbsp;<br>drop index idx_user_email on tb_user;</p><h3 id="234-使用规则"><a class="markdownIt-Anchor" href="#234-使用规则"></a> 2.3.4 使用规则</h3><h4 id="2341-最左前缀法则"><a class="markdownIt-Anchor" href="#2341-最左前缀法则"></a> 2.3.4.1 最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。 如果跳跃某一列，索引将部分失效（后面的字段索引失效）。跳过的话，后面的排序就无从说起了。最左前缀法则在用select的时候，和放的位置是没有关系的，只要存在就行。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p><h4 id="2342-索引失效情况"><a class="markdownIt-Anchor" href="#2342-索引失效情况"></a> 2.3.4.2 索引失效情况</h4><ol><li><p>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code> 换成 <code>explain select * from tb_user where phone = '17799990015';</code>这是可以的。</p></li><li><p>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</p></li><li><p>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。<code>explain select * from tb_user where profession like '软件%';</code> 这个是不会失效的，只有前面加了%才会失效。</p></li><li><p>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</p></li><li><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引。因为只要有一个没有索引，另外一个用不用索引都没有意义，都要进行全表扫描。所以就无需用索引。</p></li></ol><h4 id="2343-sql-提示"><a class="markdownIt-Anchor" href="#2343-sql-提示"></a> 2.3.4.3 SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引： <code>explain select * from tb_user use index(idx_user_pro) where profession="软件工程";</code> 不使用哪个索引： <code>explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";</code> 必须使用哪个索引： <code>explain select * from tb_user force index(idx_user_pro) where profession="软件工程";</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="2344-覆盖索引回表查询"><a class="markdownIt-Anchor" href="#2344-覆盖索引回表查询"></a> 2.3.4.4 覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义： <code>using index condition</code>：查找使用了索引，但是需要回表查询数据 <code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>覆盖索引： 如果在生成的二级索引（辅助索引）中可以一次性获得select所需要的字段，不需要回表查询。</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *； 如果在辅助索引（二级索引）中找聚集索引，如<code>select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询； 如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name='xxx';</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案： <code>select id, username, password from tb_user where username='itcast';</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引。 username和password字段建立联合索引的叶子节点挂的就是 id 所以不需要三者同时建索引。</p><h4 id="2345-前缀索引"><a class="markdownIt-Anchor" href="#2345-前缀索引"></a> 2.3.4.5 前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code> 前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>求选择性公式：</p><p>select count(distinct email) / count(<em>) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(</em>) from tb_user;</p><p>前缀索引中是有可能碰到相同的索引的情况的（因为选择性可能不为1），所以使用前缀索引进行查询的时候，mysql 会有一个回表查询的过程，确定是否为所需数据。如图中的查询到lvbu6之后还要进行回表，回表完再查xiaoy，看到xiaoy是不需要的数据，则停止查下一个。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/pre.png" alt="images" title="索引流程"></p><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="2346-单列索引联合索引"><a class="markdownIt-Anchor" href="#2346-单列索引联合索引"></a> 2.3.4.6 单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列 联合索引：即一个索引包含了多个列 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：</p><p><code>explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code> phone 和 name 都建立了索引情况下，这句只会用到phone索引字段。</p><p>联合索引的数据组织图：</p><h5 id="23461-注意事项"><a class="markdownIt-Anchor" href="#23461-注意事项"></a> 2.3.4.6.1 注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</li></ul><h3 id="235-设计原则"><a class="markdownIt-Anchor" href="#235-设计原则"></a> 2.3.5 设计原则</h3><ol><li><p>针对于数据量较大，且查询比较频繁的表建立索引</p></li><li><p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</p></li><li><p>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</p></li><li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</p></li><li><p>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</p></li></ol><h2 id="24-sql-优化"><a class="markdownIt-Anchor" href="#24-sql-优化"></a> 2.4 SQL 优化</h2><h3 id="241-插入数据"><a class="markdownIt-Anchor" href="#241-插入数据"></a> 2.4.1 插入数据</h3><p>普通插入：</p><ol><li><p>采用批量插入（一次插入的数据不建议超过1000条，500 - 1000 为宜）</p></li><li><p>手动提交事务</p></li><li><p>主键顺序插入（主键顺序插入的效率大于乱序插入）</p></li></ol><p>大批量插入： 如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><h1 id="3-客户端连接服务端时加上参数-local-infile这一行在bashcmd界面输入"><a class="markdownIt-Anchor" href="#3-客户端连接服务端时加上参数-local-infile这一行在bashcmd界面输入"></a> 3 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）</h1><p>mysql --local-infile -u root -p</p><h1 id="4-设置全局参数local_infile为1开启从本地加载文件导入数据的开关"><a class="markdownIt-Anchor" href="#4-设置全局参数local_infile为1开启从本地加载文件导入数据的开关"></a> 4 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</h1><p>set global local_infile = 1;<br>select @@local_infile;</p><h1 id="5-执行load指令将准备好的数据加载到表结构中先要把表建立起来"><a class="markdownIt-Anchor" href="#5-执行load指令将准备好的数据加载到表结构中先要把表建立起来"></a> 5 执行load指令将准备好的数据，加载到表结构中，先要把表建立起来。</h1><p>load data local infile ‘/root/sql1.log’ into table ‘tb_user’ fields terminated by ‘,’ lines terminated by ‘\n’;</p><h3 id="511-主键优化"><a class="markdownIt-Anchor" href="#511-主键优化"></a> 5.1.1 主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>主键的顺序的插入过程如下：</p><p>但是如果主键是乱序插入的话，就会导致需要插入的位置为中间的位置，会有页分裂的过程。</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。</p><p>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li><p>满足业务需求的情况下，尽量降低主键的长度，二级索引的叶子节点保存的就是主键，所以主键小占用的空间也就会少。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</p></li><li><p>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号，占用的空间大。</p></li><li><p>业务操作时，避免对主键的修改</p></li></ul><h3 id="512-order-by优化"><a class="markdownIt-Anchor" href="#512-order-by优化"></a> 5.1.2 order by优化</h3><ol><li><p>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</p></li><li><p>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</p></li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li><p>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</p></li><li><p>尽量使用覆盖索引</p></li><li><p>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</p></li><li><p>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</p></li></ul><h3 id="513-group-by优化"><a class="markdownIt-Anchor" href="#513-group-by优化"></a> 5.1.3 group by优化</h3><ul><li><p>在分组操作时，可以通过索引来提高效率</p></li><li><p>分组操作时，索引的使用也是满足最左前缀法则的</p></li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="514-limit优化"><a class="markdownIt-Anchor" href="#514-limit优化"></a> 5.1.4 limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。 优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><p>– 此语句耗时很长<br>select * from tb_sku limit 9000000, 10;<br>– 通过覆盖索引加快速度，直接通过主键索引进行排序及查询<br>select id from tb_sku order by id limit 9000000, 10;<br>– 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit<br>– select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);<br>– 通过连表查询即可实现第一句的效果，并且能达到第二句的速度<br>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where <a href="http://s.id">s.id</a> = <a href="http://a.id">a.id</a>;</p><h3 id="515-count优化"><a class="markdownIt-Anchor" href="#515-count优化"></a> 5.1.5 count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(<em>) 的时候会直接返回这个数，效率很高（前提是不适用where）； InnoDB 在执行 count(</em>) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。 优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li><p>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</p></li><li><p>用法：count(*)、count(主键)、count(字段)、count(1)</p></li><li><p>count(主键)跟count(<em>)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(</em>)一样；count(null)返回0</p></li></ul><p>各种用法的性能：</p><ul><li><p>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</p></li><li><p>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</p></li><li><p>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</p></li><li><p>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</p></li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(<em>)，所以尽量使用 count(</em>)</p><h3 id="516-update优化避免行锁升级为表锁"><a class="markdownIt-Anchor" href="#516-update优化避免行锁升级为表锁"></a> 5.1.6 update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句： <code>update student set no = '123' where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行； <code>update student set no = '123' where name = 'test';</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引，就可以由表锁变成行锁。</p><h2 id="52-视图"><a class="markdownIt-Anchor" href="#52-视图"></a> 5.2 视图</h2><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="521-创建视图"><a class="markdownIt-Anchor" href="#521-创建视图"></a> 5.2.1 创建视图</h3><p><code>CREATE [ OR REPLACE ] VIEW 视图名称[（列名列表）] AS SELECT 语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]</code></p><blockquote><p>例子： <code>create or replace view stu_wll as select id,name from student where id&lt;=10;</code></p></blockquote><h3 id="522-查询视图"><a class="markdownIt-Anchor" href="#522-查询视图"></a> 5.2.2 查询视图</h3><p>查看创建视图语句： <code>SHOW CREATE VIEW</code>视图名称；</p><p>查看视图数据：<code>SELECT*FROM</code> 视图名称； <code>show create view stu_v_1;</code></p><h3 id="523-修改视图"><a class="markdownIt-Anchor" href="#523-修改视图"></a> 5.2.3 修改视图</h3><p>方式一：<code>CREATE[OR REPLACE] VIEW 视图名称[（列名列表)）] AS SELECT 语句[ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</code></p><p>方式二：<code>ALTER VIEW 视图名称 [（列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</code></p><h3 id="524-删除视图"><a class="markdownIt-Anchor" href="#524-删除视图"></a> 5.2.4 删除视图</h3><p><code>DROP VIEW [IF EXISTS] 视图名称 [视图名称]</code></p><h3 id="525-视图检查选项"><a class="markdownIt-Anchor" href="#525-视图检查选项"></a> 5.2.5 视图检查选项</h3><p>当使用WITH CHECK QPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：CASCADED 和 LOCAL ，默认值为 CASCADED。</p><p>NOTE：如果没有开检查选项就不会进行检查。不同版本是不同含义的，要看版本。</p><h4 id="5251-cascaded"><a class="markdownIt-Anchor" href="#5251-cascaded"></a> 5.2.5.1 CASCADED</h4><p><code>级联，一旦选择了这个选项，除了会检查创建视图时候的条件，还会检查所依赖视图的条件。</code></p><blockquote><p>比如下面的例子：创建stu_V_l 视图，id是小于等于 20的。 <code>create or replace view stu_V_l as select id,name from student where id &lt;=20;</code> 再创建 stu_v_2 视图，20 &gt;= id &gt;=10。 <code>create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;=10 with cascaded check option;</code> 再创建 stu_v_3 视图。 <code>create or replace view stu_v_3 as select id,name from stu_v_2 where id&lt;=15;</code> 这条数据能够成功，stu_v_3 没有开检查选项所以不会 去判断 id 是否小于等于15, 直接检查 是否满足 stu_v_2。 <code>insert into stu_v_3 values(17,'Tom');</code></p></blockquote><h4 id="5252-local"><a class="markdownIt-Anchor" href="#5252-local"></a> 5.2.5.2 LOCAL</h4><p>本地的条件也会检查，还会向上检查。在向上找的时候，就要看是否上面开了检查选项，如果没开就不检查。和 CASCADED 的区别就是 CASCADED 不管上面开没开检查选项都会进行检查。</p><h3 id="526-更新及作用"><a class="markdownIt-Anchor" href="#526-更新及作用"></a> 5.2.6 更新及作用</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新</p><ol><li><p>聚合函数或窗口函数 ( SUM()、MIN()、MAX()、COUNT() 等 )</p></li><li><p>DISTINCT</p></li><li><p>GROUP BY</p></li><li><p>HAVING</p></li><li><p>UNION 或者UNION ALL</p></li></ol><blockquote><p>例子： 使用了聚合函数，插入会失败。 <code>create view stu_v_count as select count(*) from student;</code> <code>insert into stu_v_count values(10);</code></p></blockquote><p>作用</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p><blockquote><p>安全 数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据 数据独立 视图可帮助用户屏蔽真实表结构变化带来的影响。</p></blockquote><p>总而言之 类似于给表加上了一个外壳，通过这个外壳访问表的时候，只能按照所设计的方式进行访问与更新。</p><h2 id="53-存储过程"><a class="markdownIt-Anchor" href="#53-存储过程"></a> 5.3 存储过程</h2><p>存储过程是事先经过编译并存储在数据库中的一段SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库SQL 语言层面的代码封装与重用。</p><p>特点</p><ol><li><p>封装</p></li><li><p>复用</p></li><li><p>可以接收参数，也可以返回数据减少网络交互，效率提升</p></li></ol><h3 id="531-创建"><a class="markdownIt-Anchor" href="#531-创建"></a> 5.3.1 创建</h3><p>CREATE PROCEDURE 存储过程名称( [参数列表] )<br>​<br>BEGIN<br>​<br>SQL 语句<br>​<br>END;</p><p>NOTE: 在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter 指定SQL语句的结束符。默认是 分号作为结束符。</p><p>delimiter $ ，则 $ 符作为结束符。</p><h3 id="532-调用"><a class="markdownIt-Anchor" href="#532-调用"></a> 5.3.2 调用</h3><p>CALL 名称 ( [参数])</p><h3 id="533-查看"><a class="markdownIt-Anchor" href="#533-查看"></a> 5.3.3 查看</h3><p>查询指定数据库的存储过程及状态信息</p><p><code>SELECT* FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'</code></p><p>存储过程名称；–查询某个存储过程的定义</p><p><code>SHOW CREATE PROCEDURE</code></p><h3 id="534-删除"><a class="markdownIt-Anchor" href="#534-删除"></a> 5.3.4 删除</h3><p><code>DROP PROCEDURE [ IFEXISTS ] 存储过程名称</code></p><h3 id="535-游标"><a class="markdownIt-Anchor" href="#535-游标"></a> 5.3.5 游标</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和CLOSE，其语法分别如下。</p><blockquote><p>声明游标： <code>DECLARE 游标名称 CURSOR FOR 查询语句</code></p></blockquote><blockquote><p>打开游标： <code>OPEN 游标名称</code></p></blockquote><blockquote><p>获取游标记录： <code>FETCH 游标名称INTO变量[变量]</code></p></blockquote><p>条件处理程序： 条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><blockquote><p>DECLARE handler action HANDLER FOR condition value L condition value]…statement</p></blockquote><p>handler_action CONTINUE：继续执行当前程序</p><p>EXIT：终止执行当前程序</p><p>condition_value :</p><p><code>SQLSTATE sqlstate_value：状态码，如02000</code></p><p><code>SQLWARNING：所有以01开头的SQLSTATE代码的简写</code></p><p><code>NOT FOUND：所有以02开头的SQLSTATE代码的简写</code></p><p><code>SQLEXCEPTION：所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写</code></p><p>例子：</p><p>NOTE：要先声明普通变量，再申请游标。</p><p>要求： <code>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表（id，name，profession）中。</code></p><p>create procedure p1l(in uage int)</p><pre><code class="hljs">begin  declare uname varchar(100);   decLare upro varchar(100);  declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;   当 条件处理程序的处理的状态码为02000的时候，就会退出。  declare exit handler for SQLSTATE '02000'close u_cursor;  drop table if exists tb_user_pro;   create table if not exists tb_user_pro(  id int primary key auto_increment,   name varchar(100),   profession varchar(100)  );  open u_cursor;   while true do   fetch u_cursor into uname,Upro;   insert into tb_user_pro values(null,uname,Upro);   end while;  close u_cursor;   end;</code></pre><h2 id="54-触发器"><a class="markdownIt-Anchor" href="#54-触发器"></a> 5.4 触发器</h2><p>介绍 触发器是与表有关的数据库对象，指在insert/update/delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。 使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发（比如说 一条语句影响了 5 行 则会被触发 5 次），不支持语句级触发（比如说 一条语句影响了 5 行 则会被触发 1 次）。</p><p>触发器类型</p><p>NEW 和 OLD</p><p>INSERT</p><p>NEW 表示将要或者已经新增的数据</p><p>UPDATE</p><p>OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</p><p>DELETE</p><p>OLD表示将要或者已经删除的数据</p><h2 id="55-锁"><a class="markdownIt-Anchor" href="#55-锁"></a> 5.5 锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>NOTE : 针对事物才有加锁的意义。</p><p>分类：MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li><p>全局锁：锁定数据库中的所有表。</p></li><li><p>表级锁：每次操作锁住整张表。</p></li><li><p>行级锁：每次操作锁住对应的行数据。</p></li></ol><p>全局锁：</p><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>表锁：</p><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ol><li><p>表锁：对于表锁，分为两类：1.表共享读锁（read lock）所有的事物都只能读（当前加锁的客户端也只能读，不能写），不能写 2.表独占写锁（write lock），对当前加锁的客户端，可读可写，对于其他的客户端，不可读也不可写。 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p></li><li><p>元数据锁（meta data lock，MDL），MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）;当对表结构进行变更操作的时候，加MDL写锁（排他）。</p></li><li><p>意向锁: 为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 一个客户端对某一行加上了行锁，那么系统也会对其加上一个意向锁，当别的客户端来想要对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。</p></li></ol><p>意向锁兼容性：</p><ol><li><p>意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。</p></li><li><p>意向排他锁（lX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。</p></li></ol><p>行锁：</p><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。 InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC（read commit ）、RR（repeat read）隔离级别下都支持。</p></li><li><p>间隙锁（GapLock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。比如说 两个临近叶子节点为 15 23，那么间隙就是指 [15 , 23],锁的是这个间隙。</p></li><li><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p></li></ol><p>InnoDB实现了以下两种类型的行锁：</p><ol><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p></li></ol><p>SQL</p><p>行锁类型</p><p>说明</p><p>insert</p><p>排他锁</p><p>自动加锁</p><p>update</p><p>排他锁</p><p>自动加锁</p><p>delete</p><p>排他锁</p><p>自动加锁</p><p>select</p><p>不加任何锁</p><p>select　lock　in　share mode</p><p>排他锁</p><p>需要手动在SELECT之后加LOCK IN SHARE MODE</p><p>select　for　update</p><p>排他锁</p><p>需要手动在SELECT之后加FOR UPDATE</p><p>行锁 - 演示</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</p></li></ol><p>间隙锁/临键锁-演示</p><p>默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li><p>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</p></li><li><p>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p></li><li><p>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</p></li></ol><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p><h2 id="56-innodb-引擎"><a class="markdownIt-Anchor" href="#56-innodb-引擎"></a> 5.6 InnoDB 引擎</h2><h3 id="561-逻辑存储结构"><a class="markdownIt-Anchor" href="#561-逻辑存储结构"></a> 5.6.1 逻辑存储结构</h3><p>表空间（ibd文件），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p>区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p><p>页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每从磁盘申请4-5个区。一页包含若干行。</p><p>行，InnoDB存储引擎数据是按进行存放的。</p><h3 id="562-架构"><a class="markdownIt-Anchor" href="#562-架构"></a> 5.6.2 架构</h3><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic.png" alt="images"></p><p>Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘I0，加快处理速度。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic2.png" alt="images"></p><p>磁盘架构： <img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic6.png" alt="images"> <img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic8.png" alt="images"></p><p>InnoDB的整个体系结构为：</p><p>当业务操作的时候直接操作的是内存缓冲区，如果缓冲区当中没有数据，则会从磁盘中加载到缓冲区，增删改查都是在缓冲区的，后台线程以一定的速率刷新到磁盘。</p><h2 id="57-事务原理"><a class="markdownIt-Anchor" href="#57-事务原理"></a> 5.7 事务原理</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时败。具有ACID四大特征。</p><p>原子性，一致性，持久性这三大特性由 redo log 和 undo log 日志来保证的。 隔离性 是由锁机制和MVCC保证的。</p><p>redo log:</p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><blockquote><p>个人理解： 事物每次提交的时候都会将数据刷到redo log中而不是直接将buffer pool中的数据直接刷到磁盘中（ibd文件中），是因为redo log 是顺序写，性能处理的够快，直接刷到ibd中，是随机写，性能慢。所以脏页是在下一次读的时候，或者后台线程采用一定的机制进行刷盘到ibd中。</p></blockquote><p>undo log: 回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。 undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><blockquote><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。 Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</p></blockquote><h2 id="58-mvcc"><a class="markdownIt-Anchor" href="#58-mvcc"></a> 5.8 MVCC</h2><h3 id="581-当前读"><a class="markdownIt-Anchor" href="#581-当前读"></a> 5.8.1 当前读:</h3><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p><ul><li><p>select…lock in share mode（共享锁）。</p></li><li><p>select……for update、update、insert、delete（排他锁）都是一种当前读。</p></li></ul><h3 id="582-快照读"><a class="markdownIt-Anchor" href="#582-快照读"></a> 5.8.2 快照读:</h3><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><h3 id="583-mvcc"><a class="markdownIt-Anchor" href="#583-mvcc"></a> 5.8.3 MVCC:</h3><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h4 id="5831-mvcc-实现原理"><a class="markdownIt-Anchor" href="#5831-mvcc-实现原理"></a> 5.8.3.1 MVCC 实现原理:</h4><p>有三个隐藏的字段:</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCC.png" alt="images"></p><blockquote><p>undo log回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p></blockquote><p>undo log 版本链：</p><p>undo log日志会记录原来的版本的数据，因为是通过undo log 日志进行回滚的。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCCList.png" alt="images"></p><p>如何确定返回哪一个版本 这是由read view决定返回 undo log 中的哪一个版本。</p><blockquote><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。 RR隔离级别下，在事务中第一次执行快照读时生成ReadView，后续会复用。</p></blockquote><blockquote><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&amp;spm_id_from=pageDriver&amp;vd_source=bbc04b831b54029788a178a7c2e9ae20">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&amp;spm_id_from=pageDriver&amp;vd_source=bbc04b831b54029788a178a7c2e9ae20</a></p></blockquote><p>MVCC 靠 隐藏字段 , undo log 版本链 , read view 实现的。</p><ul><li><p>原子性-undo log</p></li><li><p>持久性-redo log</p></li><li><p>一致性-undo log + redo log</p></li><li><p>隔离性-锁 + MVCC</p></li></ul><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/readview.png" alt="images"></p><h1 id="6-数据类型"><a class="markdownIt-Anchor" href="#6-数据类型"></a> 6 数据类型</h1><h2 id="61-整型"><a class="markdownIt-Anchor" href="#61-整型"></a> 6.1 整型</h2><p>类型名称</p><p>取值范围</p><p>大小</p><p>TINYINT</p><p>-128〜127</p><p>1个字节</p><p>SMALLINT</p><p>-32768〜32767</p><p>2个宇节</p><p>MEDIUMINT</p><p>-8388608〜8388607</p><p>3个字节</p><p>INT (INTEGHR)</p><p>-2147483648〜2147483647</p><p>4个字节</p><p>BIGINT</p><p>-9223372036854775808〜9223372036854775807</p><p>8个字节</p><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="62-浮点型"><a class="markdownIt-Anchor" href="#62-浮点型"></a> 6.2 浮点型</h2><p>类型名称</p><p>说明</p><p>存储需求</p><p>FLOAT</p><p>单精度浮点数</p><p>4 个字节</p><p>DOUBLE</p><p>双精度浮点数</p><p>8 个字节</p><p>DECIMAL (M, D)，DEC</p><p>压缩的“严格”定点数</p><p>M+2 个字节</p><h2 id="63-日期和时间"><a class="markdownIt-Anchor" href="#63-日期和时间"></a> 6.3 日期和时间</h2><p>类型名称</p><p>日期格式</p><p>日期范围</p><p>存储需求</p><p>YEAR</p><p>YYYY</p><p>1901 ~ 2155</p><p>1 个字节</p><p>TIME</p><p>HH:MM:SS</p><p>-838:59:59 ~ 838:59:59</p><p>3 个字节</p><p>DATE</p><p>YYYY-MM-DD</p><p>1000-01-01 ~ 9999-12-3</p><p>3 个字节</p><p>DATETIME</p><p>YYYY-MM-DD HH:MM:SS</p><p>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</p><p>8 个字节</p><p>TIMESTAMP</p><p>YYYY-MM-DD HH:MM:SS</p><p>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</p><p>4 个字节</p><h2 id="64-字符串"><a class="markdownIt-Anchor" href="#64-字符串"></a> 6.4 字符串</h2><p>类型名称</p><p>说明</p><p>存储需求</p><p>CHAR(M)</p><p>固定长度非二进制字符串</p><p>M 字节，1&lt;=M&lt;=255</p><p>VARCHAR(M)</p><p>变长非二进制字符串</p><p>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</p><p>TINYTEXT</p><p>非常小的非二进制字符串</p><p>L+1字节，在此，L&lt;2^8</p><p>TEXT</p><p>小的非二进制字符串</p><p>L+2字节，在此，L&lt;2^16</p><p>MEDIUMTEXT</p><p>中等大小的非二进制字符串</p><p>L+3字节，在此，L&lt;2^24</p><p>LONGTEXT</p><p>大的非二进制字符串</p><p>L+4字节，在此，L&lt;2^32</p><p>ENUM</p><p>枚举类型，只能有一个枚举字符串值</p><p>1或2个字节，取决于枚举值的数目 (最大值为65535)</p><p>SET</p><p>一个设置，字符串对象可以有零个或 多个SET成员</p><p>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</p><h2 id="65-二进制类型"><a class="markdownIt-Anchor" href="#65-二进制类型"></a> 6.5 二进制类型</h2><p>类型名称</p><p>说明</p><p>存储需求</p><p>BIT(M)</p><p>位字段类型</p><p>大约 (M+7)/8 字节</p><p>BINARY(M)</p><p>固定长度二进制字符串</p><p>M 字节</p><p>VARBINARY (M)</p><p>可变长度二进制字符串</p><p>M+1 字节</p><p>TINYBLOB (M)</p><p>非常小的BLOB</p><p>L+1 字节，在此，L&lt;2^8</p><p>BLOB (M)</p><p>小 BLOB</p><p>L+2 字节，在此，L&lt;2^16</p><p>MEDIUMBLOB (M)</p><p>中等大小的BLOB</p><p>L+3 字节，在此，L&lt;2^24</p><p>LONGBLOB (M)</p><p>非常大的BLOB</p><p>L+4 字节，在此，L&lt;2^32</p><h1 id="7-权限一览表"><a class="markdownIt-Anchor" href="#7-权限一览表"></a> 7 权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><p>Privilege</p><p>Grant Table Column</p><p>Context</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></p><p>Synonym for “all privileges”</p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></p><p><code>Alter_priv</code></p><p>Tables</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></p><p><code>Alter_routine_priv</code></p><p>Stored routines</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></p><p><code>Create_priv</code></p><p>Databases, tables, or indexes</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></p><p><code>Create_role_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></p><p><code>Create_routine_priv</code></p><p>Stored routines</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></p><p><code>Create_tablespace_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></p><p><code>Create_tmp_table_priv</code></p><p>Tables</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></p><p><code>Create_user_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></p><p><code>Create_view_priv</code></p><p>Views</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></p><p><code>Delete_priv</code></p><p>Tables</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></p><p><code>Drop_priv</code></p><p>Databases, tables, or views</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></p><p><code>Drop_role_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></p><p><code>Event_priv</code></p><p>Databases</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></p><p><code>Execute_priv</code></p><p>Stored routines</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></p><p><code>File_priv</code></p><p>File access on server host</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></p><p><code>Grant_priv</code></p><p>Databases, tables, or stored routines</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></p><p><code>Index_priv</code></p><p>Tables</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></p><p><code>Insert_priv</code></p><p>Tables or columns</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></p><p><code>Lock_tables_priv</code></p><p>Databases</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></p><p><code>Process_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></p><p>See <code>proxies_priv</code> table</p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></p><p><code>References_priv</code></p><p>Databases or tables</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></p><p><code>Reload_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></p><p><code>Repl_client_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></p><p><code>Repl_slave_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></p><p><code>Select_priv</code></p><p>Tables or columns</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></p><p><code>Show_db_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></p><p><code>Show_view_priv</code></p><p>Views</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></p><p><code>Shutdown_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></p><p><code>Super_priv</code></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></p><p><code>Trigger_priv</code></p><p>Tables</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></p><p><code>Update_priv</code></p><p>Tables or columns</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></p><p>Synonym for “no privileges”</p><p>Server administration</p><p>GRANT 和 REVOKE 允许的动态权限</p><p>Privilege</p><p>Context</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></p><p>Dual password administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></p><p>Allow queries blocked by audit log filter</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></p><p>Audit log administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></p><p>Authentication administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></p><p>Backup administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></p><p>Backup and Replication administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></p><p>Backup and Replication administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></p><p>Clone administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></p><p>Firewall administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></p><p>Firewall administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></p><p>Firewall administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></p><p>Replication administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></p><p>Replication administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></p><p>Redo log archiving administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></p><p>NDB Cluster</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></p><p>Authentication administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></p><p><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></p><p>Replication administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></p><p>Resource group administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></p><p>Resource group administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></p><p>Server administration</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></p><p>Server administration</p><h1 id="8-图形化界面工具"><a class="markdownIt-Anchor" href="#8-图形化界面工具"></a> 8 图形化界面工具</h1><ul><li><p>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></p></li><li><p>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></p></li><li><p>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></p></li><li><p>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></p></li><li><p>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></p></li><li><p>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></p></li></ul><h1 id="9-安装"><a class="markdownIt-Anchor" href="#9-安装"></a> 9 安装</h1><h1 id="10-小技巧"><a class="markdownIt-Anchor" href="#10-小技巧"></a> 10 小技巧</h1><ol><li><p>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</p></li><li><p>查看Mysql数据库占用空间：</p></li></ol><p>SELECT table_schema “Database Name”<br>&nbsp; &nbsp; , SUM(data_length + index_length) / (1024 * 1024) “Database Size in MB”<br>FROM information_schema.TABLES<br>GROUP BY table_schema;</p><h1 id="11-参考文献"><a class="markdownIt-Anchor" href="#11-参考文献"></a> 11 参考文献</h1><blockquote><p><a href="https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868">https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868</a> 这篇笔记是在别人的基础上完善而来，感谢B站的黑马程序员up主，也感谢路途博客。</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObscMQ7lBmyrI0OyPHgZt0dh" deck = "👨🏻‍💻code::MySQL::完整笔记.md" --> <p>#历史记录::<br>2022/10/5🌵完整笔记 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/11/"/>
      <url>/posts/11/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础篇"><a class="markdownIt-Anchor" href="#1-基础篇"></a> 1 基础篇</h1><h2 id="11-函数"><a class="markdownIt-Anchor" href="#11-函数"></a> 1.1 函数</h2><h2 id="12-约束"><a class="markdownIt-Anchor" href="#12-约束"></a> 1.2 约束</h2><h3 id="121-外键约束"><a class="markdownIt-Anchor" href="#121-外键约束"></a> 1.2.1 外键约束</h3><h4 id="1211-删除更新行为"><a class="markdownIt-Anchor" href="#1211-删除更新行为"></a> 1.2.1.1 删除/更新行为</h4><h2 id="13-多表查询"><a class="markdownIt-Anchor" href="#13-多表查询"></a> 1.3 多表查询</h2><h3 id="131-多表关系"><a class="markdownIt-Anchor" href="#131-多表关系"></a> 1.3.1 多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="1311-一对多"><a class="markdownIt-Anchor" href="#1311-一对多"></a> 1.3.1.1 一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="1312-多对多"><a class="markdownIt-Anchor" href="#1312-多对多"></a> 1.3.1.2 多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="1313-一对一"><a class="markdownIt-Anchor" href="#1313-一对一"></a> 1.3.1.3 一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="132-查询"><a class="markdownIt-Anchor" href="#132-查询"></a> 1.3.2 查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="133-内连接查询"><a class="markdownIt-Anchor" href="#133-内连接查询"></a> 1.3.3 内连接查询</h3><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工姓名，及关联的部门的名称<br>-- 隐式<br>select e.name, d.name from employee as e, dept as d where e.dept = d.id;<br>-- 显式<br>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="134-外连接查询"><a class="markdownIt-Anchor" href="#134-外连接查询"></a> 1.3.4 外连接查询</h3><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>相当于查询表1的所有数据，包含表1和表2交集部分数据</p><p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 左<br>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;<br>select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样<br>-- 右<br>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;<br></code></pre></td></tr></tbody></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="135-自连接查询"><a class="markdownIt-Anchor" href="#135-自连接查询"></a> 1.3.5 自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工及其所属领导的名字<br>select a.name, b.name from employee a, employee b where a.manager = b.id;<br>-- 没有领导的也查询出来<br>select a.name, b.name from employee a left join employee b on a.manager = b.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="136-联合查询-union-union-all"><a class="markdownIt-Anchor" href="#136-联合查询-union-union-all"></a> 1.3.6 联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表A ...<br>UNION [ALL]<br>SELECT 字段列表 FROM 表B ...<br></code></pre></td></tr></tbody></table></figure><h4 id="1361-注意事项"><a class="markdownIt-Anchor" href="#1361-注意事项"></a> 1.3.6.1 注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h3 id="137-子查询"><a class="markdownIt-Anchor" href="#137-子查询"></a> 1.3.7 子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="1371-标量子查询"><a class="markdownIt-Anchor" href="#1371-标量子查询"></a> 1.3.7.1 标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部所有员工<br>select id from dept where name = '销售部';<br>-- 根据销售部部门ID，查询员工信息<br>select * from employee where dept = 4;<br>-- 合并（子查询）<br>select * from employee where dept = (select id from dept where name = '销售部');<br><br>-- 查询xxx入职之后的员工信息<br>select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx');<br></code></pre></td></tr></tbody></table></figure><h4 id="1372-列子查询"><a class="markdownIt-Anchor" href="#1372-列子查询"></a> 1.3.7.2 列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><p>例子：</p><h4 id="1374"><a class="markdownIt-Anchor" href="#1374"></a> 1.3.7.4</h4><h2 id="14-事务"><a class="markdownIt-Anchor" href="#14-事务"></a> 1.4 事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1. 查询张三账户余额<br>select * from account where name = '张三';<br>-- 2. 将张三账户余额-1000<br>update account set money = money - 1000 where name = '张三';<br>-- 此语句出错后张三钱减少但是李四钱没有增加<br>模拟sql语句错误<br>-- 3. 将李四账户余额+1000<br>update account set money = money + 1000 where name = '李四';<br><br>-- 查看事务提交方式<br>SELECT @@AUTOCOMMIT;<br>-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效<br>SET @@AUTOCOMMIT = 0;<br>-- 提交事务<br>COMMIT;<br>-- 回滚事务<br>ROLLBACK;<br><br>-- 设置手动提交后上面代码改为：<br>select * from account where name = '张三';<br>update account set money = money - 1000 where name = '张三';<br>update account set money = money + 1000 where name = '李四';<br>commit;<br></code></pre></td></tr></tbody></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction;<br>select * from account where name = '张三';<br>update account set money = money - 1000 where name = '张三';<br>update account set money = money + 1000 where name = '李四';<br>commit;<br></code></pre></td></tr></tbody></table></figure><h3 id="141-四大特性acid"><a class="markdownIt-Anchor" href="#141-四大特性acid"></a> 1.4.1 四大特性ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="142-并发事务"><a class="markdownIt-Anchor" href="#142-并发事务"></a> 1.4.2 并发事务</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a></p></blockquote><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="2-进阶篇"><a class="markdownIt-Anchor" href="#2-进阶篇"></a> 2 进阶篇</h1><h2 id="21-存储引擎"><a class="markdownIt-Anchor" href="#21-存储引擎"></a> 2.1 存储引擎</h2><p>MySQL体系结构：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84_20220315034329549927.png" alt="结构图" title="结构图"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述" title="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询建表语句<br>show create table account;<br>-- 建表时指定存储引擎<br>CREATE TABLE 表名(<br>...<br>) ENGINE=INNODB;<br>-- 查看当前数据库支持的存储引擎<br>show engines;<br></code></pre></td></tr></tbody></table></figure><h3 id="211-innodb"><a class="markdownIt-Anchor" href="#211-innodb"></a> 2.1.1 InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like 'innodb_file_per_table';</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h3 id="212-myisam"><a class="markdownIt-Anchor" href="#212-myisam"></a> 2.1.2 MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="213-memory"><a class="markdownIt-Anchor" href="#213-memory"></a> 2.1.3 Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="214-存储引擎特点"><a class="markdownIt-Anchor" href="#214-存储引擎特点"></a> 2.1.4 存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h3 id="215-存储引擎的选择"><a class="markdownIt-Anchor" href="#215-存储引擎的选择"></a> 2.1.5 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="22-性能分析"><a class="markdownIt-Anchor" href="#22-性能分析"></a> 2.2 性能分析</h2><h3 id="221-查看执行频次"><a class="markdownIt-Anchor" href="#221-查看执行频次"></a> 2.2.1 查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE 'Com_______';</code> 或者 <code>SHOW SESSION STATUS LIKE 'Com_______';</code><br>例：<code>show global status like 'Com_______'</code></p><h3 id="222-慢查询日志"><a class="markdownIt-Anchor" href="#222-慢查询日志"></a> 2.2.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：<br># 开启慢查询日志开关<br>slow_query_log=1<br># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>long_query_time=2<br>更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like 'slow_query_log';</code></p><h3 id="223-profile"><a class="markdownIt-Anchor" href="#223-profile"></a> 2.2.3 profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="224-explain"><a class="markdownIt-Anchor" href="#224-explain"></a> 2.2.4 explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br># 直接在select语句之前加上关键字 explain / desc<br>EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="23-索引"><a class="markdownIt-Anchor" href="#23-索引"></a> 2.3 索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="231-索引结构"><a class="markdownIt-Anchor" href="#231-索引结构"></a> 2.3.1 索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2311-b-tree"><a class="markdownIt-Anchor" href="#2311-b-tree"></a> 2.3.1.1 B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="2312-btree"><a class="markdownIt-Anchor" href="#2312-btree"></a> 2.3.1.2 B+Tree</h4><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="2313-hash"><a class="markdownIt-Anchor" href="#2313-hash"></a> 2.3.1.3 Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="2314-面试题"><a class="markdownIt-Anchor" href="#2314-面试题"></a> 2.3.1.4 面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="232-索引分类"><a class="markdownIt-Anchor" href="#232-索引分类"></a> 2.3.2 索引分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="2321-思考题"><a class="markdownIt-Anchor" href="#2321-思考题"></a> 2.3.2.1 思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 10;<br>select * from user where name = 'Arm';<br>-- 备注：id为主键，name字段创建的有索引<br></code></pre></td></tr></tbody></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="233-语法"><a class="markdownIt-Anchor" href="#233-语法"></a> 2.3.3 语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>-- 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br>-- 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br><br>-- 删除索引<br>drop index idx_user_email on tb_user;<br></code></pre></td></tr></tbody></table></figure><h3 id="234-使用规则"><a class="markdownIt-Anchor" href="#234-使用规则"></a> 2.3.4 使用规则</h3><h4 id="2341-最左前缀法则"><a class="markdownIt-Anchor" href="#2341-最左前缀法则"></a> 2.3.4.1 最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p><h4 id="2342-索引失效情况"><a class="markdownIt-Anchor" href="#2342-索引失效情况"></a> 2.3.4.2 索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="2343-sql-提示"><a class="markdownIt-Anchor" href="#2343-sql-提示"></a> 2.3.4.3 SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession="软件工程";</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession="软件工程";</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="2344-覆盖索引回表查询"><a class="markdownIt-Anchor" href="#2344-覆盖索引回表查询"></a> 2.3.4.4 覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name='xxx';</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username='itcast';</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="2345-前缀索引"><a class="markdownIt-Anchor" href="#2345-前缀索引"></a> 2.3.4.5 前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(distinct email) / count(*) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;<br></code></pre></td></tr></tbody></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="2346-单列索引联合索引"><a class="markdownIt-Anchor" href="#2346-单列索引联合索引"></a> 2.3.4.6 单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code><br>这句只会用到phone索引字段</p><h5 id="23461-注意事项"><a class="markdownIt-Anchor" href="#23461-注意事项"></a> 2.3.4.6.1 注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="235-设计原则"><a class="markdownIt-Anchor" href="#235-设计原则"></a> 2.3.5 设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="24-sql-优化"><a class="markdownIt-Anchor" href="#24-sql-优化"></a> 2.4 SQL 优化</h2><h3 id="241-插入数据"><a class="markdownIt-Anchor" href="#241-插入数据"></a> 2.4.1 插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）<br>mysql --local-infile -u root -p<br># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>select @@local_infile;<br># 执行load指令将准备好的数据，加载到表结构中<br>load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\n';<br></code></pre></td></tr></tbody></table></figure><h3 id="242-主键优化"><a class="markdownIt-Anchor" href="#242-主键优化"></a> 2.4.2 主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="243-order-by优化"><a class="markdownIt-Anchor" href="#243-order-by优化"></a> 2.4.3 order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="244-group-by优化"><a class="markdownIt-Anchor" href="#244-group-by优化"></a> 2.4.4 group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="245-limit优化"><a class="markdownIt-Anchor" href="#245-limit优化"></a> 2.4.5 limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 此语句耗时很长<br>select * from tb_sku limit 9000000, 10;<br>-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询<br>select id from tb_sku order by id limit 9000000, 10;<br>-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit<br>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);<br>-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度<br>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="246-count优化"><a class="markdownIt-Anchor" href="#246-count优化"></a> 2.4.6 count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="247-update优化避免行锁升级为表锁"><a class="markdownIt-Anchor" href="#247-update优化避免行锁升级为表锁"></a> 2.4.7 update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = '123' where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = '123' where name = 'test';</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p><h1 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型"></a> 3 数据类型</h1><h2 id="31-整型"><a class="markdownIt-Anchor" href="#31-整型"></a> 3.1 整型</h2><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="32-浮点型"><a class="markdownIt-Anchor" href="#32-浮点型"></a> 3.2 浮点型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h2 id="33-日期和时间"><a class="markdownIt-Anchor" href="#33-日期和时间"></a> 3.3 日期和时间</h2><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><h2 id="34-字符串"><a class="markdownIt-Anchor" href="#34-字符串"></a> 3.4 字符串</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;=M&lt;=255</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="35-二进制类型"><a class="markdownIt-Anchor" href="#35-二进制类型"></a> 3.5 二进制类型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="4-权限一览表"><a class="markdownIt-Anchor" href="#4-权限一览表"></a> 4 权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Grant Table Column</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td style="text-align:left">Synonym for “all privileges”</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td style="text-align:left"><code>Alter_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td style="text-align:left"><code>Alter_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td style="text-align:left"><code>Create_priv</code></td><td style="text-align:left">Databases, tables, or indexes</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td style="text-align:left"><code>Create_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td style="text-align:left"><code>Create_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td style="text-align:left"><code>Create_tablespace_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td style="text-align:left"><code>Create_tmp_table_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td style="text-align:left"><code>Create_user_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td style="text-align:left"><code>Create_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td style="text-align:left"><code>Delete_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td style="text-align:left"><code>Drop_priv</code></td><td style="text-align:left">Databases, tables, or views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td style="text-align:left"><code>Drop_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td style="text-align:left"><code>Event_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td style="text-align:left"><code>Execute_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td style="text-align:left"><code>File_priv</code></td><td style="text-align:left">File access on server host</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td style="text-align:left"><code>Grant_priv</code></td><td style="text-align:left">Databases, tables, or stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td style="text-align:left"><code>Index_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td style="text-align:left"><code>Insert_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td style="text-align:left"><code>Lock_tables_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td style="text-align:left"><code>Process_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td style="text-align:left">See <code>proxies_priv</code> table</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td style="text-align:left"><code>References_priv</code></td><td style="text-align:left">Databases or tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td style="text-align:left"><code>Reload_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td style="text-align:left"><code>Repl_client_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td style="text-align:left"><code>Repl_slave_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td style="text-align:left"><code>Select_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td style="text-align:left"><code>Show_db_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td style="text-align:left"><code>Show_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td style="text-align:left"><code>Shutdown_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td style="text-align:left"><code>Super_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td style="text-align:left"><code>Trigger_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td style="text-align:left"><code>Update_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td style="text-align:left">Synonym for “no privileges”</td><td style="text-align:left">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td style="text-align:left">Dual password administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td style="text-align:left">Allow queries blocked by audit log filter</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td style="text-align:left">Audit log administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td style="text-align:left">Backup administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td style="text-align:left">Clone administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td style="text-align:left">Redo log archiving administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td style="text-align:left">NDB Cluster</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td style="text-align:left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr></tbody></table><h1 id="5-图形化界面工具"><a class="markdownIt-Anchor" href="#5-图形化界面工具"></a> 5 图形化界面工具</h1><ul><li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h1 id="6-安装"><a class="markdownIt-Anchor" href="#6-安装"></a> 6 安装</h1><h1 id="7-小技巧"><a class="markdownIt-Anchor" href="#7-小技巧"></a> 7 小技巧</h1><ol><li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table_schema "Database Name"<br>     , SUM(data_length + index_length) / (1024 * 1024) "Database Size in MB"<br>FROM information_schema.TABLES<br>GROUP BY table_schema;<br></code></pre></td></tr></tbody></table></figure><h1 id="8-后续内容"><a class="markdownIt-Anchor" href="#8-后续内容"></a> 8 后续内容</h1><p>后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。<br>目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。<br><strong>在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力</strong><br><strong><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/README.md">https://github.com/Buildings-Lei/mysql_note/blob/main/README.md</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> MySQL </category>
          
          <category> 基础篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23 种设计模式的概念</title>
      <link href="/posts/33665/"/>
      <url>/posts/33665/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建型模式"><a class="markdownIt-Anchor" href="#1-创建型模式"></a> 1 创建型模式::</h1><!-- basicblock-end --><h2 id="11-工厂方法factory-method模式工厂方法模式"><a class="markdownIt-Anchor" href="#11-工厂方法factory-method模式工厂方法模式"></a> 1.1 工厂方法(factory method)模式：[[工厂方法模式]]</h2><p>定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟</p><h2 id="12-抽象工厂abstract-factory模式抽象工厂模式"><a class="markdownIt-Anchor" href="#12-抽象工厂abstract-factory模式抽象工厂模式"></a> 1.2 抽象工厂(abstract factory)模式：[[抽象工厂模式]]</h2><p>提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定他们具体的类</p><h2 id="13-原型prototype模式"><a class="markdownIt-Anchor" href="#13-原型prototype模式"></a> 1.3 原型(prototype)模式：</h2><p>用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象</p><h2 id="14-单例singleton模式单例模式"><a class="markdownIt-Anchor" href="#14-单例singleton模式单例模式"></a> 1.4 单例(singleton)模式：[[单例模式]]</h2><p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p><h2 id="15-构建器builder模式"><a class="markdownIt-Anchor" href="#15-构建器builder模式"></a> 1.5 构建器(builder)模式：</h2><p>将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示</p><!-- basicblock-start oid="ObsKWo536mEWs62dfYTTMUIw" --> <h1 id="2-结构型模式"><a class="markdownIt-Anchor" href="#2-结构型模式"></a> 2 结构型模式::</h1><p><strong>让类和类进行组合，获得更大的结构。</strong></p><!-- basicblock-end --><h2 id="21-适配器adapter模式适配器模式"><a class="markdownIt-Anchor" href="#21-适配器adapter模式适配器模式"></a> 2.1 适配器(adapter)模式：[[适配器模式]]</h2><p>将一个类的接口转换成用户希望得到的另一个接口。它使原本不相容的接口得以协同工作—一速记关键字：<strong>转换接口</strong></p><h2 id="22-桥接bridge模式"><a class="markdownIt-Anchor" href="#22-桥接bridge模式"></a> 2.2 桥接(bridge)模式：</h2><p>将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化一一速记关键字：<strong>继承树拆分</strong></p><h2 id="23-组合composite模式"><a class="markdownIt-Anchor" href="#23-组合composite模式"></a> 2.3 组合(composite)模式：</h2><p>将对象组合成树型结构以表示"整体-部分" 的层次结构，使得用户对单个对象和组合对象的使用具有一致性一一速记关键字：<strong>树形目录结构</strong></p><h2 id="24-装饰decorator模式装饰模式"><a class="markdownIt-Anchor" href="#24-装饰decorator模式装饰模式"></a> 2.4 装饰(decorator)模式：[[装饰模式]]</h2><p>动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活一一速记关键字：<strong>附加职责</strong><br>给英雄穿衣服</p><h2 id="25-外观facade模式外观模式"><a class="markdownIt-Anchor" href="#25-外观facade模式外观模式"></a> 2.5 外观(facade)模式：[[外观模式]]</h2><p>定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用一一速记关键字：<strong>对外统一接口</strong></p><h2 id="26-享元flyweight模式"><a class="markdownIt-Anchor" href="#26-享元flyweight模式"></a> 2.6 享元(flyweight)模式：</h2><p>提供支持大量细粒度对象共享的有效方法</p><h2 id="27-代理proxy模式代理模式"><a class="markdownIt-Anchor" href="#27-代理proxy模式代理模式"></a> 2.7 代理(proxy)模式：[[代理模式]]</h2><p>为其他对象提供一种代理以控制这个对象的访问</p><!-- basicblock-start oid="Obsi4OYJSSfluYBmiXxIJ5us" --> <h1 id="3-行为型模式"><a class="markdownIt-Anchor" href="#3-行为型模式"></a> 3 行为型模式::</h1><p><strong>用来对类或对象怎样交互和怎样分配职责进行描述。</strong></p><!-- basicblock-end --><h2 id="31-职责链chain-of-responsibility模式"><a class="markdownIt-Anchor" href="#31-职责链chain-of-responsibility模式"></a> 3.1 职责链(chain of responsibility)模式：</h2><p>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请<br>求，直到有一个对象处理这个请求一一<strong>速记关键字：传递职责</strong></p><h2 id="32-命令command模式命令模式"><a class="markdownIt-Anchor" href="#32-命令command模式命令模式"></a> 3.2 命令(command)模式：[[命令模式]]</h2><p>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的<br>操作一一速记关键字：<strong>日志记录，可撤销</strong></p><h2 id="33-解释器interpreter模式"><a class="markdownIt-Anchor" href="#33-解释器interpreter模式"></a> 3.3 解释器(interpreter)模式：</h2><p>给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</p><h2 id="34-迭代器iterator模式"><a class="markdownIt-Anchor" href="#34-迭代器iterator模式"></a> 3.4 迭代器(iterator)模式：</h2><p>提供一种方法来顺序访问一个聚合对象中的各个元素而不需要暴露该对象的内部表示</p><h2 id="35-中介者mediator模式"><a class="markdownIt-Anchor" href="#35-中介者mediator模式"></a> 3.5 中介者(mediator)模式：</h2><p>用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改<br>变对象间的交互一一速记关键字：<strong>不直接引用</strong></p><h2 id="36-备忘录memento模式"><a class="markdownIt-Anchor" href="#36-备忘录memento模式"></a> 3.6 备忘录(memento)模式：</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可用在以后将该对象恢复到原先保存的状态</p><h2 id="37-观察者observer模式观察者模式"><a class="markdownIt-Anchor" href="#37-观察者observer模式观察者模式"></a> 3.7 观察者(observer)模式：[[观察者模式]]</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新<br>红绿灯</p><h2 id="38-状态state模式"><a class="markdownIt-Anchor" href="#38-状态state模式"></a> 3.8 状态(state)模式：</h2><p>允许一个对象在其内部状态改变时改变它的行为—一速记关键字：状态变成类</p><h2 id="39-策略strategy模式策略模式"><a class="markdownIt-Anchor" href="#39-策略strategy模式策略模式"></a> 3.9 策略(strategy)模式：[[策略模式]]</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化</p><h2 id="310-模板方法template-method模式模板方法模式"><a class="markdownIt-Anchor" href="#310-模板方法template-method模式模板方法模式"></a> 3.10 模板方法(template method)模式：[[模板方法模式]]</h2><p>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤</p><h2 id="311-访问者visitor模式"><a class="markdownIt-Anchor" href="#311-访问者visitor模式"></a> 3.11 访问者(visitor)模式：</h2><p>‌‌‌表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsQ6vFJBCtQkl42MCnlF6AL" --> <p>#历史记录:: <a href="marginnote3app://note/BACBD414-669E-47DC-AE8C-336DEA8B6050">margin: 23种设计模式的概念</a><br>2022/10/4🌵23 种设计模式的概念 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/posts/6014/"/>
      <url>/posts/6014/</url>
      
        <content type="html"><![CDATA[<h1 id="1-工厂模式"><a class="markdownIt-Anchor" href="#1-工厂模式"></a> 1 工厂模式::</h1><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。<br>[[简单工厂模式]]<br>[[抽象工厂模式]]<br>[[工厂方法模式]]</p><p>不过，在GoF的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsg1TSG5zausg0cjBJykwg3" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::工厂模式.md" --> <p>#历史记录::<br>2022/10/4🌵工厂模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 创建型模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式的类别</title>
      <link href="/posts/51386/"/>
      <url>/posts/51386/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!summary] 单例模式的特点：<br>单例类只有一个实例对象<br>该单例对象必须由单例类自行创建<br>单例类对外提供一个访问该单例的全局访问点</p></blockquote><p>创建步骤:</p><ol><li>构造方法私有, 避免外部随便 new</li><li>定义私有的静态单例对象</li><li>对外提供一个访问单例对象的全局访问点<br>重点是单例对象是怎么创建的</li></ol><!-- basicblock-start oid="ObsSYsFf2je5c3qMeVyD8CfH" --> <h1 id="1-懒汉式"><a class="markdownIt-Anchor" href="#1-懒汉式"></a> 1 懒汉式::</h1><!-- basicblock-end --><p>![[懒汉式.excalidraw|1200]]</p><h2 id="11-线程不安全"><a class="markdownIt-Anchor" href="#11-线程不安全"></a> 1.1 线程不安全</h2><p><strong>优点</strong>： 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。<br><strong>需要时才创建</strong></p><p><strong>缺点：</strong><br>线程不安全，多线程环境下，如果多个线程同时进入了<code>if(uniquelnstance == nul)</code>,<br>若此时还未实例化，也就是<code>uniquelnstance==null</code>,那么就会有多个线程执行<code>uniquelnstance=new Singleton();</code>,就会实例化多个实例；此时就不是单例模式了</p><h2 id="12-线程安全"><a class="markdownIt-Anchor" href="#12-线程安全"></a> 1.2 线程安全</h2><p>优点： 延迟实例化，节约了资源，并且是线程安全的。</p><p>缺点： 性能降低了, 实例已经实例化，依然每次都会有锁, 每次只能拿到锁的线程进入该方法, **使线程阻塞，等待时间过长。</p><h2 id="13-双重检查锁实现线程安全"><a class="markdownIt-Anchor" href="#13-双重检查锁实现线程安全"></a> 1.3 双重检查锁实现（线程安全）</h2><p>![[双重检查锁实现（线程安全）.excalidraw|1500]]</p><p>优点： 延迟实例化，节约了资源；线程安全；并且相对于线程安全的懒汉式，性能提高了。<br>缺点： volatile关键字，对性能也有一些影响。</p><!-- basicblock-start oid="Obs8gNBKJObBARZqzMYgfTub" --> <h1 id="2-饿汉式线程安全"><a class="markdownIt-Anchor" href="#2-饿汉式线程安全"></a> 2 饿汉式(线程安全)::</h1><!-- basicblock-end --><p><strong>(直接创建，理解为main执行前，就创建好了)</strong></p><p>![[饿 汉式.02.excalidraw|1200]]</p><p>优点： 提起实例化好了一个实例，避免了线程不安全问题的出现，</p><p>缺点：</p><ul><li>直接实例化了实例，不再延迟实例化；</li></ul><ul><li>若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，<strong>都会使操作系统的资源浪费。</strong></li></ul><blockquote><p>[!example]<br>这种方式导致的问题就像你下载个游戏软件，可能你游戏地图还没有打开呢，但是程序已经将这些地图全部实例化。<br>到你手机上最明显体验就一开游戏内存满了，手机卡了，需要换了。</p></blockquote><!-- basicblock-start oid="ObsSygJ8Gefm1ic4Z2atOcij" --> <h1 id="3-静态内部类实现线程安全"><a class="markdownIt-Anchor" href="#3-静态内部类实现线程安全"></a> 3 静态内部类实现（线程安全）::</h1><p>[[static 关键字]] ^ougi2n</p><!-- basicblock-end --><p>![[静态内部类实现（线程安全）.excalidraw|1000]]</p><!-- basicblock-start oid="ObsEYuFkVke6paJdREdPRUCU" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::单例模式的类别.md"--><h1 id="4-枚举类实现线程安全-不懂"><a class="markdownIt-Anchor" href="#4-枚举类实现线程安全-不懂"></a> 4 枚举类实现（线程安全):: 不懂</h1><!-- basicblock-end --><p>![[枚举类实现（线程安全).excalidraw]]</p><p>优点： 写法简单，线程安全，天然防止反射和反序列化调用。防止反序列化</p><blockquote><p>序列化： 把java对象转换为字节序列的过程；<br>反序列化： 通过这些字节序列在内存中新建java对象的过程；</p></blockquote><p>说明：<br>反序列化将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。<br>我们要防止反序列化，避免得到多个实例，枚举类天然防止反序列化。<br>其他单例模式可以通过重写readResolve()方法，从而防止反序列化，使实例唯一重写</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210041606500.png" alt="|800"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs55CGtGg3QXrFKt66EazYc"  --> <p>#历史记录:: <a href="marginnote3app://note/0188497B-BEF3-46C4-8B7E-56873D2DB0D9">margin : 单例模型6种实现及各实现的优缺点</a><br>2022/10/4🌵单例模式的类别 : 第一次创建</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1344y1g7CL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">单例模式之静态内部类方式_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 创建型模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="/posts/14040/"/>
      <url>/posts/14040/</url>
      
        <content type="html"><![CDATA[<h1 id="1-装饰模式的理论"><a class="markdownIt-Anchor" href="#1-装饰模式的理论"></a> 1 装饰模式的理论::</h1><!-- basicblock-end --><blockquote><p>[!summary] 定义: 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<br>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。</p></blockquote><blockquote><p>[!tip] 什么时候用:<br>装饰模式就是把要附加的功能分别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择的、按顺序的使用装饰功能包装对象。</p></blockquote><p><a href="marginnote3app://note/F16ED398-5E2B-41C1-9410-41BA1ACA0301">margin: 装饰模式结构图</a>: 我感觉不用看这个, 看懂最下边的案例就行<br>![[装饰模式 2022-10-04 21.54.22.excalidraw]]</p><!-- basicblock-start oid="ObsFYjtkPH0qFp3VXZuFqZbR" --> <h1 id="2-装饰模式的案例"><a class="markdownIt-Anchor" href="#2-装饰模式的案例"></a> 2 装饰模式的案例::</h1><!-- basicblock-end --><p>给一个英雄穿上各种衣服(装备), 以增加各种属性</p><p><img src="https://img-blog.csdnimg.cn/fbd2e070adea42f8b43e60b19c4f5a71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//一般情况下，用继承实现类的功能拓展</span><br><span class="hljs-comment">//装饰模式 可以动态给一个类增加功能</span><br><br><span class="hljs-comment">//抽象英雄</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHero</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mHp;<br><span class="hljs-type">int</span> mMp;<br><span class="hljs-type">int</span> mAt;<span class="hljs-comment">// 攻击力</span><br><span class="hljs-type">int</span> mDf;<span class="hljs-comment">// 防御力</span><br>};<br><br><span class="hljs-comment">//具体英雄</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroA</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroA</span>() {<br>mHp = <span class="hljs-number">0</span>;<br>mMp = <span class="hljs-number">0</span>;<br>mAt = <span class="hljs-number">0</span>;<br>mDf = <span class="hljs-number">0</span>;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"血量："</span> &lt;&lt; mHp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"魔法："</span> &lt;&lt; mMp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"攻击："</span> &lt;&lt; mAt &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"防御："</span> &lt;&lt; mDf &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//英雄穿上某个装饰物 那么他还是个英雄</span><br><span class="hljs-comment">//装饰物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractEquipmet</span> : <span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AbstractEquipmet</span>(AbstractHero* hero) {<br><span class="hljs-keyword">this</span>-&gt;pHero = hero; <span class="hljs-comment">// 继承之前的属性</span><br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>AbstractHero* pHero;<br><br>};<br><br><span class="hljs-comment">//狂徒</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KuangtuEquipment</span> :<span class="hljs-keyword">public</span> AbstractEquipmet {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">KuangtuEquipment</span>(AbstractHero* hero) :<span class="hljs-built_in">AbstractEquipmet</span>(hero) {} <span class="hljs-comment">// ❓应该是继承之前的属性吧</span><br><span class="hljs-comment">//增加额外的功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddKuangtu</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄穿上狂徒之后..."</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;mHp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mHp;<br><span class="hljs-keyword">this</span>-&gt;mMp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mMp;<br><span class="hljs-keyword">this</span>-&gt;mAt = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mAt;<br><span class="hljs-keyword">this</span>-&gt;mDf = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mDf + <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;pHero;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">AddKuangtu</span>();<br>cout &lt;&lt; <span class="hljs-string">"血量："</span> &lt;&lt; mHp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"魔法："</span> &lt;&lt; mMp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"攻击："</span> &lt;&lt; mAt &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"防御："</span> &lt;&lt; mDf &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//无尽</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wujing</span> : <span class="hljs-keyword">public</span> AbstractEquipmet {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Wujing</span>(AbstractHero* hero) :<span class="hljs-built_in">AbstractEquipmet</span>(hero) {}<br><span class="hljs-comment">//增加额外的功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddWujing</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄穿上无尽之后..."</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;mHp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mHp;<br><span class="hljs-keyword">this</span>-&gt;mMp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mMp;<br><span class="hljs-keyword">this</span>-&gt;mAt = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mAt + <span class="hljs-number">80</span>;<br><span class="hljs-keyword">this</span>-&gt;mDf = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mDf;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;pHero;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">AddWujing</span>();<br>cout &lt;&lt; <span class="hljs-string">"血量："</span> &lt;&lt; mHp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"魔法："</span> &lt;&lt; mMp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"攻击："</span> &lt;&lt; mAt &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"防御："</span> &lt;&lt; mDf &lt;&lt; endl;<br>}<br>};<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>AbstractHero* hero = <span class="hljs-keyword">new</span> HeroA;<br>hero-&gt;<span class="hljs-built_in">ShowStatus</span>();<br>cout &lt;&lt; <span class="hljs-string">"----------------------------"</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//给裸奔的英雄穿上衣服后</span><br>hero = <span class="hljs-keyword">new</span> <span class="hljs-built_in">KuangtuEquipment</span>(hero);<br>hero-&gt;<span class="hljs-built_in">ShowStatus</span>();<br><br>cout &lt;&lt; <span class="hljs-string">"----------------------------"</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//装备武器</span><br>hero = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Wujing</span>(hero);<br>hero-&gt;<span class="hljs-built_in">ShowStatus</span>();<br><br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/f27bb61be3924b958509187cb02c9442.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><!-- basicblock-start oid="Obs9XzwL64CuPFabz88Ayxfm" --> <h1 id="3-装饰模式的优缺点"><a class="markdownIt-Anchor" href="#3-装饰模式的优缺点"></a> 3 装饰模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1)对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</p><p>(2)可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。</p><p>(3)可以对一个对象进行多次装饰。</p><p>(4)具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</p><p><strong>缺点：</strong></p><p>使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。</p><!-- basicblock-start oid="ObsysPFc7oqSZNfC01E2tz7l" --> <h1 id="4-装饰模式的适用场景"><a class="markdownIt-Anchor" href="#4-装饰模式的适用场景"></a> 4 装饰模式的适用场景::</h1><!-- basicblock-end --><p>(1) 动态、透明的方式给单个对象添加职责。</p><p>(2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。</p><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObswmkOaFSGS0t3Vq594ZSmF" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::结构型模式::装饰模式.md" --> <p>#历史记录::<br>2022/10/4🌵装饰模式 : 第一次创建</p><!-- basicblock-end --><p><a href="marginnote3app://note/8B983839-DEFA-4C02-933D-D7C97AFE5A8F">margin: 装饰模式</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/posts/7739/"/>
      <url>/posts/7739/</url>
      
        <content type="html"><![CDATA[<h1 id="1-观察者模式的理论"><a class="markdownIt-Anchor" href="#1-观察者模式的理论"></a> 1 观察者模式的理论::</h1><!-- basicblock-end --><p>它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。<br>这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。<br>![[观察者模式 2022-10-04 20.36.01.excalidraw]]</p><h2 id="11-主要构成"><a class="markdownIt-Anchor" href="#11-主要构成"></a> 1.1 主要构成</h2><p><strong>Subject(抽象被观察者)</strong>：<br>将所有观察者对象保存到一个集合里（通常是ArrayList),主题可以有任意数量的观察者，抽象主题提供增加、删除观察者对象的接口(attach、detach)</p><p><strong>Observer(抽象观察者)</strong>：<br>它定义了一个更新接口方法(update),使得在得到主题更改通知时更新自己</p><p><strong>ConcreteSubject(具体被观察者)</strong>：  红绿灯<br>有关状态存入具体观察者对象，具体被观察者的内部状态发生改变时，给所有加入过的观察者发送通知。</p><p><strong>ConcreteObserver(具体观察者)</strong>：车辆<br>实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p><h2 id="12-优缺点"><a class="markdownIt-Anchor" href="#12-优缺点"></a> 1.2 优缺点</h2><p>优点： 解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换</p><p>缺点： 调试复杂，而且在java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。</p><!-- basicblock-start oid="ObsoM1zvXwXJcvLx9wrf8Wra" --> <h1 id="2-观察者模式的案例"><a class="markdownIt-Anchor" href="#2-观察者模式的案例"></a> 2 观察者模式的案例::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/faea0b63bf5547849e88e3b8a42c27c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span><span class="hljs-comment">// 英雄队列</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象的英雄</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHero</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroA</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroA</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄A正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄A停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroB</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroB</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄B正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄B停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroC</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroC</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄C正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄C停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroD</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroD</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄D正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄D停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroE</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroE</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄E正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄E停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//观察目标抽象: BOSS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBoss</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//添加观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//删除观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">deleteHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//通知所有观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//具体的观察者 BOSSA</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BOSSA</span> :<span class="hljs-keyword">public</span> AbstractBoss {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//添加观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>{<br>pHeroList.<span class="hljs-built_in">push_back</span>(hero); <span class="hljs-comment">// 往队列里添加一个英雄</span><br>}<br><span class="hljs-comment">//删除观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">deleteHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>{<br>pHeroList.<span class="hljs-built_in">remove</span>(hero);<br>}<br><span class="hljs-comment">//通知所有观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">for</span> (list&lt;AbstractHero*&gt;::iterator it = pHeroList.<span class="hljs-built_in">begin</span>(); it != pHeroList.<span class="hljs-built_in">end</span>();it++) {<br>(*it)-&gt;<span class="hljs-built_in">Update</span>();<br>}<br>}<br><span class="hljs-keyword">public</span>:<br>list&lt;AbstractHero*&gt; pHeroList;<span class="hljs-comment">// 英雄队列</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">//创建观察者</span><br>AbstractHero* heroA = <span class="hljs-keyword">new</span> HeroA;<br>AbstractHero* heroB = <span class="hljs-keyword">new</span> HeroB;<br>AbstractHero* heroC = <span class="hljs-keyword">new</span> HeroC;<br>AbstractHero* heroD = <span class="hljs-keyword">new</span> HeroD;<br>AbstractHero* heroE = <span class="hljs-keyword">new</span> HeroE;<br><br><span class="hljs-comment">//创建观测目标</span><br>AbstractBoss* bossA = <span class="hljs-keyword">new</span> BOSSA;<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroA);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroB);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroC);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroD);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroE);<br><br>cout &lt;&lt; <span class="hljs-string">"heroC阵亡..."</span> &lt;&lt; endl;<br>bossA-&gt;<span class="hljs-built_in">deleteHero</span>(heroC);<br><br>cout &lt;&lt; <span class="hljs-string">"BOSS死了...通知其他英雄停止攻击，抢装备..."</span> &lt;&lt; endl;;<br>bossA-&gt;<span class="hljs-built_in">notify</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/197e38fd39f34c4a888b3b3d706486e1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsAevvR48nFdqLiDjbPFxmB" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::行为型模式::观察者模式.md" --> <p>#历史记录::<br>2022/10/4🌵观察者模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/posts/58640/"/>
      <url>/posts/58640/</url>
      
        <content type="html"><![CDATA[<h1 id="1-策略模式的理论"><a class="markdownIt-Anchor" href="#1-策略模式的理论"></a> 1 策略模式的理论::</h1><!-- basicblock-end --><blockquote><p>[!Summary] 我感觉策略模式就是普通的继承+重写: 看例子吧</p></blockquote><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。<br>策略模式让算法独立于使用它的客户而独立变化。</p><blockquote><p>[!summary]  总结: 对象通过不同的策略完成不同的动作<br>也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为引起环境角色表现出不同的行为。</p></blockquote><h2 id="11-优缺点"><a class="markdownIt-Anchor" href="#11-优缺点"></a> 1.1 优缺点</h2><p><strong>优点:</strong></p><p>(1)策略模式提供了对“<strong>开闭原则”的完美支持</strong>，<br>用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p><p>(2)使用策略模式可以避免多重条件选择语句(if-else)。</p><blockquote><p>[!quote] 直接修改 if-else 语句可能会导致错误<br>多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</p></blockquote><p>(3)策略模式提供了一种算法的复用机制。<br>由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</p><p><strong>缺点：</strong></p><p>(1)客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<strong>策略模式只适用于客户端知道所有的算法或行为的情况。</strong><br>这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，<strong>策略模式只适用于客户端知道所有的算法或行为的情况。</strong></p><p>(2)策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p><h2 id="12-主要构成"><a class="markdownIt-Anchor" href="#12-主要构成"></a> 1.2 主要构成</h2><p>Stragety(策略的抽象，接口)<br>ConcreteStragetyA、ConcreteStrategyB.(具体的策略实现类)<br>Context(用来操作策略的上下文环境类)：环境类的构造函数包含了Strategy类，通过多态传进来不同的具体策略(ConcreteStrategyA。ConcreteStrategyB)来调用不同策略的方法</p><!-- basicblock-start oid="ObsPa45lYeT48TZkO5sG4axM" --> <h1 id="2-策略模式的案例"><a class="markdownIt-Anchor" href="#2-策略模式的案例"></a> 2 策略模式的案例::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/ea96f816090a48c8937389ac64ba8010.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象武器 武器策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeaponStrategy</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">UseWeapon</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife</span> : <span class="hljs-keyword">public</span> WeaponStrategy { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">UseWeapon</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 重写</span><br>cout &lt;&lt; <span class="hljs-string">"使用匕首!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AK47</span> : <span class="hljs-keyword">public</span> WeaponStrategy{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">UseWeapon</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"使用AK47!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWeapon</span><span class="hljs-params">(WeaponStrategy* weapon)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pWeapon = weapon;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThrowWeapon</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 挥舞武器(使用武器)</span><br><span class="hljs-keyword">this</span>-&gt;pWeapon-&gt;<span class="hljs-built_in">UseWeapon</span>();<br>}<br><span class="hljs-keyword">private</span>:<br>WeaponStrategy* pWeapon;<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">//创建角色</span><br>Character* character = <span class="hljs-keyword">new</span> Character;<br><br><span class="hljs-comment">//武器策略</span><br>WeaponStrategy* knife = <span class="hljs-keyword">new</span> Knife;<br>WeaponStrategy* ak47 = <span class="hljs-keyword">new</span> AK47;<br><br>character-&gt;<span class="hljs-built_in">setWeapon</span>(knife);<br>character-&gt;<span class="hljs-built_in">ThrowWeapon</span>();<br><br>character-&gt;<span class="hljs-built_in">setWeapon</span>(ak47);<br>character-&gt;<span class="hljs-built_in">ThrowWeapon</span>();<br><br><span class="hljs-keyword">delete</span> ak47;<br><span class="hljs-keyword">delete</span> knife;<br><span class="hljs-keyword">delete</span> character;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsQ7GseC9e9gV5sAjQvFl3X" --> <h1 id="3-策略模式的适用场景"><a class="markdownIt-Anchor" href="#3-策略模式的适用场景"></a> 3 策略模式的适用场景::</h1><!-- basicblock-end --><p>准备一组算法，并将每一个算法封装起来，使得它们可以互换。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsJ2qpT7MLTVZ8c5qcAAldg" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::行为型模式::策略模式.md" --> <p>#历史记录::<br>2022/10/4🌵策略模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/posts/22978/"/>
      <url>/posts/22978/</url>
      
        <content type="html"><![CDATA[<h1 id="1-命令模式的理论"><a class="markdownIt-Anchor" href="#1-命令模式的理论"></a> 1 命令模式的理论</h1><p>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；<br>对请求排队或者记录请求日志，以及支持可撤销的操作。<br>命令模式是一种对象行为型模式，其别名为动作(Action)模式或事(Transaction)模式。</p><p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><p><img src="https://img-blog.csdnimg.cn/b6bc474a9cd640a3bdfa50f75544f544.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="2-命令模式的案例"><a class="markdownIt-Anchor" href="#2-命令模式的案例"></a> 2 命令模式的案例</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span><span class="hljs-comment">// 给请求排队</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//协议处理类: 💡处理客户端可能发来的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleClientProtocol</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//处理增加金币</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddMoney</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家增加金币！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//处理增加钻石</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddDiamod</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家增加钻石！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//处理玩家装备</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddEquipment</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家穿装备！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//处理玩家升级</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddLevel</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家升级！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//命令接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCommand</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//处理客户端请求的接口</span><br>};<br><br><span class="hljs-comment">//处理增加金币请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddMoneyCommand</span> :<span class="hljs-keyword">public</span> AbstractCommand {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddMoneyCommand</span>(HandleClientProtocol* protocol) { <span class="hljs-comment">// ❓</span><br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写</span><br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddMoney</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//处理增加钻石的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddDimondCommnd</span> :<span class="hljs-keyword">public</span> AbstractCommand{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddDimondCommnd</span>(HandleClientProtocol* protocol) {<br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddDiamod</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//处理玩家装备装备的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddEquipmentCommnd</span> :<span class="hljs-keyword">public</span> AbstractCommand {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddEquipmentCommnd</span>(HandleClientProtocol* protocol) {<br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddEquipment</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//处理玩家升级的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddLevelCommand</span> :<span class="hljs-keyword">public</span> AbstractCommand {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddLevelCommand</span>(HandleClientProtocol* protocol) {<br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddLevel</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//服务器程序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRequest</span><span class="hljs-params">(AbstractCommand* command)</span> </span>{<br>mCommands.<span class="hljs-built_in">push</span>(command); <span class="hljs-comment">// 入队</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startHandle</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 开始处理</span><br><span class="hljs-keyword">while</span> (!mCommands.<span class="hljs-built_in">empty</span>()) {<br><br><span class="hljs-built_in">Sleep</span>(<span class="hljs-number">2000</span>);<br><br>AbstractCommand* command = mCommands.<span class="hljs-built_in">front</span>();<br>command-&gt;<span class="hljs-built_in">handle</span>();<br>mCommands.<span class="hljs-built_in">pop</span>();<br>}<br>}<br><span class="hljs-keyword">public</span>:<br>queue&lt;AbstractCommand*&gt; mCommands;<span class="hljs-comment">// 待处理的请求都在这里, 让他们排队</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><br>HandleClientProtocol* protocol = <span class="hljs-keyword">new</span> HandleClientProtocol;<br><span class="hljs-comment">//客户端增加金币的请求</span><br>AbstractCommand* addmoney = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddMoneyCommand</span>(protocol);<br><span class="hljs-comment">//客户端增加钻石的请求</span><br>AbstractCommand* adddimond = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddDimondCommnd</span>(protocol);<br><span class="hljs-comment">//客户端穿装备的请求</span><br>AbstractCommand* addequiment = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddEquipmentCommnd</span>(protocol);<br><span class="hljs-comment">//客户端升级的请求</span><br>AbstractCommand* addlevel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddLevelCommand</span>(protocol);<br><br><span class="hljs-comment">//将客户端请求加入到处理的队列中</span><br>Server* server = <span class="hljs-keyword">new</span> Server;<br>server-&gt;<span class="hljs-built_in">addRequest</span>(addmoney);<br>server-&gt;<span class="hljs-built_in">addRequest</span>(adddimond);<br>server-&gt;<span class="hljs-built_in">addRequest</span>(addequiment);<br>server-&gt;<span class="hljs-built_in">addRequest</span>(addlevel);<br><br><span class="hljs-comment">//服务器开始处理请求</span><br>server-&gt;<span class="hljs-built_in">startHandle</span>();<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-命令模式的优缺点"><a class="markdownIt-Anchor" href="#3-命令模式的优缺点"></a> 3 命令模式的优缺点</h1><p><strong>优点：</strong></p><p>​ (1)降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</p><p>(2)新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。</p><p>(3)可以比较容易地设计一个命令队列或宏命令（组合命令）。</p><p><strong>缺点：</strong><br>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</p><h1 id="4-命令模式的适用场景"><a class="markdownIt-Anchor" href="#4-命令模式的适用场景"></a> 4 命令模式的适用场景</h1><p>(1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</p><p>(2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</p><p>(3) 系统需要将一组操作组合在一起形成宏命令。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsv9P0LVOEViF3ttUYB6qU7" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::行为型模式::命令模式.md" --> <p>#历史记录::<br>2022/10/2🌵命令模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/posts/42856/"/>
      <url>/posts/42856/</url>
      
        <content type="html"><![CDATA[<p>行为型模式: 用来对类或对象怎样交互和怎样分配职责进行描述。</p><!-- basicblock-start oid="Obs0wj56nH90qhsOwgG1cLQt" --> <h1 id="1-模板方法的理论"><a class="markdownIt-Anchor" href="#1-模板方法的理论"></a> 1 模板方法的理论::</h1><!-- basicblock-end --><p>![[模板方法模式 2022-10-02 22.58.16.excalidraw]]</p><ul><li>&amp; 定义一个操作中算法的<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020">框架</a>，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li></ul><!-- basicblock-start oid="ObsdstvOGbnX9W0wLZrnfd9r" --> <h1 id="2-模板方法的案例"><a class="markdownIt-Anchor" href="#2-模板方法的案例"></a> 2 模板方法的案例::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/618b7109db364e98bb0b9e99870ed137.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DrinkTemplate</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//注水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boildwater</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//加辅助料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//模板方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Make</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">Boildwater</span>();<br><span class="hljs-built_in">Brew</span>();<br><span class="hljs-built_in">PourInCup</span>();<br><span class="hljs-built_in">AddSomething</span>();<br>}<br>};<br><br><span class="hljs-comment">//冲泡咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> DrinkTemplate {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//注水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boildwater</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"煮山泉水..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"冲泡咖啡..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"咖啡倒入杯中..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//加辅助料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddSomething</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"加糖，加牛奶，加点醋..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//冲泡茶</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> DrinkTemplate {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//注水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boildwater</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"煮自来水..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"冲泡铁观音..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"茶水倒入杯中..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//加辅助料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddSomething</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"加糖，加柠檬，加生姜..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><br>DrinkTemplate* tea = <span class="hljs-keyword">new</span> Tea;<br>tea-&gt;<span class="hljs-built_in">Make</span>();<br><br>cout &lt;&lt; <span class="hljs-string">"----------------"</span> &lt;&lt; endl;<br><br>DrinkTemplate* coffee = <span class="hljs-keyword">new</span> Coffee;<br>coffee-&gt;<span class="hljs-built_in">Make</span>();<br><br><span class="hljs-keyword">delete</span> tea;<br><span class="hljs-keyword">delete</span> coffee;<br>}<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsSJ1jlWHX1gT3RxypseEhf" --> <h1 id="3-模板方法模式的优缺点"><a class="markdownIt-Anchor" href="#3-模板方法模式的优缺点"></a> 3 模板方法模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1)在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</p><p>(2)模板方法模式是一种代码复用技术，它在类库设计中尤为重要，<strong>它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</strong></p><p>(3)可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</p><p>(4)在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</p><p><strong>缺点：</strong><br>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2PZn2klaTlt8zwXXH41qS" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::行为型模式::模板方法模式.md" --> <p>#历史记录::<br>2022/10/2🌵模板方法模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 行为型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/posts/39555/"/>
      <url>/posts/39555/</url>
      
        <content type="html"><![CDATA[<h1 id="1-适配器模式理论"><a class="markdownIt-Anchor" href="#1-适配器模式理论"></a> 1 适配器模式理论::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/5b3e4c76c6d94290936feeb60948108c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><!-- basicblock-start oid="ObsNl3SHTLsjJZdKnoU0uiZR" --> <h1 id="2-适配器模式案例"><a class="markdownIt-Anchor" href="#2-适配器模式案例"></a> 2 适配器模式案例::</h1><!-- basicblock-end --><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//💡适配器模式 就是将已经写好的接口(但是这个接口不符合需求), 转换成目标接口</span><br><br><span class="hljs-comment">//这函数我已经写好了</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myprint</span>{<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span> </span>{<br>cout &lt;&lt; v1 + v2 &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//定义目标接口 我要适配成什么样的，</span><br><span class="hljs-comment">//要适配成只能传一个参数的，适配for_each第三个参数的适用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>= <span class="hljs-number">0</span>;{<span class="hljs-comment">// 💡目标接口, 只有一个参数</span><br><br>};<br><br><span class="hljs-comment">//写适配器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapater</span> :<span class="hljs-keyword">public</span> Target {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Adapater</span>(<span class="hljs-type">int</span> param) {<br><span class="hljs-keyword">this</span>-&gt;param = param;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(v,param)</span></span>;<br>}<br><span class="hljs-keyword">public</span>:<br>Myprint print;<br><span class="hljs-type">int</span> param;<br>};<br><br><span class="hljs-comment">//MyBind2nd，原来param固定的10，现在提供一个方法改</span><br><span class="hljs-function">Adapater <span class="hljs-title">MyBind2nd</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Adapater</span>(v);<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>v.<span class="hljs-built_in">push_back</span>(i);<br>}<br><br><span class="hljs-comment">//适配器模式的运用</span><br><span class="hljs-comment">//for_each()的第三个参数是个带一个参数的函数，但是Myprint需要两个参数</span><br>for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MyBind2nd</span>(<span class="hljs-number">10</span>));<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsmDTz27IdYee6u3DZUTCan" --> <h1 id="3-适配器模式的优缺点"><a class="markdownIt-Anchor" href="#3-适配器模式的优缺点"></a> 3 适配器模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1)将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p><p>(2)增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p><p>(3)灵活性和扩展性都非常好，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p><p><strong>缺点：</strong></p><p>适配器中置换适配者类的某些方法比较麻烦。</p><!-- basicblock-start oid="ObsN8UYJcNVWVxTFOlqKIia8" --> <h1 id="4-适配器模式的适用场景"><a class="markdownIt-Anchor" href="#4-适配器模式的适用场景"></a> 4 适配器模式的适用场景::</h1><!-- basicblock-end --><p>(1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</p><p>(2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsrmtbAdbqS65DuTo7TmCAI" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::结构型模式::适配器模式.md" --> <p>#历史记录::<br>2022/10/2🌵适配器模式 : 代码没听懂⏱0-15<br><a href="https://www.bilibili.com/video/BV1Mb411t7ut?p=34&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">3-04 适配器模式_哔哩哔哩_bilibili</a></p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/posts/33101/"/>
      <url>/posts/33101/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><blockquote><p>废话理论（建议直接看总结）：</p><p>根据迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。</p><p>Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。</p></blockquote><blockquote><p>[!summary] 总结：<br>外观模式就是将复杂的子类系统抽象到同一个的接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必要直接与复杂的子类系统进行交互。</p></blockquote><!-- basicblock-start oid="ObsNzszGnr0QFlXbyTcA0BUi" --> <h1 id="2-外观模式的案例"><a class="markdownIt-Anchor" href="#2-外观模式的案例"></a> 2 外观模式的案例::</h1><!-- basicblock-end --><p>根据类图，实现家庭影院外观模式应用。<br>实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，dvd打开；<br>实现游戏模式：电视打开，音响打开，游戏机打开。</p><p><img src="https://img-blog.csdnimg.cn/6b54a7eca1714ea4983ec47f238ce192.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//电视机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Televison</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"电视机打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"电视机关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//灯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"灯打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"灯关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//音箱</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Audio</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"音箱打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"音箱关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//麦克风</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Microphone</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"麦克风打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"麦克风关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//DVD</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DVDPlayer</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"DVD播放器打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"DVD播放器关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//游戏机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gamemachine</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"游戏机打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"游戏机关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">// 💡外观模式 1</span><br><span class="hljs-comment">//KTV模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KTVModel</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">KTVModel</span>() {  <span class="hljs-comment">// 创建对象</span><br>pTv = <span class="hljs-keyword">new</span> Televison;<br>pLight = <span class="hljs-keyword">new</span> Light;<br>pAudio = <span class="hljs-keyword">new</span> Audio;<br>pMicrophone = <span class="hljs-keyword">new</span> Microphone;<br>pDVD = <span class="hljs-keyword">new</span> DVDPlayer;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnKtv</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 打开</span><br>pTv-&gt;<span class="hljs-built_in">On</span>();<br>pLight-&gt;<span class="hljs-built_in">Off</span>();<br>pAudio-&gt;<span class="hljs-built_in">On</span>();<br>pMicrophone-&gt;<span class="hljs-built_in">On</span>();<br>pDVD-&gt;<span class="hljs-built_in">On</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OffKtv</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 关闭</span><br>pTv-&gt;<span class="hljs-built_in">Off</span>();<br>pLight-&gt;<span class="hljs-built_in">On</span>();<br>pAudio-&gt;<span class="hljs-built_in">Off</span>();<br>pMicrophone-&gt;<span class="hljs-built_in">Off</span>();<br>pDVD-&gt;<span class="hljs-built_in">Off</span>();<br>}<br><br>~<span class="hljs-built_in">KTVModel</span>() { <span class="hljs-comment">// 析构</span><br><span class="hljs-keyword">delete</span> pTv;<br><span class="hljs-keyword">delete</span> pLight;<br><span class="hljs-keyword">delete</span> pAudio;<br><span class="hljs-keyword">delete</span> pMicrophone;<br><span class="hljs-keyword">delete</span> pDVD;<br>}<br><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 先定义对象</span><br>Televison* pTv;<br>Light* pLight;<br>Audio* pAudio;<br>Microphone* pMicrophone;<br>DVDPlayer* pDVD;<br>};<br><br><span class="hljs-comment">// 游戏模式同理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>KTVModel* ktv = <span class="hljs-keyword">new</span> KTVModel; <span class="hljs-comment">// 只和 KEVmode 打交道就行了</span><br>ktv-&gt;<span class="hljs-built_in">OnKtv</span>();<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsNnwrWwy6xyYvYmICn3jY1" --> <h1 id="3-外观模式的优缺点"><a class="markdownIt-Anchor" href="#3-外观模式的优缺点"></a> 3 外观模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1) 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。<br>通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</p><p>(2)它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，<strong>只需要调整外观类</strong>即可。</p><p>(3)一个子系统的修改对其他子系统没有任何影响。</p><p><strong>缺点：</strong></p><p>(1)不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</p><p>(2)如果设计不当，<strong>增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</strong></p><!-- basicblock-start oid="Obsa9mNTBwX4GDzWgvOJKc2m" --> <h1 id="4-外观模式的适用场景"><a class="markdownIt-Anchor" href="#4-外观模式的适用场景"></a> 4 外观模式的适用场景::</h1><!-- basicblock-end --><p>(1) 复杂系统需要简单入口使用。</p><p>(2) 客户端程序与多个子系统之间存在很大的依赖性。</p><p>(3) 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsew9tJ8MecAJrNV6P29x4s"  --> <p>#历史记录::<br>2022/10/2🌵外观模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/posts/48004/"/>
      <url>/posts/48004/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><p>代理模式的定义：<strong>为其他对象提供一种代理(方式)以控制对这个对象的访问</strong>。<br>在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>![[代理模式结构图.excalidraw]]<br>![[代理模式 2022-10-02 20.43.18.excalidraw]]</p><h2 id="11-远程代理"><a class="markdownIt-Anchor" href="#11-远程代理"></a> 1.1 远程代理</h2><p>一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。</p><blockquote><p>[!example]<br>“哈，其实你是一定用过的，WebService <a href="http://xn--3ds.NET">在.NET</a> 中的应用是怎么做的？”<br>“哦，我明白什么叫远程代理了，当我在应用程序的项目中加入一个 web 引用，引用一个 webService,<br>时会在项目中生成一个 WebReference 的文件夹和一些文件，其实它们就是代理，这就使得客户端程序<br>用代理就可以解决远程访问的问题。原来这就是代理模式的应用呀。”</p></blockquote><h2 id="12-虚拟代理"><a class="markdownIt-Anchor" href="#12-虚拟代理"></a> 1.2 虚拟代理</h2><p>根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象，这样就可以达到性能的最优化。</p><blockquote><p>[!example]<br>比如说你打开一个很大的 HTML 网页时，里面可能有很多的文字和图片，但你还是可以很快打开它，此时你所看到的是所有的文字，但图片却是一张一张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。<br>原来浏览器当中是用代理模式来优化下载的。</p></blockquote><h2 id="13-安全代理"><a class="markdownIt-Anchor" href="#13-安全代理"></a> 1.3 安全代理</h2><p>用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。</p><h2 id="14-智能指引"><a class="markdownIt-Anchor" href="#14-智能指引"></a> 1.4 智能指引</h2><p>是指当调用真实的对象时，代理处理另外一些事。</p><p>1如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。</p><p>代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。<br>“哦，明白。说白了，代理就是真实对象的代表。</p><h1 id="2-代理模式的案例"><a class="markdownIt-Anchor" href="#2-代理模式的案例"></a> 2 代理模式的案例::</h1><blockquote><p>传统方法局限：是个人都能调用</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//提供一种代理来控制对其他对象的访问</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstraactCommonInterface</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-comment">//我已经写好的系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mysystem</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"系统启动..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//必须有权限验证，不是所有人都能来启动我的启动，必须提供用户名和密码</span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">//这样不行。是个人都能启动</span><br>Mysystem* system = <span class="hljs-keyword">new</span> Mysystem;<br>system -&gt; <span class="hljs-built_in">run</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//提供一种代理来控制对其他对象的访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstraactCommonInterface</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-comment">//我已经写好的系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mysystem</span> :<span class="hljs-keyword">public</span> AbstraactCommonInterface{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"系统启动..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//💡: 用一个代理类来管理用户</span><br><span class="hljs-comment">// 必须有权限验证，不是所有人都能来启动我的启动，必须提供用户名和密码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MysystemProxy</span> :<span class="hljs-keyword">public</span> AbstraactCommonInterface {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MysystemProxy</span>(string username,string password) {<br><span class="hljs-keyword">this</span>-&gt;mUsername = username;<br><span class="hljs-keyword">this</span>-&gt;mPassword = mPassword;<br><br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkUsernameAndPassword</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (mUsername == <span class="hljs-string">"admin"</span>&amp;&amp;mPassword == <span class="hljs-string">"admin"</span>) { <span class="hljs-comment">// admin 只是一个例子</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkUsernameAndPassword</span>()) {<br>cout &lt;&lt; <span class="hljs-string">"用户名和密码正确，验证通过..."</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;pSystem-&gt;<span class="hljs-built_in">run</span>();<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"用户名或密码错误，权限不足...."</span> &lt;&lt; endl;<br>}<br>}<br>~<span class="hljs-built_in">MysystemProxy</span>() { <span class="hljs-comment">// 析构函数</span><br><span class="hljs-keyword">if</span> (pSystem != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> pSystem;<br>}<br>}<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 💡需要的变量</span><br>Mysystem* pSystem;<br>string mUsername;<br>string mPassword;<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>MysystemProxy* proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MysystemProxy</span>(<span class="hljs-string">"root"</span>,<span class="hljs-string">"admin"</span>); <span class="hljs-comment">// 💡通过代理启动</span><br>proxy-&gt;<span class="hljs-built_in">run</span>();<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">//这样不行。是个人都能启动</span><br>Mysystem* system = <span class="hljs-keyword">new</span> Mysystem;<br>system -&gt; <span class="hljs-built_in">run</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//调用代理模式</span><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/ab34facdb3e74edf86bf646b2491cd0d.png#pic_center" alt="在这里插入图片描述"></p><h1 id="3-代理模式的优缺点"><a class="markdownIt-Anchor" href="#3-代理模式的优缺点"></a> 3 代理模式的优缺点::</h1><p><strong>优点：</strong></p><p>(1)能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。<br>(2)客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，<strong>符合开闭原则</strong>，系统具有较好的灵活性和可扩展性。</p><p><strong>缺点：</strong><br>代理实现较为复杂。</p><h1 id="4-代理模式的适用场景"><a class="markdownIt-Anchor" href="#4-代理模式的适用场景"></a> 4 代理模式的适用场景::</h1><p>为其他对象提供一种代理以控制对这个对象的访问。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsgHSYGOytuVKUVix8FoW7G" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::结构型模式::代理模式.md" --> <p>#历史记录:: <a href="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">margin: 代理模式</a><br>2022/10/2🌵代理模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 结构型模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/56170/"/>
      <url>/posts/56170/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单列模式: 系统只有一个对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>{<br><br>A a; <span class="hljs-comment">// 这个系统中只能有一个 A 类型的对象</span><br><br>}<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!summary] 单例模式: 保证一个类仅有一个实例，并提供一个访问它的全局访问点<br>方便对实例个数的控制并节约系统资源。</p></blockquote><p>![[单例模式 2022-10-04 14.40.48.excalidraw]]</p><!-- basicblock-start oid="ObsHlpWnjsCHM3IRkNfhQlY8" --> <h1 id="2-实现单例步骤"><a class="markdownIt-Anchor" href="#2-实现单例步骤"></a> 2 实现单例步骤::</h1><!-- basicblock-end --><p><strong>使用</strong></p><ul><li>私有构造函数<ul><li>不能让别人 new 它， 确保单例类只能自己创建实例</li></ul></li><li>私有静态变量<ul><li>确保只有一个实例</li></ul></li><li>公有静态函数<ul><li>提供静态对外接口，可以让用户获得单例对象</li></ul></li></ul><p>私有构造函数保证了不能通过构造函数来创建对象，只能通过公有静态函数返回唯一私有静态变量</p><!-- basicblock-start oid="ObsdmaP5SKhIhMztoi9JmS5M" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::单例模式.md"--><p><strong>原则:</strong></p><ol><li>私有构造 (防止类通过常规方法实例化)</li><li>以静态方法或者枚举返回实例。 (保证实例的唯一性)</li><li>确保实例只有一个，尤其是多线程环境。(保证创建实例的线程安全)</li><li>❓确保反序列化时不会重新构造对象。(在有序列化反序列化的场景下防止单例被莫名破坏)</li></ol> <!-- basicblock-end --><blockquote><p>[!tip]<br>简单来说就是，单例类的构造方不让其他人修改和使用；<br>并且单例类自己只创建一个实例，这个实例，其他人也无法修改和直接使用；<br>然后单例类提供一个调用方法，想用这个实例，只能调用。这样就确保了全局只创建了一个实例。<br><a href="https://www.bilibili.com/video/BV1Mb411t7ut?p=23&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=256.728737">04:16</a></p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">private</span>: <span class="hljs-comment">// 1️⃣.构造函数私有化 : 不能让别人 new 它</span><br><span class="hljs-built_in">A</span>() {<br>a = <span class="hljs-keyword">new</span> A;<br>}<br><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//2️⃣.增加静态 + 私有, 的当前类的指针变量</span><br><span class="hljs-comment">// private 的原因是不能让别人直接访问到 a, 想访问它只能通过 getInstance</span><br><span class="hljs-comment">// 如果用 public, 别人可以直接通过 A::a 访问到 A</span><br><span class="hljs-type">static</span> A* a; <span class="hljs-comment">// 💡加了 static 后, 静态的成员函数可以通过类名去调用: A::a;</span><br><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//3️⃣.提供静态对外接口(public)，可以让用户获得单例对象</span><br><span class="hljs-function"><span class="hljs-type">static</span> A* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> a;<br>}<br>};<br><br><br>A* A::a = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 类外初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>{<br>A a; <span class="hljs-comment">// ❗️或A*a=new A;  这两个会调用构造函数，要让不能构造函数, 想访问它只能通过 getInstance</span><br>A::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">// 访问 a</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs7JAJIyiYk5eIowHrKVi9b" --> <h1 id="3-单例模式的类别"><a class="markdownIt-Anchor" href="#3-单例模式的类别"></a> 3 [[单例模式的类别]]::</h1><!-- basicblock-end --><h1 id="4-懒汉-饿汉黑马案例"><a class="markdownIt-Anchor" href="#4-懒汉-饿汉黑马案例"></a> 4 懒汉, 饿汉黑马案例</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//单例 分为懒汉式 饿汉式</span><br><br><span class="hljs-comment">// ---💡接着上面的代码的---</span><br><span class="hljs-comment">//1.懒汉式(需要的时候才会创建)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_lazy</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_lazy</span>() { cout &lt;&lt; <span class="hljs-string">"我是懒汉构造！"</span> &lt;&lt; endl; }<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_lazy* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 第一次用的时候在创建</span><br><span class="hljs-keyword">if</span> (pSingleton == <span class="hljs-literal">NULL</span>) {<br>pSingleton = <span class="hljs-keyword">new</span> Singleton_lazy;<br>}<br><span class="hljs-keyword">return</span> pSingleton;<br>}<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_lazy* pSingleton;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_lazy* Singleton_lazy::pSingleton = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//2.饿汉式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_hungry</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_hungry</span>() { cout &lt;&lt; <span class="hljs-string">"我是饿汉构造！"</span> &lt;&lt; endl; }<span class="hljs-comment">// 💡在 main 函数之前就创建了</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_hungry* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> pSingleton;<span class="hljs-comment">// 💡上面没有判断了</span><br>}<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_hungry* pSingleton;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_hungry* Singleton_hungry::pSingleton = <span class="hljs-keyword">new</span> Singleton_hungry;<span class="hljs-comment">// 💡在这 new, 在 main 函数之前就创建了</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>Singleton_lazy* p1 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">// 💡取到单例对象</span><br>Singleton_lazy* p2 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p1 == p2) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式！"</span> &lt;&lt; endl;<br>}<br><br>Singleton_hungry* p3 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">// 💡取到单例对象</span><br>Singleton_hungry* p4 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p3 == p4) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式!"</span> &lt;&lt; endl;<br>}<br>}<br><span class="hljs-comment">// 💡经测试, 以上两个都是单例对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-comment">//A a; // 或A*a=new A;  这两个会调用构造函数，要让不能构造函数</span><br><span class="hljs-comment">//A::getInstance();💡静态的成员函数可以通过类名去调用</span><br><br><span class="hljs-built_in">test01</span>();<br>cout &lt;&lt; <span class="hljs-string">"main函数开始执行！"</span> &lt;&lt; endl;<br><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsTE2UQF3DlSrNjS7wSnSIc" --> <h1 id="5-单例对象释放"><a class="markdownIt-Anchor" href="#5-单例对象释放"></a> 5 单例对象释放::</h1><!-- basicblock-end --><p>不用考虑内存释放问题</p><blockquote><p>1.单例对象从头到尾就一份内存，也不大, 没必要释放</p><p>2.如果非要提供释放，可以写一个析构函数: 运行完自动释放：</p></blockquote><p>如果在类中提供一个函数去释放, 那么只要有一个人调用了函数, 整个代码其他用到单例对象的地方都不管用了<br>所以不能提供释放的函数</p><p>//💡💡如果非要写，可以加个析构函数，运行完自动释放</p><p>看💡💡</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//实现单例步骤</span><br><span class="hljs-comment">//1.构造函数私有化</span><br><span class="hljs-comment">//2.增加静态私有的当前类的指针变量</span><br><span class="hljs-comment">//3.提供静态对外接口，可以让用户获得单例对象</span><br><br><span class="hljs-comment">//单例 分为懒汉式 饿汉式</span><br><br><span class="hljs-comment">//1.懒汉式(需要的时候才会创建)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_lazy</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_lazy</span>() { cout &lt;&lt; <span class="hljs-string">"我是懒汉构造！"</span> &lt;&lt; endl; }<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_lazy* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (pSingleton == <span class="hljs-literal">NULL</span>) {<br>pSingleton = <span class="hljs-keyword">new</span> Singleton_lazy;<br>}<br><span class="hljs-keyword">return</span> pSingleton;<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0 </span><br><span class="hljs-comment">//💡💡这样释放不行，万一谁手贱释放，就直接没了，这个权限不能给</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">freeSpace</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (pSingleton != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> pSingleton;<br>}<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//💡💡如果非要写，可以加个这个，运行完自动释放</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Garbo</span> {<br>~<span class="hljs-built_in">Garbo</span>() {<br><span class="hljs-keyword">if</span> (pSingleton != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> pSingleton;<br>}<br>}<br>};<br><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_lazy* pSingleton;<br><span class="hljs-type">static</span> Garbo garbo;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_lazy* Singleton_lazy::pSingleton = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//2.饿汉式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_hungry</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_hungry</span>() { cout &lt;&lt; <span class="hljs-string">"我是饿汉构造！"</span> &lt;&lt; endl; }<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_hungry* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> pSingleton;<br>}<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_hungry* pSingleton;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_hungry* Singleton_hungry::pSingleton = <span class="hljs-keyword">new</span> Singleton_hungry;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>Singleton_lazy* p1 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<br>Singleton_lazy* p2 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p1 == p2) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式！"</span> &lt;&lt; endl;<br>}<br><br>Singleton_hungry* p3 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<br>Singleton_hungry* p4 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p3 == p4) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式!"</span> &lt;&lt; endl;<br>}<br>}<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br>Singleton_lazy::<span class="hljs-built_in">freeSpace</span>();<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br>cout &lt;&lt; <span class="hljs-string">"main函数开始执行！"</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsQhGVkIZ2Q9Bkn6O5B6sLf" --> <p>多线程概念::![[多线程.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsN7XTfOhM7pW8auRlyPK27" --> <h1 id="6-单例模式的优缺点"><a class="markdownIt-Anchor" href="#6-单例模式的优缺点"></a> 6 单例模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong><br>先说个定义<br>(1)单例模式提供了对唯一实例的受控访问<br>(2)节约系统资源。由于在系统内存中只存在一个对象。<br><strong>有些实例，全局只需要一个就够了，使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。</strong></p><p><strong>缺点：</strong><br>(1) 扩展略难。单例模式中没有抽象层。<br>(2) 单例类的职责过重。</p><!-- basicblock-start oid="Obsa0pwoZD3yUTwIhPW3JRi6" --> <h1 id="7-单例模式的适用场景"><a class="markdownIt-Anchor" href="#7-单例模式的适用场景"></a> 7 单例模式的适用场景::</h1><h2 id="71-应用场景举例"><a class="markdownIt-Anchor" href="#71-应用场景举例"></a> 7.1 应用场景举例：</h2><p>1.网站计数器<br>2.应用程序的日志应用<br>3.Web项目中的配置对象的读取<br>4.<strong>数据库连接池</strong><br>5.多线程池<br>6.windows的资源管理器</p><h2 id="72-使用场景总结"><a class="markdownIt-Anchor" href="#72-使用场景总结"></a> 7.2 使用场景总结：</h2><ul><li>系统<strong>只需要一个实例对象</strong>，<br>如系统要求提供一个唯一的序列号生成器或资源管理器（像windows的资源管理器），<br>资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例<strong>只允许使用一个公共访问点</strong>，除了该公共访问点，不能通过其他途径访问该实例。</li><li><strong>频繁实例化然后又销毁的对象</strong>，使用单例模式可以提高性能</li><li><strong>经常使用的对象，但实例化时耗费时间或者资源多，</strong><br>如<strong>数据库连接池</strong>，使用单例模式，可以提高性能，降低资源损坏</li><li>使用线程池之类的控制资源时，使用单例模式，可以方便资源之间的通信</li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsNrP9PIGHBwETRCuXiR300"--> <p>#历史记录:: <a href="marginnote3app://note/70635F09-3528-44A0-AA4B-85CB0B593041">margin</a><br>2022/10/2🌵单列模式 : 第一次创建: ⏱1-18</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1Mb411t7ut?p=23&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">2-08 单例模式_饿汉式和懒汉式创建_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 创建型模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/posts/56456/"/>
      <url>/posts/56456/</url>
      
        <content type="html"><![CDATA[<h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1 原理::</h1><p>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，<br>但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。</p><p>抽象工厂模式为工厂方法模式的进一步延伸，其将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。<br><strong>虽然对于新增一个产品族很方便，并且也符合开闭原则，但是新增一个产品等级结构，会对整个工厂结构进行大改</strong><br>![[抽象工厂模式 2022-10-02 15.48.45.excalidraw]]</p><p><strong>应用</strong><br>Spring中的BeanFactory</p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApple</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//中国苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaApple</span> :<span class="hljs-keyword">public</span> AbstractApple {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"中国苹果！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//美国苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAApple</span> :<span class="hljs-keyword">public</span> AbstractApple {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"美国苹果！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//日本苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanApple</span> :<span class="hljs-keyword">public</span> AbstractApple {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"日本苹果！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//抽象香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBanana</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//中国香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaBanana</span> :<span class="hljs-keyword">public</span> AbstractBanana {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"中国香蕉！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//美国香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USABanan</span> :<span class="hljs-keyword">public</span> AbstractBanana {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"美国香蕉！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//日本香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanBanan</span> :<span class="hljs-keyword">public</span> AbstractBanana {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"日本香蕉！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//抽象鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPear</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><br><span class="hljs-comment">//中国鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaPear</span>:<span class="hljs-keyword">public</span> AbstractPear{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"中国鸭梨！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//美国鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAPear</span> :<span class="hljs-keyword">public</span> AbstractPear {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"美国鸭梨！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//日本鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanPear</span> :<span class="hljs-keyword">public</span> AbstractPear {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"日本鸭梨！"</span> &lt;&lt; endl;<br>}<br>};<br><br><br><span class="hljs-comment">//抽象工厂 💡针对产品族</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//中国工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaApple;<span class="hljs-comment">// ❓ChinaApple只是一个变量名吗</span><br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaBanana;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaPear;<br>}<br>};<br><br><span class="hljs-comment">//美国工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USAApple;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USABanan;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>  USAPear;<br>}<br>};<br><br><span class="hljs-comment">//日本工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanApple;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanBanan;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>  JapanPear;<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>AbstractFactory* factory = <span class="hljs-literal">NULL</span>;<br>AbstractApple* apple = <span class="hljs-literal">NULL</span>;<br>AbstractBanana* banana = <span class="hljs-literal">NULL</span>;<br>AbstractPear* pear = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//中国工厂, 其他同理</span><br>factory = <span class="hljs-keyword">new</span> ChinaFactory;<br>apple = factory-&gt;<span class="hljs-built_in">CreateApple</span>();<br>banana = factory-&gt;<span class="hljs-built_in">CreateBanana</span>();<br>pear = factory-&gt;<span class="hljs-built_in">CreatePear</span>();<br><br>apple-&gt;<span class="hljs-built_in">ShowName</span>();<br>banana-&gt;<span class="hljs-built_in">ShowName</span>();<br>pear-&gt;<span class="hljs-built_in">ShowName</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3 总结::</h1><h2 id="31-优缺点"><a class="markdownIt-Anchor" href="#31-优缺点"></a> 3.1 优缺点</h2><ul><li>优点：<br>(1)拥有工厂方法模式的优点</li></ul><p>(2)当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p><p>(3)增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><ul><li>缺点：<br><strong>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</strong></li></ul><h2 id="32-适用场景"><a class="markdownIt-Anchor" href="#32-适用场景"></a> 3.2 适用场景</h2><p>(1) <strong>系统中有多于一个的产品族</strong>。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</p><p>(2) 产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObscOitdWqzcsdqVkwoIBEr8" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::抽象工厂模式.md" --> <p>#历史记录::<br>2022/10/2🌵抽象工厂模式 : 第一次创建, ⏱</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 创建型模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/posts/31151/"/>
      <url>/posts/31151/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><blockquote><p>[!summary] 简单工厂模式 + 开闭原则 = 工厂方法模式<br>工厂方法模式中，将简单工厂中的工厂类变为一个抽象接口。<br>负责给出不同工厂应该实现的方法，自身不再负责创建各种产品，而是将具体的创建操作交给实现该接口的子工厂类来做。<br>通过多态的形式解决了简单工厂模式不符合开闭原则的问题。<br>虽然在新增产品时不仅要新增一个产品类还要实现与之对应的子工厂，但是相较于简单工厂模式更符合开闭原则<br>![[工厂方法模式 2022-10-01 10.45.51.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obsgj6Ogz3tyFxGHBLaXbs37" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::工厂方法模式.md"--><p><a href="marginnote3app://note/94C1FA5E-7AAF-424E-972F-42365D72D715">margin: 实际应用</a></p><!-- basicblock-end --><p>JDK中的Collection接口中Iterator的实现。<br>Collection中不同的实现类生产适合于自己的迭代器对象<br>1.Factory:Collection<br>1.SubFactoryA:LinkedList<br>2.SubFactoryB:ArrayList</p><p>2.Product:Iterator<br>1.ProductA:Listltr<br>2.ProductB:Itr<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210042126232.png" alt=""></p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210042114098.png" alt=""></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象水果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruit</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是苹果!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是香蕉!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pear</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是鸭梨!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruitFactory</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 💡它变成多个函数</span><br>};<br><br><br><span class="hljs-comment">//苹果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>}<br>};<br><br><span class="hljs-comment">//香蕉工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PearFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>}<br>};<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>AbstractFruitFactory* factory = <span class="hljs-literal">NULL</span>;<br>AbstractFruit* fruit = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//创建一个苹果工厂</span><br>factory = <span class="hljs-keyword">new</span> AppleFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br><br><span class="hljs-comment">//创建一个香蕉工厂</span><br>factory = <span class="hljs-keyword">new</span> BananaFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br><br><span class="hljs-comment">//创建一个鸭梨工厂</span><br>factory = <span class="hljs-keyword">new</span> PearFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br>fruit = <span class="hljs-literal">NULL</span>;<br>factory = <span class="hljs-literal">NULL</span>;<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="21-知识点"><a class="markdownIt-Anchor" href="#21-知识点"></a> 2.1 知识点</h2><!-- basicblock-start oid="ObsqjzA56mA9sGh7nWGUQ7NL" --> <p>如何抽象函数, 让一个函数名实现不同的功能. ::<br>先继承，再重写<br>这也叫策略模式</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruitFactory</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 抽象函数</span><br>};<br><br><br><span class="hljs-comment">//苹果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<span class="hljs-comment">// 1️⃣先继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 2️⃣再重写</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>}<br>};<br><span class="hljs-comment">// ---🌵同理---</span><br><br><span class="hljs-comment">//香蕉工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PearFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>}<br>};<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h1 id="3-使用场景"><a class="markdownIt-Anchor" href="#3-使用场景"></a> 3 使用场景::</h1><ol><li>客户端不知道它所需要的对象的类。<ol><li>我们直接和抽象工厂打交道</li></ol></li><li>抽象工厂类通过其子类来指定创建哪个对象。</li></ol><!-- basicblock-start oid="ObsYg9aiafi86nrpz6WDexgs" --> <h1 id="4-工厂方法模式的总结"><a class="markdownIt-Anchor" href="#4-工厂方法模式的总结"></a> 4 工厂方法模式的总结::</h1><!-- basicblock-end --><p>传统方法：如果想创建两个苹果，得具体实例化两个，然后再调用功能，以后再用还得记名字</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Apple a；<br>a.<span class="hljs-built_in">func</span>();<br>Aplle b；<br>b.<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></tbody></table></figure><p>工厂方法模式：可以不用具体一个对象，然后调用</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">factory = <span class="hljs-keyword">new</span> AppleFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<span class="hljs-comment">//造a</span><br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<span class="hljs-comment">//造b</span><br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br></code></pre></td></tr></tbody></table></figure><hr><!-- basicblock-end --><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsle4CtAZeZpu6u9Zy1H0d4" --> <p>#历史记录:: <a href="marginnote3app://note/615E1303-5D29-444A-BF5C-E20B69A3E587">margin: 工厂方法模式</a><br>2022/10/2🌵工厂方法模式 :  第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 创建型模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/posts/59366/"/>
      <url>/posts/59366/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><p>[[UML 外国小哥.excalidraw]]<br>![[简单工厂模式理论.excalidraw]]<br><strong>优点：</strong></p><ol><li>客户端和具体实现类解耦（不直接发生关系）</li><li>对于某些对象创建过程比较复杂情况，我们不用考虑这些了</li></ol><p>缺点</p><ul><li>简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则</li></ul><blockquote><p>增加水果需要修改水果源代码，简单的新建对象需要修改工厂源代码</p></blockquote><ul><li>这个类职责过重，这个类发生问题，影响很多使用这个工厂的模块</li></ul><blockquote><p>并且若是有多个判断条件共同决定创建对象，则后期修改会越来越复杂。</p></blockquote><p><strong>实际应用</strong><br>JDK中的DateFormate、Calendar类都有使用，通过不同参数返回我们需要的对象。</p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210042102793.png" alt=""></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象水果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruit</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> :<span class="hljs-keyword">public</span> AbstractFruit { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 重写</span><br>cout &lt;&lt; <span class="hljs-string">"我是苹果!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是香蕉!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pear</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是鸭梨!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//水果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactor</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 直接拿来用, 不用关心创建对象</span><br><span class="hljs-function"><span class="hljs-type">static</span> AbstractFruit * <span class="hljs-title">CreateFruit</span><span class="hljs-params">(string flag)</span> </span>{ <span class="hljs-comment">// 💡要设置成静态方法</span><br><span class="hljs-comment">// 静态可以不用对象调用，直接类名加点方法，不是静态需要创建对象然后调用, 不用static 无法创建对象</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-string">"apple"</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">"banana"</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">"pear"</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>}<br><span class="hljs-keyword">else</span> {<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>FruitFactor* factory = <span class="hljs-keyword">new</span> FruitFactor;<span class="hljs-comment">// 创建变量</span><br>AbstractFruit* fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">"apple"</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">"banana"</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">"pear"</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">delete</span> factory;<br>factory = <span class="hljs-literal">NULL</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>^jw3irr</p><p>不难看出，Fruit类是一个“巨大的”类，在该类的设计中存在如下几个问题：</p><p>(1) 在Fruit类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。</p><p>(2) Fruit类的职责过重，它负责初始化和显示所有的水果对象，将各种水果对象的初始化代码和显示代码集中在一个类中实现，<strong>违反了“单一职责原则”</strong>，不利于类的重用和维护；</p><p>(3) 当需要增加新类型的水果时，<strong>必须修改Fruit类的源代码，违反了“开闭原则”。</strong></p><ul><li>&amp; 所以简单工厂模式没有列入 23 种设计模式</li></ul><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3 总结::</h1><h2 id="31-简单工厂模式的优缺点"><a class="markdownIt-Anchor" href="#31-简单工厂模式的优缺点"></a> 3.1 <strong>简单工厂模式的优缺点</strong></h2><p>优点：</p><p>(1)实现了对象创建和使用的分离。<br>(2)不需要记住具体类名，记住参数即可，减少使用者记忆量。</p><p>缺点：<br>(1)对工厂类职责过重，一旦不能工作，系统受到影响。<br>(2)<strong>违反“单一职责原则”</strong>，将各种水果对象的初始化代码和显示代码集中在一个类中实现，增加系统中类的个数，复杂度和理解度增加。<br>(3)<strong>违反“开闭原则”</strong>，添加新产品需要修改工厂逻辑，工厂越来越复杂。</p><h2 id="32-适用场景"><a class="markdownIt-Anchor" href="#32-适用场景"></a> 3.2 适用场景</h2><p>（1）工厂类负责<strong>创建的对象较少</strong>: 由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>（2）客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsq5b3m24aCiZqAxEMlm8Qi" --> <p>#历史记录::<br>2022/9/30🌵简单工厂模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 创建型模型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>依赖倒转原则</title>
      <link href="/posts/53557/"/>
      <url>/posts/53557/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!summary] 依赖于抽象 (接口)，不要依赖具体的实现 (类)，也就是针对接口编程。<br>![[依赖倒转原则 2022-09-30 18.26.39.excalidraw]]</p></blockquote><h1 id="1-第一种情况-一层依赖一层"><a class="markdownIt-Anchor" href="#1-第一种情况-一层依赖一层"></a> 1 第一种情况: 一层依赖一层</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;;<br><br><br><span class="hljs-comment">//银行工作人员</span><br><span class="hljs-comment">// 这里违背了单一功能原则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankWorker</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveService</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理存款业务..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">payService</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理支付业务..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tranferService</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理转账业务..."</span> &lt;&lt; endl;<br>}<br><br>};<br><br><span class="hljs-comment">//中层模块, 封装好的方法</span><br><span class="hljs-comment">// 把类抽出来变成单个函数, 每个函数只做一件事</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSaveBussiness</span><span class="hljs-params">(BankWorker* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">saveService</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPayBussiness</span><span class="hljs-params">(BankWorker* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">payService</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doTranferBussiness</span><span class="hljs-params">(BankWorker* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">tranferService</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// 业务逻辑</span><br>BankWorker* worker = <span class="hljs-keyword">new</span> BankWorker;<br><span class="hljs-built_in">doSaveBussiness</span>(worker);  <span class="hljs-comment">//办理存款业务</span><br><span class="hljs-built_in">doPayBussiness</span>(worker); <span class="hljs-comment">//办理支付业务</span><br><span class="hljs-built_in">doTranferBussiness</span>(worker); <span class="hljs-comment">//办理转账业务</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-第二种情况-基于中间类"><a class="markdownIt-Anchor" href="#2-第二种情况-基于中间类"></a> 2 第二种情况: 基于中间类</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;;<br><br><span class="hljs-comment">//依赖倒转原则</span><br><span class="hljs-comment">//抽象层: 把存款, 转账等业务抽象出来</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractWorkerBank</span> { <br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 办理业务  </span><br>};<br><br><span class="hljs-comment">//只办理存款业务 :  单独设置每个函数: 先继承在重写函数, 下边函数同理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveBankWorker</span> : <span class="hljs-keyword">public</span>  AbstractWorkerBank { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写</span><br>cout &lt;&lt; <span class="hljs-string">"办理存款业务"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//只办理转账业务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferBankWorker</span> : <span class="hljs-keyword">public</span>  AbstractWorkerBank {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理转账业务"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//只办理付款业务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PayBankWorker</span> : <span class="hljs-keyword">public</span>  AbstractWorkerBank {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理付款业务"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//💡高层模块: 依赖于抽象层</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoBankBussiness</span><span class="hljs-params">(AbstractWorkerBank* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">doBussiness</span>();<br><span class="hljs-keyword">delete</span> worker;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">DoBankBussiness</span>(<span class="hljs-keyword">new</span> SaveBankWorker); <span class="hljs-comment">//办理存款业务</span><br><span class="hljs-built_in">DoBankBussiness</span>(<span class="hljs-keyword">new</span> TransferBankWorker); <span class="hljs-comment">//办理转账业务</span><br><span class="hljs-built_in">DoBankBussiness</span>(<span class="hljs-keyword">new</span> PayBankWorker); <span class="hljs-comment">//办理付款业务</span><br><br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs0yGHY0U19xpLxTKImma6D"  --> <p>#历史记录::<br>2022/9/30🌵依赖倒转原则 : 第一次创建<br>2022/10/16: anki 复习</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 面向对象原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>合成复用原则</title>
      <link href="/posts/14793/"/>
      <url>/posts/14793/</url>
      
        <content type="html"><![CDATA[<h1 id="1-合成复用原则"><a class="markdownIt-Anchor" href="#1-合成复用原则"></a> 1 合成复用原则::</h1><blockquote><p>[!summary] 对于继承和组合，优先使用组合。<br>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系</p></blockquote><p>1、概念：<br>优先使用组合 contains a（聚合 has a)，而不是继承 is a 来达到目的<br>[[UML 外国小哥.excalidraw]]</p><blockquote><p>[!summary] 白箱/黑箱复用<br>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用）</p><p>组合/聚合复用：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用）<br>。</p></blockquote><!-- basicblock-start oid="Obsq9zKIzZUCS8raf1riTXBX" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::面向对象原则::合成复用原则.md"--><p>2、原因：<br>继承会将实现细节暴露给子类，继承复用破坏了封装性，是白箱复用<br>使用继承时需要考虑里氏替换原则</p><p>3、优点：<br>新类对象存取成员对象只通过成员对象的接口，是黑箱复用，系统更灵活，降低耦合度，可以在运行时动态进行，<br>新对象可动态引用与成员对象类型相同的对象</p><!-- basicblock-end --><p>4、缺点：<br>需要管理较多对象</p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCar</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-comment">//大众车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dazhong</span> :<span class="hljs-keyword">public</span> AbstractCar {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 把 run 函数实现(重写)</span><br>cout &lt;&lt; <span class="hljs-string">"大众车启动"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//拖拉机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuolaji</span> : <span class="hljs-keyword">public</span> AbstractCar {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"拖拉机启动"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//笨方法，针对具体类 不适用继承</span><br><span class="hljs-comment">// 每个人要想开车, 都要单独继承那个车</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">// 💡人 1: 想开拖拉机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> :<span class="hljs-keyword">public</span> Tuolaji {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tuolaji</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">run</span>();<br>}<br>};<br><span class="hljs-comment">// 人 2 : 想开大众</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span> :<span class="hljs-keyword">public</span> Dazhong {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dazhong</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">run</span>();<br>}<br>};<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//💡可以使用合成复用原则</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCar</span><span class="hljs-params">(AbstractCar* car)</span> </span>{ <span class="hljs-comment">// 创建一个抽象车的变量</span><br><span class="hljs-keyword">this</span>-&gt;car = car;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Doufeng</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;car-&gt;<span class="hljs-built_in">run</span>();<br><span class="hljs-comment">// 类似析构函数, 释放指针, 也可以在外边写成析构函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;car != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;car;<br><span class="hljs-keyword">this</span>-&gt;car = <span class="hljs-literal">NULL</span>;<br>}<br>}<br><br><span class="hljs-keyword">public</span>:<br>AbstractCar* car; <span class="hljs-comment">// 抽象出来car指针, 写一个类来解决问题</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br>Person* p = <span class="hljs-keyword">new</span> Person;<br>p-&gt;<span class="hljs-built_in">setCar</span>(<span class="hljs-keyword">new</span> Dazhong); <span class="hljs-comment">// 传入什么开什么</span><br>p-&gt;<span class="hljs-built_in">Doufeng</span>();<br><br>p-&gt;<span class="hljs-built_in">setCar</span>(<span class="hljs-keyword">new</span> Tuolaji);<br>p-&gt;<span class="hljs-built_in">Doufeng</span>();<br><br><span class="hljs-keyword">delete</span> p;<br>}<br><br><br><span class="hljs-comment">//继承和组合优先使用组合</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsL6awL3zwRbLriSZBmPRDw"  --> <p>#历史记录:: <a href="marginnote3app://note/262903F4-1774-445A-88FE-A9457DEB99AE">margin: 组合复用原则</a><br>2022/9/30🌵合成复用原 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 面向对象原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迪米特原则（最少知道原则）</title>
      <link href="/posts/10716/"/>
      <url>/posts/10716/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><p>概念：<br>一个对象应当对其他对象有尽可能少的了解，即不和陌生人说话<br>"朋友圈"概念（以下情况是该对象朋友）：</p><p>1、 this:</p><ol><li>该对象方法中的参数</li><li>实例变量直接引用的对象</li><li>实例变量如果是一个聚集 （聚合对象），聚集中的元素</li><li>该对象方法中创建的变量</li></ol><p>2、要求：</p><ol><li>优先考虑将一个类设计成不变类</li><li>尽量降低一个类的访问权限</li><li>谨慎使用 Serializable（持久化，通过序列化一个对象，将其写入磁盘，以后程序调用时重新恢复该对象）</li><li>尽量降低成员的访问权限</li></ol><p>3、优点：降低类之间的耦合</p><p>4、缺点：过多使用迪米特法则，会产生大量中介类，设计变复杂</p><p>尽量在知道越少的情况下, 把事情办好</p><blockquote><p>[!tip]   一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）</p></blockquote><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><p>![[迪米特原则（最少知道原则） 2022-09-30 16.37.13.excalidraw]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//迪米特原则，又叫最少知道原则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBuilding</span> {<span class="hljs-comment">// 💡抽象类, 应该是虚函数的原因吧</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//楼盘A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildingA</span> :<span class="hljs-keyword">public</span> AbstractBuilding { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">// ❗️public 下别人才能访问到</span><br><span class="hljs-built_in">BuildingA</span>() { <br>mQuilty = <span class="hljs-string">"高品质"</span>; <span class="hljs-comment">// 设置属性</span><br>};<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写父类函数</span><br>cout &lt;&lt; <span class="hljs-string">"楼盘A"</span> &lt;&lt; mQuilty&lt;&lt;<span class="hljs-string">"被售卖！"</span>&lt;&lt;endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mQuilty;<br>}<br><span class="hljs-keyword">public</span>:<br>string mQuilty; <span class="hljs-comment">// 创建一个属性 </span><br>};<br><br><span class="hljs-comment">// ---🌵下边同理---</span><br><br><span class="hljs-comment">//楼盘B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildingB</span> :<span class="hljs-keyword">public</span> AbstractBuilding {<br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">BuildingB</span>() { mQuilty = <span class="hljs-string">"低品质"</span>; };<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"楼盘B"</span> &lt;&lt; mQuilty &lt;&lt; <span class="hljs-string">"被售卖！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mQuilty;<br>}<br><span class="hljs-keyword">public</span>:<br>string mQuilty;<br>};<br><br><span class="hljs-comment">//用户调用v1: 💡一个一个的去问价, 这样不好</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>BuildingA* ba = <span class="hljs-keyword">new</span> BuildingA;<br><span class="hljs-comment">// 判断低品质楼盘是否被售卖</span><br><span class="hljs-keyword">if</span> (ba-&gt;mQuilty == <span class="hljs-string">"低品质"</span>) { <br>ba-&gt;<span class="hljs-built_in">sale</span>();<br>}<br><br>BuildingB* bb = <span class="hljs-keyword">new</span> BuildingB;<br><span class="hljs-keyword">if</span> (bb-&gt;mQuilty == <span class="hljs-string">"低品质"</span>) {<br>bb-&gt;<span class="hljs-built_in">sale</span>();<br>}<br>}<br><br><span class="hljs-comment">//💡增加一个中介类, 用来维护楼盘</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> { <span class="hljs-comment">// 也可以是抽象类, 比如有中介 A, 中介 B. 如果以后好要好拓展的话, 必须做成抽象类</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mediator</span>() {<br>AbstractBuilding* building = <span class="hljs-keyword">new</span> BuildingA; <span class="hljs-comment">// 创建 A 楼盘</span><br>vBuilding.<span class="hljs-built_in">push_back</span>(building);<span class="hljs-comment">// 添加新楼盘</span><br>building = <span class="hljs-keyword">new</span> BuildingB;<span class="hljs-comment">// 同理</span><br>vBuilding.<span class="hljs-built_in">push_back</span>(building);<br>};<br><br><span class="hljs-comment">//对外提供接口: 💡用户是需要某一个楼盘, 所以函数返回值是楼盘指针</span><br><span class="hljs-function">AbstractBuilding* <span class="hljs-title">findMyBuilding</span><span class="hljs-params">(string quality)</span> </span>{ <span class="hljs-comment">// 参数: 提供想要什么样的品质的房子</span><br><span class="hljs-comment">//for (vector&lt;AbstractBuilding*&gt;::iterator it = vBuilding.begin(); it != vBuilding.end(); it++) {</span><br><span class="hljs-comment">//if ((*it)-&gt;getQuality() == quality){</span><br><span class="hljs-comment">//return *it;</span><br><span class="hljs-comment">//}</span><br><span class="hljs-comment">//}</span><br><span class="hljs-comment">// 💡这样写更好</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : vBuilding) {<br><span class="hljs-keyword">if</span> ((it)-&gt;<span class="hljs-built_in">getQuality</span>() == quality) {<br><span class="hljs-keyword">return</span> it; <span class="hljs-comment">// 返回想要楼盘</span><br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br><br>~<span class="hljs-built_in">Mediator</span>() { <span class="hljs-comment">// 析构函数, 用来释放函数</span><br><span class="hljs-keyword">for</span> (vector&lt;AbstractBuilding*&gt;::iterator it = vBuilding.<span class="hljs-built_in">begin</span>(); it != vBuilding.<span class="hljs-built_in">end</span>(); it++) {<br><span class="hljs-keyword">if</span> (*it != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> *it;<br>}<br>}<br>}<br><span class="hljs-keyword">public</span>:<br>vector&lt;AbstractBuilding*&gt; vBuilding; <span class="hljs-comment">// 💡创建一个抽象的楼盘, 方便 管理所有楼盘</span><br>};<br><span class="hljs-comment">// 用户调用 v2: 直接跟中介打交道</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br>Mediator* mediator = <span class="hljs-keyword">new</span> Mediator;<br><br>AbstractBuilding* building = mediator-&gt;<span class="hljs-built_in">findMyBuilding</span>(<span class="hljs-string">"高品质"</span>);<br><br><span class="hljs-keyword">if</span> (building != <span class="hljs-literal">NULL</span>) {<br>building-&gt;<span class="hljs-built_in">sale</span>();<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"没有符合您条件的楼盘！"</span> &lt;&lt; endl;<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRrR88KlayiXedR3qO1jYy" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::面向对象原则::迪米特原则（最少知道原则）.md" --> <p>#历史记录::<br>2022/9/30🌵迪米特原则（最少知道原则） : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 面向对象原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开闭原则</title>
      <link href="/posts/65425/"/>
      <url>/posts/65425/</url>
      
        <content type="html"><![CDATA[<h1 id="1-开闭原则"><a class="markdownIt-Anchor" href="#1-开闭原则"></a> 1 开闭原则</h1><blockquote><p>[!summary] 开闭原则，对扩展开放，对修改关闭，增加功能是通过增加代码来实现，而不是去修改源代码<br>![[2. C++设计模式-面向对象原则 2022-09-30 15.15.02.excalidraw]]</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//开闭原则，对扩展开放，对修改关闭，增加功能是通过增加代码来实现，而不是去修改源代码</span><br><br><br><span class="hljs-comment">//写一个抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCaculator</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// virtual 虚函数关键字</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlusCalcultor</span> :<span class="hljs-keyword">public</span> AbstractCaculator { <span class="hljs-comment">// 继承抽象类</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;mA = a;<br><span class="hljs-keyword">this</span>-&gt;mB = b;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写抽象类的函数</span><br><span class="hljs-keyword">return</span> mA + mB;<br>}<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 定义两个操作数</span><br><span class="hljs-type">int</span> mA;<br><span class="hljs-type">int</span> mB;<br>};<br><br><span class="hljs-comment">// 下边同理, 增加功能只是增加类, 而没有修改原代码</span><br><br><span class="hljs-comment">//减法计算器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinuteCalcultor</span> :<span class="hljs-keyword">public</span> AbstractCaculator {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;mA = a;<br><span class="hljs-keyword">this</span>-&gt;mB = b;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mA - mB;<br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mA;<br><span class="hljs-type">int</span> mB;<br>};<br><br><span class="hljs-comment">//乘法计算器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplyCalcultor</span> :<span class="hljs-keyword">public</span> AbstractCaculator {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;mA = a;<br><span class="hljs-keyword">this</span>-&gt;mB = b;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mA * mB;<br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mA;<br><span class="hljs-type">int</span> mB;<br>};<br><span class="hljs-comment">// ---</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// 用加法计算器, 就 new 那个类</span><br>AbstractCaculator* calcultor = <span class="hljs-keyword">new</span> PlusCalcultor;<br>calcultor-&gt;<span class="hljs-built_in">setOperatorNumber</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>cout&lt;&lt;calcultor-&gt;<span class="hljs-built_in">getResult</span>()&lt;&lt;endl;<br><br><span class="hljs-keyword">delete</span> calcultor;  <span class="hljs-comment">//不删除的话就变成一个野指针了</span><br><br>calcultor = <span class="hljs-keyword">new</span> MinuteCalcultor;<br>calcultor-&gt;<span class="hljs-built_in">setOperatorNumber</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; calcultor-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">delete</span> calcultor;<br>calcultor = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">//需要立刻置为NULL</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>[[this 指针]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs9mqw4bbQs5GtDqV3JoDHx"  --> <p>#历史记录::<br>2022/9/30🌵开闭原则 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 面向对象原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>this 指针</title>
      <link href="/posts/39691/"/>
      <url>/posts/39691/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用法"><a class="markdownIt-Anchor" href="#1-用法"></a> 1 用法::</h1><p>![[this 指针 2022-09-30 15.56.56.excalidraw]]</p><ol><li><p>tihs 指针不占用类的内存</p></li><li><p>this 指针存的是什么<br>1.对于构造函数是本身的地址，</p><ol start="2"><li>对于成员函数: 是用调用对象的首地址</li></ol></li><li><p>静态的成员函数是没办法操作this？为什么？<br>静态函数先于对象存在 是所有对象共有的 没有this<br><a href="https://www.bilibili.com/video/BV1C7411Y7Kb/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=892.941194">14:52</a></p></li></ol><h1 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2 原理::</h1><p>![[this 指针 2022-09-30 16.09.51.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsdfc8wLx6VitFN6dX3VVXy"  --> <p>#历史记录::<br>2022/9/30🌵this 指针 : 第一次创建</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1C7411Y7Kb/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">【小神仙讲 c++教程】this指针讲解_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2. C++设计模式-面向对象原则</title>
      <link href="/posts/34643/"/>
      <url>/posts/34643/</url>
      
        <content type="html"><![CDATA[<p>学习设计模式将有助于更加深入地理解面向对象思想，让你知道::</p><ol><li>如何将代码分散在几个不同的类中？</li><li>为什么要有“接口”？</li><li>何谓针对抽象编程？</li><li>何时不应该使用继承？</li><li>如果不修改源代码增加新功能？ N</li><li>更好地阅读和理解现有类库与其他系统中的源代码。<br>学习设计模式会让你早点脱离面向对象编程的"菜乌期〞。</li></ol><h1 id="1-面向对象设计原则"><a class="markdownIt-Anchor" href="#1-面向对象设计原则"></a> 1 <a href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&amp;spm=1001.2101.3001.7020">面向对象</a>设计原则</h1><p>向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。<br>面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。</p><blockquote><p>[!summary] 原则的目的：高内聚，低耦合</p></blockquote><p>![[2. C++设计模式-面向对象原则 2022-09-30 14.45.46.excalidraw]]</p><h2 id="11-开闭原则非常重要"><a class="markdownIt-Anchor" href="#11-开闭原则非常重要"></a> 1.1 [[开闭原则]]::非常重要</h2><h2 id="12-迪米特原则最少知道原则"><a class="markdownIt-Anchor" href="#12-迪米特原则最少知道原则"></a> 1.2 [[迪米特原则（最少知道原则）]]</h2><h2 id="13-合成复用原则"><a class="markdownIt-Anchor" href="#13-合成复用原则"></a> 1.3 [[合成复用原则]]</h2><h2 id="14-依赖倒转原则"><a class="markdownIt-Anchor" href="#14-依赖倒转原则"></a> 1.4 [[依赖倒转原则]]</h2><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsIq0nAuWPTqgNuu6yo2PJi"  --> <p>#历史记录::<br>2022/9/30🌵2. C++设计模式-面向对象原则 :<br>2022/10/16: anki 复习</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 设计模式 </category>
          
          <category> C++ 设计模式 </category>
          
          <category> 面向对象原则 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯法能解决n层for循环的问题</title>
      <link href="/posts/47391/"/>
      <url>/posts/47391/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第77题-组合"><a class="markdownIt-Anchor" href="#1-第77题-组合"></a> 1 第77题. 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入:&nbsp;n = 4, k = 2<br>输出:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">[  <br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],  <br>]<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObskdNGepvmQRtT1ysKQnMMv" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>本题这是回溯法的经典题目。</p><p>直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>输入：n = 100, k = 3 那么就三层for循环，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = j + <span class="hljs-number">1</span>; u &lt;= n; n++) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; u &lt;&lt; endl;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>如果n为100，k为50呢，那就50层for循环，是不是开始窒息</strong>。</p><p><strong>此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！</strong></p><p>咋整？</p><p>回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。</p><p>那么回溯法怎么暴力搜呢？</p><p>上面我们说了<strong>要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题</strong>。</p><p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p><p>此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。<br>eg: [[2.组合问题|2.组合问题]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs8BXO897x6RWPCu6wz5afF" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::回溯法能解决n层for循环的问题.md" --> <p>#历史记录::<br>2022/9/28🌵回溯法能解决n层for循环的问题 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++新特性</title>
      <link href="/posts/24592/"/>
      <url>/posts/24592/</url>
      
        <content type="html"><![CDATA[<h1 id="1-constexpr和const-c新特性"><a class="markdownIt-Anchor" href="#1-constexpr和const-c新特性"></a> 1 [[constexpr和const  (C++新特性)]]::</h1><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs4CjFnETiHrllICn2EFFV2" deck = "👨🏻‍💻code::C++::C++基础::C++新特性.md" --> <p>#历史记录::<br>2022/9/27🌵C++新特性 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>33. 二叉总结篇</title>
      <link href="/posts/34644/"/>
      <url>/posts/34644/</url>
      
        <content type="html"><![CDATA[<ul><li><blockquote><p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">代码随想录</a></p></blockquote></li></ul><!-- basicblock-start oid="ObsjdkiiY5tysXh4RCgbY7mg" --> <h1 id="1-如何选择遍历顺序"><a class="markdownIt-Anchor" href="#1-如何选择遍历顺序"></a> 1 如何选择遍历顺序::</h1><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如: 单纯求深度就用前序，[[13. 二叉树的所有路径]]也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p><!-- basicblock-end --><p>![[33. 二叉总结篇 2022-09-27 11.35.38.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsKKiINwntYPzar7npw2rMj" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::33. 二叉总结篇.md" --> <p>#历史记录::<br>2022/9/27🌵33. 二叉总结篇 : ⏱0-10</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33. 把二叉搜索树转换为累加树</title>
      <link href="/posts/61698/"/>
      <url>/posts/61698/</url>
      
        <content type="html"><![CDATA[<h1 id="1-538把二叉搜索树转换为累加树"><a class="markdownIt-Anchor" href="#1-538把二叉搜索树转换为累加树"></a> 1 538.把二叉搜索树转换为累加树</h1><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">力扣题目链接</a></p><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node&nbsp;的新值等于原树中大于或等于&nbsp;node.val&nbsp;的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20201023160751832.png" alt="538.把二叉搜索树转换为累加树"></p><ul><li>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</li><li>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</li></ul><p>示例 2：</p><ul><li>输入：root = [0,null,1]</li><li>输出：[1,null,1]</li></ul><p>示例 3：</p><ul><li>输入：root = [1,0,2]</li><li>输出：[3,3,2]</li></ul><p>示例 4：</p><ul><li>输入：root = [3,2,4,1]</li><li>输出：[7,9,4,10]</li></ul><p>提示：</p><ul><li>树中的节点数介于 0 和 104 之间。</li><li>每个节点的值介于 -104 和 104 之间。</li><li>树中的所有值 互不相同 。</li><li>给定的树为二叉搜索树。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>二叉搜索树, 反中序遍历得到递减数组</p><p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。<br>这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，<br>并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过, 用 pre cur(carl 版) 指针就不用在定义一个 sum 变量了(下次看看)⏱0-24</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❗️sum 得放到函数外边, 不然每次递归的时候就重置</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">convertBST</span>(root-&gt;right);<br>        sum += root-&gt;val;<br>        root-&gt;val = sum;<br>        <span class="hljs-built_in">convertBST</span>(root-&gt;left);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs45Ym7GBgeih6pzHoOpalp" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::33. 把二叉搜索树转换为累加树.md" --> <p>#历史记录::<br>2022/9/27🌵33. 把二叉搜索树转换为累加树 : v1, 通过, 用 pre cur(carl 版) 指针就不用在定义一个 sum 变量了 ⏱0-24</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32. 将有序数组转换为二叉搜索树</title>
      <link href="/posts/16177/"/>
      <url>/posts/16177/</url>
      
        <content type="html"><![CDATA[<h1 id="1-108将有序数组转换为二叉搜索树"><a class="markdownIt-Anchor" href="#1-108将有序数组转换为二叉搜索树"></a> 1 108.将有序数组转换为二叉搜索树</h1><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">力扣题目链接</a></p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点&nbsp;的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p><img src="https://img-blog.csdnimg.cn/20201022164420763.png" alt="108.将有序数组转换为二叉搜索树"></p><!-- basicblock-start oid="Obs22xPCUGNbwpZPC3aGHhsE" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obs0Dsnzk3RGcsOkyNNLhVD5" --> <p>题目中说要转换为一棵高度平衡二叉搜索树。这和转换为一棵普通二叉搜索树有什么差别呢::<br>其实这里不用强调平衡二叉搜索树，数组构造二叉树，构成平衡树是自然而然的事情，因为<strong>大家默认都是从数组中间位置取值作为节点元素</strong>，一般不会随机取，所以想构成不平衡的二叉树是自找麻烦。</p><!-- basicblock-end --><p>如果根据数组构造一棵二叉树。<br><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。<br>[[18. 从中序与后序遍历序列构造二叉树]]<br>[[19. 最大二叉树]]<br>本题要比上边两道题简单点, 为有序数组构造二叉搜索树，寻找分割点就比较容易了。<br>分割点就是数组中间位置的节点。</p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？<br>取哪一个都可以，只不过构成了不同的平衡二叉搜索树<br>![[32. 将有序数组转换为二叉搜索树 2022-09-27 10.36.43.excalidraw]]</p><!-- basicblock-start oid="Obsq70n6W7jnqmTZnWc5R4wN" --> <h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><!-- basicblock-end --><p>构造树一般用前序遍历<br>v1, 二叉树有多个, 执行代码不符合没事的, 能通过⏱0-55<br>题解有个左闭右开的写法没看懂</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector%<span class="hljs-number">3</span>Cint%<span class="hljs-number">3</span>E&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>{<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span> (nums[mid]);<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, mid<span class="hljs-number">-1</span>);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, mid+<span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>       <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYFfG1QsXhcRp6fgFuq7eG" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::32. 将有序数组转换为二叉搜索树.md" --> <p>#历史记录::<br>2022/9/27🌵32. 将有序数组转换为二叉搜索树 :v1, 二叉树有多个, 执行代码不符合没事的, 能通过⏱0-55</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>挤出切削制备梯度结构铝带材的新工艺及机理</title>
      <link href="/posts/39144/"/>
      <url>/posts/39144/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="marginnote3app://note/4F1AF518-98F3-4F7B-B287-0D6FF4C9F7C6">margin</a></p></blockquote><!-- basicblock-start oid="ObsOmqHBx3T1yWz5yAgxvkyb" --> <p><strong>摘要</strong>::</p><!-- basicblock-end --><p>研究结果表明,随着挤出厚度的增加,高应变区范围无明显变化,但低应变区增大,更多的材料从侧向挤出。挤出切削制备的梯度结构铝带材晶粒细化显著,硬度提升明显,晶粒尺寸与硬度在厚度层上均呈明显的梯度分布规律。制备的梯度结构铝带材的拉伸强度随着挤出厚度的增加呈下降趋势,而延伸率有所上升。相比原始样品,梯度结构铝带材的拉伸强度几乎提升了一倍,而延伸率仅略微下降。</p><!-- basicblock-start oid="ObszpDSVAW4ynoQ8IqguoV6u" --> <h1 id="1-挤出切削原理与实验设计"><a class="markdownIt-Anchor" href="#1-挤出切削原理与实验设计"></a> 1 挤出切削原理与实验设计::</h1><!-- basicblock-end --><p>![[挤出切削变形区示意图.30.excalidraw|900]]<br>考虑到在室温下进行加工, 热传递系数设为 40 (N/s)/(mm/ ) ℃ 。 模 拟 中 , 挤 出 厚 度 值 分 别 设 为1.0 mm、1.2 mm、1.4 mm 和 1.6 mm,挤压速度设为 20 mm/s,不设置背压,保证其他参数不变。有限元计算步长为 0.02 mm, 总步数为 2 500 步, 选择稳态时间作为模拟结果。</p><!-- basicblock-start oid="Obs5ym8ruT8wW6NBO7VHnl5v" --> <h1 id="2-挤出切削成形过程"><a class="markdownIt-Anchor" href="#2-挤出切削成形过程"></a> 2 挤出切削成形过程::</h1><!-- basicblock-end --><p>挤出切削不同阶段成形过程::<br>![[挤出切削不同阶段成形过程.excalidraw]]</p><!-- basicblock-start oid="ObsjhN8plgPXjC2A9BXSi6Ha" --> <h2 id="21-材料流速"><a class="markdownIt-Anchor" href="#21-材料流速"></a> 2.1 材料流速::</h2><!-- basicblock-end --><p>![[不同挤出厚度下的材料流速分布图.excalidraw]]</p><!-- basicblock-start oid="ObsQVdbbnTxKdl2xZsiJXO7s" --> <h2 id="22-等效应变"><a class="markdownIt-Anchor" href="#22-等效应变"></a> 2.2 等效应变::</h2><!-- basicblock-end --><p>![[不同挤出厚度下的等效应变分布图.excalidraw]]</p><!-- basicblock-start oid="Obsf7f991VVsPcxziKgGbEL9" --> <h2 id="23-等效应变率"><a class="markdownIt-Anchor" href="#23-等效应变率"></a> 2.3 等效应变率::</h2><!-- basicblock-end --><p>![[不同挤出厚度下的等效应变率分布图.excalidraw]]</p><!-- basicblock-start oid="Obs9X8Ra8u78Jcb28iuEwIEo" --> <h2 id="24-等效应力"><a class="markdownIt-Anchor" href="#24-等效应力"></a> 2.4 等效应力::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 21.38.34.excalidraw]]</p><h2 id="25-温度分布"><a class="markdownIt-Anchor" href="#25-温度分布"></a> 2.5 温度分布</h2><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 21.54.18.excalidraw]]</p><h1 id="3-挤出切削实验结果分析"><a class="markdownIt-Anchor" href="#3-挤出切削实验结果分析"></a> 3 挤出切削实验结果分析</h1><!-- basicblock-start oid="Obst1taKUKec30Y2sZt5T9Dh" --> <h2 id="31-成形效果"><a class="markdownIt-Anchor" href="#31-成形效果"></a> 3.1 成形效果::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 22.05.13.excalidraw]]</p><!-- basicblock-start oid="ObsPMwrdVIMLIBBsMl6TF6JX" --> <h2 id="32-纯铝材料微观组织"><a class="markdownIt-Anchor" href="#32-纯铝材料微观组织"></a> 3.2 纯铝材料微观组织::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 22.10.23.excalidraw]]</p><p>![[晶粒尺寸分布情况.excalidraw]]</p><!-- basicblock-start oid="ObsKGDbQrKgvML5Baw4qtDR1" --> <h2 id="33-梯度结构铝带材的硬度"><a class="markdownIt-Anchor" href="#33-梯度结构铝带材的硬度"></a> 3.3 梯度结构铝带材的硬度::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-27 11.50.29.excalidraw]]</p><!-- basicblock-start oid="Obsl09KS99NlHQRAk2CJ2utM" --> <h2 id="34-梯度结构铝带材的拉伸性能"><a class="markdownIt-Anchor" href="#34-梯度结构铝带材的拉伸性能"></a> 3.4 梯度结构铝带材的拉伸性能::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-27 12.06.20.excalidraw]]</p><!-- basicblock-start oid="ObsjbPtgt7RHVsHY86kslTK5" --> <h1 id="4-结论"><a class="markdownIt-Anchor" href="#4-结论"></a> 4 结论::</h1><!-- basicblock-end --><h2 id="41"><a class="markdownIt-Anchor" href="#41"></a> 4.1</h2><p>通过数值模拟可知挤出切削成形过程可分为三个阶段: 分别是初始切入阶段、初始成形阶段和稳定成形阶段。<br><strong>带材厚度层上的应变梯度明显</strong>,<br>带材根部在挤出通道内形成**Y字形高应变率区域和高温区域 <strong>,<br>应力集中在带材根部与刀具倒棱刀刃的接触部分(B 点)<br>随着挤出厚度的增大,高应变区范围基本无变化,低应变区在厚度层中占比更大</strong>,而应力、应变率和温度的变化均不是很明显。<br>在实际加工中,随着挤出厚度的增加,材料侧向挤出流动时所受挤出通道的限制减弱,导致侧向流出的材料增多,意味着材料转化率提高。</p><h2 id="42"><a class="markdownIt-Anchor" href="#42"></a> 4.2</h2><p>经过挤出切削加工后,铝带材的晶粒细化显著,沿厚度层方向呈梯度分布,具体表现为带材B 侧细晶层有大量尺寸均匀的细晶分布,<br>从 B 侧到A 侧塑性变形程度减弱,细晶逐渐过渡为尺寸较大的拉长晶。<br>应变的梯度变化导致晶粒尺寸呈梯度分布, <strong>高应变区域的晶粒细化比低应变区的更为彻底</strong>。</p><h2 id="43"><a class="markdownIt-Anchor" href="#43"></a> 4.3</h2><p>相比纯铝原始材料,梯度结构铝带材的硬度显著提高,抗拉强度为原材料的两倍左右,而延伸率有所下降。<br>晶粒尺寸的梯度变化也导致硬度呈梯度分布。<br><strong>随着挤出厚度的增大,梯度结构铝带材的抗拉强度与延伸率呈“倒置”关系,即抗拉强度下降的同时延伸率提高</strong>。</p><h2 id="44"><a class="markdownIt-Anchor" href="#44"></a> 4.4</h2><p>挤出切削工艺能够通过改变挤出厚度<strong>实现晶粒沿厚度方向呈不同程度的细化梯度,协调细晶区和粗晶区在厚度层中的占比</strong>,从而兼顾材料的强度和塑性,<br>一步法制备综合性能良好的梯度超细晶结构材料,突破了传统大塑性变形工艺所制备超细晶材料塑性显著降低的局限性,使得材料应用更加广泛。</p><h2 id="45"><a class="markdownIt-Anchor" href="#45"></a> 4.5</h2><p>挤出切削用于制备梯度材料可行,而且工艺简单, 效率高, 可适用其他大多数中低强度金属。</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs2acAOpDTlRTF7pGxopzqA" deck = "👨🏻‍🎓科研::论文学习::挤出切削制备梯度结构铝带材的新工艺及机理.md" --> <p>#历史记录::<br>2022/9/28🌵挤出切削制备梯度结构铝带材的新工艺及机理 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
          <category> 论文学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>塑性流动挤出切削制备梯度结构纯铜片材的工艺及机理</title>
      <link href="/posts/51208/"/>
      <url>/posts/51208/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs4QI9tFJif0Sqr7xvVYU9r" deck = "👨🏻‍🎓科研::论文学习::塑性流动挤出切削制备梯度结构纯铜片材的工艺及机理.md" --> <p>#历史记录::<br>2022/9/26🌵塑性流动挤出切削制备梯度结构纯铜片材的工艺及机理 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
          <category> 论文学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>31. 修剪二叉搜索树</title>
      <link href="/posts/13253/"/>
      <url>/posts/13253/</url>
      
        <content type="html"><![CDATA[<h1 id="1-修剪二叉搜索树"><a class="markdownIt-Anchor" href="#1-修剪二叉搜索树"></a> 1 修剪二叉搜索树</h1><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">力扣题目链接</a></p><p>给定一个二叉搜索树，同时给定最小边界L&nbsp;和最大边界&nbsp;R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p><img src="https://img-blog.csdnimg.cn/20201014173115788.png" alt="669.修剪二叉搜索树|500"></p><p><img src="https://img-blog.csdnimg.cn/20201014173219142.png" alt="669.修剪二叉搜索树1|500"></p><!-- basicblock-start oid="ObszVInIZro8xkDRE6sZWQl8" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>![[31. 修建二叉搜索树 2022-09-26 10.49.52.excalidraw]]</p><ul><li>对根结点 root进行深度优先遍历。对于当前访问的结点，如果结点为空结点，直接返回空结点；</li><li>如果结点的值小于 low，那么说明该结点及它的左子树都不符合要求，我们返回对它的右结点进行修剪后的结果；</li><li>如果结点的值大于high，那么说明该结点及它的右子树都不符合要求，我们返回对它的左子树进行修剪后的结果；</li><li>如果结点的值位于区间 [low,high]，<ul><li>$ 我们将结点的左结点设为对它的左子树修剪后的结果，</li><li>$ 右结点设为对它的右子树进行修剪后的结果。</li></ul></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 重点关注有❓的地方⏱0-31</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<span class="hljs-comment">// ❓return: ✅一直向下寻找符合的区间的右孩子节点</span><br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>找到一条边就返回::<br>[[递归函的返回值#3 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs8wq4AlSDbqg6cWpM1V1DT" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::31. 修建二叉搜索树.md" --> <p>#历史记录::<br>2022/9/26🌵31. 修建二叉搜索树 : v1, 重点关注有❓的地方⏱0-31</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30. 删除二叉搜索树中的节点</title>
      <link href="/posts/357/"/>
      <url>/posts/357/</url>
      
        <content type="html"><![CDATA[<h1 id="1-450删除二叉搜索树中的节点"><a class="markdownIt-Anchor" href="#1-450删除二叉搜索树中的节点"></a> 1 450.删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">力扣题目链接</a></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的&nbsp;key&nbsp;对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为&nbsp;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，h 为树的高度。</p><p>示例:</p><p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点|500"></p><!-- basicblock-start oid="ObscFkRbYK1BrgDrVtqbfU91" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end -->&gt;<p>二叉搜索树删除节点就涉及到结构调整了</p><p>根据二叉搜索树的性质<br>没找到删除的节点，遍历到空节点直接返回了            💡判断逻辑</p><p><code>// 找到了删除的节点</code></p><ul><li><p>$ 如果目标节点就是当前节点，分为以下三种情况：    💡中<br>其无左子：其<strong>右子顶替其位置</strong>，删除了该节点；<br>其无右子：其<strong>左子顶替其位置</strong>，删除了该节点；<br>其左右子节点都有：<br>1. 取其左子树<br>2. 放到其右子树的最左节点的左孩子上<br>3. 然后右子树顶替其位置，由此删除了该节点。💡转化成了其无左子</p></li><li><p>$ 如果目标节点小于当前节点值，则去左子树中删除；💡左</p></li><li><p>$ 如果目标节点大于当前节点值，则去右子树中删除；💡右</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p><!-- basicblock-start oid="Obs2nnSNEnMWGwUCzBL2MaxO" --> <h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><!-- basicblock-end --><h2 id="31"><a class="markdownIt-Anchor" href="#31"></a> 3.1</h2><p>v1, 通过, 还是很清楚的, 还可以写的简洁点, 看<a href="https://leetcode.cn/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/">别人的题解</a>, 🌵⏱1-12</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>        <span class="hljs-keyword">if</span>(root-&gt;val == key){<br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>){<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 其无左子</span><br>                <span class="hljs-keyword">return</span> root-&gt;right;<span class="hljs-comment">// 💡在 return 下面就不会执行了delete, 这里不写也可以，但C++最好手动释放一下吧, 如果放在上边要重新定义一个 temp</span><br>                <span class="hljs-keyword">delete</span> root;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 其无右子</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>                <span class="hljs-keyword">delete</span> root; <br>            }<br>            <span class="hljs-keyword">else</span>{ <span class="hljs-comment">// 左右孩子都有</span><br>                TreeNode* cur = root-&gt;right;<br>                <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">NULL</span>){<span class="hljs-comment">// 找右子树的最左面的节点</span><br>                    cur = cur-&gt;left;<br>                }<br>                cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 其左子树挂到其右子树的最左面的节点的左孩子上</span><br>                <span class="hljs-keyword">return</span> root-&gt;right; <span class="hljs-comment">// 返回其右子树</span><br>                <span class="hljs-keyword">delete</span> root; <br>            }<br>        }<br>        <span class="hljs-comment">// 💡这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住，代码如下：</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right,key);<br>        <span class="hljs-keyword">return</span> root;<br>        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObskD4MXHAnEHdvzf71wHHH4" --> <p>这里相当于把新的节点(处理结果)返回给上一层，<br>遍历到 root 的左孩子了, 逻辑处理的结果要返回给左孩子, 这里就要 root-&gt;left接住，root-&gt;right 同理, 代码如下::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h2 id="32"><a class="markdownIt-Anchor" href="#32"></a> 3.2</h2><p>更简单的题解, 后序遍历也可</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (key &gt; root-&gt;val)    root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);     <span class="hljs-comment">// 去右子树删除</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root-&gt;val)    root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);  <span class="hljs-comment">// 去左子树删除</span><br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 当前节点就是要删除的节点</span><br>        {<br>            <span class="hljs-keyword">if</span> (! root-&gt;left)   <span class="hljs-keyword">return</span> root-&gt;right; <span class="hljs-comment">// 情况1，欲删除节点无左子</span><br>            <span class="hljs-keyword">if</span> (! root-&gt;right)  <span class="hljs-keyword">return</span> root-&gt;left;  <span class="hljs-comment">// 情况2，欲删除节点无右子</span><br>            TreeNode* node = root-&gt;right;           <span class="hljs-comment">// 情况3，欲删除节点左右子都有 </span><br>            <span class="hljs-keyword">while</span> (node-&gt;left)          <span class="hljs-comment">// 寻找欲删除节点右子树的最左节点</span><br>                node = node-&gt;left;<br>            node-&gt;left = root-&gt;left;    <span class="hljs-comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span><br>            root = root-&gt;right;         <span class="hljs-comment">// 欲删除节点的右子顶替其位置，节点被删除</span><br>        }<br>        <span class="hljs-keyword">return</span> root;    <br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsnJDaOfJXUh5NJtbxV2OSB" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::30. 删除二叉搜索树中的节点.md" --> <p>#历史记录::<br>2022/9/26🌵30. 删除二叉搜索树中的节点 : [第一次创建](&lt;v1, 通过, 还是很清楚的, 还可以写的简洁点, 看<a href="https://leetcode.cn/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/">别人的题解</a>, 🌵⏱1-12&gt;)</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.5 线程同步机制类封装及线程池实现</title>
      <link href="/posts/63427/"/>
      <url>/posts/63427/</url>
      
        <content type="html"><![CDATA[<h1 id="1-线程池"><a class="markdownIt-Anchor" href="#1-线程池"></a> 1 线程池</h1><p>要解决的问题::<br>平时不可能来一个客户端, 就创建一个线程, 因为如果来一万个客户端访问怎么办</p><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所 有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子 线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式:</p><ul><li>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin(轮流 选取)算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器 的整体压力。</li><li>主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任 务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线 程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在 工作队列上。</li></ul><p>![[线程池的一般模型.excalidraw]]</p><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量<br>N :如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来 说，那线程池中的线程数量最好也设置为4(或者+1防止其他因素造成的线程阻塞);</p><p>对于IO密集型的任务(<strong>客户端的访问请求</strong>)，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一 般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p><h2 id="11-总结"><a class="markdownIt-Anchor" href="#11-总结"></a> 1.1 总结</h2><ul><li>空间换时间，浪费服务器的硬件资源，换取运行效率。</li><li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</li><li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。</li><li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。<ul><li><blockquote><p>之前是来一个客户端, 就创建一个线程, 用完再销毁, 现在是不用销毁</p></blockquote></li></ul></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsKCOAsLSF0FpdgRdPXZeY5" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.5 线程同步机制类封装及线程池实现.md" --> <p>#历史记录::<br>2022/9/25🌵5.5 线程同步机制类封装及线程池实现 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.4 服务器编程基本框架和两种高效的事件处理模式</title>
      <link href="/posts/24013/"/>
      <url>/posts/24013/</url>
      
        <content type="html"><![CDATA[<h1 id="1-服务器编程基本框架"><a class="markdownIt-Anchor" href="#1-服务器编程基本框架"></a> 1 服务器编程基本框架::</h1><!-- basicblock-end --><p>![[5.4 服务器编程基本框架和两种高 效的事件处理模式 2022-09-25 15.56.51.excalidraw]]<br>I/O 处理单元是服务器管理客户连接的模块。<br>它通常要完成以下工作:</p><ul><li>等待并接受新的客户连接</li><li>接收 客户数据</li><li>将服务器响应数据返回给客户端<br>但是数据的收发不一定在 I/O 处理单元中执行，也可能在 逻辑单元中执行，具体在何处执行取决于事件处理模式。</li></ul><p>一个逻辑单元<br>通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直 接发送给客户端(具体使用哪种方式取决于事件处理模式)。<strong>服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。</strong></p><p>网络存储单元可以是数据库、缓存和文件，但不是必须的。</p><p>请求队列是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个 逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处 理竞态条件。请求队列通常被实现为池的一部分。<br>- 池: 进程池, 线程池</p><!-- basicblock-start oid="ObsyDWkdrkeCkpTkN3ylKeZ5" --> <h1 id="2-两种高效的事件处理模式"><a class="markdownIt-Anchor" href="#2-两种高效的事件处理模式"></a> 2 两种高效的事件处理模式::</h1><!-- basicblock-end --><ul><li>服务器程序通常需要处理三类事件:I/O 事件、信号及定时事件。<ul><li>I/O事件: 数据的到达与读写</li></ul></li></ul><p>有两种高效的事件处理模式:Reactor和 Proactor，<br><strong>同步 I/O 模型通常用于实现 Reactor 模式</strong><br>异步 I/O 模型通常用于实现 Proactor 模式。</p><ul><li>&amp; 本项目打算用, 同步的 I/O 模型, 模拟出 Proactor 模式</li></ul><!-- basicblock-start oid="ObsQ0hB08klpqYYuA48uN5Fy" --> <h2 id="21-reactor模式"><a class="markdownIt-Anchor" href="#21-reactor模式"></a> 2.1 Reactor模式::</h2><!-- basicblock-end --><p>要求主线程(I/O处理单元)只<strong>负责监听</strong>文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将 socket 可读可写事件放入请求队列，交给工作线程处理。<br>除此之外，主线程不做 任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步 I/O(以 epoll_wait 为例)实现的 Reactor 模式的工作流程是:</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件</li><li>当主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li></ol><p>![[Reactor 模式的工作流程.excalidraw]]</p><!-- basicblock-start oid="Obs9WOvlxhQMk3GpVPtultPm" --> <h2 id="22-proactor模式"><a class="markdownIt-Anchor" href="#22-proactor模式"></a> 2.2 Proactor模式::</h2><!-- basicblock-end --><p>Proactor 模式将所有 I/O 操作都交给主线程和内核来处理(进行读、写)，<strong>工作线程仅仅负责业务逻辑</strong>。使用异步 I/O 模型(以 aio_read 和 aio_write 为例)实现的</p><ul><li>$ Reactor模式的工作线程, 要负责读写和业务逻辑, 主线程只监听</li></ul><p>Proactor 模式的工作流程是:</p><ol><li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置， 以及读操作完成时如何通知应用程序(这里以信号为例)。</li><li>主线程继续处理其他逻辑。</li><li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li></ol><p>![[Proactor 模式的工作流程 .excalidraw]]</p><!-- basicblock-start oid="Obs5XsZ0pZj8fFFv824XsMxf" --> <h1 id="3-模拟-proactor-模式"><a class="markdownIt-Anchor" href="#3-模拟-proactor-模式"></a> 3 模拟 Proactor 模式::</h1><!-- basicblock-end --><p>使用同步 I/O 方式模拟出 Proactor 模式。原理是:主线程执行数据读写操作，读写完成之后，主线程向 工作线程通知这一”完成事件“。<strong>那么从工作线程的角度来看，它们就直接获得了数据读写的结果</strong>，接下来要做的只是对读写的结果进行逻辑处理。</p><p>使用同步 I/O 模型(以 epoll_wait为例)模拟出的 Proactor 模式的工作流程如下:</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ol><p>![[模拟 Proactor 模式的工作流程.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs4iSGdegGxq6BbSRU4qW9t" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.4 服务器编程基本框架和两种高 效的事件处理模式.md" --> <p>#历史记录::<br>2022/9/25🌵5.4 服务器编程基本框架和两种高 效的事件处理模式 : 第一次创建⏱0-51</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 协议(应用层的协议)</title>
      <link href="/posts/39549/"/>
      <url>/posts/39549/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><p>超文本传输协议(Hypertext Transfer Protocol，HTTP)是一个简单的<strong>请求 - 响应协议</strong>，<strong>它通常运行在 TCP 之上</strong>。<br>它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。<br>请求和响应消息的 头以 ASCII 形式给出;而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p><ul><li><blockquote><p>客户端给服务端发消息是请求, 服务端给客户端回消息是相应</p></blockquote></li></ul><!-- basicblock-start oid="ObsVTv1Q355JS3rRhsXBpY5H" --> <h1 id="2-概述"><a class="markdownIt-Anchor" href="#2-概述"></a> 2 概述::</h1><!-- basicblock-end --><p>HTTP 是一个客户端终端(用户)和服务器端(网站)请求和应答的标准(TCP)。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口(<strong>默认端口为80</strong>)。<br>- &gt; 一般的网站都是 80 端口, 默认不写也是 80 端口. eg: <a href="http://www.baidu.com">www.baidu.com</a> = <a href="http://www.baidu.com:80">www.baidu.com:80</a>, 实测冒号不行, 因为是网站限制<br>- $ <a href="https://www.baidu.com:80">https://www.baidu.com:80</a>访问出错是因为这里使用的是https协议，不是http协议，https协议默认端口是443，使用&nbsp;<a href="https://www.baidu.com:443">https://www.baidu.com:443</a> 就可以正常访问了</p><p>我们 称这个客户端为用户代理程序(user agent)。应答的服务器上存储着一些资源，比如 HTML 文件和图 像。我们称这个应答服务器为源服务器(origin server)。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道(tunnel)。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口(默认是80端口)的 TCP 连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比 如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><!-- basicblock-start oid="ObsMfthAg00OJbp2nwGLKik5" --> <h1 id="3-工作原理"><a class="markdownIt-Anchor" href="#3-工作原理"></a> 3 工作原理</h1><!-- basicblock-end --><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客 户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版 本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><ul><li>$ 研究的是 HTTP 报文</li></ul><!-- basicblock-start oid="Obs7qDszJjSyUkybfLVoe0WL" --> <h2 id="31-以下是-http-请求响应的步骤"><a class="markdownIt-Anchor" href="#31-以下是-http-请求响应的步骤"></a> 3.1 以下是 HTTP 请求/响应的步骤::</h2><!-- basicblock-end --><ol><li><p>客户端连接到 Web 服务器<br>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口(默认为 80 )<strong>建立一个 TCP 套接字连接</strong>. 例如，<a href="http://www.baidu.com">http://www.baidu.com</a>。(URL)</p></li><li><p>发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求 头部、空行和请求数据 4 部分组成。</p></li><li><p>服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。<strong>服务器将资源复本写到 TCP 套接字，由客户端读取</strong>。一个 响应由状态行、响应头部、空行和响应数据 4 部分组成。</p></li><li><p>释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接;若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应 头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><ul><li>~</li></ul><!-- basicblock-start oid="Obs4nccFj0T2j0myW9JYXfFY" --> <h2 id="32-网站访问的例子"><a class="markdownIt-Anchor" href="#32-网站访问的例子"></a> 3.2 网站访问的例子::</h2><!-- basicblock-end --><p>例如:在浏览器地址栏键入URL，按下回车之后会经历以下流程:</p><ol><li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p></li><li><p>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</p></li><li><p>浏览器发出读取文件( URL 中域名后面部分对应的文件)的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p></li><li><p>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</p></li><li><p>释放 TCP 连接;</p></li><li><p>浏览器将该 HTML 文本并显示内容。</p></li></ol><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232208911.png" alt="|800"></p><p>HTTP 协议是基于 TCP/IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p><ul><li>&amp; 换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</li></ul><!-- basicblock-start oid="ObsrDdFms5CG2kfXKZrLD703" --> <h1 id="4-http-请求-响应报文格式"><a class="markdownIt-Anchor" href="#4-http-请求-响应报文格式"></a> 4 HTTP 请求-响应报文格式::</h1><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232227414.png" alt="|800"></p><p>![[HTTP 协议(应用层的协议) 2022-09-23 22.30.21.excalidraw]]</p><!-- basicblock-start oid="Obsly8IhndtiuirPRqztqc80" --> <h1 id="5-http状态码"><a class="markdownIt-Anchor" href="#5-http状态码"></a> 5 HTTP状态码::</h1><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232252932.png" alt="|800"></p><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态 的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型:</p><p>1xx消息——请求已被服务器接收，继续处理<br>2xx成功——请求已成功被服务器接收、理解、并接受<br>3xx重定向——需要后续操作才能完成这一请求<br>4xx请求错误——请求含有词法错误或者无法被执行<br>5xx服务器错误——服务器在处理某个正确请求时发生错误</p><p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如"200 OK"，“404 Not Found”，但是WEB开发者仍 然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232252270.png" alt="|900"></p><p>更多状态码:<a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">https://baike.baidu.com/item/HTTP状态码/5053660?fr=aladdin</a></p><!-- basicblock-start oid="ObswjnA4vJp8dHiASiocJtpX" --> <h1 id="6-http请求方法"><a class="markdownIt-Anchor" href="#6-http请求方法"></a> 6 HTTP请求方法::</h1><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232254528.png" alt=""></p><p>HTTP/1.1 协议中共定义了八种方法(也叫“动作”)来以不同方式操作指定的资源:<br>一般都是 get 和 post</p><ol><li><p><strong>GET</strong>: 💡<strong>获取</strong>, 向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副 作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</p><ul><li>&amp; 本项目只用 GET 请求</li></ul></li><li><p>HEAD:与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文 部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该 资源的信息”(元信息或称元数据)。</p></li><li><p><strong>POST</strong>:向指定资源提交数据，请求服务器进行处理(例如提交表单或者上传文件)。数据被包含 在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><ol><li>eg: 填写个人账号</li></ol></li><li><p>PUT:向指定资源位置上传其最新内容。</p></li><li><p>DELETE:请求服务器删除 Request-URI 所标识的资源。</p></li><li><p>TRACE:回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p>OPTIONS:这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*'来代替资源名称，</p><p>向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</p></li><li><p>CONNECT:HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服</p></li></ol><p>务器的链接(经由非加密的 HTTP 代理服务器)</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyzABVQfD8rS9YOaqSFmUt" deck = "👨🏻‍💻code::项目::webserver::5 第五章::HTTP 协议(应用层的协议).md" --> <p>#历史记录::<br>2022/9/23🌵HTTP 协议(应用层的协议) ⏱1-27</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web Server(网页服务器)</title>
      <link href="/posts/57288/"/>
      <url>/posts/57288/</url>
      
        <content type="html"><![CDATA[<h1 id="1-web-server网页服务器"><a class="markdownIt-Anchor" href="#1-web-server网页服务器"></a> 1 Web Server(网页服务器)::</h1><!-- basicblock-end --><p>一个 Web Server 就是一个服务器软件(程序)，或者是运行这个服务器软件的硬件(计算机)。<br>其主要功能是通过 HTTP 协议与<strong>客户端(通常是浏览器(Browser))</strong>,进行通信，来接收，存储，处理来自 客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容(文件、网页等)或返 回一个 Error 信息。</p><p>![[5.3 Web服务器简介及HTTP协议 2022-09-23 21.38.30.excalidraw]]<br>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则 先将你的域名<strong>解析成相应的 IP 地址</strong>或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。</p><p>这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针 对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。</p><ul><li><p>&amp; 我们研究 HTTP 协议, 就是研究它的报文</p></li><li><p>&amp; HTTP 协议它的底层是基于 TCP 协议去通信的, 因为要保证数据的安全</p></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsdXHLcceexbBUljEM7FA24" deck = "👨🏻‍💻code::项目::webserver::5 第五章::Web Server(网页服务器).md" --> <p>#历史记录::<br>2022/9/23🌵Web Server(网页服务器) : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.3 Web服务器简介及HTTP协议</title>
      <link href="/posts/39188/"/>
      <url>/posts/39188/</url>
      
        <content type="html"><![CDATA[<h1 id="1-web-server网页服务器"><a class="markdownIt-Anchor" href="#1-web-server网页服务器"></a> 1 [[Web Server(网页服务器)]]</h1><h1 id="2-http-协议应用层的协议"><a class="markdownIt-Anchor" href="#2-http-协议应用层的协议"></a> 2 [[HTTP 协议(应用层的协议)]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObseOfmcyKHDqmrwX43Jc2xg" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.3 Web服务器简介及HTTP协议.md" --> <p>#历史记录::<br>2022/9/23🌵5.3 Web服务器简介及HTTP协议 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.2 Unix、 Linux上的五种lO模型</title>
      <link href="/posts/43789/"/>
      <url>/posts/43789/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsefwkIjB6k2Z2ese3h5UDz" deck = "👨🏻‍💻code::项目::webserver::5  项目实战与总结::5.2 Unix、 Linux上的五种lO模型.md" --> <p>#历史记录::<br>2022/10/14🌵5.2 Unix、 Linux上的五种lO模型 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电解抛光的流程</title>
      <link href="/posts/30219/"/>
      <url>/posts/30219/</url>
      
        <content type="html"><![CDATA[<p>铝的电解抛光, 其他材料只是溶液不同</p><h1 id="1-准备工作"><a class="markdownIt-Anchor" href="#1-准备工作"></a> 1 准备工作</h1><h2 id="11-先磨样-粗磨到细磨"><a class="markdownIt-Anchor" href="#11-先磨样-粗磨到细磨"></a> 1.1 先磨样, 粗磨到细磨</h2><p>800, 1500, 2500<br>把样品夹好, 略微高出夹紧块一点(太高也不行), 一定轻拿轻放, 不然观察有凹坑<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209231804012.jpeg" alt="|200"></p><h2 id="12-在抛光"><a class="markdownIt-Anchor" href="#12-在抛光"></a> 1.2 在抛光,</h2><p>用专门的那个布, 和抛光喷剂<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209231804321.jpeg" alt="|200"></p><h2 id="13-电解失败如何处理"><a class="markdownIt-Anchor" href="#13-电解失败如何处理"></a> 1.3 电解失败如何处理</h2><p>如果之前电解失败, 观察晶相不好,  查文献得知, 铝在电解抛光前用氢氧化钠溶液先洗一遍, 可去除之前的污渍<br>1. 泡氢氧化钠溶液 1 分钟<br>2. 涮两遍水清洗掉氢氧化钠<br>1. 热水更容易洗掉<br>3. 涮一遍酒精,<br>1. 方便吹干<br>2. 也溶解氢氧化钠<br>4. 用吹风机吹干</p><p>如果还是不行, 就重新磨样(直接从高目数), 抛光, 在电解</p><h1 id="2-电解抛光"><a class="markdownIt-Anchor" href="#2-电解抛光"></a> 2 电解抛光</h1><h2 id="21-清洗样品"><a class="markdownIt-Anchor" href="#21-清洗样品"></a> 2.1 清洗样品</h2><ul><li>涮两遍清水</li><li>涮一遍酒精,<ol><li>方便吹干</li></ol></li><li>用吹风机吹干</li></ul><h2 id="22-电解"><a class="markdownIt-Anchor" href="#22-电解"></a> 2.2 电解</h2><p>溶液: 1:9 高氯酸和酒精<br>电压 20v<br>黑色是阴极, 红色是阳极</p><ul><li>用阳极夹住镊子(样品), 样品表面朝下<ul><li>因为阴极和阳极要对向, 此处阴极向上, 所以阳极要朝下</li></ul></li><li>放入电解液, 立马打开电解器开关和搅拌器开关, 放置 40 秒</li></ul><h2 id="23-最后处理"><a class="markdownIt-Anchor" href="#23-最后处理"></a> 2.3 最后处理</h2><ul><li>在电解液中放置 40 秒后, 拿出来迅速泡两遍水(清洗电解液)</li><li>放进硝酸, 大概十几, 二十秒<ul><li>洗去电解液, 洗去灰</li></ul></li><li>涮一遍酒精,  用吹风机吹干<ol><li>泡酒精是为了方便吹干</li></ol></li><li>包住样品<ul><li>拿个保鲜膜</li><li>样品表面朝上, 用保鲜膜从样品下方包,</li><li>在样品上方留一定空隙在拧一下</li></ul></li></ul><h1 id="3-简单观察"><a class="markdownIt-Anchor" href="#3-简单观察"></a> 3 简单观察</h1><p>不错的效果, 能看出来晶相<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209231801505.jpeg" alt="|700"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObstdTiQokh0sPEuuqAKheEM" deck = "👨🏻‍🎓科研::电解抛光的流程.md" --> <p>#历史记录::<br>2022/9/23🌵电解抛光的流程 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>29. 二叉搜索树中的插入操作</title>
      <link href="/posts/35027/"/>
      <url>/posts/35027/</url>
      
        <content type="html"><![CDATA[<h1 id="1-701二叉搜索树中的插入操作"><a class="markdownIt-Anchor" href="#1-701二叉搜索树中的插入操作"></a> 1 701.二叉搜索树中的插入操作</h1><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">力扣题目链接</a></p><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p><img src="https://img-blog.csdnimg.cn/20201019173259554.png" alt="701.二叉搜索树中的插入操作|400"></p><p>提示：</p><ul><li>给定的树上的节点数介于 0 和 10^4 之间</li><li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li><li>-10^8 &lt;= val &lt;= 10^8</li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>可以不考虑改变树的结构的插入方式</strong>,  在原先基础上插入就行<br>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbk63ina5g30eo08waja.gif" alt="701.二叉搜索树中的插入操作"><br>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>需要调整二叉树的结构么？ 并不需要。</strong>。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过,  比较简单⏱ 0-25</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-comment">// 下一层将加入节点返回(上边)，本层用root-&gt;left或者root-&gt;right将其接住。</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZDoQppYekSBwSqZhoIrUy" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::29. 二叉搜索树中的插入操作.md" --> <p>#历史记录::<br>2022/9/23🌵29. 二叉搜索树中的插入操作 : v1, 通过,  比较简单⏱ 0-25</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归函数的返回值</title>
      <link href="/posts/49353/"/>
      <url>/posts/49353/</url>
      
        <content type="html"><![CDATA[<p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点:: ^03d9cc</p><h1 id="1-如果需要搜索整棵二叉树且不用处理递归返回值递归函数就不要返回值"><a class="markdownIt-Anchor" href="#1-如果需要搜索整棵二叉树且不用处理递归返回值递归函数就不要返回值"></a> 1 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值</h1><p>[[18. 路径总和|18. 路径总和]]</p><h1 id="2-如果需要搜索整棵二叉树且需要处理递归返回值递归函数就需要返回值"><a class="markdownIt-Anchor" href="#2-如果需要搜索整棵二叉树且需要处理递归返回值递归函数就需要返回值"></a> 2 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。</h1><h2 id="21-28-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#21-28-二叉搜索树的最近公共祖先"></a> 2.1 [[28. 二叉搜索树的最近公共祖先]]</h2><p>搜索一条边的写法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (递归函数(root-&gt;left)) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span> (递归函数(root-&gt;right)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></tbody></table></figure><p>搜索整个树写法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">left = 递归函数(root-&gt;left);<br>right = 递归函数(root-&gt;right);<br>left与right的逻辑处理;<br></code></pre></td></tr></tbody></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><h1 id="3-如果要搜索其中一条符合条件的路径那么递归一定需要返回值因为遇到符合条件的路径了就要及时返回"><a class="markdownIt-Anchor" href="#3-如果要搜索其中一条符合条件的路径那么递归一定需要返回值因为遇到符合条件的路径了就要及时返回"></a> 3 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</h1><ul><li>&amp; 找到目标节点就结束递归的情况<br>eg: [[22. 二叉搜索树中的搜索#^mwvvme]]</li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsysS788jcKXNf67nwqGCgk" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::递归函数什么时候需要返回值.md" --> <p>#历史记录::<br>2022/9/23🌵递归函数什么时候需要返回值 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>28. 二叉搜索树的最近公共祖先</title>
      <link href="/posts/694/"/>
      <url>/posts/694/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#1-二叉搜索树的最近公共祖先"></a> 1 二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">力扣题目链接</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://img-blog.csdnimg.cn/20201018172243602.png" alt="235. 二叉搜索树的最近公共祖先"></p><p>示例 1:</p><ul><li>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</li><li>输出: 6</li><li>解释: 节点 2 和节点 8 的最近公共祖先是 6。</li></ul><p>示例 2:</p><ul><li>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</li><li>输出: 2</li><li>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li></ul><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><!-- basicblock-start oid="ObsCQaDIhJ6zuxwfoFILa6R3" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>和[[26. 二叉树的最近公共祖先]]不同，普通二叉树求最近公共祖先需要使用回溯，<strong>从底向上来查找</strong>，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么<strong>只要从上向下遍历就可以了。</strong></p><p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p>如图所示：p为节点3，q为节点5</p><p><img src="https://img-blog.csdnimg.cn/20210204150858927.png" alt="235.二叉搜索树的最近公共祖先|500"></p><p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！<br>[[18. 路径总和#^03d9cc]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>用迭代法更好一点</p><blockquote><p>[!example]-</p><!-- basicblock-start oid="ObsQgR0cL03Riw2IWBx5gNbM" --> </blockquote><p>![[28. 二叉搜索树的最近公共祖先 2022-09-30 08.45.39.excalidraw]]::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/">Loading Question… - 力扣（LeetCode）</a></p><h2 id="31-迭代"><a class="markdownIt-Anchor" href="#31-迭代"></a> 3.1 迭代</h2><p>v1:通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">while</span>(root) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) { <span class="hljs-comment">// ❗️不是 root &gt; p</span><br>                root = root-&gt;left;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) {<br>                root = root-&gt;right;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// ❗️else 不能省</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-递归"><a class="markdownIt-Anchor" href="#32-递归"></a> 3.2 递归</h2><p>v1, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br><span class="hljs-comment">// 第一种情况</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val){<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        }<br><span class="hljs-comment">// 第二种情况</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val){<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        }<br><span class="hljs-comment">// 第三种情况</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[递归函的返回值#2 1 28 二叉搜索树的最近公共祖先|递归函数什么时候需要返回值]]</p><h1 id="4-迭代"><a class="markdownIt-Anchor" href="#4-迭代"></a> 4 迭代</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsJDQVCmUGJ9XRPcDGiAzEV" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::28. 二叉搜索树的最近公共祖先.md" --> <p>#历史记录::<br>2022/9/23🌵28. 二叉搜索树的最近公共祖先 : 有一点点懵, 还行⏱1-17</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27. 二叉树周末总结</title>
      <link href="/posts/56265/"/>
      <url>/posts/56265/</url>
      
        <content type="html"><![CDATA[<p>看了总结, 那个内容不多,   整理到了二叉搜索树</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsqya4STijB8A9RqffclD01" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::27. 二叉树周末总结.md" --> <p>#历史记录::<br>2022/9/23🌵27. 二叉树周末总结 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. 二叉树的最近公共祖先</title>
      <link href="/posts/15641/"/>
      <url>/posts/15641/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#1-二叉树的最近公共祖先"></a> 1 二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:&nbsp; root =&nbsp;[3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p><p>示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p><p>示例&nbsp;2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209221119231.png" alt=""></p><ul><li><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">题解的流程图</a></p></blockquote></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1: 看题解的流程图, 很清楚⏱1-05</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q); <span class="hljs-comment">// 左</span><br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span>  &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 公共祖先在右子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<span class="hljs-comment">// 公共祖先在左子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsFdr3s5N4yCB0XTQlmZGaN" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::26. 二叉树的最近公共祖先.md" --> <p>#历史记录::<br>2022/9/22🌵26. 二叉树的最近公共祖先 : v1: 看题解的流程图, 很清楚⏱1-05</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. 二叉搜索树中的众数</title>
      <link href="/posts/16602/"/>
      <url>/posts/16602/</url>
      
        <content type="html"><![CDATA[<h1 id="1-501二叉搜索树中的众数"><a class="markdownIt-Anchor" href="#1-501二叉搜索树中的众数"></a> 1 501.二叉搜索树中的众数</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">力扣题目链接</a></p><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有<strong>众数（出现频率最高的元素）</strong>。</p><p>假定 BST 有如下定义：<br>[[二叉搜索树]]</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>例如：</p><p>给定 BST [1,null,2,2],</p><p><img src="https://img-blog.csdnimg.cn/20201014221532206.png" alt="501. 二叉搜索树中的众数"></p><p>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><!-- basicblock-start oid="ObsWi09KAKMcXYABbGrnRiQy" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>分两个思路: 是二叉树, 不是二叉树</p><h2 id="21-不是二叉搜索树"><a class="markdownIt-Anchor" href="#21-不是二叉搜索树"></a> 2.1 不是二叉搜索树</h2><p>[[map]]<br>如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</p><!-- basicblock-start oid="Obs9OzCi1FIQ44aAkgQKVmlU" --> <p>map 中的排序::<br>C++中如果使用std::map或者std::multimap可以对key排序，但不能对value排序。</p><!-- basicblock-end --><!-- basicblock-start oid="ObsUuRh2eYUEnUnwoLFxdUSI" --> <h2 id="22-是二叉搜索树"><a class="markdownIt-Anchor" href="#22-是二叉搜索树"></a> 2.2 是二叉搜索树::</h2><!-- basicblock-end --><h3 id="221"><a class="markdownIt-Anchor" href="#221"></a> 2.2.1</h3><ul><li>&amp; 中序遍历搜索树, 得到有序数组. 遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了</li></ul><h3 id="222"><a class="markdownIt-Anchor" href="#222"></a> 2.2.2</h3><ul><li>$ 直接在树上操作<ul><li>使用了pre指针和cur指针,<strong>只需要遍历一遍二叉搜索树，就求出了众数的集合</strong></li></ul></li></ul><p>v1, 通过, 抄了一遍,大概明白了⏱0-40</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 第一个节点</span><br>            count = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre-&gt;val == cur-&gt;val){<span class="hljs-comment">// 与前一个节点数值相同</span><br>            count++;<br>        }<br>        <span class="hljs-keyword">else</span>{<span class="hljs-comment">// 与前一个节点数值不同</span><br>            count = <span class="hljs-number">1</span>;<br>        }<br>        pre = cur;<span class="hljs-comment">// 更新上一个节点</span><br><br>        <span class="hljs-keyword">if</span>(count == maxCount){<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br>        <span class="hljs-keyword">if</span>(count &gt; maxCount){<span class="hljs-comment">// 不止一个众数的时候</span><br>            maxCount = count;<span class="hljs-comment">// 更新最大频率</span><br>            result.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">// 不要忘记清空result，之前result里的元素都失效了, 因为众数不止一个</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 不会做了<br>这个是只能找出一个众数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">if</span>(pre-&gt;val == cur-&gt;val) count++;<br>        }<br><br>        <span class="hljs-keyword">else</span> count = <span class="hljs-number">1</span>;<br>        pre = cur;<br>        <span class="hljs-keyword">if</span>(count == maxCount){<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br>        <span class="hljs-keyword">if</span>(count &gt; maxCount){<br>            maxCount = count;<br>            result.<span class="hljs-built_in">clear</span>();<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);<br>        <span class="hljs-keyword">return</span>;<br><br>        <br>        <br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsecQeY0a3GuLyXMEgccrCp" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::25. 二叉搜索树中的众数.md" --> <p>#历史记录::<br>2022/9/22🌵25. 二叉搜索树中的众数 : v1, 通过, 抄了一遍,大概明白了⏱0-40</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空类</title>
      <link href="/posts/50155/"/>
      <url>/posts/50155/</url>
      
        <content type="html"><![CDATA[<h1 id="1-不含函数或者含有函数"><a class="markdownIt-Anchor" href="#1-不含函数或者含有函数"></a> 1 不含函数或者含有函数::</h1><p>![[空类 2022-09-21 22.16.00.excalidraw]]<br>多重继承的空类的大小也是1。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father1</span>{}; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father2</span>{};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>:Father1, Father2{};<br></code></pre></td></tr></tbody></table></figure><h1 id="2-含有虚函数"><a class="markdownIt-Anchor" href="#2-含有虚函数"></a> 2 含有虚函数::</h1><p>![[空类 2022-09-21 22.21.22.excalidraw]]</p><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::空类.md"--><h1 id="3-何时共享虚函数地址表"><a class="markdownIt-Anchor" href="#3-何时共享虚函数地址表"></a> 3 何时共享虚函数地址表::</h1><!-- basicblock-end --><p>如果派生类继承的第一个是基类，且该基类定义了虚函数地址表，则派生类就共享该表首址占用的存储单元。<br>对于除前述情形以外的其他任何情形，派生类在处理完所有基类或虚基类后，根据派生类是否建立了虚函数地址表，确定是否为该表首址分配存储单元。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>{}; <span class="hljs-comment">//sizeof(x)：1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X {}；<span class="hljs-comment">//sizeof(Y):4 💡虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X {}；<span class="hljs-comment">//sizeof(z):4 💡虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Y {}；<span class="hljs-comment">//sizeof(A):8❓</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">public</span> Y, <span class="hljs-keyword">public</span> Z{}; <span class="hljs-comment">//sizeof(B)：8💡两个虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Y, <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> z {}；<span class="hljs-comment">//sizeof(c)：12 ❓</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> ：<span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> C{}；<span class="hljs-comment">//sizeof(D)：16❓</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsSTzxRkOeHVkL1rcMxavtB" deck = "👨🏻‍💻code::C++::C++基础::空类.md" --> <p>#历史记录:: <a href="https://www.bilibili.com/video/BV1LK411s7ES/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++虚函数_哔哩哔哩_bilibili</a><br>2022/9/21🌵空类 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么需要虚继承</title>
      <link href="/posts/54153/"/>
      <url>/posts/54153/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><p>虚继承: 使得在派生类中只保留一份间接基类的成员。</p><p>多继承: 是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。</p><ul><li>&amp; 使用多继承经常出现二义性，必须十分小心； 一般只有在比较简单和不易出现二义性或者实在必要情况下才使用多继承，能用单一继承解决问题就不要用多继承。</li></ul><!-- basicblock-start oid="ObsRiK1y7O0WBisAEBS51kpj" --> <h1 id="2-目的"><a class="markdownIt-Anchor" href="#2-目的"></a> 2 目的::</h1><!-- basicblock-end --><p>虚继承的目的是让某个类做出声明，<strong>承诺愿意共享它的基类</strong><br>其中，这个被共享的基类就称为虚基类(Virtual Base Class),<br>其中A就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><!-- basicblock-start oid="ObsAHdpB4FXUD0EriY4SIJ4t" --> <h1 id="3-案例"><a class="markdownIt-Anchor" href="#3-案例"></a> 3 案例::</h1><!-- basicblock-end --><h2 id="31"><a class="markdownIt-Anchor" href="#31"></a> 3.1</h2><p>类A有一个成员变量a,不使用虚继承，那么在类D中直接访问a就会产生歧义。</p><ul><li><p>$ 编译器不知道它究竟来自A-&gt;B-&gt;D这条路径，还是来自A-&gt;C-&gt;D这条路径。</p></li><li><p>? 不是拷贝问题, 而是路径问题吗: ✅是拷贝也是路径问题<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209212204647.png" alt="|700"><br>![[为什么需要虚继承 2022-09-21 21.52.30.excalidraw]]</p></li><li><p>? ✅使用虚继承: 访问 a 只会是类 A 中的 A, 不会是 B, C 中的 a, 因为 BC 中继承的a不是类 A 的拷贝, 而直接是 A 中的 a</p></li></ul><h2 id="32"><a class="markdownIt-Anchor" href="#32"></a> 3.2</h2><p>iostream从istream和ostream直接继承而来，而istream和ostream又都继承自一个共同的名为baseios的类，是典型的菱形继承。<br>此时istream和ostream必须采用虚继承，否则将导致<strong>iostream类中保留两份baseios类的成员</strong></p><ul><li>&amp; 说明了还是拷贝了<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209212209696.png" alt="|700"></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsuhSYsGn9BeRAJQoLYrBto" deck = "👨🏻‍💻code::C++::C++基础::为什么需要虚继承.md" --> <p>#历史记录::<br>2022/9/21🌵为什么需要虚继承 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/posts/25357/"/>
      <url>/posts/25357/</url>
      
        <content type="html"><![CDATA[<p>![[多态 与虚函数 .excalidraw]]</p><!-- basicblock-start oid="ObseGtaD73KcOI6yxImR8KvQ" --> <h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><p>同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为</p><ul><li><blockquote><p>（重载实现编译时多态，虚函数实现运行时多态)</p></blockquote></li></ul><p>将方法定义在子类中, 每次用同样名字的函数,但是不同子类执行的不一样<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209272024506.png" alt="|500"></p><p><a href="https://www.bilibili.com/video/BV1wZ4y1B7A7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">8分钟搞懂面向对象编程 | 面向过程vs面向对象 | OOP | 封装 继承 多态_哔哩哔哩_bilibili</a></p><!-- basicblock-start oid="ObseRDfJVSuhiNRJcbKIMGIU" --> <h1 id="2-功能"><a class="markdownIt-Anchor" href="#2-功能"></a> 2 功能::</h1><!-- basicblock-end --><p>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作；</p><ul><li>&amp; 简单一句话：允许将子类类型的指针赋值给父类类型的指针。</li></ul><!-- basicblock-start oid="ObsUuJSbUDxuFrLbNe2OFBCY" --> <h1 id="3-实现多态有两种方式"><a class="markdownIt-Anchor" href="#3-实现多态有两种方式"></a> 3 实现多态有两种方式::</h1><!-- basicblock-end --><p>1.覆盖(override)：是指子类重新定义父类的虚函数的做法<br>2.重载(overload)：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同)</p><ul><li>$ 例如： 基类是一个抽象对象一一人，那学生、运动员也是人，而使用这个抽象对象既可以表示学生、也可以表示运动员。</li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsCzqbVYfUIWxCriexORb4K" deck = "👨🏻‍💻code::C++::C++基础::多态.md" --> <p>#历史记录::<br>2022/9/21🌵多态 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚函数</title>
      <link href="/posts/24405/"/>
      <url>/posts/24405/</url>
      
        <content type="html"><![CDATA[<p>![[多态 与虚函数 .excalidraw]]</p><p>定义:</p><p>当基类希望派生类定义适合自己的版本，就将这些函数声明成虚函数(virtual)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Vfunc</span><span class="hljs-params">()</span></span>{};<span class="hljs-comment">// 当基类希望派生类定义适合自己的版本的 Vfunc</span><br><br>};<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObspW69cHg82emHE7dIIIQoJ" --> <p>1、虚函数是动态绑定的<br>也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数，这是虚函数的基本功能。::</p><!-- basicblock-end --><!-- basicblock-start oid="Obsm7oDNTqQec1I6vbJQHXhF" --> <p>2、与多态的关系 （不同继承关系的类对象，调用同一函数产生不同行为）</p><ul><li>&amp; 调用函数的对象必须是指针或者引用</li><li>&amp; 被调用的函数必须是虚函数(virtual)，且完成了虚函数的重写（派生类中有一个跟基类的完全相同虚函数）::</li></ul><!-- basicblock-end --><!-- basicblock-start oid="ObsvJSMSzvYLJlAnldZ9BFvt" --> <p>3、动态绑定, 绑定的是动态类型<br>所对应的函数或属性依赖于对象的动态类型，发生在运行期。::</p><!-- basicblock-end --><!-- basicblock-start oid="Obsu4ScYCweLwvZklIrS9jwf" --> <p>4、构造函数不能是虚函数::<br>而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好，多态是被disable的。</p><!-- basicblock-end --><!-- basicblock-start oid="Obsr7PvRHP5hpPu57rcnnHtA" --> <p>5、虚函数的工作方式::<br>当类中至少有一个虚函数, 编译期就会为类 A生成一个虚函数表<br>依赖虚函数表vtbl工作的，表来保存虚函数地址，当我们用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。这个机制可以保证派生类中的虚函数被调用到。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209212227729.png" alt=""></p><!-- basicblock-end --><!-- basicblock-start oid="ObswXHOHy30OPDCU5xZPNNH2" --> <p>6、析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。::</p><!-- basicblock-end --><!-- basicblock-start oid="ObsNDVJqMokws0GafeU8Y2Jt" --> <p>7、将一个函数定义为纯虚函数。<br>实际上是将这个类定义为抽象类，不能实例化对象；纯虚函数通常没有定义体，但也完全可以拥有。::</p><!-- basicblock-end --><p>8、 inline, static, constructor三种函数都不能带有virtual关键字。<br>(1) inline是在编译时展开，必须要有实体。<br>内联函数是指在编译期间用被调用函数体本身来代替函数的调用指令，但虚函数的多态特性需要在运行时根据对象<br>类型才知道调用哪个虚函数，所以没法在编译时进行内联函数展开。<br>(2) static属于class自己的类相关，必须有实体；<br>static成员没有this指针。virtual函数一定要通过对象来调用，有隐藏的this指针，实例相关。</p><p>9、 析构函数可以是纯虚的<br>但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。</p><p>10、派生类的override虚函数定义必须和父类完全一致。<br>除了一个特例，如果父类中返回值是一个指针或引用，子类override时可以返回这个指针（或引用）的派生。</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsu7HQtjS477mDHwN0DQvXX" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::虚函数.md"--><p>#历史记录::<br>2022/9/21🌵虚函数 :</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1LK411s7ES/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++虚函数_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 三大特性</title>
      <link href="/posts/3476/"/>
      <url>/posts/3476/</url>
      
        <content type="html"><![CDATA[<p><strong>访问权限</strong></p><p>C++通过public、.protected、private三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。<br>在类的内部（定义类的代码内部），无论成员被声明为public、protected还是private,都是可以互相访问的， 没有访问权限的限制。<br>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问pubc属性的成员，不能访问private、protected属性的成员。<br>无论共有继承、私有和保护继承，私有成员不能被“派生类”访问，基类中的共有和保护成员能被“派生类"访问。<br>对于共有继承，只有基类中的共有成员能被“派生类对象”访问，保护和私有成员不能被“派生类对象"”访问。对于私有和保护继承，基类中的所有成员不能被“派生类对象"访问。</p><h1 id="1-封装"><a class="markdownIt-Anchor" href="#1-封装"></a> 1 封装::</h1><p><strong>定义</strong>： 数据和代码捆绑在一起，避免外界干扰和不确定性访问；</p><p><strong>功能</strong>： 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，<br>例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p><h1 id="2-继承"><a class="markdownIt-Anchor" href="#2-继承"></a> 2 继承::</h1><p><strong>定义</strong>： 让某种类型对象获得另一个类型对象的属性和方法</p><p><strong>功能</strong>： 它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展<br>常见的继承有三种方式：<br>1、实现继承：指使用基类的属性和方法而无需额外编码的能力<br>2、接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力<br>- ? 是子类也得有函数吗<br>3、可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力<br>- ? 可拓展功能吗</p><p>💡<strong>例如</strong>：</p><ul><li>&amp; 将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法。</li></ul><p><a href="https://www.bilibili.com/video/BV1wZ4y1B7A7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">8分钟搞懂面向对象编程 | 面向过程vs面向对象 | OOP | 封装 继承 多态_哔哩哔哩_bilibili</a><br>![[C++ 三大特性 2022-09-27 20.22.16.excalidraw]]</p><h1 id="3-多态"><a class="markdownIt-Anchor" href="#3-多态"></a> 3 [[多态]]::</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRKwqyYulceDLT0e3L5TCR"  --> <p>#历史记录::<br>2022/9/21🌵C++ 三大特性 : <a href="marginnote3app://note/025A6CAE-DC4A-44BE-85DF-74E7B59576A5">margin</a></p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24.二叉搜索树的最小绝对差</title>
      <link href="/posts/12931/"/>
      <url>/posts/12931/</url>
      
        <content type="html"><![CDATA[<h1 id="1-530二叉搜索树的最小绝对差"><a class="markdownIt-Anchor" href="#1-530二叉搜索树的最小绝对差"></a> 1 530.二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">力扣题目链接</a></p><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20201014223400123.png" alt="530二叉搜索树的最小绝对差"></p><p>提示：树中至少有 2 个节点。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-转成递增数组"><a class="markdownIt-Anchor" href="#21-转成递增数组"></a> 2.1 转成递增数组</h2><p>中序遍历转为递增数组, 在数组中 遍历一遍, 统计出最小差值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vec.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 💡统计有序数组的最小差值</span><br>            result = <span class="hljs-built_in">min</span>(result, vec[i] - vec[i<span class="hljs-number">-1</span>]);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p><!-- basicblock-start oid="Obs28HoLjKYXLBQlGBUJjUqz" --> <h2 id="22-不转化递增数组而直接比较"><a class="markdownIt-Anchor" href="#22-不转化递增数组而直接比较"></a> 2.2 不转化递增数组而直接比较::</h2><!-- basicblock-end --><p>需要用一个pre节点记录一下cur节点的前一个节点。</p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210204153247458.png" alt="530.二叉搜索树的最小绝对差"></p><p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。<br>v1: 通过, 写了一遍, 断点调试了一遍, 感觉真正搞懂了中序遍历的过程</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-type">int</span> result = INT_MAX;   <br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void 类型不返回任何值</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span>){<br>            result = <span class="hljs-built_in">min</span>(result, cur-&gt;val - pre-&gt;val);<br>        }<br>        pre = cur;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right);<br>    }<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsOzXWLboBLrJznvS06xXV0" --> <p>找最小值::<br>先定义一个最大值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> result = INT_MAX;<br>result = min(result, cur-&gt;val - pre-&gt;val);<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsi3UEGhMdw3d82lqs2PXUR" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::24.二叉搜索树的最小绝对差.md" --> <p>#历史记录::<br>2022/9/21🌵24.二叉搜索树的最小绝对差 : v1: 通过, 写了一遍, 断点调试了一遍, 感觉真正搞懂了中序遍历的过程⏱0-38</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. 验证二叉搜索树</title>
      <link href="/posts/35976/"/>
      <url>/posts/35976/</url>
      
        <content type="html"><![CDATA[<h1 id="1-98验证二叉搜索树"><a class="markdownIt-Anchor" href="#1-98验证二叉搜索树"></a> 1 98.验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">力扣题目链接</a></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210203144334501.png" alt="98.验证二叉搜索树"></p><!-- basicblock-start oid="ObshF2z7TepcKWPolt2VhfPy" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><h2 id="21-中序构造递增数组"><a class="markdownIt-Anchor" href="#21-中序构造递增数组"></a> 2.1 中序构造递增数组</h2><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p><p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了</strong></p><h3 id="211-代码"><a class="markdownIt-Anchor" href="#211-代码"></a> 2.1.1 代码</h3><p>v1, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span>{ <span class="hljs-comment">// 💡其实不需要传 vec 参数, vec 在外边定义(全局变量), 函数里边直接 push_back 就行</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void类型, 不能返回 NULL</span><br>        <span class="hljs-built_in">traversal</span>(root-&gt;left, vec);<br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;right, vec);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traversal</span>(root, vec);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// ❗️不能i=0, vec[i] &gt;= vec[i+1], 因为 i+1 已经超过了范围</span><br>            <span class="hljs-keyword">if</span>(vec[i<span class="hljs-number">-1</span>] &gt;= vec[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// ❗️要有'='号</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^44p3md</p><!-- basicblock-start oid="ObszbeJDwapQgPZ0NlAU4DG7" --> <p>void类型函数::<br>不能返回 NULL</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span>{<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void类型, 不能返回 NULL</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>[[for 循环]]</p><h2 id="22-直接递归判断是否是递增"><a class="markdownIt-Anchor" href="#22-直接递归判断是否是递增"></a> 2.2 直接递归判断是否是递增</h2><p>在中序遍历的过程中, 逐次比较元素是不是从小到大的<br>carl, 断点调试看懂了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> maxVal = LONG_MIN; <span class="hljs-comment">// 因为后台测试数据中有int最小值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br>        <span class="hljs-comment">// 中序遍历，验证遍历 左 &lt; 中 &lt; 右</span><br>        <span class="hljs-keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsNlPfoaZ3O3Ja9BgmtfHLh" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::23. 验证二叉搜索树.md" --> <p>#历史记录::<br>2022/9/21🌵23. 验证二叉搜索树 : 第一个思路简单, 第二个思路看懂了, 没写⏱0-33</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. 二叉搜索树中的搜索</title>
      <link href="/posts/11655/"/>
      <url>/posts/11655/</url>
      
        <content type="html"><![CDATA[<h1 id="1-700二叉搜索树中的搜索"><a class="markdownIt-Anchor" href="#1-700二叉搜索树中的搜索"></a> 1 700.二叉搜索树中的搜索</h1><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">力扣题目地址</a></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><p><img src="https://img-blog.csdnimg.cn/20210204155522476.png" alt="700.二叉搜索树中的搜索"></p><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p><!-- basicblock-start oid="Obs4iAVyITtzgH0WdEcIwT0y" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>[[二叉搜索树]]</p><h2 id="21-迭代法"><a class="markdownIt-Anchor" href="#21-迭代法"></a> 2.1 迭代法</h2><p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。<br>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p><p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong><br>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p><p><img src="https://img-blog.csdnimg.cn/20200812190213280.png" alt="二叉搜索树"></p><p>二叉搜索树: 左小右大</p><h3 id="211-代码"><a class="markdownIt-Anchor" href="#211-代码"></a> 2.1.1 代码</h3><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root = root-&gt;left;<span class="hljs-comment">// 节点值比目标值大, 就往小的地方找即左子树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root = root-&gt;right;<span class="hljs-comment">// 同理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 此处就是找到的情况了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// ❗️要有找不到的情况</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>第一次看到了如此简单的迭代法，是不是感动的痛哭流涕，哭一会~</p><!-- basicblock-start oid="ObsUEjBtpnDNEmm4clXZSc4h" --> <h2 id="22-递归法"><a class="markdownIt-Anchor" href="#22-递归法"></a> 2.2 递归法::</h2><!-- basicblock-end --><p>在递归遍历的时候，什么时候直接return 递归函数的返回值，什么时候不用加这个 return呢。<br><strong>就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong>[[18. 路径总和#^03d9cc]]</p><h3 id="221-代码"><a class="markdownIt-Anchor" href="#221-代码"></a> 2.2.1 代码::</h3><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val); <span class="hljs-comment">// 💡注意这里的 return</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<span class="hljs-comment">// 💡💡之前都会用一个变量把 return 接住, 不接住的话就直接返回了</span><br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// ❗️这个不能少, 每次都要返回给 if 判断语句那里</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^mwvvme</p><p>v2 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{ <br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// ❗️NULL 和 val 的顺序不能变</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsPTm0TSQ3ztddcJoB61gUQ" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::22. 二叉搜索树中的搜索.md" --> <p>#历史记录::<br>2022/9/21🌵22. 二叉搜索树中的搜索 :  简单题⏱0-31</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::atomic</title>
      <link href="/posts/59657/"/>
      <url>/posts/59657/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前置与后置1-1-a-是否是线程安全的"><a class="markdownIt-Anchor" href="#1-前置与后置1-1-a-是否是线程安全的"></a> 1 [[前置<ins>与后置</ins>#1 1 a 是否是线程安全的]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsQUI5zgo1uepM3fXwsixYV" --> <h1 id="2-int-ab在c中是否是线程安全的"><a class="markdownIt-Anchor" href="#2-int-ab在c中是否是线程安全的"></a> 2 int a=b在C++中是否是线程安全的::</h1><!-- basicblock-end --><p>int a = b;从C/C++语法的级别来看，这是条语句应该是原子的；但从编译器得到的汇编指令来看，由于现在计算机CPU架构体系的限制，数据不能直接从内存某处搬运到内存另外一处，必须借助寄存器中转，因此这条语句一般对应两条计算机指令，即将变量b的值搬运到某个寄存器（如eax)中，再从该寄存器搬运到变量a的内存地址中：<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209202245531.png" alt=""></p><p>既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第一条指令执行完毕后被剥夺CPU时间片，切换到另一个线程而出现不确定的情况。<br>解决办法：C++11新标准发布后改变了这种困境，新标准提供了对<strong>整形变量原子操作的相关库</strong>，即std:atomic, 这是一个模板类型：</p><ul><li>$</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">atomic</span>:<br><br>我们可以传入具体的整型类型对模板进行实例化，实际上stl库也提供了这些实例化的模板类型<br><br><span class="hljs-comment">// 初始化1</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; value;<br>value = <span class="hljs-number">99</span>;<span class="hljs-comment">// 💡通过</span><br><br><span class="hljs-comment">// 初始化2</span><br><span class="hljs-comment">//下面代码在Linux平台上无法编译通过 (指在gcc编译器）</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; value = <span class="hljs-number">99</span>;<span class="hljs-comment">// ❗️出错, 系统不允许直接赋值, 禁止编译器自动生成</span><br><span class="hljs-comment">//出错的原因是这行代码调用的是std:：atomic的拷贝构造函数</span><br><span class="hljs-comment">//而根据c++11语言规范，std::atomic的拷贝构造函数使用=delete标记禁止编译器自动生成</span><br><span class="hljs-comment">//g++在这条规则上遵循了c++11语言规范。</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsISsGVqOe4a25Z2d5f4MoL" deck = "👨🏻‍💻code::C++::C++基础::stdatomic.md" --> <p>#历史记录::<br>2022/9/20🌵stdatomic : <a href="marginnote3app://note/AF118F7E-D507-4AA5-AA33-0B9C547E71A7">margin</a></p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前置++与后置++</title>
      <link href="/posts/28971/"/>
      <url>/posts/28971/</url>
      
        <content type="html"><![CDATA[<p>自+1, 必须使用在变量</p><h1 id="1-后置"><a class="markdownIt-Anchor" href="#1-后置"></a> 1 后置++</h1><p>参与运算时: 先使用<ins>之前的的值, 在</ins><br>eg:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 版本 1 = 版本 2</span><br><br><span class="hljs-comment">// 版本 1</span><br><span class="hljs-keyword">while</span>(size--){<br><br>}<br><br><span class="hljs-comment">// 版本 2</span><br><span class="hljs-keyword">while</span>(size){<br>size--<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>后置为了返回旧值创建了一个临时对象，在函数结束的时候这个对象就会被销毁</p><!-- basicblock-start oid="ObsbleM6HvLKvVfrCQ2FbXEU" extra = "[margin](marginnote3app://note/40E6DB02-A325-4677-B64E-D9A609FE8681)"--> <h2 id="11-a-是否是线程安全的"><a class="markdownIt-Anchor" href="#11-a-是否是线程安全的"></a> 1.1 a++ 是否是线程安全的::</h2><p><a href="marginnote3app://note/40E6DB02-A325-4677-B64E-D9A609FE8681">margin</a></p><!-- basicblock-end --><p>a++：从C/C++语法的级别来看，这是一条语句，应该是原子的；但从编译器得到的汇编指令来看，其实不是原子的。<br>其一般对应三条指令，首先将变量对应的内存值搬运到某个寄存器（如eax)中，然后将该寄存器中的值自增1， 再将该寄存器中的值搬运回a代表的内存中</p><ul><li>$ 系统中没法直接对变量操作, 计算, 赋值…, 需要寄存器里操作, 在搬回本来的内存</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209272001228.png" alt="|400"></p><!-- basicblock-start oid="ObsvqKfKSKrTbtmMsIIdqhIE" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::前置++与后置++.md"--><p>现在假设 i 的值是0，有两个线程，每个线程对变量 i 的值都递增1，预想一下，其结果应该是2，可实际运行结构可能是1,是不是很奇怪？</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209202225411.png" alt="|1000"></p><ul><li>? 没找到指令 456  ✅算了不找了, 没找到</li><li>$ 主要想说: <strong>操作系统线程调度的不确定性</strong>, 线程不是顺序执行的</li></ul><!-- basicblock-end --><h1 id="2-前置"><a class="markdownIt-Anchor" href="#2-前置"></a> 2 前置++</h1><p>参与运算时: 使用++后的值,</p><p>最好使用前置++，因为他不会创建临时对象，进而不会带来构造和析构而造成的格外开销。</p><!-- basicblock-start oid="ObsfcjJZr9imcDOst3eYjLmk" --> <p>运算符::<br>[ ] : 下标运算       eg:  arr[5]<br>{}  :  数组初始化  eg: int a[3] 二 {1,2,3}</p><!-- basicblock-end --><!-- basicblock-start oid="Obs9ua2Ej2XMy6dAXCRaYfi9" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::前置++与后置++.md"--><h1 id="3-区别"><a class="markdownIt-Anchor" href="#3-区别"></a> 3 区别::</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209202214087.png" alt=""></p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsaW0B5sy4l7hZ0imFaIkhg" deck = "👨🏻‍💻code::C++::C++基础::前置++与后置++.md" --> <p>#历史记录::<br>2022/9/20🌵前置<ins>与后置</ins> : margin 里边的不懂<a href="marginnote3app://note/F2C85E29-1092-4D10-89F0-9FA8884AA5E0">margin</a></p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21. 合并二叉树</title>
      <link href="/posts/57925/"/>
      <url>/posts/57925/</url>
      
        <content type="html"><![CDATA[<h1 id="1-617合并二叉树"><a class="markdownIt-Anchor" href="#1-617合并二叉树"></a> 1 617.合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">力扣题目链接</a></p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为&nbsp;NULL 的节点将直接作为新二叉树的节点。</p><p>示例&nbsp;1:</p><p><img src="https://img-blog.csdnimg.cn/20210204153634809.png" alt="617.合并二叉树"></p><p>注意: 合并必须从两个树的根节点开始</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>本题使用哪种遍历都是可以的！</strong></p><p>我们下面以前序遍历为例。<br>中序和后序遍历也行, 但是<strong>前序遍历是最好理解的，我建议大家用前序遍历来做就OK。</strong><br>动画如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif" alt="617.合并二叉树"></p><ol><li><p><strong>确定递归函数的参数和返回值：</strong><br>参数是两个树, 返回值是合并后的树的根节点</p></li><li><p><strong>确定终止条件：</strong><br>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，💡遍历到t1 = NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。</p></li></ol><p>t2 同理</p><p>代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br><span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过, 好理解的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2;<span class="hljs-comment">// 遍历到t1 的空节点了</span><br>        <span class="hljs-keyword">if</span>(t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1;<span class="hljs-comment">// 同理</span><br><br>        t1-&gt;val += t2-&gt;val;<br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<span class="hljs-comment">// 💡遍历两个二叉树</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^okrf9t</p><!-- basicblock-start oid="ObsNZExSDg0KwODwTCCW0DEi" --> <p>同时遍历两个二叉树呢::<br>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。<br>遍历两个二叉树, 用一个变量接住返回值<br>eg:<br>[[8. 对称二叉树#^4yh3i4]]<br>[[21. 合并二叉树#^okrf9t]]</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyTaJnzlbgoRCv7xBABW1H" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::21. 合并二叉树.md" --> <p>#历史记录::<br>2022/9/20🌵21. 合并二叉树 : v1, 通过, 好理解的⏱0-27</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. 二叉树周末总结</title>
      <link href="/posts/61791/"/>
      <url>/posts/61791/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201010%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E5%91%A8%E4%B8%80">本周小结！（二叉树系列三） | 代码随想录</a></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsHL62fg2ifYOqsvF49gbCm" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::20. 二叉树周末总结.md" --> <p>#历史记录::<br>2022/9/20🌵20. 二叉树周末总结 : 没看</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19. 最大二叉树</title>
      <link href="/posts/48622/"/>
      <url>/posts/48622/</url>
      
        <content type="html"><![CDATA[<h1 id="1-54最大二叉树"><a class="markdownIt-Anchor" href="#1-54最大二叉树"></a> 1 54.最大二叉树</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">力扣题目地址</a></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中<strong>最大值左边部分</strong>构造出的最大二叉树。</li><li>右子树是通过数组中<strong>最大值右边部分</strong>构造出的最大二叉树。</li></ul><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>示例 ：</p><p><img src="https://img-blog.csdnimg.cn/20210204154534796.png" alt="654.最大二叉树"></p><p>提示：</p><p>给定的数组的大小在 [1, 1000] 之间。</p><!-- basicblock-start oid="ObsWDpZhFY65NcAndCNgw5bP" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>最大二叉树的构建过程如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjuvioezg30dw0921ck.gif" alt="654.最大二叉树"></p><!-- basicblock-start oid="Obs4rHsHDdSPcumjAc14BqDe" --> <p><strong>构造树一定采用::<br>前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</strong></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1: 抄了一遍, 还有优化的空间,优化: 直接通过下标构造左子树和右子树</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>    <span class="hljs-comment">// 1️⃣构造根节点</span><br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 构造根节点, 值的话下边会重新覆盖</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>){ <span class="hljs-comment">// 题目说了数组大小是大于等于 1 的,💡如果传入的数组大小为1，说明遍历到了叶子节点了。</span><br>            node-&gt;val = nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-comment">// 找到数组的最大值, 即二叉树的根节点</span><br>        <span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; maxValue){<br>                maxValue = nums[i];<br>                maxValueIndex = i;<br>            }<br>        }<br>        <span class="hljs-comment">// 2️⃣给根节点赋值</span><br>        node-&gt;val = maxValue; <span class="hljs-comment">// 重新给根节点赋值</span><br>        <br>        <span class="hljs-comment">//---------💡以上是中节点的处理逻辑: 构造根节点(数组的最大值)-----------</span><br>        <br><br>        <span class="hljs-comment">//💡左: 最大值所在的下标左区间 构造左子树</span><br>        <span class="hljs-keyword">if</span>(maxValueIndex &gt; <span class="hljs-number">0</span>){ <span class="hljs-comment">// 保证左区间至少有一个元素, 跟上面的 if 联动</span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>; <span class="hljs-comment">// 坚持的是左闭右开的原则</span><br>            node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br><br>        <span class="hljs-comment">//💡右: 最大值所在的下标右区间 构造右子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>; <span class="hljs-comment">// 坚持的是左闭右开的原则</span><br>            node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br>        <span class="hljs-keyword">return</span> node;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码比较冗余，效率也不高，每次还要切割的时候每次都要定义新的vector（也就是数组），但逻辑比较清晰。</p><!-- basicblock-start oid="ObstWlxuC0GYKOFzr0rctNeY" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::19. 最大二叉树.md"--><p>❓vec 创建的时候直接是左闭右开原则吗::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❓vec 创建的时候直接是左闭右开原则吗</span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>; <span class="hljs-comment">// 坚持的是左闭右开</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObscJCKln3bXKbXv5eVNWtDr" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::19. 最大二叉树.md" --> <p>#历史记录::<br>2022/9/20🌵19. 最大二叉树: v1: 抄了一遍, 还有优化的空间,优化: 直接通过下标构造左子树和右子树⏱ 0-50</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>extern 与 static</title>
      <link href="/posts/63304/"/>
      <url>/posts/63304/</url>
      
        <content type="html"><![CDATA[<h1 id="1-extern-与-static"><a class="markdownIt-Anchor" href="#1-extern-与-static"></a> 1 extern 与 static</h1><h2 id="11-extern"><a class="markdownIt-Anchor" href="#11-extern"></a> 1.1 extern</h2><p>定义：<br>声明外部变量【在函数或者文件外部定义的全局变量】</p><h2 id="12-static"><a class="markdownIt-Anchor" href="#12-static"></a> 1.2 static</h2><p>作用：实现多个对象之间的数据共享+隐藏，并且使用静态成员还不会破坏隐藏原则；默认初始化为0</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsleJQIuqDBYQxuSYlpAEA6" deck = "👨🏻‍💻code::C++::C++基础::extern 与 static.md" --> <p>#历史记录::<br>2022/9/19🌵extern 与 static</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="/posts/27531/"/>
      <url>/posts/27531/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><blockquote><p>若要修改const修饰的变量的值，需要加上关键字[[volatile]];</p></blockquote><p>与const绝对对立的，是类型修饰符</p><ul><li><p>影响编译器编译的结果，用该关键字声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化；</p></li><li><p>会从内存中重新装载内容，而不是直接从寄存器拷贝内容。</p></li></ul><h1 id="2-作用"><a class="markdownIt-Anchor" href="#2-作用"></a> 2 作用：</h1><p>指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问</p><h1 id="3-使用场合"><a class="markdownIt-Anchor" href="#3-使用场合"></a> 3 使用场合：</h1><p>在中断服务程序和cpu相关寄存器的定义</p><h1 id="4-举例说明"><a class="markdownIt-Anchor" href="#4-举例说明"></a> 4 举例说明：</h1><p>空循环：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(vo1ati1e <span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000</span>;i++);<span class="hljs-comment">//它会执行，不会被优化掉</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2aUB5U26q3Lg3FEtSZIZh" deck = "👨🏻‍💻code::C++::C++基础::volatile.md" extra = "[margin](marginnote3app://note/9E5A1B6B-1EEB-478C-98ED-8D53A57F8583)"--> <p>#历史记录::<br>2022/9/19🌵volatile</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const和static的区别</title>
      <link href="/posts/45167/"/>
      <url>/posts/45167/</url>
      
        <content type="html"><![CDATA[<h1 id="1-const和static的区别"><a class="markdownIt-Anchor" href="#1-const和static的区别"></a> 1 const和static的区别</h1><h2 id="11-const关键字"><a class="markdownIt-Anchor" href="#11-const关键字"></a> 1.1 [[const关键字]]</h2><h2 id="12-static"><a class="markdownIt-Anchor" href="#12-static"></a> 1.2 static</h2><h2 id="13-区别"><a class="markdownIt-Anchor" href="#13-区别"></a> 1.3 区别</h2><p>![[关键字与运算符 2022-09-19 20.57.19.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsm3NiiLPlpEsAmLU4VhXEF" deck = "👨🏻‍💻code::C++::C++基础::const和static的区别.md" --> <p>#历史记录::<br>2022/9/19🌵const和static的区别</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>new和malloc</title>
      <link href="/posts/25348/"/>
      <url>/posts/25348/</url>
      
        <content type="html"><![CDATA[<h1 id="1-new和malloc"><a class="markdownIt-Anchor" href="#1-new和malloc"></a> 1 new和malloc</h1><!-- basicblock-start oid="ObsqC3yqp7soyNLvBGChFzfM" --> <h2 id="11-new"><a class="markdownIt-Anchor" href="#11-new"></a> 1.1 new::</h2><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span> (<span class="hljs-number">0</span>);<br>---<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>{ <span class="hljs-comment">// 构造函数</span><br>age = <span class="hljs-number">10</span><br>}<br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>(){<br><span class="hljs-comment">// 💡new 构造函数</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span> (<span class="hljs-number">0</span>); <span class="hljs-comment">// dummyHead 初始化为 0</span><br>A* pa = <span class="hljs-keyword">new</span> A; <span class="hljs-comment">// 会调用构造函数 A ; 初始值 pa = 10</span><br>A* pa2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <span class="hljs-comment">// 会调用构造函数 A ; 初始值 pa = 10</span><br><br><br><span class="hljs-comment">// new int</span><br><span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;      <span class="hljs-comment">//  1.直接new int,给随机值</span><br><span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> <span class="hljs-number">0</span>；   <span class="hljs-comment">//  2.new int()给初始值0</span><br><span class="hljs-type">int</span>* p3 =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (<span class="hljs-number">100</span>);<span class="hljs-comment">//  3.new int(100)给初始值100</span><br><br>}<br><br></code></pre></td></tr></tbody></table></figure><p>new做的主要的两件事情，<br>1.先调用operator new()// 里面有malloc函数<br>2.再调用构造函数<br>3.同时增加一个析构函数<br>总结：<br>1.new做的事情，先申请一块地 再修房子<br>申请土地由<strong>malloc</strong>完成 修房子由<strong>构造函数</strong>完成</p><p>2.delete做的事情，先把房子销毁 再回收地<br>销段房子由<strong>析构函数</strong>完成 回收地用<strong>free</strong>完成<br>![[new.excalidraw]]</p><!-- basicblock-start oid="ObsWmUOk9dAlIN3xoYf4mRkZ" --> <h2 id="12-malloc"><a class="markdownIt-Anchor" href="#12-malloc"></a> 1.2 malloc::</h2><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>; <span class="hljs-comment">// 返回的是空指针</span><br><span class="hljs-comment">// 下面举个例子</span><br><span class="hljs-comment">//Student 一个学员的信息</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> //取别名</span><br><span class="hljs-class">{</span><br><span class="hljs-type">int</span> num:<br><span class="hljs-type">char</span> name [<span class="hljs-number">10</span>]；<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> *<span class="hljs-title">pnext</span>;</span><span class="hljs-comment">//指针</span><br>}STU; <br>STU* <span class="hljs-title function_">CreateList</span><span class="hljs-params">()</span>{<br>STU *P =(STU*) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(STU))：<span class="hljs-comment">//(STU*):强转, mallc 计算 STU 的长度给它 *P 分配一个空间</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1ee4y1D727?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">malloc函数，两分钟理解它，小白也能懂_哔哩哔哩_bilibili</a></p><!-- basicblock-start oid="ObsD3hs5N2Snmam674FR0MEv" --> <h2 id="13-区别"><a class="markdownIt-Anchor" href="#13-区别"></a> 1.3 区别::</h2><!-- basicblock-end --><h3 id="131-new-malloc"><a class="markdownIt-Anchor" href="#131-new-malloc"></a> 1.3.1 new malloc</h3><p>![[New 与 Malloc的区别.excalidraw]]</p><ul><li>opeartor new/operator delete可以被重载，而malloc/free并不允许重载。</li><li>使用new操作符申请内存分配时无须指定内存块的大小，而malloc则需要显式地指出所需内存的尺寸eg : <code>malloc(sizeof(int))</code>。</li><li>new操作符<strong>从自由存储区</strong>上为对象动态分配内存空间，而malloc函数从<strong>堆上</strong>动态分配内存。</li></ul><p><a href="https://www.bilibili.com/video/BV1vg41197B8?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++ new和malloc区别_哔哩哔哩_bilibili</a></p><h3 id="132-delete-free"><a class="markdownIt-Anchor" href="#132-delete-free"></a> 1.3.2 delete free</h3><p>同理，delete 与 free的区别也就比较明显：delete 不但释放内存,而且在释放内存之前会调用类的析构函数（当然必须要类的析构函数数存在）。</p><!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::C++::C++基础::new和malloc.md"--><h1 id="2-new-delete-malloc-free-关系"><a class="markdownIt-Anchor" href="#2-new-delete-malloc-free-关系"></a> 2 new、delete、malloc、free 关系::</h1><!-- basicblock-end --><p><a href="marginnote3app://note/CDA5C05E-C9DB-4536-AF1F-8820335D1275">margin: new、delete、malloc、free关系</a></p><p>如果是带有自定义析构函数的类类型，用 <code>new[]</code> 来创建类对象数组，而用 delete 来释放会发生什么？用下面的例子来说明：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {};<br>A* pAa = <span class="hljs-keyword">new</span> A[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">delete</span> pAa;<br></code></pre></td></tr></tbody></table></figure><p>delete pAa, 做了两件事：</p><ol><li>调用一次 pAa 指向的对象的析构函数</li><li>调用 operator delete (pAa); 释放内存</li></ol><p>显然❓，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，<br>❓这里只有一个函数</p><p>如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。</p><p>直接释放 pAa 指向的内存空间，这个总是会造成严重的段错误，程序必然会奔溃！<br>因为分配的空间的起始地址是 pAa 指向的地方减去 4 个字节的地方。你应该传入参数设为那个地址！<br>❓为什么 PAa 是指向的地方减去 4 个字节的地方</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsooTZwCuezehzDrzRykaNY" deck = "👨🏻‍💻code::C++::C++基础::new和malloc.md" --> <p>#历史记录::<br>2022/9/19🌵new和malloc</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>override和overload</title>
      <link href="/posts/30853/"/>
      <url>/posts/30853/</url>
      
        <content type="html"><![CDATA[<h1 id="1-override和overload"><a class="markdownIt-Anchor" href="#1-override和overload"></a> 1 override和overload</h1><ol><li>overload是重载，这些方法(函数)的名称相同而参数形式不同, 一个方法有不同的版本，存在于<strong>一个类</strong>中。<br>规则：</li><li>函数处在相同的范围（即在同一个类中）</li><li>与原函数的区别<ol><li>函数名字必须相同，</li><li>参数列表（函数特征：参数类型、个数、顺序）必须不同,</li><li>返回值类型可同可不同</li><li>访问修饰符可以不同.</li></ol></li></ol><!-- basicblock-start oid="Obs8ZSX3cNU3z8PgURkow35g" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::关键字与运算符.md"--><ol start="3"><li>virtual 关键字可有可无</li></ol><p>1.不能通过访问权限、返回类型、抛出的异常进行重载</p><p>3.方法的异常类型和数目不会对重载造成影响使用多态, 是为了避免在父类里大量重载引起代码臃肿且难于维护。</p><!-- basicblock-end --><p>![[关键字与运算符 2022-09-18 21.24.11.excalidraw]]</p><ol start="2"><li>override是重写（覆盖）了一个方法以实现不同的功能，发生在父子类中<br>规则：</li></ol><p>1.与原函数的区别(儿子都要比父亲的权限小)<br>1. 方法名、参数列表必须相同，<br>2. 返回值范围小于等于父类，<br>3. 抛出的异常范围小于等于父类，<br>4. 访问修饰符范围<strong>大于</strong>等于父类；<br>5. 如果父类方法访问修饰符为private 则子类就不能重写该方法。(💡爸爸的隐私你不能看)</p><!-- basicblock-start oid="ObsDZtp2aOLGSwWY7koWnVpP" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::关键字与运算符.md"--><p>2.被重写的方法不能为orivate<br>3.静态方法不能被重写为非静态的方法<br>4.重写方法的访问修饰符一定要大于被重写方法的访问修饰符(public&gt;:protected&gt;default&gt;private)</p><!-- basicblock-end --><p>override关键字父类中被<strong>virtual修饰的方法，在子类中可以重写。</strong><br>这样宽松的策略会有两个问题无法直观的判断，</p><ol><li>子类中的方法是否是重写的方法</li><li>不小心写错了子类中的需要重写的函数，包括函数名和参数等。<br>被override修饰的子类中的方法，可以避免这两个问题<br><a href="https://www.bilibili.com/video/BV1Sm4y1X71z?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++11中新增的override关键字_哔哩哔哩_bilibili</a><br>![[关键字与运算符 2022-09-18 21.40.29.excalidraw]]</li></ol><p>重写与重载的本质区别是，加入了override的修饰符的方法，此方法始终只有一个被你使用的方法。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsBPzrV2LJxlUwgUVNH0KSl" deck = "👨🏻‍💻code::C++::C++基础::override和overload.md" --> <p>#历史记录::<br>2022/9/19🌵override和overload</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>define和inline的区别</title>
      <link href="/posts/58722/"/>
      <url>/posts/58722/</url>
      
        <content type="html"><![CDATA[<h1 id="define和inline的区别"><a class="markdownIt-Anchor" href="#define和inline的区别"></a> define和inline的区别</h1><ol><li>define<br>![[关键字与运算符#3 2 1 define]]</li></ol><p>2、inline:<br>调用简单函数时, 直接把简单函数的内容放到调用的地方</p><p>inline是先将内联函数编译完成生成了函数体直接插入被调用的地方，减少了压栈，跳转和返回的操作。没有普通函数调用时的额外开销；</p><p>内联函数是一种特殊的函数，会进行类型检查, 这是比 define 宏定义的优势</p><p>对编译器的一种<strong>建议</strong>，编译器有可能拒绝这种请求,</p><ul><li>&amp; 自己不定义内联函数, 编译器也会为简单函数执行内联操作</li><li>&amp; 自己定义的内联函数, 如果太复杂, 编译器也会拒绝</li></ul><p>![[C++基础 2022-09-14 22.23.18.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsdErpigQ7nQS2M2D5E2HpE" deck = "👨🏻‍💻code::C++::C++基础::define和inline的区别.md" --> <p>#历史记录::<br>2022/9/19🌵define和inline的区别</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>define和typedef的区别</title>
      <link href="/posts/62768/"/>
      <url>/posts/62768/</url>
      
        <content type="html"><![CDATA[<h1 id="1-define和typedef的区别"><a class="markdownIt-Anchor" href="#1-define和typedef的区别"></a> 1 define和typedef的区别</h1><p>都是用来起别名的</p><h2 id="11-使用区别"><a class="markdownIt-Anchor" href="#11-使用区别"></a> 1.1 使用区别</h2><h3 id="111-define"><a class="markdownIt-Anchor" href="#111-define"></a> 1.1.1 define</h3><ol><li>可以给常量起别名 ,</li><li>也可以给类型起别名, 但是只能用一次, 不能连续用<br>eg:</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">define MAX <span class="hljs-number">255</span>; <span class="hljs-comment">// max = 255</span><br>define st <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// st = string</span><br>st a = <span class="hljs-string">"hello"</span> <span class="hljs-comment">//  string a = "hello"</span><br>st b = <span class="hljs-string">"world"</span> <span class="hljs-comment">// 💡只能用一次, 这里就失效了</span><br></code></pre></td></tr></tbody></table></figure><h3 id="112-typedef"><a class="markdownIt-Anchor" href="#112-typedef"></a> 1.1.2 typedef</h3><p>只能给类型起别名, 可以连续用</p><blockquote><p>有些类型特别长, 每次写比较复杂, 所以用一个简单的来代替它</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span> st;  <span class="hljs-comment">// st = string</span><br>st a = <span class="hljs-string">"hello"</span> <span class="hljs-comment">//  string a = "hello"</span><br>st b = <span class="hljs-string">"world"</span> <span class="hljs-comment">//  string b = "world" 💡可以继续用</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209142129292.png" alt="|500"></p><p><strong>一般来说, 我们用 define 给常量起别名, 用 typedef 给类型起别名</strong></p><h2 id="12-区别"><a class="markdownIt-Anchor" href="#12-区别"></a> 1.2 区别</h2><p>![[1.1-1.2 GCC 2022-09-06 20.50.17.excalidraw]]</p><h3 id="121-define"><a class="markdownIt-Anchor" href="#121-define"></a> 1.2.1 define:</h3><ul><li>define被称为宏定义, 是 C 语言的一种预处理指令, 宏定义的本质是单纯的字符中替换,没有类型检查, 不安全</li><li>是在编译的预处理阶段, 直接进行文本替换<ul><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209142145810.png" alt=""><br><a href="https://www.bilibili.com/video/BV1si4y1x781?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C语言：typedef和define到底有什么不同_哔哩哔哩_bilibili</a></li></ul></li></ul><!-- basicblock-start oid="ObsePJeTu1gewV7wWUobuNhC" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::关键字与运算符.md"--><ol start="3"><li>可以用来防止头文件重复引用</li><li>✔️不分配内存，给出的是立即数，有多少次使用就进行多少次替换</li></ol><!-- basicblock-end --> <p>^6azck6</p><h3 id="122-typedef"><a class="markdownIt-Anchor" href="#122-typedef"></a> 1.2.2 typedef</h3><ol><li><p>为一种类型起一个新的名字</p></li><li><p>是在编译、运行的时候处理的, 不是在预处理的时候进行替换的</p></li><li><p>有对应的数据类型，是要进行判断.</p><ul><li>💡检查传入的参数, 是否符合我要进行计算的类型</li></ul></li></ol><!-- basicblock-start oid="ObsoEqJarFWBkmPLt9laEJMn" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::关键字与运算符.md"--><ol start="4"><li>在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</li></ol><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObssC7JTq9tPlwYccFXGLWyb" deck = "👨🏻‍💻code::C++::C++基础::define和typedef的区别.md" --> <p>#历史记录::<br>2022/9/19🌵define和typedef的区别</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指针与引用</title>
      <link href="/posts/28636/"/>
      <url>/posts/28636/</url>
      
        <content type="html"><![CDATA[<p>指针存放某个对象的地址，</p><ul><li>❓✔️其本身就是变量（命了名的对象），</li><li>本身就有地址，所以可以有指向指针的指针；</li><li>所指向的地址和其指向的地址中所存放的数据, 都可以改变.</li></ul><p>引用就是变量的别<br>- 必须初始化<br>- 不存在指向空值的引用，但是存在指向空值的指针<br>- 从一而终，不可变</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsbv8wXTWLraSae4NVreZSq" deck = "👨🏻‍💻code::C++::C++基础::指针与引用.md" --> <p>#历史记录::<br>2022/9/19🌵指针与引用</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>constexpr和const  (C++新特性)</title>
      <link href="/posts/63272/"/>
      <url>/posts/63272/</url>
      
        <content type="html"><![CDATA[<h1 id="1-const-const关键字"><a class="markdownIt-Anchor" href="#1-const-const关键字"></a> 1 const :: [[const关键字]]</h1><h1 id="2-constexpr"><a class="markdownIt-Anchor" href="#2-constexpr"></a> 2 constexpr</h1><p>复杂系统中很难分辨一个初始值是不是常量表达式，可以将变量声明为constexpr类型，由编译器来验证变量的值是否是一个常量表达式。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">constexpr <span class="hljs-type">int</span> n = <span class="hljs-number">20</span>; <br>constexpr <span class="hljs-type">int</span> m = n +<span class="hljs-number">1</span>; <br><span class="hljs-type">static</span> constexpr <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br></code></pre></td></tr></tbody></table></figure><p>必须使用常量初始化： 如果constexpr声明中定义了一个指针，constexpr仅对指针有效，和所指对象无关。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">constexpr <span class="hljs-type">int</span>*p = nullptr;<span class="hljs-comment">//常量指针J顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>*q = nullptr;<span class="hljs-comment">//指向常量的指针 , 左定值, 顶层 const</span><br><span class="hljs-type">int</span>*<span class="hljs-type">const</span> q = nullptr;<span class="hljs-comment">//右定向, 底层 const</span><br></code></pre></td></tr></tbody></table></figure><h2 id="21-constexpr-函数"><a class="markdownIt-Anchor" href="#21-constexpr-函数"></a> 2.1 constexpr 函数</h2><p>constexprl函数是指能用于常量表达式的函数。<br>函数的返回类型和所有形参类型都是字面值类型，函数体有且只有一条return语句。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">constexpr <span class="hljs-type">int</span> <span class="hljs-title function_">new</span><span class="hljs-params">()</span>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>为了可以在编译过程展开，constexpr函数被隐式转换成了内联函数。<br>constexpr和内联函数可以在程序中多次定义，一般定义在头文件。</p><h2 id="22-constexpr构造函数"><a class="markdownIt-Anchor" href="#22-constexpr构造函数"></a> 2.2 constexpr构造函数</h2><p>构造函数不能说const,.但字面值常量类的构造函数可以是constexpr。<br>constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。对象调用的成员函数必须使用constexpr修饰</p><h2 id="23-constexprl的好处"><a class="markdownIt-Anchor" href="#23-constexprl的好处"></a> 2.3 constexprl的好处</h2><ul><li>为一些不能修改数据提供保障，写成变量则就有被意外修改的风险。</li><li>有些场景，编译器可以在编译期对constexpr的代码进行优化，提高效率。<ul><li>&amp; 直接编译期间就编译好了, 到了程序执行的时候不会调用函数, 而是直接替换, 有点像 define 的文本替换</li></ul></li><li>相比宏来说，没有额外的开销，但更安全可靠。</li></ul><h1 id="3-区别"><a class="markdownIt-Anchor" href="#3-区别"></a> 3 区别</h1><p>![[关键字与运算符 2022-09-19 21.05.40.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsvU0PwOw9lYipDWjsAAsJF" deck = "👨🏻‍💻code::C++::C++基础::constexpr和const  (C++新特性).md" --> <p>#历史记录::<br>2022/9/19🌵constexpr和const  (C++新特性)</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const关键字</title>
      <link href="/posts/58873/"/>
      <url>/posts/58873/</url>
      
        <content type="html"><![CDATA[<p><strong>const的作用： 被它修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。</strong></p><p>若要修改const修饰的变量的值，需要加上关键字[[volatile]]; 若想要修改const成员函数中某些与类状态无关的数据成员，可以使用mutable关键字来修饰这个数据成员；</p><h1 id="1-常量指针与指针常量"><a class="markdownIt-Anchor" href="#1-常量指针与指针常量"></a> 1 常量指针与指针常量</h1><p>指针常量：顶层const:指针本身是常量；即指针指向的对象无法改变<br><code>const int* d=new int(2);</code>, const 在 <code>*</code> 的左边,</p><p>常量指针：底层const:指针所指的对象是常量；即底层数据无法通过指针改变<br><code>int *const e=new int(2);</code>, const 在 <code>*</code> 的右边</p><ul><li>&amp; <mark>左定值</mark>(<strong>指针自己的值</strong>无法改变)，<mark>右定向</mark>(<strong>无法通过指针改变指向</strong>的值)：指的是const在<code>*</code>的左还是右边</li></ul><h2 id="11-指针常量-顶层const-指针指向的对象无法改变"><a class="markdownIt-Anchor" href="#11-指针常量-顶层const-指针指向的对象无法改变"></a> 1.1 指针常量 (顶层const): 指针指向的对象无法改变</h2><p>指针常量： 指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。<br>指针常量强调的是==<strong>指针==的不可改变性</strong>。💡不可以指向新的对象<br>特点： 靠近变量类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">形式： 数据类型* <span class="hljs-type">const</span> 指针变量 = &amp;变量名<br><br><span class="hljs-comment">//2.指针常量, 💡指针在前边</span><br><span class="hljs-type">int</span> tmp3 = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> tmp4 = <span class="hljs-number">13</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;tmp3；<span class="hljs-comment">// 常量指针</span><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">//正确：可以更改指向对象的值</span><br> p = &amp;tmp4；<span class="hljs-comment">//错误：不可以指向新的对象, 💡指针不可以修改</span><br></code></pre></td></tr></tbody></table></figure><h2 id="12-常量指针底层const-底层数据无法通过指针改变"><a class="markdownIt-Anchor" href="#12-常量指针底层const-底层数据无法通过指针改变"></a> 1.2 常量指针（底层const) : 底层数据无法通过指针改变</h2><p><mark>常量指针</mark>： 是指定义了一个指针，这个指针指向一个只读的对象，<strong>不能通过常量指针来改变这个对象的值。</strong><br>常量指针强调的是<strong>指针对<mark>其所指对象</mark>的不可改变性</strong>。💡不可以通过指针来改变对象<br>特点： 靠近变量名。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1 常量指针, 💡指针在后边</span><br><span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;temp;<span class="hljs-comment">// (1) const 数据类型 *指针变量 = &amp;变量名</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p = &amp;temp;<span class="hljs-comment">// (2)数据类型 const *指针变量 = &amp;变量名</span><br><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 错误,不能通过常量指针来改变这个对象的值。</span><br>temp = <span class="hljs-number">9</span>; <span class="hljs-comment">// 💡正确, 直接改变原来对象可以</span><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsfWlcGza1Zp9RGq7lHOetY" deck = "👨🏻‍💻code::C++::C++基础::const关键字.md" --> <p>#历史记录::<br>2022/9/19🌵const关键字</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小鹤音形</title>
      <link href="/posts/55080/"/>
      <url>/posts/55080/</url>
      
        <content type="html"><![CDATA[<p>![[小鹤音形 2022-09-18 19.01.09.excalidraw]]</p><p>把字拆成小部首, 小部首更常用<br>把一个字中的小且独立的字作为拆分因素<br>比如：“树” 取“木寸”，而不是 “木对” 或“ 权寸”；“喜”取“士口”而不是“吉口”<br>偏旁通常放在通俗的称呼上</p><p>鹤形多数是采用声母定键: 这个字根的声母就是这个字根的键位<br>如：犭反<strong>犬</strong>的q，卩 阝单双<strong>耳</strong>的e，冫氵两三<strong>点</strong>的d；部分成字部件也是取的声母，如：黑h，金j，虫i</p><!-- basicblock-start oid="ObsMHxNKixot5f7lZvPFJfVq" --> <h1 id="1-拆分规则"><a class="markdownIt-Anchor" href="#1-拆分规则"></a> 1 拆分规则::</h1><!-- basicblock-end --><h2 id="11-字取首末-只取第一个字根和最后一个字根"><a class="markdownIt-Anchor" href="#11-字取首末-只取第一个字根和最后一个字根"></a> 1.1 <strong>字取首末</strong>:  只取第一个字根和最后一个字根</h2><p>示例：“画”拆分为“横田凵”，首末取“横凵”</p><h2 id="12-相交不拆"><a class="markdownIt-Anchor" href="#12-相交不拆"></a> 1.2 相交不拆</h2><p>释义：相交不拆，字根如果与其它笔画相交，则此字根即被破坏而不可取，这样就免去了字中找字的麻烦，而可以简单直接取到笔画</p><p>示例：“中”，此字中的“口”与笔画竖相交，则此“口”已被破坏，不能再拆为“口”，只能被拆成首末笔“竖竖”，其它如“未” 不能取“二”，“重” 不能取“千”，“里”不能取“ 甲”，“子” 不能取“ 了”，曹，不能取草字头</p><h2 id="13-插隔不取字根如被单笔画插入或被结构隔离则不再被认为是字根"><a class="markdownIt-Anchor" href="#13-插隔不取字根如被单笔画插入或被结构隔离则不再被认为是字根"></a> 1.3 插隔不取：字根如被单笔画插入或被结构隔离则不再被认为是字根</h2><p>平: 两个倒八, 插入了干,此时“干”就因为被单笔画插入而不能取,因此 “平”被拆分成“横十”</p><h2 id="14-廴辶优先以廴-辶为部首的字首码先取"><a class="markdownIt-Anchor" href="#14-廴辶优先以廴-辶为部首的字首码先取"></a> 1.4 “廴辶”优先：以“廴 辶”为部首的字，首码先取</h2><p>示例： “这→辶文，建→廴聿</p><h2 id="15-其他"><a class="markdownIt-Anchor" href="#15-其他"></a> 1.5 其他</h2><p>“日” 只能往上延伸</p><ol><li>单笔画字因无字根可拆，重复自身笔画码补全四码，如：一 yiaa、乙 yivv</li><li>单笔画字被用做字根时，当笔画解，如：旦 djoa、亿 yirv</li><li>繁体字根可视同其简体字根，如：鳥鸟，馬马，魚鱼，車车，糹纟，飠饣，門门，釒钅……等</li></ol><h1 id="2-小字字根的定义"><a class="markdownIt-Anchor" href="#2-小字字根的定义"></a> 2 小字字根的定义</h1><!-- basicblock-start oid="ObsWy34SwpQoCg1RZ8E1VB7Z" --> <h2 id="21-基本小字"><a class="markdownIt-Anchor" href="#21-基本小字"></a> 2.1 基本小字::</h2><p>一个字如果不再包含字或部件则为小字<br>示例：“十之冉我五也垂中”这些字中都不再包含有其它字或部件，所以本身就是小字</p><h2 id="22-衍生小字"><a class="markdownIt-Anchor" href="#22-衍生小字"></a> 2.2 衍生小字:</h2><h3 id="221-部件或小字以附加单笔画方式衍生出来的字也为小字如果衍生结果含两字则分取"><a class="markdownIt-Anchor" href="#221-部件或小字以附加单笔画方式衍生出来的字也为小字如果衍生结果含两字则分取"></a> 2.2.1 部件或小字以附加单笔画方式衍生出来的字也为小字，如果衍生结果含两字则分取</h3><p>①、单笔画可以是在小字或部件的不同隔离区附加<br>十→干→午<br>隔离区附加单笔画衍生小字过程：十→木，十→米</p><p>②、💡衍生结果包含两个字就要拆开: eg：兀→元，💡不取"元", 因为“元”可分开为两个字：二儿，所以“元”字分拆为“二儿”，其它同理如：示: 二小，兵: 丘八</p><p>③、“日”部件只向上方衍生字根 示例：“→白→百”等字向上方加单笔画衍生的字根为小字字根；而不向其他方向衍生字根，如“→旦→亘，→旧”等字则不为小字字根</p><h3 id="222-一个字除部件囗匚冂凵勹之外不再含其它部件或字则为小字含则分取"><a class="markdownIt-Anchor" href="#222-一个字除部件囗匚冂凵勹之外不再含其它部件或字则为小字含则分取"></a> 2.2.2 一个字除部件“囗匚冂凵勹”之外，<strong>不再含其它部件或字</strong>，则为小字，含则分取</h3><pre><code class="hljs">示例：“巨臣勿而出击”等字包含框部件外再无其它部件，则为小字；“匝匹句匀同函”等字含框部件外还含其它部件或字，则分取另：开口框在字中开口时才为部件 , 💡被封口了就不是部件    示例：“同巨击出”等字中的“冂匚凵”**没有被封口即为部件**；“皿且甲”中的“冂”被封了口，则不被认为是部件    💡是框当不当部件，皿中的框不当部件,文档里面写的是皿被封了口，就不能拆分成框了，只能作为小字使用了</code></pre><!-- basicblock-end --><!-- basicblock-start oid="ObsCTHSUNorxq2eBFnWoT66n" --> <h2 id="23-小字拆分"><a class="markdownIt-Anchor" href="#23-小字拆分"></a> 2.3 小字拆分::</h2><p>附加一个单笔画的方式衍生的小字，作为一个字需要拆分时，分取单笔画与衍生前的部分；</p><p>eg: 白 是由"丿"和"日"组成的, 打字的时候就打"丿日"<br>释义：附加一个单笔画衍生的小字，衍生过程即拆分过程。</p><!-- basicblock-end --><!-- basicblock-start oid="ObsBiZ71LvKPSRd6GcMRpTXY" --> <h1 id="3-拆分示例"><a class="markdownIt-Anchor" href="#3-拆分示例"></a> 3 拆分示例::</h1><p>“鹤”，左部“冖”与“撇”相交，所以拆不出“冖”，取首笔“点”，右部取“鸟”，全码为hedn<br>“走”，上部取“土”，下部取“人”，全码为zztr<br>“武”，取首笔“横”，末部取“止”，此字拆分的字根顺序为：横弋止，全码为wuav，同理“或→戈横，戊→戈撇，越→土折”<br>“难”，左部取“又”，右部“隹”非字根，取“龶”，全码为njyf<br>“战”，左部“占”非字根，取首笔“竖”，右部取“戈”，全码为vjlg<br>“豫”，左部“予”非字根，取“龴”，右部“象”非字根，取末笔“捺”，全码yusn</p><!-- basicblock-end --><!-- basicblock-start oid="ObsUOxdqVB62TylclrqKr9yy" --> <h1 id="4-字根序"><a class="markdownIt-Anchor" href="#4-字根序"></a> 4 字根序::</h1><p>笔画不停的形成字根<br>从首笔开始与其它笔画（不论顺序）组成字根则为首字根，首字根笔画之外剩余笔画再按剩余首笔画组成字根，直到最末组成的为末字根<br>试”按字根的顺序应为：讠弋 工，所以字根序的首末字根为 讠工。<br>例：匡→匚王 、武→横止 、框→木王 、式→弋工 、挂→扌土 、粤→撇折、潭→氵十、捏→扌土、或→戈横、越→土折</p><!-- basicblock-end --><h1 id="5-部件"><a class="markdownIt-Anchor" href="#5-部件"></a> 5 部件</h1><p>![[小鹤音形 2022-09-18 19.55.54.excalidraw]]</p><h1 id="6-小字字根"><a class="markdownIt-Anchor" href="#6-小字字根"></a> 6 小字字根</h1><p><strong>小字规则字根，免记忆</strong></p><p>小字字根列表（理解<a href="https://help.flypy.com/#/gz?id=xzgz">小字规则</a>的用户请跳过此表）：</p><ul><li><p>一些可能会不认识的小字：戊wù、戌xū、耒lěi、爿pán、豕shǐ、臾yú、聿yù、廿niàn、巳sì、曳yè、夬guài</p><p>a 凹<br>b 百 白 八 卜 匕 卞 不 巴 本 必 丙 半 办<br>c 寸 才 匆 册<br>d 大 丁 刀 歹 刁 东 丹 电 氐<br>e 二 耳 儿 而<br>f 非 方 飞 夫 凡 甫 弗 乏 丰<br>g 广 弓 戈 工 瓜 干 个 甘 丐 果 更 夬<br>h 禾 户 互 乎 火<br>i 川 厂 车 长 叉 尺 丑 臣 成 垂 斥 串 产 出<br>j 巾 几 九 斤 久 巨 己 井 及 夹 甲 臼 韭 戋 柬 击<br>k 口 开 亏<br>l 了 力 乐 来 良 两 里 吏 耒 卵 丽<br>m 木 毛 米 门 马 皿 末 灭 母 民 么 面<br>n 廿 女 牛 鸟 乃 内 农 年<br>p 片 平 爿<br>q 七 千 犬 丘 曲 且 气 乞<br>r 人 入 冉 壬 刃<br>s 三 巳 肃<br>t 土 天 太 屯<br>u 十 尸 士 手 身 水 上 少 术 失 生 世 申 史 升 事 书 束 勺 戍 豕 氏 矢<br>v 止 爪 主 舟 之 正 丈 中 专 朱 州 重 乍<br>w 王 瓦 五 无 万 午 亡 未 乌 韦 勿 为 戊 我 丸 兀<br>x 小 西 心 血 下 夕 乡 戌 习<br>y 又 酉 已 于 义 与 夭 玉 牙 丫 永 尤 也 业 由 央 亚 严 用 幺 禺 臾 尹 禹 夷 弋 聿 雨 曳<br>z 再 自 子</p></li></ul><h1 id="7-二字简码"><a class="markdownIt-Anchor" href="#7-二字简码"></a> 7 二字简码：</h1><p>主要以二字词为主，编码取每个字的前两码组成，<br>三字词全码为前两字首码加末字前两码，<br>四字以上词为前三字首码加末字首码。<br>音形码方案的输入是字词结合的输入，字是基础，词基本是标准意义的词，你不能把“我的、我是。。。”这样的也当词来打，打熟简码字之后有些包含一简字的词可能你也会习惯拆开来打，这应该是确定性更重要的体现</p><p><strong>二简词：</strong> 即两码二字词（取两字的首码即声声），共362个</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZsJXZWtmIdsy6KNsTOJym" deck = "🚀技能::小鹤音形.md" --> <p>#历史记录::<br>2022/9/18🌵小鹤音形 :&nbsp;学习完毕⏱1-17</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.13 - 1.16 GDB调试</title>
      <link href="/posts/53653/"/>
      <url>/posts/53653/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是-gdb"><a class="markdownIt-Anchor" href="#1-什么是-gdb"></a> 1 什么是 GDB::</h1><!-- basicblock-end --><ul><li><p>GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环 境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。</p></li><li><p>一般来说，GDB 主要帮助你完成下面四个方面的功能:</p><ol><li>启动程序，可以按照自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式) 。</li><li>当程序被停住时，可以检查此时程序中所发生的事。</li><li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG。</li></ol></li></ul><!-- basicblock-start oid="Obs5BnIy8bvlfX5kp1ykdMlT"  deck = "source::_posts::👨🏻‍💻code::项目::Linux::命令"--> <p>vim : set nu :: 显示行号</p><!-- basicblock-end --><!-- basicblock-start oid="Obsqtt8hR5mqIUjiUJ3BTNiQ" --> <h1 id="2-准备工作"><a class="markdownIt-Anchor" href="#2-准备工作"></a> 2 准备工作::</h1><!-- basicblock-end --><p>实操：</p><p><strong>编译程序时加入调试信息</strong>： 最后加个-g 参数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc test.c -o test -g <span class="hljs-comment">// 💡生成 gdb 调试文件</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209181730028.png" alt=""></p><!-- basicblock-start oid="ObsEYfmxZJFz9Q1F9WF5tSHY" --> <ul><li><code>-g</code> 选项的作用::</li><li><strong>是在可执行文件中加入源代码的信息</strong>，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</li></ul><!-- basicblock-end --><ul><li>通常，在为调试而编译时，我们会()关掉编译器的优化选项(<code>-O</code>)， 并打开调试选项(<code>-g</code>)。另外，<code>-Wall</code> 在尽量不影响程序行为的情况下选项打开所有 warning，也可以发现许多问题，避免一些不必要的 BUG。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -g -Wall program.c -o program <span class="hljs-comment">// -Wall 打开所有的警告</span><br><span class="hljs-comment">// program.c : 源文件, program : 可执行程序</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-gdb-命令"><a class="markdownIt-Anchor" href="#3-gdb-命令"></a> 3 GDB 命令</h1><!-- basicblock-start oid="Obs45aiLrLhWAnRCRLht5Q1T" --> <h2 id="31-启动-退出-查看代码"><a class="markdownIt-Anchor" href="#31-启动-退出-查看代码"></a> 3.1 启动、退出、查看代码::</h2><!-- basicblock-end --><p>gdb是一个shell命令<br>下边的命令都是它内部的</p><p>启动和退出</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gdb 可执行程序 <span class="hljs-comment">// 启动程序</span><br>quit <span class="hljs-comment">// q 也行</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObskXJVeR4MNhRzF4jfsQtvo" deck= "❓疑问::👨🏻‍💻code::项目::webserver::1 第一章::1.13 - 1.16 GDB调试.md"--><p>给程序设置参数/获取设置参数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span> args <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-comment">// 💡应该只是设置一个变量而已</span><br>show args<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>GDB使用帮助</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">help<br></code></pre></td></tr></tbody></table></figure><p>查看当前文件代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">list</span>/l<span class="hljs-comment">// 从默认位置显示💡默认显示main函数的代码，一下显示10行</span><br><span class="hljs-built_in">list</span>/l 行号<span class="hljs-comment">// 从指定的行显示💡L 20&nbsp; 显示15-25行，显示上下5行</span><br><span class="hljs-built_in">list</span>/l 函数名<span class="hljs-comment">// 从指定的函数显示</span><br></code></pre></td></tr></tbody></table></figure><p>查看非当前文件代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">list</span>/l 文件名:行号  <span class="hljs-comment">// 💡查看其他文件的代码，一定不能缺后边的":"，否则当成函数名</span><br><span class="hljs-built_in">list</span>/l 文件名:函数名<br></code></pre></td></tr></tbody></table></figure><p>设置显示的行数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">show <span class="hljs-built_in">list</span>/listsize <br><span class="hljs-built_in">set</span> <span class="hljs-built_in">list</span>/listsize 行数<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsF4kPKhxvIKiedM2g1cf5K" --> <h2 id="32-断点操作"><a class="markdownIt-Anchor" href="#32-断点操作"></a> 3.2 断点操作::</h2><!-- basicblock-end --><p>设置断点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">b/<span class="hljs-keyword">break</span> 行号<br>b/<span class="hljs-keyword">break</span> 函数名 <br>b/<span class="hljs-keyword">break</span> 文件名:行号 <br>b/<span class="hljs-keyword">break</span> 文件名:函数<br><br><span class="hljs-comment">// 给其他文件里打断点</span><br>b bubble.cpp :bubbleSort(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>)<br></code></pre></td></tr></tbody></table></figure><p>查看断点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">i/info b/<span class="hljs-keyword">break</span><br></code></pre></td></tr></tbody></table></figure><p>删除断点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">d/del/delete 断点编号<br></code></pre></td></tr></tbody></table></figure><p>设置断点无效</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">dis/disable 断点编号<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsIHWOtB7YfziFXcV92IKuP" deck= "❓疑问::👨🏻‍💻code::项目::webserver::1 第一章::1.13 - 1.16 GDB调试.md"--><p>无效会使 Enb&nbsp; 变为&nbsp; Enb。/ / &nbsp; Enb：可用的(enable)&nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y(yes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n(no)</p><!-- basicblock-end --><p>设置断点生效</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ena/enable 断点编号<br></code></pre></td></tr></tbody></table></figure><p>设置条件断点(一般用在循环的位置)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b/<span class="hljs-keyword">break</span> <span class="hljs-number">10</span> <span class="hljs-keyword">if</span> i==<span class="hljs-number">5</span> <span class="hljs-comment">// 不能用=，因为=是赋值</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsXzNOfXRMhLP8AsNcdZldp" --> <h2 id="33-调试命令"><a class="markdownIt-Anchor" href="#33-调试命令"></a> 3.3 调试命令::</h2><!-- basicblock-end --><p>运行GDB程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">start(程序停在第一行) <br>run(遇到断点才停)<br></code></pre></td></tr></tbody></table></figure><p>继续运行，到下一个断点停</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">c/<span class="hljs-keyword">continue</span><br></code></pre></td></tr></tbody></table></figure><p>向下执行一行代码==(不会进入被调用的函数中)==</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">n/next<br></code></pre></td></tr></tbody></table></figure><p>变量操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">p/print 变量名(打印变量值) <br>ptype 变量名(打印变量类型)<br></code></pre></td></tr></tbody></table></figure><p>向下单步调试==(遇到函数进入函数体)==</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">s/step<br><span class="hljs-title function_">finish</span><span class="hljs-params">(跳出函数体)</span><br></code></pre></td></tr></tbody></table></figure><p>自动变量操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">display 变量名(自动打印指定变量的值) <br>i/info display <span class="hljs-comment">// 查看设置的自动变量</span><br>undisplay 编号<span class="hljs-comment">// 删除自动变量</span><br></code></pre></td></tr></tbody></table></figure><p>其它操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span> var 变量名=变量值 (循环中用的较多) <br>until (跳出循环) <span class="hljs-comment">// ❓要把断点删掉</span><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsA62GNxmefgpysqwb8Vs9q" --> <h1 id="4-具体细节"><a class="markdownIt-Anchor" href="#4-具体细节"></a> 4 具体细节::</h1><ul><li><p>运行到断点，断点的那行并没有执行</p></li><li><p>跳出循环体或者跳出函数体要求下边没有断点了才能跳出</p></li><li><p>? 断点无论是向下一步, 还是不进入函数体的向下一步, 都会正常执行该句</p></li><li><p>设置自动变量就是后边<strong>每次都对变量自动执行print操作</strong>，而不用手动显示变量值,</p><ul><li>&amp; 而如果进入其他函数就不再显示自动打印的变量了，因为已经没有了</li></ul></li><li><p>设置变量值可以在循环中使用，来控制循环变量</p></li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsSpvvGf62ODMnF5x2wbbNh" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.13 - 1.16 GDB调试.md" --> <p>#历史记录::<br>2022/9/18🌵1.13 - 1.16 GDB调试 : 看了所有的命令, 没有实操, 留下了三个❓⏱0-51<br>2022/9/19🌵1.13 - 1.16 GDB调试: 又复习一遍⏱0-30</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.10 - 1.12 makefile</title>
      <link href="/posts/55359/"/>
      <url>/posts/55359/</url>
      
        <content type="html"><![CDATA[<h1 id="1-makefile"><a class="markdownIt-Anchor" href="#1-makefile"></a> 1 Makefile</h1><!-- basicblock-start oid="ObsVCbaeXVzkBEHxQDAmKbkk" --> <h2 id="11-什么是-makefile"><a class="markdownIt-Anchor" href="#11-什么是-makefile"></a> 1.1 什么是 Makefile::</h2><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中， <strong>Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作</strong>，因为 Makefile 文件就 像一个 Shell 脚本一样，也可以执行操作系统的命令。</p><p>Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整 个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个 解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令， 比如 Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。</p><!-- basicblock-end --><!-- basicblock-start oid="ObsAmYpEFlk60gco2w0pNYQs" --> <h2 id="12-makefile-文件命名和规则"><a class="markdownIt-Anchor" href="#12-makefile-文件命名和规则"></a> 1.2 Makefile 文件命名和规则::</h2><!-- basicblock-end --><p>文件命名：makefile 或者 Makefile</p><p>Makefile 规则：</p><ul><li>一个 Makefile 文件中可以有一个或者多个规则</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">目标 : 依赖 <br>    命令(Shell 命令)<span class="hljs-comment">// 前边是 tab 缩进</span><br>    <br></code></pre></td></tr></tbody></table></figure><p>目标:最终要生成的文件(伪目标除外)</p><p>依赖:生成目标所需要的文件或是目标</p><p>命令:通过执行命令对依赖操作生成目标(命令前必须 Tab 缩进)</p><p><strong>- Makefile 中的其它规则一般都是为第一条规则服务的。</strong></p><p>make默认只执行Makefile第一条语句，如果其他语句与第一条无关，则不执行。</p><!-- basicblock-start oid="Obs6liwB1xuL7V0E3XVnOAaY" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <h3 id="121-通过-makefile-自动化编译工程"><a class="markdownIt-Anchor" href="#121-通过-makefile-自动化编译工程"></a> 1.2.1 通过 makefile 自动化编译工程::</h3><p>先安裝一下 make 命令：sudo apt install make</p><p>目标: 对calc中的进行编译一起生成一个app可执行文件</p><p>创建 makefile 文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">vim Makefile <span class="hljs-comment">// Makefile 文件一定命名为Makefile 或者makefile, 不然识别不了</span><br></code></pre></td></tr></tbody></table></figure><p>编辑 makefile ：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">app: sub.c add.c mult.c div.c main.c<span class="hljs-comment">// 目标 : 依赖</span><br>        gcc sub.c add.c mult.c div.c main.c -o app <span class="hljs-comment">// 命令</span><br></code></pre></td></tr></tbody></table></figure><p><code>make</code> 命令: <strong>按<mark>当前目录下</mark>的 makefile 去自动执行命令</strong>，生成了 app。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">make   <span class="hljs-comment">// 相当于执行了:  gcc sub.c add.c mult.c div.c main.c -o app</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obs1xOoIzB6f6HvBbnut4dKl" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <h3 id="122-工作原理"><a class="markdownIt-Anchor" href="#122-工作原理"></a> 1.2.2 工作原理::</h3><!-- basicblock-end --><ul><li>&amp; Makefile 中的其它规则一般都是为第一条规则服务的。</li><li>命令在执行之前，<strong>需要先检查规则中的依赖是否存在</strong></li><li>如果存在，执行命令</li><li>如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令。</li><li>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</li><li>如果依赖的时间比目标的时间晚，需要重新生成目标。<br>eg: main.c 被修改了<br>main.o: main.c<br>gcc -c main.c -o main.o<br>因为main.c的时间比main.o的时间晚，说明了它更新过了。所以要重新执行该命令生成最新的main.o</li><li>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行。</li></ul><p>案例：</p><p>编辑 makefile 文件。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">app: sub.o add.o mult.o div.o main.o <span class="hljs-comment">//💡app 是目标: 后边是他的依赖</span><br>        gcc sub.o add.o mult.o div.o main.o -o app<br><br>sub.o:sub.c <span class="hljs-comment">// 💡二级目标和依赖</span><br>        gcc -c sub.c -o sub.o<br><br>add.o:add.c<br>        gcc -c add.c -o add.o<br><br>mult.o:mult.c<br>        gcc -c mult.c -o mult.o<br><br>div.o:div.c<br>        gcc -c div.c -o div.o<br><br>main.o:main.c<br>        gcc -c main.c -o main.o<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">make<br><span class="hljs-comment">// 相当于执行了以下命令</span><br>-&gt;<br>gcc -c sub.c -o sub.o <span class="hljs-comment">// 先执行二级目标依赖, 他们是为一级目标依赖提供支持的</span><br>gcc -c add.c -o add.o<br>gcc -c mult.c -o mult.o<br>gcc -c div.c -o div.o<br>gcc -c main.c -o main.o<br>gcc sub.o add.o mult.o div.o main.o -o app<br></code></pre></td></tr></tbody></table></figure><p>而<strong>分规则的</strong>写法，只会重新编译有修改的 .o 文件，再链接生成 app，效率更高。<br>假设只有add.c 修改了，后边只会执行 add.o:add.c 这个命令<br>只更新修改过的</p><p>与前面的 makefile 写法对比：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这里直接一步到位的, -o 命令直接使.c 文件生成了.o 文件</span><br>app: sub.c add.c mult.c div.c main.c<br>        gcc sub.c add.c mult.c div.c main.c -o app<br></code></pre></td></tr></tbody></table></figure><p>当 .c 文件更新时，makefile 在执行规则中的命令时，会比较目标和依赖文件的时间，如果依赖的时间比目标的时间晚，会更新目标。这种写法一旦更新某一个文件，都会执行该命令，重新编译所有的 .o 文件，再链接更新 app 。</p><ul><li>&amp; 所有的规则都是服务于第一条规则的，如果下边的规则生成的不是第一个规则所需的依赖，或者与第一条规则没关系就不会执行(除非特别指定）</li></ul><!-- basicblock-start oid="Obs4fvRLFfjnlOxNz9YXPNdy" --> <h2 id="13-如何简化-makefile-的写法"><a class="markdownIt-Anchor" href="#13-如何简化-makefile-的写法"></a> 1.3 如何简化 makefile 的写法::</h2><ul><li>? 这些好像只能在 makefile 文件下用, 我在外边使用说找不到该命令</li><li>? <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209211553114.png" alt=""></li></ul><!-- basicblock-end --><ul><li><p>自定义变量</p><p><code>变量名=变量值</code>  <code>var=hello</code></p></li></ul><!-- basicblock-start oid="Obs4ecx2iEKtVarUMlbJgmPl" --> <ul><li>预定义变量(提前定义好的变量)::</li></ul><table><thead><tr><th>预定义变量</th><th></th><th>备注</th></tr></thead><tbody><tr><td>AR</td><td>归档维护程序的名称，默认值为 ar</td><td>之前静态库打包用的</td></tr><tr><td>CC</td><td>C 编译器的名称，默认值为 cc</td><td>可以理解成 gcc</td></tr><tr><td>CXX</td><td>C++ 编译器的名称，默认值为 g++</td><td></td></tr><tr><td>$@</td><td>目标的完整名称</td><td>获取某一个内容</td></tr><tr><td>$&lt;</td><td>第一个依赖文件的名称</td><td></td></tr><tr><td>$^</td><td>所有的依赖文件</td><td></td></tr></tbody></table><!-- basicblock-end --><ul><li>如何获取变量的值<br><code>$(变量名)</code><br>eg:<br><code>$(cc)</code>就获取到了 cc<br><code>$(var)</code> 就获取到了 hello</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">$@         $&lt;         $^       <br>这三个是自动变量, 只能在规则的命令中使用, 不能用到规则当中<br><br><span class="hljs-comment">// eg</span><br>目标 ...: 依赖 ... <span class="hljs-comment">// 这是规则</span><br>    命令(Shell 命令)<span class="hljs-comment">// 💡这是规则命令, 只能在这个部分使用</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsfKH9K0Es2e68hifPe4hHn" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <p>用变量简化 makfile 命令::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">app:main.c a.c b.c <span class="hljs-comment">// 💡app 是目标, main.c a.c b.c 是他的依赖</span><br>gcc -c main.c a.c b.c <br><span class="hljs-comment">// 上面的命令可以直接写成这样</span><br>$(CC) -c $^ <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$(cc): gcc</span><br><span class="hljs-comment">$^ : 所有的依赖文件 : main.c a.c b.c</span><br><span class="hljs-comment">$@ : 目标的完整名称 :&nbsp;app          </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"># 定义变量<br>src=sub.o add.o mult.o div.o main.o<span class="hljs-comment">// 定义依赖</span><br>target=app <span class="hljs-comment">// 定义目标</span><br><br>$(target):$(src)<br>        $(CC) $(src) -o $(target)<br><br><span class="hljs-comment">// 下边的二级目标和依赖还要手动写, 怎么解决看下边 ### 1.3.1</span><br>sub.o:sub.c<br>        gcc -c sub.c -o sub.o<br><br>add.o:add.c<br>        gcc -c add.c -o add.o<br><br>mult.o:mult.c<br>        gcc -c mult.c -o mult.o<br><br>div.o:div.c<br>        gcc -c div.c -o div.o<br><br>main.o:main.c<br>        gcc -c main.c -o main.o        <br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsUdagLCQlNQvY2DaxKOpZy"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>复制与删除::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">cp text.c text2.c <span class="hljs-comment">// 在当前目录习复制 text.c</span><br>rm * .o<span class="hljs-comment">// 删除具体后缀的文件</span><br>rm app <span class="hljs-comment">// 删除 app</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="ObseiWUainM23AW7mSTZZRBo" --> <h3 id="131-模式匹配二级目标和依赖怎么简化"><a class="markdownIt-Anchor" href="#131-模式匹配二级目标和依赖怎么简化"></a> 1.3.1 模式匹配(二级目标和依赖怎么简化)::</h3><p>^a51e57</p><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 怎么简化</span><br>sub.o:sub.c<br>        gcc -c sub.c -o sub.o<br>add.o:add.c<br>        gcc -c add.c -o add.o<br>mult.o:mult.c<br>        gcc -c mult.c -o mult.o<br>div.o:div.c<br>        gcc -c div.c -o div.o<br>main.o:main.c<br>        gcc -c main.c -o main.o <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%.o:%.c<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsDMcIqwYCJ4cTQuls17TCN" --> <p>通配符%::</p><ul><li>%:通配符，匹配一个字符串</li><li>两个%匹配的是同一个字符串</li></ul><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">%.o:%.c <span class="hljs-comment">// 会匹配, sub.o : sub.c, add, mult, div main 同理</span><br>    $(cc) -c $&lt; -o $@ <span class="hljs-comment">// gcc - c sub.o -o app</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$(cc): gcc</span><br><span class="hljs-comment">$^ : 所有的依赖文件 : main.c a.c b.c</span><br><span class="hljs-comment">$@ : 目标的完整名称 :&nbsp;app   </span><br><span class="hljs-comment">$&lt; : 第一个依赖文件的名称</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><p>改写后：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"># 定义变量<br>src=sub.o add.o mult.o div.o main.o<br>target=app<br>$(target):$(src)<br>        $(CC) $(src) -o $(target)<br>        <br>%.o:%.c<br>        $(CC) -c $&lt; -o $@ <span class="hljs-comment">// gcc - c sub.o -o app</span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>$&lt;</code> 为第一个依赖的名称，</li><li><code>$@</code> 为目标的完整名称，<br><code>%.o:%.c</code>: 首先为 sub.c 生成 sub.o, 后边 add.c, mult.c, div.c, main.c 也能匹配这个规则, 因为一级目标 需要这些二级目标, 所以也会逐个生成</li></ul><!-- basicblock-start oid="ObscwTRNP3NVw5IXIfpM1fDb" --> <h3 id="132-如何简化定义变量的操作"><a class="markdownIt-Anchor" href="#132-如何简化定义变量的操作"></a> 1.3.2 如何简化定义变量的操作::</h3><!-- basicblock-end --><p>定义变量的时候如何自动获取 “.x” 后缀的文件</p><blockquote><p>可以简化定义变量的操作, eg: src=sub.o add.o mult.o div.o main.o</p></blockquote><p>查找指定文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$(wildcard PATTERN...) <span class="hljs-comment">// $(函数名 函数参数)</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>功能：获取指定目录下<strong>指定类型</strong>的文件列表。</p></li><li><p>参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔。</p></li><li><p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</p></li><li><p>示例：</p></li></ul><!-- basicblock-start oid="undefined" --> <p><code>*</code>通配符::表示任意的</p><!-- basicblock-end --><p><code>$(wildcard ./*.c ./sub/*.c)</code> : 获取当前目录下的.c 文件 和 sub 目录下的.c 文件<br>返回值格式: a.c b.c c.c d.c e.c f.c</p><!-- basicblock-start oid="Obs3pv8eLTaVfMMSJQLJRtpF" --> <h4 id="1321-如何将c-文件变成o-文件"><a class="markdownIt-Anchor" href="#1321-如何将c-文件变成o-文件"></a> 1.3.2.1 如何将.c 文件变成.o 文件::</h4><!-- basicblock-end --><p>查找指定文件并替换：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)<br></code></pre></td></tr></tbody></table></figure><ul><li>示例：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$(patsubst %.c, %.o, a.c b.c)<span class="hljs-comment">// 将a.c, b.c 变成 a.o, b.o</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">- 功能：查找&lt;text&gt;中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合<br><br>  模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。<br><br>- &lt;pattern&gt;可以包括通配符`%`，表示任意长度的字串。如果&lt;replacement&gt;<br><br>  中也包含`%`，那么，&lt;replacement&gt;中的这个`%`将是&lt;pattern&gt;中的那个%<br><br>  所代表的字串。(可以用`\`来转义，以`\%`来表示真实含义的`%`字符)<br><br>- 返回：函数返回被替换过后的字符串<br></code></pre></td></tr></tbody></table></figure><p>优化后：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义变量</span><br><span class="hljs-comment"># add.c sub.c main.c mult.c div.c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span> // 查找当前目录下的.c 文件<br>objs=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span> // 💡将.c 文件替换成.o 文件<br><br>// 💡target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(objs)</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(objs)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">%.o:%.c</span><br>        <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs3KbfmFrEGqbKcT09Oa6yw" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <h1 id="2-最终版本"><a class="markdownIt-Anchor" href="#2-最终版本"></a> 2 最终版本::</h1><!-- basicblock-end --><p>编译链接后不需要 .o 文件，可以删除，在 makefile 文件里后面加上一条规则。<br>^9qsu74</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义变量</span><br><span class="hljs-comment"># add.c sub.c main.c mult.c div.c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objs=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span>//💡 .o 文件<br><br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(objs)</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(objs)</span> -o <span class="hljs-variable">$(target)</span><br><br><br><span class="hljs-section">%.o:%.c</span><br>        <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>        rm <span class="hljs-variable">$(objs)</span> -f<br></code></pre></td></tr></tbody></table></figure><p><code>clean</code> 规则与第一条规则无关，执行 <code>make</code> 时不会执行 <code>clean</code> 规则。<br>所以只能执行命令make clean删除：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">make clean <span class="hljs-regexp">//</span> 单独执行 clean 命令<br></code></pre></td></tr></tbody></table></figure><hr><p>但当有一个名为 clean 的文件时，因为<code>clean</code> 没有依赖，执行 <code>make clean</code>与名为 clean 的文件对比而更新 clean 文件，导致无法执行 <code>clean</code> 规则。<br>将 <code>clean</code> 定义为伪目标，这样不会生成特定的文件，就不会与名为 clean 的文件对比而无法执行 <code>clean</code> 规则了。</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean // 定义一个伪目标, 这样使用 make clean 就不会与外边的 clean 文件做对比了</span><br><span class="hljs-section">clean:</span><br>        rm <span class="hljs-variable">$(objs)</span> -f<br></code></pre></td></tr></tbody></table></figure><ul><li>&amp; 其实也没必要, 不要在当前目录下创建文件名字为 clean 的文件就行了</li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObshDhqIzljSgBC0Idg3cMFj" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <p>#历史记录::<br>2022/9/18🌵1.10 - 1.12 makefile : 简单一点就不用那个简化版本, 复杂的需要简化版本, 我觉得学会原始版本就行. 先掌握了原始版本, 在说简化版的(那个感觉像正则表达式),最终复习版本: [[1.10 - 1.12 makefile#^9qsu74]]⏱2-0,<br>2022/9/19🌵整体复习了一遍, 都看懂了, 简单的⏱0-30</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18. 从中序与后序遍历序列构造二叉树</title>
      <link href="/posts/31429/"/>
      <url>/posts/31429/</url>
      
        <content type="html"><![CDATA[<h1 id="1-106从中序与后序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#1-106从中序与后序遍历序列构造二叉树"></a> 1 106.从中序与后序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接</a></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder =&nbsp;[9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p><p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p><!-- basicblock-start oid="ObsulTdKbfPEN1jUOcdIrH7S" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>![[18. 从中序与后序遍历序列构造二叉树 2022-09-18 10.42.17.excalidraw]]</p><ol><li>后序数组为 0, 空节点<ul><li>&amp; 递归终止条件</li></ul></li><li>后序数组最后一个节点元素为中节点</li><li>寻找中序数组中的中节点,作为切割点</li><li>切中序数组,切成中序左数组和中序右数组 <strong>（顺序别搞反了，一定是先切中序数组）</strong><ul><li>&amp; 因为中序: 左中右: 通过中能够把左右区间找到, 而后序: 左右中, 没法通过中节点把左右区间找到</li></ul></li><li>切后序数组, 切成后序左数组和后序右数组</li><li>递归处理左区间和右区间</li></ol><h2 id="21-思考"><a class="markdownIt-Anchor" href="#21-思考"></a> 2.1 思考</h2><p>前序和中序可以唯一确定一棵二叉树。<br>后序和中序可以唯一确定一棵二叉树。<br>那么前序和后序可不可以唯一确定一棵二叉树呢？<br><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。<br>举一个例子：</p><p><img src="https://img-blog.csdnimg.cn/20210203154720326.png" alt="106.从中序与后序遍历序列构造二叉树2|700"></p><p>tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。<br>tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。<br>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！<br>所以前序和后序不能唯一确定一棵二叉树！</p><!-- basicblock-start oid="ObsISTWjlaNfryeuakU5S861" --> <h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><!-- basicblock-end --><p>v1, 通过, 看懂了, 抄了一遍</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span></span>{<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 💡定义中节点j</span><br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue); <br><br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 💡剪枝</span><br><br>        <span class="hljs-type">int</span> delimiterIndex; <span class="hljs-comment">// 分割符用来确定中序数组中的 "中节点位置下标": 💡用middleINdex更好看一些</span><br>        <span class="hljs-keyword">for</span>(delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++){<br>            <span class="hljs-keyword">if</span>(inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 此时 break 出去后,得到了中节点的下标值</span><br>        }<br>        <span class="hljs-comment">// 💡循环不变量: 左闭右开</span><br>        <span class="hljs-comment">// 切割中序数组: 左中右</span><br>        <span class="hljs-comment">//中序数组的: 左子树区间：[0, delimiterIndex)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<span class="hljs-comment">// 💡下标从 0 开始的, 取不到delimiterIndex</span><br>        <span class="hljs-comment">//中序数组的: 右子树区间: [delimiterIndex + 1, end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br><br>        <span class="hljs-comment">//后序数组 postorder 舍弃末尾元素</span><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br><br>        <span class="hljs-comment">// 切割后序数组: 左右中</span><br>        <span class="hljs-comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span><br>        <span class="hljs-comment">// 后序数组的: 左子树区间[0, leftInorder.size)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-comment">// 后序数组的: 右子树区间[leftInorder.size(), end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        <span class="hljs-comment">// 递归处理</span><br>        <span class="hljs-comment">// 构建左子树, 传入中序数组的左子树区间, 后序数组的左子树区间.这样又是一个中序数组, 一个后序数组, 又可以按照上面的逻辑</span><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br><br>        <span class="hljs-comment">// 构建右子树</span><br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br>        <span class="hljs-keyword">return</span> root;<br><br>        <br><br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt; postorder)</span></span>{<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 💡可以先忽略剪枝</span><br><br>        <span class="hljs-type">int</span> middleIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; middleIndex &lt; inorder.<span class="hljs-built_in">size</span>(); middleIndex++){<br>            <span class="hljs-keyword">if</span>(inorder[middleIndex] == rootValue) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 取出中序数组的中的中节点</span><br>        }<br><span class="hljs-comment">// 💡循环不变量: 左闭右开</span><br><span class="hljs-comment">// 重新定义中序数组的左右区间</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + middleIndex)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + middleIndex + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <br><span class="hljs-comment">// 重新定义后序数组的左右区间</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size() , postorder.end())</span></span>; <span class="hljs-comment">// 💡左闭右开, 取得到 middleIndex 那个位置, 看一下exclidraw 就明白了</span><br>        <br><span class="hljs-comment">// 递归处理左右区间</span><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder); <span class="hljs-comment">// 左</span><br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder); <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br><br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>    <span class="hljs-comment">// 💡这里也可以先忽略剪枝</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>此时应该发现了，如上的代码性能并不好，应为每层递归定定义了新的vector（就是数组），既耗时又耗空间，但上面的代码是最好理解的，为了方便读者理解，所以用如上的代码来讲解。</strong><br>下面给出用下标索引写出的代码版本：（思路是一样的，只不过不用重复定义vector了，每次用下标索引来分割）</p><p>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postorderBegin, <span class="hljs-type">int</span> postorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorderEnd - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorderEnd - postorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br>        <span class="hljs-type">int</span> leftPostorderBegin =  postorderBegin;<br>        <span class="hljs-type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是 需要加上 中序区间的大小size</span><br>        <span class="hljs-comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br>        <span class="hljs-type">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>; <span class="hljs-comment">// 排除最后一个元素，已经作为节点了</span><br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-105从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#4-105从前序与中序遍历序列构造二叉树"></a> 4 105.从前序与中序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">力扣题目链接</a></p><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder =&nbsp;[3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：</p><p><img src="https://img-blog.csdnimg.cn/20210203154626672.png" alt="105. 从前序与中序遍历序列构造二叉树"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZWXTX5hBxE5V1bPIDc5LR" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::18. 从中序与后序遍历序列构造二叉树.md" --> <p>#历史记录::<br>2022/9/18🌵18. 从中序与后序遍历序列构造二叉树 :v1, 通过看懂了, 抄了一遍 , # 105.从前序与中序遍历序列构造二叉树没做⏱1-10<br>2022/9/18🌵18. 从中序与后序遍历序列构造二叉树: v2, 抄了一遍⏱0-15</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年09月15日 实验设计</title>
      <link href="/posts/9190/"/>
      <url>/posts/9190/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsgXRty2uIaSNhMVByK63rc" deck = "👨🏻‍🎓科研::2022::09::2022年09月15日 实验设计.md" --> <p>#历史记录::<br>2022/9/15🌵2022年09月15日 实验设计</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
          <category> 2022 </category>
          
          <category> 09 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关键字与运算符</title>
      <link href="/posts/44179/"/>
      <url>/posts/44179/</url>
      
        <content type="html"><![CDATA[<h1 id="1-指针与引用"><a class="markdownIt-Anchor" href="#1-指针与引用"></a> 1 [[指针与引用]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obs2B8oGr5nTzAffAQrPykHp"  extra = "[margin](marginnote3app://note/DF7FE30B-C7ED-4374-AA09-FDD201AA5A93)"--> <h1 id="2-const关键字"><a class="markdownIt-Anchor" href="#2-const关键字"></a> 2 [[const关键字]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsgLK5epyESFi7Y3d3ciOJg"  extra = "[margin](marginnote3app://note/53F1C912-5C26-418E-AF65-412FA8360CD4)"--> <h1 id="3-define和typedef的区别"><a class="markdownIt-Anchor" href="#3-define和typedef的区别"></a> 3 [[define和typedef的区别]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obsy1SMLwOpHxSLCrrHTVBF9"  extra = "[margin](marginnote3app://note/2C28D3E0-C477-4881-85C5-7E06660DD83B)"--> <h1 id="4-define和inline的区别"><a class="markdownIt-Anchor" href="#4-define和inline的区别"></a> 4 [[define和inline的区别]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obs9omdQgY1cgqxwiut7ieAM"  extra = "[margin](marginnote3app://note/B576E328-63AD-4A2A-B7D5-CADA708C14E1)"--> <h1 id="5-override和overload"><a class="markdownIt-Anchor" href="#5-override和overload"></a> 5 [[override和overload]] ::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsTRZAQ4AT7xrE5t688Ln79"  extra = "[margin](marginnote3app://note/82808465-7D55-484C-A354-9CD4CD5A73AE)"--> <h1 id="6-new和malloc"><a class="markdownIt-Anchor" href="#6-new和malloc"></a> 6 [[new和malloc]] ::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsHLqiUdLoOGs864sKGvo5P"  extra = "[margin](marginnote3app://note/9E7B3406-DEE7-4CE6-B315-FF5135902FA6)"--> <h1 id="7-constexpr和const-c新特性"><a class="markdownIt-Anchor" href="#7-constexpr和const-c新特性"></a> 7 [[constexpr和const  (C++新特性)]]::</h1><p>[[C++新特性]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsoptukXVhaTzjg3zFG2Vi1" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::关键字与运算符.md"--><h1 id="8-const和static的区别"><a class="markdownIt-Anchor" href="#8-const和static的区别"></a> 8 [[const和static的区别]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsvSnEVdYtjuqO8Jggw5Lho"  extra = "[margin](marginnote3app://note/D21576CA-7330-4573-8A4C-12353C65B912)"--> <h1 id="9-extern-与-static"><a class="markdownIt-Anchor" href="#9-extern-与-static"></a> 9 [[extern 与 static]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsYyg34Q20TONVH4v5d3iws"  extra = "[margin](marginnote3app://note/F2C85E29-1092-4D10-89F0-9FA8884AA5E0)"--> <h1 id="10-前置与后置"><a class="markdownIt-Anchor" href="#10-前置与后置"></a> 10 [[前置<ins>与后置</ins>]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObskjT4JilAyWTfqhHerVJ3h"  extra = "[margin](marginnote3app://note/AF118F7E-D507-4AA5-AA33-0B9C547E71A7)"--> <h1 id="11-stdatomic"><a class="markdownIt-Anchor" href="#11-stdatomic"></a> 11 [[stdatomic]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsyGuXVhYhkcSH0zbyC5ExF"  extra = "[margin](marginnote3app://note/025A6CAE-DC4A-44BE-85DF-74E7B59576A5)"--> <h1 id="12-c-三大特性"><a class="markdownIt-Anchor" href="#12-c-三大特性"></a> 12 [[C++ 三大特性]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsiCuXCs2Z4xHIIoeul3Obb"  extra = "[margin](marginnote3app://note/E065ED15-11D5-44DD-88FC-8183FA89C037)"--> <h1 id="13-虚函数"><a class="markdownIt-Anchor" href="#13-虚函数"></a> 13 [[虚函数]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obss2iG3hoVvrTUQes8cQP6V"  extra = "[margin](marginnote3app://note/E4A2E8E7-C6DF-4B57-970D-205737CFFC4C)"--> <h1 id="14-为什么需要虚继承"><a class="markdownIt-Anchor" href="#14-为什么需要虚继承"></a> 14 [[为什么需要虚继承]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsW93KnNeVsEVri938VUYsu"  extra = "[margin](marginnote3app://note/D9853C54-DBD1-4C62-97AE-DA1E98F569AC)"--> <h1 id="15-空类"><a class="markdownIt-Anchor" href="#15-空类"></a> 15 [[空类]]::</h1><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18. 路径总和</title>
      <link href="/posts/38740/"/>
      <url>/posts/38740/</url>
      
        <content type="html"><![CDATA[<p>相信很多同学都会疑惑，递归函数什么时候要有返回值，什么时候没有返回值，特别是有的时候递归函数返回类型为bool类型。</p><p>那么接下来我通过详细讲解如下两道题，来回答这个问题：</p><ul><li>112.路径总和</li><li>113.路径总和ii</li></ul><h1 id="4-112路径总和"><a class="markdownIt-Anchor" href="#4-112路径总和"></a> 4 112路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/">力扣题目链接</a></p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明:&nbsp;叶子节点是指没有子节点的节点。</p><p>示例:&nbsp; 给定如下二叉树，以及目标和 sum = 22，</p><p><img src="https://img-blog.csdnimg.cn/20210203160355234.png" alt="112.路径总和1"></p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><!-- basicblock-start oid="ObsJ38kAGz6rCfdGobYiJblf" --> <h2 id="41-思路"><a class="markdownIt-Anchor" href="#41-思路"></a> 4.1 思路::</h2><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和|600"></p><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p><ol><li>确定递归函数的参数和返回类型<br>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。<br>返回值: bool 类型: true, false</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span>   <span class="hljs-comment">// 注意函数的返回类型</span></span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>确定终止条件</li></ol><p>首先计数器如何统计这一条路径的和呢？</p><p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p><p><strong>如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。</strong></p><p>如果遍历到了叶子节点，count不为0，就是没找到。</p><p>递归终止条件代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>确定单层递归的逻辑</li></ol><!-- basicblock-start oid="Obsrzv5G8Uy3849rJgnF7ZzQ" --> <p>终止条件是判断叶子节点::递归的过程中就不要让空节点进入递归了。</p><p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 ,💡终止条件是判断叶子节点::递归的过程中就不要让空节点进入递归了。</span><br>    count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>    count -= cur-&gt;right-&gt;val;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;right-&gt;val;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h2 id="42-代码"><a class="markdownIt-Anchor" href="#42-代码"></a> 4.2 代码</h2><p>carl &amp; v1:</p><!-- basicblock-start oid="ObsvtEcJKanSyKW74de5qkZA" --> <p>回溯的过程::<br>// 💡回溯就是递归在返回上一层的时候在多加一个步骤.<br>// 💡普通的递归返回上一层,只是没有附带一个操作. 这个操作就是回溯</p><!-- basicblock-end --><p>v1, 无法通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左</span><br>            count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, count);<br>            <span class="hljs-comment">// 💡回溯就是递归在返回上一层的时候在多加一个步骤. </span><br>            <span class="hljs-comment">// 💡普通的递归返回上一层,只是没有附带一个操作. 这个操作就是回溯</span><br>            count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>            count -= cur-&gt;right-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, count);<br>            count += cur-&gt;right-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>以上代码精简之后如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">haspathsum</span><span class="hljs-params">(treenode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">haspathsum</span>(root-&gt;left, sum - root-&gt;val) || <span class="hljs-built_in">haspathsum</span>(root-&gt;right, sum - root-&gt;val);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>是不是发现精简之后的代码，已经完全看不出分析的过程了，所以我们要把题目分析清楚之后，在追求代码精简。</strong> 这一点我已经强调很多次了！</p><p>v2: 通过, v1 版不精简版无法通过, 看这个就行</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// ❓为什么返回 true 会直接退出, 返回 false 却不会</span><br>        }<br>        <span class="hljs-comment">// ❗️没办法把两个返回值拆开</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="5-路径总和ii"><a class="markdownIt-Anchor" href="#5-路径总和ii"></a> 5 路径总和ii</h1><p><a href="https://leetcode.cn/problems/path-sum-ii/">力扣题目链接</a></p><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明:&nbsp;叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和&nbsp;sum = 22，</p><p><img src="https://img-blog.csdnimg.cn/20210203160854654.png" alt="113.路径总和ii1.png"></p><h2 id="51-思路"><a class="markdownIt-Anchor" href="#51-思路"></a> 5.1 思路</h2><p>113.路径总和ii要遍历整个树，找到所有路径，<strong>所以递归函数不要返回值！</strong></p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210203160922745.png" alt="113.路径总和ii"></p><p>为了尽可能的把细节体现出来，我写出如下代码（<strong>这份代码并不简洁，但是逻辑非常清晰</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">// 递归函数不需要返回值，因为我们要遍历整个树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 遇到了叶子节点且找到了和为sum的路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br><span class="hljs-comment">// 💡回溯的操作有两个: path 路径的 pop, count 值的加回来</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;left-&gt;val);<br>            count -= cur-&gt;left-&gt;val;        <span class="hljs-comment">// 💡递归操作多了一个</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, count);    <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;left-&gt;val;        <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯, 💡就多了这个</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;right-&gt;val);<br>            count -= cur-&gt;right-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, count);   <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;right-&gt;val;       <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathsum</span>(treenode* root, <span class="hljs-type">int</span> sum) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> result;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 把根节点放进路径</span><br>        <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>至于113. 路径总和ii 的迭代法我并没有写，用迭代方式记录所有路径比较麻烦，也没有必要，如果大家感兴趣的话，可以再深入研究研究。<br>[[15. 二叉树中递归带着回溯]]</p><p>v2: 未通过, 错误在❗️处, 不懂怎么解决</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> count,  vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// ❗️不懂, 调试显示操作空指针了, 但是下面明明让空指针不进入循环了</span><br>        <span class="hljs-keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; count == node-&gt;val){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        }<br><br>        <span class="hljs-keyword">if</span>(node-&gt;left){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;left, count - node-&gt;val, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>        <span class="hljs-keyword">if</span>(node-&gt;right){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;right, count - node-&gt;val, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br><br>    }<br><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">getPath</span>(root, targetSum, path, result);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs4GemwCeCImGHKqF6utBFo" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::18. 路径总和.md" --> <p>#历史记录::<br>2022/09/10🌵112. 路径总和: 递归法看懂了, 理解了回溯的过程(断点调试), 但是没对着打一遍, 迭代法不用看. ⏱1-04<br>2022/09/11🌵113. 路径总和ii, 递归的时候就多了一个回溯操作而已, 看懂了, 但是没对着写一遍代码⏱0-12<br>2022/09/12🌵112. 路径总和:  看v2简短代码, 理解其过程了⏱0-50<br>2022/09/13🌵113. 路径总和ii, v2: 未通过, 错误在❗️处, 不懂怎么解决⏱0-30</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. 找左下角的值</title>
      <link href="/posts/61049/"/>
      <url>/posts/61049/</url>
      
        <content type="html"><![CDATA[<h1 id="1-513找树左下角的值"><a class="markdownIt-Anchor" href="#1-513找树左下角的值"></a> 1 513.找树左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">力扣题目链接</a></p><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p>示例 1:</p><p><img src="https://img-blog.csdnimg.cn/20210204152956836.png" alt="513.找树左下角的值"></p><p>示例 2:</p><p><img src="https://img-blog.csdnimg.cn/20210204153017586.png" alt="513.找树左下角的值1"></p><!-- basicblock-start oid="Obs4VYeWXPGHrCmOJadXeitc" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>找出树的最后一行找到最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。</p><p>层序遍历只需要记录最后一行的第一个节点数值就可以了<br>每一层都记录一下第一个节点的值, 然后不断覆盖即可, 到了最后就得到了最后一行的第一个节点</p><!-- basicblock-end --><!-- basicblock-start oid="ObslzqM4Ig02v8E6kbj5Urfv" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><!-- basicblock-end --><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 记录最后一行第一个元素, 每一层都覆盖一遍, 直至最后一层</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 💡放到 pop() 上边 下边都行</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);  <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObstWMFjjheISVPVJbxyCfhl" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::17. 找左下角的值.md" --> <p>#历史记录::<br>2022/09/10🌵17. 找左下角的值 : 层序遍历很简单, 递归不用看⏱0-26<br>2022/09/12🌵17. 找左下角的值 : 独立写出来了, 很简单 ⏱0-10</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.左叶子之和</title>
      <link href="/posts/50095/"/>
      <url>/posts/50095/</url>
      
        <content type="html"><![CDATA[<h1 id="1-404左叶子之和"><a class="markdownIt-Anchor" href="#1-404左叶子之和"></a> 1 404.左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">力扣题目链接</a></p><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20210204151927654.png" alt="404.左叶子之和1"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><!-- basicblock-start oid="ObsffknYZdQ1qeK2vt83Mc3d" --> <p>如何判断左叶子节点::<br>通过当前节点无法判断, <strong>要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p><ol><li>如果该节点的左节点不为空，</li><li>该节点的左节点的左节点为空(左孙子)，该节点的左节点的右节点为空，</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    左叶子节点处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>2022/9/19;;;;;;;fsdfsf；;　;张,i。。。。1150-220=930.00</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftlValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left); <span class="hljs-comment">// 💡收集左子树的左叶子和,</span><br>        <span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<span class="hljs-comment">// 💡收集右子树的左叶子和,</span><br>        <span class="hljs-type">int</span> midValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果是判断是左叶子, 就把它的值收集起来(辅给一个中间变量)</span><br>        <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>){<br>            midValue = root-&gt;left-&gt;val;<br>        } <br>        <span class="hljs-comment">// 不断叠加</span><br>        <span class="hljs-type">int</span> sum = midValue + leftlValue +  rightValue;<span class="hljs-comment">// 💡 某个子树的根节点的左叶子和是其左右子树的和,然后返回给该节点, 该节点又成为上一层的左/右子树, 最后不断递归到原始根节点</span><br>        <span class="hljs-keyword">return</span> sum;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2 , 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftSum = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightSum = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️❓  if(!root-&gt;left &amp;&amp; root-&gt;left-&gt;left &amp;&amp; root-&gt;left-&gt;right)不行</span><br>            temp = root-&gt;left-&gt;val;<br>        }<br>        <span class="hljs-type">int</span> sum = temp + leftSum + rightSum;<br>        <span class="hljs-keyword">return</span> sum;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsPayaRA0PkUVLasN5bPggx" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::16.左叶子之和.md" --> <p>#历史记录::<br>2022/09/10🌵16.左叶子之和 : 递归: 大概懂了, sum 那块还有点懵 ➕ 层序遍历没看 ⏱0-33<br>2022/09/12🌵16.左叶子之和 : sum 那块看懂了,  写在了 v1 的代码中⏱0-26</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 二叉树中递归带着回溯</title>
      <link href="/posts/63200/"/>
      <url>/posts/63200/</url>
      
        <content type="html"><![CDATA[<p>二叉树中递归带着回溯::</p><p>[[4.组合总和III]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++){ <span class="hljs-comment">// ❗️不要忘记=号</span><br>    <span class="hljs-comment">//sum += i;</span><br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(n, k , i+<span class="hljs-number">1</span>, sum + i); <span class="hljs-comment">// 💡sum + i 直接传进这里跟注释的效果一样</span><br>    <span class="hljs-comment">//sum -= i;</span><br>    path.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></tbody></table></figure><p>[[13. 二叉树的所有路径]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) <span class="hljs-built_in">traversal</span>(cur-&gt;left, path + <span class="hljs-string">"-&gt;"</span>, result); <span class="hljs-comment">// 左  回溯就隐藏在这里</span><br></code></pre></td></tr></tbody></table></figure><p>大家应该可以感受出来，如果把 <code>path + "-&gt;"</code>作为函数参数就是可以的，因为并有没有改变path的数值，执行完递归函数之后，path依然是之前的数值（相当于回溯了）: <strong>相当于后边会执行 path.pop_back()</strong></p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObskFrGZ75Wu05UQz4f05D4w" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::15. 二叉树中递归带着回溯.md" --> <p>#历史记录::<br>2022/09/10🌵15. 二叉树中递归带着回溯 : 看不太懂 ⏱0-13<br>2022/09/12🌵15. 二叉树中递归带着回溯:&nbsp;通过断点调试看懂了, 只看我代码备注💡的 ⏱0-15</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.9 静态库和动态库的对比</title>
      <link href="/posts/43829/"/>
      <url>/posts/43829/</url>
      
        <content type="html"><![CDATA[<h1 id="1-静态库和动态库的对比"><a class="markdownIt-Anchor" href="#1-静态库和动态库的对比"></a> 1 静态库和动态库的对比::</h1><h2 id="11-程序编译成可执行程序的过程"><a class="markdownIt-Anchor" href="#11-程序编译成可执行程序的过程"></a> 1.1 程序编译成可执行程序的过程::</h2><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209111652798.png" alt="|800"></p><ul><li>&amp; 动态库和静态库的区别就在于<strong>链接阶段如何处理库</strong></li></ul><p>静态库: 把库的整个内容拷进去<br>动态库: 告知这个库里有什么东西，在哪里放着，运行的实际过程中才会去找这个库</p><p>这两种处理方式也分别被称为静态链接方式和动态链接方式</p><ul><li><p>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中。</p></li><li><p><strong>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中。</strong></p>  <!-- basicblock-start deck= "❓疑问::👨🏻‍💻code::项目::webserver::1 第一章::1.9 静态库和动态库的对比.md"--><ul><li>程序启动之后，动态库会被动态加载到内存中，通过 ldd (list dynamic dependencies)命令检查动态库依赖关系。</li><li>如何定位共享库文件呢：当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是 由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH</strong>段 ——&gt; <strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong> ——&gt; <strong>/etc/ld.so.cache</strong>文件列表 ——&gt; <strong>/lib/</strong>，/usr/lib 目录找到库文件后将其载入内存。</li></ul>  <!-- basicblock-end --></li></ul><!-- basicblock-end --><!-- basicblock-start oid="ObsDKgJ8nfvZ3zvhJ9jIfKk5" --> <h1 id="2-静态库和动态库的制作过程"><a class="markdownIt-Anchor" href="#2-静态库和动态库的制作过程"></a> 2 静态库和动态库的制作过程::</h1><p>![[1.9 静态库和动态库的对比 2022-09-08 16.41.22.excalidraw]]<br>[[1.4-1.6  静态库和动态库#^hr9kzt]], [[1.4-1.6  静态库和动态库#^8oo3nd]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsQbyRkCglWMlKv71t6hgC5" --> <h1 id="3-静态库与动态库的优缺点"><a class="markdownIt-Anchor" href="#3-静态库与动态库的优缺点"></a> 3 静态库与动态库的优缺点::</h1><!-- basicblock-end --><h2 id="31-静态库的优缺点"><a class="markdownIt-Anchor" href="#31-静态库的优缺点"></a> 3.1 静态库的优缺点</h2><p>优点:</p><ul><li>静态库被打包到应用程序中加载速度快,<ul><li>&amp; 因为代码直接打包进去了</li></ul></li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点:</p><ul><li>消耗系统资源，浪费内存</li><li>更新、部署、发布麻烦<ul><li>&amp; 如果静态库更新了,所有使用它的应用程序都需要重新编译、发布给用户(对于玩家来说,只是一个很小的改动,却导致整个程序重新下载,全量更新)。而且静态库占用空间,所以有了动态库<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209151506567.png" alt=""></li></ul></li></ul><h2 id="32-动态库的优缺点"><a class="markdownIt-Anchor" href="#32-动态库的优缺点"></a> 3.2 动态库的优缺点</h2><p>优点:</p><ul><li>可以实现进程间资源共享(共享库)<ul><li>&amp; 因为每一次执行都要调用某路径下的文件, 该路径下的文件可以实现共享，也可以实时修改</li></ul></li><li>更新、部署、发布简单<ul><li>&amp; 动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</li></ul></li><li>可以控制何时加载动态库</li></ul><p>缺点：</p><ul><li>加载速度比静态库慢, 其实相差不太多</li><li>发布程序时需要提供依赖的动态库</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209151506969.png" alt=""></p><p><strong>所以，库较小时建议制作静态库，库较大时建议制作动态库。</strong></p><p><a href="https://zeefan.notion.site/?v=c8f779be7dee48979931444cb7d77ada">https://zeefan.notion.site/?v=c8f779be7dee48979931444cb7d77ada</a></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsn2hnDuXPvMfqmeRaZcaRt" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.9 静态库和动态库的对比.md" --> <p>#历史记录::<br>2022/9/8🌵1.9 静态库和动态库的对比  大概看了一下, 做了卡片</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.1 阻塞和非阻塞、同步和异步(网络 IO)</title>
      <link href="/posts/47674/"/>
      <url>/posts/47674/</url>
      
        <content type="html"><![CDATA[<h1 id="1-阻塞非阻塞-同步异步网络io方面的"><a class="markdownIt-Anchor" href="#1-阻塞非阻塞-同步异步网络io方面的"></a> 1 阻塞/非阻塞、同步/异步(网络IO方面的)::</h1><!-- basicblock-end --><p>典型的一次IO的两个阶段是什么::<br>数据就绪 和 数据读写</p><h2 id="11-数据就绪"><a class="markdownIt-Anchor" href="#11-数据就绪"></a> 1.1 数据就绪</h2><p>根据系统IO操作的就绪状态分为</p><ul><li>阻塞</li><li>非阻塞</li></ul><h2 id="12-数据读写"><a class="markdownIt-Anchor" href="#12-数据读写"></a> 1.2 数据读写</h2><p>根据应用程序和内核的交互方式分为 2</p><ul><li>同步</li><li>异步<ul><li>多路 IO 复用是异步</li></ul></li></ul><p>陈硕(人名):在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。</p><ul><li>&amp; 调用 recv, read 等等都是同步 IO, 使用特殊的接口才是异步 IO</li></ul><p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，<br>数据就绪阶段分为 阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p><ul><li>同步: 表示A向B请求调用一个网络IO接口时(或者调用某个业务逻辑API接口时)，数据的读写都是 由请求方A自己来完成的(不管是阻塞还是非阻塞);</li><li>异步: 表示A向B请求调用一个网络IO接口时 (或者调用某个业务逻辑API接口时)，向B传入请求的事件以及事件发生时通知的方式，A就可以 处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。<ul><li>&amp; 本项目不涉及异步, 因为编程很复杂</li></ul></li></ul><p>![[5.1 阻塞和非阻塞、同步和异步(网络 IO) 2022-09-21 16.37.09.excalidraw]]</p><p>同步阻塞<br>同步非阻塞</p><p>异步阻塞<br>异步非阻塞</p><p>邓东阿帆<br>11红灯红灯</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsnGZZO4uLPB3Gs2SpBicnM" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.1 阻塞和非阻塞、同步和异步(网络 IO).md" --> <p>#历史记录::<br>2022/9/8🌵5.1 阻塞和非阻塞、同步和异步(网络 IO) : 很好理解 ⏱1-00</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 5  项目实战与总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.二叉树周末总结</title>
      <link href="/posts/30222/"/>
      <url>/posts/30222/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObseXnu8DtSTQzxUsk2P21vj" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::14.二叉树周末总结.md" --> <p>#历史记录::<br>2022/9/10🌵14.二叉树周末总结 : 没看</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. 二叉树的所有路径</title>
      <link href="/posts/41119/"/>
      <url>/posts/41119/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树的所有路径"><a class="markdownIt-Anchor" href="#1-二叉树的所有路径"></a> 1 二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣题目链接</a></p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。<br>示例:<br><img src="https://img-blog.csdnimg.cn/2021020415161576.png" alt="257.二叉树的所有路径1|600"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>因为要求根节点到叶子节点的路径,只有<strong>用前序遍历(中左右), 才能先父节点, 在孩子节点</strong></p><p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。<br>![[13. 二叉树的所有路径 2022-09-08 10.28.43.excalidraw]]</p><h2 id="21-21递-归函数函数参数以及返回值"><a class="markdownIt-Anchor" href="#21-21递-归函数函数参数以及返回值"></a> 2.1 2.1递 归函数函数参数以及返回值</h2><p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; path, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; result)</span><br></code></pre></td></tr></tbody></table></figure><h2 id="22-确定递归终止条件"><a class="markdownIt-Anchor" href="#22-确定递归终止条件"></a> 2.2 确定递归终止条件</h2><p>再写递归的时候都习惯了这么写：</p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (cur <span class="hljs-operator">=</span><span class="hljs-operator">=</span> NULL) {<br>    终止处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsWo0JTseUeo6ZW6o58eWaj" --> <p><strong>本题要找到叶子节点，就开始结束的处理逻辑的写法</strong> ::</p><p><strong>那么什么时候算是找到了叶子节点？</strong><br><s>通过父节点来判断叶子节点, 左叶子同理</s><br>当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。</p><p>所以本题的终止条件是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    终止处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不为空才开始递归</span><br><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h3 id="221-终止处理的逻辑"><a class="markdownIt-Anchor" href="#221-终止处理的逻辑"></a> 2.2.1 终止处理的逻辑</h3><!-- basicblock-start oid="ObsYiit19mGwqF3uu5oWbxio" --> <p>使用vector方便来做回溯::</p><p>这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。</p><p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p><!-- basicblock-end --><p>这里我们先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 遇到叶子节点</span><br>    string sPath;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 将path里记录的路径转为string格式</span><br>        sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>        sPath += <span class="hljs-string">"-&gt;"</span>;<br>    }<br>    sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 记录最后一个节点（叶子节点）</span><br>    result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 收集一个路径</span><br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="23-确定单层递归逻辑"><a class="markdownIt-Anchor" href="#23-确定单层递归逻辑"></a> 2.3 确定单层递归逻辑</h2><p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p><p><code>path.push_back(cur-&gt;val);</code></p><p>然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p><p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不为空才开始递归</span><br><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p><!-- basicblock-start oid="ObsnMwvRLXkxbDNPD7V0J75I" --> <p>回溯怎么写::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>}<br>path.pop_back();<br></code></pre></td></tr></tbody></table></figure><p>这个回溯就要很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。</p><p><strong>所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p><p>那么代码应该这么写：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>    path.pop_back(); <span class="hljs-comment">// 回溯</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>    path.pop_back(); <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* cur , vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">// 先添加 path</span><br>        <span class="hljs-keyword">if</span>(cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>){<br>            string sPath;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++){<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">"-&gt;"</span>;<br>            }<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]); <span class="hljs-comment">// 最后一个节点要单独记录一下, 因为放到循环里会多一个"-&gt;"</span><br>            result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 记录一次路径</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;left){<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;right){<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>         vector&lt;string&gt; result; <span class="hljs-comment">// 初始化是🈚️</span><br>         vector&lt;<span class="hljs-type">int</span>&gt; path;<br>         <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>         <span class="hljs-built_in">traversal</span>(root, path, result);<br>         <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* cur , vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">//"中", 先添加 path, 因为是到了叶子节点就收集,如果在if结果下边, 就会漏掉叶子节点</span><br>        <span class="hljs-keyword">if</span>(cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 💡到了叶子节点才会执行</span><br>            string sPath;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++){<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">"-&gt;"</span>;<br>            }<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]); <span class="hljs-comment">// 最后一个节点要单独记录一下, 因为放到循环里会多一个"-&gt;"</span><br>            result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 记录一次路径</span><br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// ❓什么也没有 return 只是单纯的返回上一层?💡是的 因为返回值是 void</span><br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;left){ <span class="hljs-comment">// ❗️空指针不进入递归, 否则第一行代码就操作空指针了</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;right){<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 💡返回上一层后开始由下至上执行回溯</span><br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>         vector&lt;string&gt; result; <span class="hljs-comment">// 初始化是🈚️</span><br>         vector&lt;<span class="hljs-type">int</span>&gt; path;<br>         <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>         <span class="hljs-built_in">traversal</span>(root, path, result);<br>         <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3,通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 💡如果放到 if 语句下边会漏掉叶子节点</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>){<br>            string sPath;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++){<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">"-&gt;"</span>;<br>            }<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]);<br>            result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// ❗️应当在 if 函数中, 因为 sPath 出去 if 函数就失效了</span><br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// ❗️return 在 if 函数中</span><br>        }<br><br><br>        <span class="hljs-keyword">if</span>(node-&gt;left){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;left, path, result); <span class="hljs-comment">// ❗️不要忘了其他参数: path, result;</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>        <span class="hljs-keyword">if</span>(node-&gt;right){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        vector&lt;string&gt; result;<br>        <span class="hljs-built_in">getPath</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-精简代码"><a class="markdownIt-Anchor" href="#4-精简代码"></a> 4 精简代码</h1><p>[[15. 二叉树中递归带着回溯]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsQ3rLCCR2MhM7QhYfBTDty" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::13. 二叉树的所有路径.md" --> <p>#历史记录::<br>2022/09/08🌵13. 二叉树的所有路径 :代码抄了一遍, 中间还夹杂着和师弟聊天⏱1-15<br>2022/09/09🌵 13. 二叉树的所有路径 :复习了一遍, 关于回溯的第二遍过程还没想是怎么实现的⏱0-43<br>2022/09/ 11 🌵13. 二叉树的所有路径 : v3 ,熟悉一遍吧, 自己边写边看,不算独立写出来⏱0-30</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.7 - 1.8 动态库加载失败原因</title>
      <link href="/posts/27351/"/>
      <url>/posts/27351/</url>
      
        <content type="html"><![CDATA[<h1 id="1-动态库加载失败的原因"><a class="markdownIt-Anchor" href="#1-动态库加载失败的原因"></a> 1 动态库加载失败的原因</h1><p>工作原理：</p><ul><li>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中。</li><li><strong>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中。(报错的原因)</strong></li><li>程序启动之后，动态库会被动态加载到内存中，通过 ldd (list dynamic dependencies)命令检查动态库依赖关系。<strong>列出动态的依赖</strong></li><li>如何定位共享库文件呢：当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的<strong>动态载入器</strong>来获取该绝对路径。</li><li>对于elf格式的可执行程序，是 由<strong><a href="http://ld-linux.so">ld-linux.so</a></strong>(<strong>动态载入器</strong>)来完成的，它先后搜索elf文件的 <strong>DT_RPATH</strong>段 ——&gt; <strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong> ——&gt; <strong>/etc/ld.so.cache</strong>文件列表 ——&gt; <strong>/lib/</strong>，/usr/lib (这个不建议)目录找到库文件后将其载入内存。<ul><li>&amp; 就在这几个目录中，放入你的动态库，让系统找到就行了</li></ul></li></ul><p>ldd 命令检查动态库依赖关系：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> main<br></code></pre></td></tr></tbody></table></figure><p>发现 <code>libcalc.so =&gt; not found</code> ：</p><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">linux-vdso.<span class="hljs-keyword">so</span>.1 =&gt;  (0x00007ffcd55f8000)<br>libcalc.<span class="hljs-keyword">so</span> =&gt; not found<br>libc.<span class="hljs-keyword">so</span>.6 =&gt; /lib64/libc.<span class="hljs-keyword">so</span>.6 (0x00007fe2ddf8f000)<br>/lib64/ld-linux-x86-64.<span class="hljs-keyword">so</span>.2 (0x000055996189f000)<br></code></pre></td></tr></tbody></table></figure><p>动态库加载失败的原因：查找动态库的时候找不到动态库，因为没有指定动态库的绝对路径。</p><p>解决方法：在搜索 elf 文件的路径下配置，这样在查找的时候就能找到。</p><p><strong>DT_RPATH</strong>段改变不了，就需要修改环境变量。<br>发森</p><h2 id="11-配置动态库环境变量"><a class="markdownIt-Anchor" href="#11-配置动态库环境变量"></a> 1.1 配置动态库环境变量</h2><p>海红灯神岛</p><h3 id="111-修改环境变量-ld_library_path"><a class="markdownIt-Anchor" href="#111-修改环境变量-ld_library_path"></a> 1.1.1 修改<strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong>。</h3><p>方法一：临时修改 <strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong>。</p><p>首先确定动态库所在路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">pwd<br><span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library/lib<br></code></pre></td></tr></tbody></table></figure><p>改变环境变量：</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/lib<br></code></pre></td></tr></tbody></table></figure><p>(<code>:</code> 表示拼接)</p><p>查看设置好的环境变量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></tbody></table></figure><p>(备注：清除环境变量命令)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> LD_LIBRARY_PATH<br></code></pre></td></tr></tbody></table></figure><p>结果：</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/li<br></code></pre></td></tr></tbody></table></figure><p>用 ldd 命令检查动态库依赖关系：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> main<br></code></pre></td></tr></tbody></table></figure><p>这时候发现 <code>libcalc.so</code> 查找到了路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">linux-vdso.so.<span class="hljs-number">1</span> =&gt;  (<span class="hljs-number">0</span>x00007ffe8efa3000)<br>libcalc.so =&gt; <span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library<span class="hljs-regexp">/lib/</span>libcalc.so(<span class="hljs-number">0</span>x00007f907702f000)<br>libc.so.<span class="hljs-number">6</span> =&gt; <span class="hljs-regexp">/lib64/</span>libc.so.<span class="hljs-number">6</span> (<span class="hljs-number">0</span>x00007f9076c65000)<br><span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span> (<span class="hljs-number">0</span>x00005597336f6000)<br></code></pre></td></tr></tbody></table></figure><p>运行 main 程序成功：</p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">./main<br>a = <span class="hljs-number">20</span>, <span class="hljs-keyword">b</span> = <span class="hljs-number">12</span><br>a + <span class="hljs-keyword">b</span> = <span class="hljs-number">32</span><br>a - <span class="hljs-keyword">b</span> = <span class="hljs-number">8</span><br>a * <span class="hljs-keyword">b</span> = <span class="hljs-number">240</span><br>a / <span class="hljs-keyword">b</span> = <span class="hljs-number">1</span>.<span class="hljs-number">666667</span><br></code></pre></td></tr></tbody></table></figure><p>但是该方法不是永久的，因为环境变量是在终端里配置的，所以重新打开终端就要重新配置环境变量。</p><p>永久配置方法：</p><p>有两种，用户级别的配置和系统级别的配置。</p><p>用户级别的配置：</p><p>home 文件（root）下，其实有一个 <code>.bashrc</code> 文件，配置该文件即可。</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">vim <span class="hljs-string">.bashrc</span><br></code></pre></td></tr></tbody></table></figure><p><code>shift + G</code> 跳到最后一行，按 <code>o</code> 插入。</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/lib<br></code></pre></td></tr></tbody></table></figure><p><code>:wq</code> 保存并退出：<code>esc</code> 键退出 -&gt; <code>:</code> (符号输入)-&gt; <code>wq</code> (保存退出)</p><p>使得修改生效：</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">. <span class="hljs-string">.bashrc</span><br><span class="hljs-string">//</span> 或者<br>source <span class="hljs-string">.bashrc</span><br></code></pre></td></tr></tbody></table></figure><p>在 library 用 ldd 命令检查动态库依赖关系：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> main<br></code></pre></td></tr></tbody></table></figure><p>这时候发现 <code>libcalc.so</code> 查找到了路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">linux-vdso.so.<span class="hljs-number">1</span> =&gt;  (<span class="hljs-number">0</span>x00007ffe8efa3000)<br>libcalc.so =&gt; <span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library<span class="hljs-regexp">/lib/</span>libcalc.so(<span class="hljs-number">0</span>x00007f907702f000)<br>libc.so.<span class="hljs-number">6</span> =&gt; <span class="hljs-regexp">/lib64/</span>libc.so.<span class="hljs-number">6</span> (<span class="hljs-number">0</span>x00007f9076c65000)<br><span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span> (<span class="hljs-number">0</span>x00005597336f6000)<br></code></pre></td></tr></tbody></table></figure><p>系统级别的设置：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></tbody></table></figure><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/lib<br></code></pre></td></tr></tbody></table></figure><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></tbody></table></figure><p>发现拼接问题：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:<span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library<span class="hljs-regexp">/lib:/</span>root<span class="hljs-regexp">/Linux/</span>lesson1.<span class="hljs-number">6</span><span class="hljs-regexp">/library/</span>lib:<span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library/lib<br></code></pre></td></tr></tbody></table></figure><p>这是因为前面设置了用户级别的环境变量，导致出错，重新打开 shell 即可。</p><h3 id="112-修改etcldsocache文件"><a class="markdownIt-Anchor" href="#112-修改etcldsocache文件"></a> 1.1.2 修改**/etc/ld.so.cache**文件</h3><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>ld.so.cache<br></code></pre></td></tr></tbody></table></figure><p>发现是二进制文件，无法修改，需要间接地修改。</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vim</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></tbody></table></figure><p>写入路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library/lib<br></code></pre></td></tr></tbody></table></figure><p>更新：</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo ldconfig</span><br></code></pre></td></tr></tbody></table></figure><h3 id="113-放到lib或usrlib下"><a class="markdownIt-Anchor" href="#113-放到lib或usrlib下"></a> 1.1.3 放到**/lib/**或/usr/lib下</h3><p>不建议用这种方法，因为该目录下有很多系统库，如果自己的库与系统库重名，放进去就会把系统库覆盖掉。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsFwg8X1xKotZmab6Q5JrPy" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.7 动态库加载失败原因.md" --> <p>#历史记录::<br>2022/9/7🌵1.7 动态库加载失败原因 : 没看</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库与动态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4-1.6  静态库和动态库</title>
      <link href="/posts/52054/"/>
      <url>/posts/52054/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是库"><a class="markdownIt-Anchor" href="#1-什么是库"></a> 1 什么是库</h1><ul><li><p>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用 者一些可以直接拿来用的变量、函数或类。</p></li><li><p>库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。</p></li><li><p>库文件有两种，静态库和动态库(共享库)，区别是:静态库在程序的链接阶段被复制到了程序中;动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p></li><li><p>库的好处：1.代码保密 2.方便部署和分发</p></li></ul><h1 id="2-静态库的制作和使用"><a class="markdownIt-Anchor" href="#2-静态库的制作和使用"></a> 2 静态库的制作和使用</h1><p>命名规则：<strong>libxxx.a</strong></p><blockquote><p>lib : 前缀(固定)</p><p>xxx : 库的名字，自己起</p><p>.a : 后缀(固定)</p></blockquote><!-- basicblock-start oid="ObswtJbNRTn86BKCBGkcD1aT" --> <p>静态库的制作::</p><ol><li>gcc -c “文件 1, 文件 2”,  获得 .o 文件</li><li>将 .o 文件打包，使用 ar 工具（archive）</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">ar rcs libxxx.a xxx.o xxx.o<br><span class="hljs-comment">// libxxx: 其中 xxx 是自己命名的</span><br><span class="hljs-comment">// r - 将文件插入备存文件中</span><br><span class="hljs-comment">// c - 建立备存文件</span><br><span class="hljs-comment">// s - 索引</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obsa99kCCBjsR3HuWdEmW9uG" --> <p>静态库的使用::</p><!-- basicblock-end --> ^hr9kzt<p>在这个目录下<br>💡目标把 mian.c 编译成可执行的文件<br>calc 文件夹下是要制作成库的源文件，library 是完整的工程文件库，library 下的 src 文件夹中是制作静态库的源文件。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209062211463.png" alt="|400"><br>^6nlece ^eyzj1l</p><ul><li>&amp; 开始</li></ul><!-- basicblock-start oid="ObskPvKcbu0ivoF9JzGAvkh4" --> <p>-I 是什么意思::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 进入到 src 文件夹中，将源文件编译生成 -o 文件，因为源文件中使用到了 include 下的 head.c 文件(使用里边头文件)，所以用 `-I` 搜索头文件所在目录，如果不加就是在当前目录下搜索：</span><br>gcc -c add.c div.c mult.c sub.c -I ../include/ <span class="hljs-comment">// ../include/ 表示上一层文件夹的 include 目录, ./ : 表示这层</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>生成后的文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">.<br>├── add.c<br>├── add.o<br>├── div.c<br>├── div.o<br>├── mult.c<br>├── mult.o<br>├── sub.c<br>└── sub.o<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsCuiqY5wNUAK7R8ZXgfDWh" --> <p>生成静态库::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将 .o 文件打包，生成 libcalc.a 库：</span><br>ar rcs libsuanshu.a add.o div.o mult.o sub.o <span class="hljs-comment">// libxxx , xxx 是自己命名的</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obsa99kCCBjsR3HuWdEmW9uG"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>移动文件::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将 libcalc.a 移动到 lib 目录下：</span><br>mv libsuanshu.a ../lib/<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="ObsYOxKtGbIpg7Bsjc7x8oe8" --> <p>gcc -I(大 i) ,- L, -l(小 L) 命令是什么意思::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 目标:静态库的使用，编译生成 app：</span><br><span class="hljs-comment">// 先进入到 main.c 的目录下, 然后编译 main.c</span><br>gcc main.c -o app -I ./include/ -L ./lib/ -l suanshu <span class="hljs-comment">// 注意-l后边接的不是libsuanshu，还是lib后边的suanshu</span><br><span class="hljs-comment">// `-I` 为搜索 `head.h` 所在目录，用 `-I` 搜索头文件所在目录，如果不加就是在当前目录下搜索</span><br><span class="hljs-comment">// `-L` 为搜索指定动态库/静态库的名字，-L 用的是自己定义的函数</span><br><span class="hljs-comment">// `-l` 为所使用到的库的名字。(自己创建的静态库/动态库)</span><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 运行 app</span><br>./app<br></code></pre></td></tr></tbody></table></figure><ul><li>&amp; 结束</li></ul><!-- basicblock-start oid="ObstOe3LHy0hYekMZOxmc3IW"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>linux 怎么创建文件::</p><p>创建文件夹使用   mkdir x<br>创建文件使用       vim xxx  或者 touch x/a.txt<br>删除文件夹使用   rm -rf x/</p><!-- basicblock-end --><!-- basicblock-start oid="Obsax5VF7CBLkyARjpXDGj2M"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>怎么安装软件::</p><p>sudo  apt install gcc  安装gcc<br>gcc -v  gcc - - version(更简单一些)查看版本</p><!-- basicblock-end --><h1 id="3-动态库的制作和使用"><a class="markdownIt-Anchor" href="#3-动态库的制作和使用"></a> 3 动态库的制作和使用</h1><!-- basicblock-start oid="ObsZUJVLyxBfLjjfWsXLTl7Y" --> <p>动态库的命名规则::</p><p><strong><a href="http://libxxx.so">libxxx.so</a></strong></p><blockquote><p>lib : 前缀(固定)</p><p>xxx : 库的名字，自己起</p><p>.so : 后缀(固定), 静态库是.a 后缀</p><p>在Linux下是一个可执行文件</p></blockquote><!-- basicblock-end --><!-- basicblock-start oid="ObsVFwW5lvWwpfTmpiTBcQSa" --> <h2 id="31-动态库的制作"><a class="markdownIt-Anchor" href="#31-动态库的制作"></a> 3.1 动态库的制作::</h2><ol><li>gcc 得到 .o 文件，得到和位置无关的代码</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -c –fpic/-fPIC a.c b.c <br><span class="hljs-comment">// -fpic/-fPIC 位置无关, a.c b.c: .c 文件</span><br><span class="hljs-comment">// 单独 gcc -c 是制作.o 文件, 但是与位置有关                 </span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>gcc 得到动态库</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -shared a.o b.o -o libcalc.so<br></code></pre></td></tr></tbody></table></figure><p>[[1.10 - 1.12 makefile#^a51e57]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsMyJ0Wxxext7hatQD3jNuN"  deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.4-1.6  静态库和动态库.md" --> <p>动态库制作实操::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// tree 目录</span><br>.<br>├── calc<br>│&nbsp;&nbsp; ├── add.c<br>│&nbsp;&nbsp; ├── div.c<br>│&nbsp;&nbsp; ├── head.h<br>│&nbsp;&nbsp; ├── main.c<br>│&nbsp;&nbsp; ├── mult.c<br>│&nbsp;&nbsp; └── sub.c<br>└── library<br>    ├── include<br>    │&nbsp;&nbsp; └── head.h<br>    ├── lib<br>    ├── main.c<br>    └── src<br>        ├── add.c<br>        ├── div.c<br>        ├── mult.c<br>        └── sub.c<br></code></pre></td></tr></tbody></table></figure><p>进入到 calc 文件夹下用 .c 文件制作动态库，gcc 得到 .o 文件，得到和位置无关的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -c -fpic add.c div.c mult.c sub.c -I ../include <br><span class="hljs-comment">// ../表示上两层</span><br></code></pre></td></tr></tbody></table></figure><p>gcc 得到动态库：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -shared add.o div.o mult.o sub.o -o libcalc.so<br></code></pre></td></tr></tbody></table></figure><p>ll 查看文件，可以看到 <a href="http://libcalc.so">libcalc.so</a> 是<strong>可执行文件</strong>：<br>库文件是绿色的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ll<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209071610754.png" alt=""></p><h2 id="32-动态库使用"><a class="markdownIt-Anchor" href="#32-动态库使用"></a> 3.2 动态库使用::</h2><!-- basicblock-start oid="ObsMyJ0Wxxext7hatQD3jNuN"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"-->  ^8oo3nd<p>复制文件::<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209071614735.png" alt="|300"></p><p>将动态库 <a href="http://libcalc.so">libcalc.so</a> 复制到 lib 文件下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"> cp libcalc.so ../lib -r<br><span class="hljs-comment">// 因为是目录所以要加上 -r参数让它递归的拷贝</span><br><span class="hljs-comment">// Eg：cp calc library ../lesson06 -r(拷贝calc 和library 到上一级的lesson06 目录)</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>使用动态库，编译生成 main 文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc main.c -o main -I ./include/ -L ./lib -l calc<br></code></pre></td></tr></tbody></table></figure><p><code>-I</code> 为搜索 <code>head.h</code> 所在目录，<code>-L</code> 为搜索库所在目录，<code>-l</code> 为所使用到的库的名称。</p><p>执行 main 文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./main<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209071616365.png" alt="|800"></p><p>出现错误，找不到动态库文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./main: error <span class="hljs-keyword">while</span> loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory<br></code></pre></td></tr></tbody></table></figure><ul><li>&amp; 我没出现错误</li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsbtJlyghK3mR35Dr14SNqp" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.4-1.6  静态库和动态库.md" --> <p>#历史记录::<br>2022/09/06🌵1.4-1.6  静态库和动态库<br>2022/09/07🌵复习了静态库的制作和使用,[[1.4-1.6  静态库和动态库#^6nlece]]⏱0-8<br>2022/09/07🌵学习了动态库的制作和使用⏱0-41</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12. 平衡二叉树</title>
      <link href="/posts/19617/"/>
      <url>/posts/19617/</url>
      
        <content type="html"><![CDATA[<h1 id="1-110平衡二叉树"><a class="markdownIt-Anchor" href="#1-110平衡二叉树"></a> 1 110.平衡二叉树</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">力扣题目 链接</a></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点&nbsp;的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><p><img src="https://img-blog.csdnimg.cn/2021020315542230.png" alt="110.平衡二叉树"></p><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><p><img src="https://img-blog.csdnimg.cn/20210203155447919.png" alt="110.平衡二叉树1"></p><p>返回 false 。</p><!-- basicblock-start oid="Obs9XIZAfxIaaCbt7ZqAAAaV" --> <p>怎么去思考递归::<br>![[12. 平衡二叉树 2022-09-07 10.08.26.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsXx4zwKtRu8v4JBaNAXu2B" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>后序遍历<br>分别求出其左右子树的高度，<br>差值小于等于1，则返回当前二叉树的高度，<br>否则则返回-1，表示已经不是二叉平衡树了。</p><!-- basicblock-end --><h2 id="21-代码"><a class="markdownIt-Anchor" href="#21-代码"></a> 2.1 代码</h2><p>v1: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span></span>{<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span>(leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 💡此处不是判断最底层的节点, 而是返回后上一层的节点</span><br>        <span class="hljs-type">int</span> rightHeitht = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeitht) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeitht); <span class="hljs-comment">// 返回上一层</span><br>    }<br><br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeight</span>(root) == <span class="hljs-number">-1</span> ? <span class="hljs-literal">false</span> :&nbsp;<span class="hljs-literal">true</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2: 官方题解, 更容易理解</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">height</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">height</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span> || rightHeight == <span class="hljs-number">-1</span> || <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) { <span class="hljs-comment">// ❗️必须要有前两个判断条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root) &gt;= <span class="hljs-number">0</span>;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>![[12. 平衡二叉树 2022-09-11 22.58.07.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsA2gNDFyw1C2sz4lz9tiDA" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::12. 平衡二叉树.md" --> <p>#历史记录::<br>2022/09/06🌵12. 平衡二叉树 : 思路简单, 代码易懂⏱0-26<br>2022/09/11🌵12. 平衡二叉树 : 细节还是有的, <strong>不能漏了剪枝</strong>, 想了一大会⏱0-31</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1-1.2 GCC</title>
      <link href="/posts/11990/"/>
      <url>/posts/11990/</url>
      
        <content type="html"><![CDATA[<h1 id="1-gcc"><a class="markdownIt-Anchor" href="#1-gcc"></a> 1 GCC</h1><h2 id="11-gcc-与-g-的区别"><a class="markdownIt-Anchor" href="#11-gcc-与-g-的区别"></a> 1.1 GCC 与 G++ 的区别</h2><p>gcc 和 g++都是GNU(组织)的一个编译器。</p><pre><code class="hljs">**gcc与g++都能编译c/c++文件，只是gcc不能自动和c++程序的库进行，因此可以使用gcc编译g++链接，也可以直接额全用g++**</code></pre><ul><li>&amp; <strong>全额使用g++就行</strong></li></ul><p><strong>误区一</strong>:gcc 只能编译 c 代码，g++ 只能编译 c++ 代码。两者都可以，请注意：</p><ul><li>后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序。</li><li>后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些。</li><li>编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统 一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只 能用 g++ 似的。</li></ul><p><strong>误区二</strong>：gcc 不会定义 __cplusplus 宏，而 g++ 会</p><ul><li>实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释。</li><li>如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义。</li></ul><p><strong>误区三</strong>：编译只能用 gcc，链接只能用 g++</p><ul><li>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++。</li><li>gcc 命令不能自动和C<ins>程序使用的库联接，所以通常使用 g</ins> 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价。</li></ul><table><thead><tr><th>gcc 编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>预处理指定的源文件，不进行编译</td></tr><tr><td>-S</td><td>编译指定的源文件，但是不进行汇编</td></tr><tr><td>-c</td><td>编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td>-o [file1] [file2] / [file2] -o [file1]</td><td>将文件 file2 编译成可执行文件 file1</td></tr><tr><td>-I directory</td><td>指定 include 包含文件的搜索目录</td></tr><tr><td>-g</td><td>在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td>-D</td><td>在程序编译的时候，指定一个宏</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-wall</td><td>生成所有警告信息</td></tr><tr><td>-On</td><td>n的取值范围:0~3。编译器的优化选项的4个级别，-O0表 示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td>-l</td><td>在程序编译的时候，指定使用的库</td></tr><tr><td>-L</td><td>指定编译的时候，搜索的库的路径</td></tr><tr><td>-fPIC/fpic</td><td>生成与位置无关的代码</td></tr><tr><td>-shared</td><td>生成共享目标文件，通常用在建立共享库时</td></tr><tr><td>-std</td><td>指定 c 方言，如：-std=c99，gcc默认的方言是GNU C</td></tr></tbody></table><!-- basicblock-start oid="Obsl8nA1rjcL45Ssgeq34bT8" --> <h2 id="12-gcc-的编译过程"><a class="markdownIt-Anchor" href="#12-gcc-的编译过程"></a> 1.2 GCC 的编译过程::</h2><p>![[1.1-1.2 GCC 2022-09-06 20.50.17.excalidraw]]<br>先进入程序所在目录，然后使用该命令编译: <code>g++ test.cpp -o app</code> :</p><blockquote><p>test.cpp 是文件, app是自己起的名字</p></blockquote><p>用这个形式:  <mark><strong><code>g++ -o&nbsp; app test.cpp</code></strong></mark></p><p><code>./app</code>：执行编译的结果</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsoyz9ehuc6HUjArGzt7ODx" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.1-1.2 GCC.md" --> <p>#历史记录::<br>2022/9/5🌵1.1-1.2 GCC : 编译的过程是重点</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>总笔记</title>
      <link href="/posts/4280/"/>
      <url>/posts/4280/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文件io"><a class="markdownIt-Anchor" href="#1-文件io"></a> 1 文件IO</h1><p><a href="%E8%AF%BE%E4%BB%B6/1.17%20%E6%96%87%E4%BB%B6IO.pdf">1.17 文件IO</a></p><h2 id="11-标准c库io函数和linux系统io函数对比"><a class="markdownIt-Anchor" href="#11-标准c库io函数和linux系统io函数对比"></a> 1.1 标准C库IO函数和Linux系统IO函数对比</h2><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174357.png" alt="image-20220328130316589"></p><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174406.png" alt="image-20220328130330587"></p><h2 id="12-虚拟地址空间"><a class="markdownIt-Anchor" href="#12-虚拟地址空间"></a> 1.2 虚拟地址空间</h2><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174413.png" alt="image-20220328130352951"></p><p>程序和进程的区别：</p><p>程序是可执行文件，可执行文件只占用磁盘的空间，不占用内存空间。</p><p>当程序运行起来后，操作系统会为程序的启动或运行分配一些资源，这时候操作系统就会创建一个进程，进程就是为程序运行所分配资源的东西。</p><p>进程就是正在运行的程序，进程占用内存空间，一个程序启动以后，会生成一个虚拟地址空间，虚拟地址空间会通过 CPU 当中的 MMU 逻辑管理单元把虚拟地址空间中的数据映射到物理内存中去。</p><h2 id="13-13文件描述符"><a class="markdownIt-Anchor" href="#13-13文件描述符"></a> 1.3 1.3[[文件描述符]]</h2><h2 id="14-linux系统io函数"><a class="markdownIt-Anchor" href="#14-linux系统io函数"></a> 1.4 Linux系统IO函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="141-open函数"><a class="markdownIt-Anchor" href="#141-open函数"></a> 1.4.1 [[open函数]]</h3><h3 id="142-read函数和write函数"><a class="markdownIt-Anchor" href="#142-read函数和write函数"></a> 1.4.2 [[read函数和write函数]]</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">1.4</span><span class="hljs-number">.3</span> lseek函数<br><br>查看说明文档<br><br></code></pre></td></tr></tbody></table></figure><p>man 2 lseek<br>man 3 fseek</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>```c<br><span class="hljs-comment">// 标准C库的函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><br><span class="hljs-comment">// Linux系统函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br>- 参数：<br>      - fd: 文件描述符，通过 open 得到的，通过这个 fd 操作某个文件<br>        - offset: 偏移量<br>        - whence: <br>SEEK_SET<br>              设置文件指针的偏移量<br>            SEEK_CUR<br>              设置偏移量：当前位置 + 第二个参数 offset 的值<br>            SEEK_END<br>              设置偏移量：文件大小 + 第二个参数 offset 的值<br>- 返回值：返回文件指针的位置<br>              <br>作用：<br><span class="hljs-number">1.</span> 移动文件指针到头文件<br>    <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_SET);<br><span class="hljs-number">2.</span> 获取当前文件指针的位置<br>    <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_CUR);<br><span class="hljs-number">3.</span> 获取文件的长度<br>   <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_END);<br><span class="hljs-number">4.</span> 拓展文件的长度，当前文件 <span class="hljs-number">10b</span>，<span class="hljs-number">110b</span>，增加了 <span class="hljs-number">100</span> 个字节<br>    <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">100</span>, SEEK_END);<br></code></pre></td></tr></tbody></table></figure><p>拓展文件长度：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lseek.c</span><br><span class="hljs-comment">// 原 hello.txt 为 12 字节，拓展了 100 个字节，写入了 1 个空数据，最后为 113 字节大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 打开文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"hello.txt"</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">//拓展文件</span><br>    <span class="hljs-type">int</span> ret = lseek(fd, <span class="hljs-number">100</span>, SEEK_END);   <span class="hljs-comment">// 从文件末尾开始拓展 100 字节</span><br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"lseek"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 写入一个空数据</span><br>    write(fd, <span class="hljs-string">" "</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么要写入空数据？</p><p>lseek()不是扩展数据的功能，只是可以利用lseek()去扩展文件，lseek()只是单纯的移动文件指针偏移。而写入数据后才能扩展数据大小，显示出字节数。</p><p>拓展文件有什么实际用途？</p><p>在下载文件时，先按照文件大小拓展出来，然后再慢慢往里面下载，以防磁盘空间不足。</p><h3 id="143-stat函数和lstat函数"><a class="markdownIt-Anchor" href="#143-stat函数和lstat函数"></a> 1.4.3 stat函数和lstat函数</h3><p>查看说明文档</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> stat<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br>作用：获取一个文件相关的一些信息<br>    参数：<br>      - pathname：操作的文件的路径<br>        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span> ，设置 errno<br><span class="hljs-type">int</span> <span class="hljs-title function_">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br>作用：获取软链接文件相关的一些信息<br>    参数：<br>      - pathname：操作的文件的路径<br>        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span> ，设置 errno<br></code></pre></td></tr></tbody></table></figure><p>在 Linux 中也有一个命令 stat ，通过它可以查看一个文件的信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> a.txt<br></code></pre></td></tr></tbody></table></figure><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">  文件："a.txt"<br>  大小：13        块：8          IO 块：4096   普通文件<br>设备：fd01h/64769dInode：658603      硬链接：1<br>权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)<br>最近访问：2022<span class="hljs-string">-04</span><span class="hljs-string">-03</span> 16:07:04.823402070 <span class="hljs-string">+0800</span><br>最近更改：2022<span class="hljs-string">-04</span><span class="hljs-string">-03</span> 16:07:04.823402070 <span class="hljs-string">+0800</span><br>最近改动：2022<span class="hljs-string">-04</span><span class="hljs-string">-03</span> 16:07:04.826402123 <span class="hljs-string">+0800</span><br>创建时间：-<br></code></pre></td></tr></tbody></table></figure><p>stat结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> {</span><br><span class="hljs-type">dev_t</span>st_dev;<span class="hljs-comment">// 文件的设备编号</span><br>    <span class="hljs-type">ino_t</span>st_ino;<span class="hljs-comment">// 节点</span><br><span class="hljs-type">mode_t</span>st_mode;<span class="hljs-comment">// 文件的类型和存取的权限</span><br><span class="hljs-type">nlink_t</span>st_nlink;<span class="hljs-comment">// 连到该文件的硬连接数目</span><br>    <span class="hljs-type">uid_t</span>st_uid;<span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-type">gid_t</span>st_gid;<span class="hljs-comment">// 组ID</span><br>    <span class="hljs-type">dev_t</span>st_rdev;<span class="hljs-comment">// 设备文件的设备编号</span><br>    <span class="hljs-type">off_t</span>st_size;<span class="hljs-comment">// 文件字节数(文件大小)</span><br>    <span class="hljs-type">blksize_t</span>st_blksize;<span class="hljs-comment">// 块大小</span><br>    <span class="hljs-type">blkcnt_t</span> st_blocks;<span class="hljs-comment">// 块数</span><br>    <span class="hljs-type">time_t</span> st_atime;<span class="hljs-comment">// 最后一次访问时间</span><br>    <span class="hljs-type">time_t</span> st_mtime;<span class="hljs-comment">// 最后一次修改时间</span><br>    <span class="hljs-type">time_t</span>st_ctime;<span class="hljs-comment">// 最后一次改变时间(指属性)</span><br> };<br></code></pre></td></tr></tbody></table></figure><p>st_mode变量</p><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174524.png" alt="image-20220403162503909"></p><p>获取 a.txt 的信息，返回大小</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">statbuf</span>;</span><br>    <span class="hljs-type">int</span> ret = stat(<span class="hljs-string">"a.txt"</span>, &amp;statbuf);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"stat"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"size: %ld\n"</span>, statbuf.st_size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>创建软链接</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ln -s <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">b</span>.txt<br></code></pre></td></tr></tbody></table></figure><p>创建出软链接 b.txt ，指向了 a.txt</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lrwxrwxrwx</span> <span class="hljs-number">1</span> root root    <span class="hljs-number">5</span> Apr  <span class="hljs-number">3</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span> b.txt -&gt; a.txt<br></code></pre></td></tr></tbody></table></figure><p>用 <code>stat b.txt</code> 查看信息</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">File</span>: ‘b.txt’ -&gt; ‘a.txt’<br>  <span class="hljs-attribute">Size</span>: <span class="hljs-number">5</span>               Blocks: <span class="hljs-number">0</span>          IO Block: <span class="hljs-number">4096</span>   symbolic link<br><span class="hljs-attribute">Device</span>: fd01h/<span class="hljs-number">64769</span>d    Inode: <span class="hljs-number">658601</span>      Links: <span class="hljs-number">1</span><br><span class="hljs-attribute">Access</span>: (<span class="hljs-number">0777</span>/lrwxrwxrwx)  Uid: (    <span class="hljs-number">0</span>/    root)   Gid: (    <span class="hljs-number">0</span>/    root)<br><span class="hljs-attribute">Access</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">03</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">44</span>.<span class="hljs-number">509931636</span> +<span class="hljs-number">0800</span><br><span class="hljs-attribute">Modify</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">03</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">44</span>.<span class="hljs-number">412929931</span> +<span class="hljs-number">0800</span><br><span class="hljs-attribute">Change</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">03</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">44</span>.<span class="hljs-number">412929931</span> +<span class="hljs-number">0800</span><br> <span class="hljs-attribute">Birth</span>: -<br></code></pre></td></tr></tbody></table></figure><p>用 <code>stat</code> 获取软链接文件的信息，其实获取的是软链接 b.txt 指向的 a.txt 的信息，如果要获取 软链接 b.txt 的信息就要用 <code>lstat</code> 。</p><h3 id="144-模拟实现-ls-l-命令"><a class="markdownIt-Anchor" href="#144-模拟实现-ls-l-命令"></a> 1.4.4 模拟实现 ls -l 命令</h3><p>模拟实现 ls-l 命令的程序代码：</p><p><a href="https://github.com/huyup1e2n3g/WebServer/blob/main/code/lesson1.25/ls-l.c">ls-l.c</a></p><h3 id="145-文件属性操作函数"><a class="markdownIt-Anchor" href="#145-文件属性操作函数"></a> 1.4.5 文件属性操作函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断文件的权限或判断文件是否存在</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>;<br><span class="hljs-comment">// 修改文件的权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> mode)</span>;<br><span class="hljs-comment">// 修改文件的所有者或者所在组</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span>;<br><span class="hljs-comment">// 缩减或扩展文件的大小</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>;<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> access<br><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> chmod<br><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> chown<br><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> truncate<br></code></pre></td></tr></tbody></table></figure><h4 id="1451-access函数"><a class="markdownIt-Anchor" href="#1451-access函数"></a> 1.4.5.1 access函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>;<br>作用：判断某个文件是否有某个权限，或者判断文件是否存在<br>    参数：<br>      - pathname：判断的文件路径<br>      - mode：<br>      R_OK: 判断是否有读权限<br>        W_OK: 判断是否有写权限<br>        X_OK: 判断是否有执行权限<br>        F_OK: 判断文件是否存在<br>返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// access.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">"a.txt"</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"access"</span>);<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"文件存在\n"</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="1452-chmod函数"><a class="markdownIt-Anchor" href="#1452-chmod函数"></a> 1.4.5.2 chmod函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span>;<br>作用：修改文件的权限<br>    参数：<br>      - pathname: 需要修改的文件的路径<br>      - <span class="hljs-type">mode_t</span>: 需要修改的权限值，八进制的数<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span><br>        <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// chmod.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>  <span class="hljs-comment">// 修改文件权限</span><br>    <span class="hljs-type">int</span> ret = chmod(<span class="hljs-string">"a.txt"</span>, <span class="hljs-number">0775</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"chmod"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>修改前：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-r--r--<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 14 </span>Apr <span class="hljs-number"> 4 </span>15:52 a.txt<br></code></pre></td></tr></tbody></table></figure><p>修改后：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rwxrwxr-x<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 14 </span>Apr <span class="hljs-number"> 4 </span>15:52 a.txt<br></code></pre></td></tr></tbody></table></figure><h4 id="1453-truncate函数"><a class="markdownIt-Anchor" href="#1453-truncate函数"></a> 1.4.5.3 truncate函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>;<br>作用：缩减或扩展文件的尺寸至指定的大小<br>    参数：<br>      - path: 需要修改的文件的路径<br>      - length: 需要最终文件变成的大小<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// truncate.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 扩大文件大小</span><br>    <span class="hljs-type">int</span> ret = truncate(<span class="hljs-string">"b.txt"</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"truncate"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>扩展前：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-r--r--<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 13 </span>Apr <span class="hljs-number"> 4 </span>16:03 b.txt<br></code></pre></td></tr></tbody></table></figure><p>扩展后：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-r--r--<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 20 </span>Apr <span class="hljs-number"> 4 </span>16:03 b.txt<br></code></pre></td></tr></tbody></table></figure><h3 id="146-目录操作函数"><a class="markdownIt-Anchor" href="#146-目录操作函数"></a> 1.4.6 目录操作函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">// 删除空目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br><span class="hljs-comment">// 重命名目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>; <br><span class="hljs-comment">// 更改当前的目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><span class="hljs-comment">// 获取当前的路径</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档</p><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">man</span> 2 <span class="hljs-keyword">mkdir</span><br></code></pre></td></tr></tbody></table></figure><h4 id="1461-mkdir函数"><a class="markdownIt-Anchor" href="#1461-mkdir函数"></a> 1.4.6.1 mkdir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br>作用：创建一个目录<br>    参数：<br>      - pathname: 创建的目录的路径<br>      - mode: 权限，八进制的数<br>    返回值：<br>    成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span>   <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// mkdir.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 创建一个 aaa 目录</span><br>    <span class="hljs-type">int</span> ret = mkdir(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"mkdir"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>生成 aaa 目录：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">drwxr</span>-xr-x <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> Apr  <span class="hljs-number">4</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span> aaa<br></code></pre></td></tr></tbody></table></figure><h4 id="1462-rename函数"><a class="markdownIt-Anchor" href="#1462-rename函数"></a> 1.4.6.2 rename函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// rename.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 将 aaa 目录改名为 bbb</span><br>    <span class="hljs-type">int</span> ret = rename(<span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"rename"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="1463-chdir函数"><a class="markdownIt-Anchor" href="#1463-chdir函数"></a> 1.4.6.3 chdir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br>作用：修改进程的工作目录<br>    比如在 /home/nowcoder 启动了一个可执行程序 a.out ，进程的工作目录就是 /home/nowcoder<br>    参数：<br>      - path: 需要修改的工作目录<br></code></pre></td></tr></tbody></table></figure><h4 id="1464-getcwd函数"><a class="markdownIt-Anchor" href="#1464-getcwd函数"></a> 1.4.6.4 getcwd函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br>作用：获取当前工作目录<br>    参数：<br>      - buf: 存储的路径，指向的是一个数组（传出参数）<br>      - size: 数组的大小<br>    返回值：<br>      返回的指向的一块内存，这个数据就是第一个参数<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// chdir.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 获取当前的工作目录</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    getcwd(buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当前的工作目录是：%s\n"</span>, buf);<br><br>    <span class="hljs-comment">// 修改工作目录</span><br>    <span class="hljs-type">int</span> ret = chdir(<span class="hljs-string">"/root/Linux/lesson1.27/bbb"</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"chdir"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 创建一个新的文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"chdir.txt"</span>, O_CREAT | O_RDWR, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 关闭文件</span><br>    close(fd);<br><br>    <span class="hljs-comment">// 获取当前的工作目录</span><br>    <span class="hljs-type">char</span> buf1[<span class="hljs-number">128</span>];<br>    getcwd(buf1, <span class="hljs-keyword">sizeof</span>(buf1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当前的工作目录是：%s\n"</span>, buf1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="147-目录遍历函数"><a class="markdownIt-Anchor" href="#147-目录遍历函数"></a> 1.4.7 目录遍历函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 打开目录</span><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">// 读取目录里的内容</span><br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br><span class="hljs-comment">// 关闭目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">3</span> opendir<br></code></pre></td></tr></tbody></table></figure><h4 id="1471-opendir函数"><a class="markdownIt-Anchor" href="#1471-opendir函数"></a> 1.4.7.1 opendir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br>参数：<br>      - name: 需要打开的目录的名称<br>    返回值：<br>      DIR * 类型，理解为目录流<br>      错误返回 <span class="hljs-literal">NULL</span><br></code></pre></td></tr></tbody></table></figure><h4 id="1472-readdir函数"><a class="markdownIt-Anchor" href="#1472-readdir函数"></a> 1.4.7.2 readdir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br>作用：读取目录中的数据‘<br>    参数：dirp 是 opendir 返回的结果<br>    返回值：<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> 代表读取到的文件的信息</span><br><span class="hljs-class">        读取到了末尾或者失败了，返回<span class="hljs-title">NULL</span></span><br></code></pre></td></tr></tbody></table></figure><p>dirent 结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> {</span><br>  <span class="hljs-comment">// 此目录进入点的inode</span><br><span class="hljs-type">ino_t</span>d_ino;       <span class="hljs-comment">/* inode number */</span><br>    <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>  <span class="hljs-type">off_t</span>   d_off;       <span class="hljs-comment">/* not an offset; see NOTES */</span><br>    <span class="hljs-comment">// d_name 的长度，不包含 NULL 字符</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> d_reclen;    <span class="hljs-comment">/* length of this record */</span><br>    <span class="hljs-comment">// d_name 所指的文件类型</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>  d_type;      <span class="hljs-comment">/* type of file; not supported by all file system types */</span><br>    <span class="hljs-comment">// 文件名</span><br>  <span class="hljs-type">char</span>d_name[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* filename */</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>d_type</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">DT_BLK      This is <span class="hljs-keyword">a</span> block device.块设备<br>DT_CHR      This is <span class="hljs-keyword">a</span> <span class="hljs-keyword">character</span> device.字符设备<br>DT_DIR      This is <span class="hljs-keyword">a</span> <span class="hljs-built_in">directory</span>.目录<br>DT_FIFO     This is <span class="hljs-keyword">a</span> named pipe (FIFO).软连接<br>DT_LNK      This is <span class="hljs-keyword">a</span> symbolic link.管道<br>DT_REG      This is <span class="hljs-keyword">a</span> regular <span class="hljs-built_in">file</span>.件<br>DT_SOCK     This is <span class="hljs-keyword">a</span> UNIX domain <span class="hljs-built_in">socket</span>.套普通文接字<br>DT_UNKNOWN  The <span class="hljs-built_in">file</span> type is unknown.未知<br></code></pre></td></tr></tbody></table></figure><h4 id="1473-closedir函数"><a class="markdownIt-Anchor" href="#1473-closedir函数"></a> 1.4.7.3 closedir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br>作用：关闭目录<br></code></pre></td></tr></tbody></table></figure><p>遍历目录下文件数量程序代码：</p><p><a href="https://github.com/huyup1e2n3g/WebServer/blob/main/code/lesson1.28/readFileNum.c">readFileNum.c</a></p><h3 id="148-dup-dup2-函数"><a class="markdownIt-Anchor" href="#148-dup-dup2-函数"></a> 1.4.8 dup、dup2 函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 复制文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>; <br><span class="hljs-comment">// 重定向文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>; <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>;<br>作用：复制一个新的文件描述符<br>    fd = <span class="hljs-number">3</span>, <span class="hljs-type">int</span> fd1 = dup(fd);<br>fd 指向的是 a.txt，fd1 也是指向 a.txt<br>    从空闲的文件描述符中找一个最小的，作为新的拷贝的文件描述符<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br>  作用：重定向文件描述符<br>    oldfd 指向 a.txt, newfd 指向 b.txt<br>    调用函数成功后：newfd 和 b.txt 做 close, newfd 指向了 a.txt<br>    oldfd 必须是一个有效的文件描述符<br>    oldfd 和 newfd 值相同，相当于什么都没有做<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dup.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"a.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-type">int</span> fd1 = dup(fd);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"dup"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd : %d , fd1 : %d\n"</span>, fd, fd1);<br>    close(fd);<br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">"hello,world"</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"write"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    close(fd1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dup2.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"1.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">"2.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd : %d, fd1 : %d\n"</span>, fd, fd1);<br>    <span class="hljs-type">int</span> fd2 = dup2(fd, fd1);<br>    <span class="hljs-keyword">if</span>(fd2 == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"dup2"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">"hello, dup2"</span>;<br>    <span class="hljs-type">int</span> len = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"write"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd : %d, fd1 : %d, fd2 : %d\n"</span>, fd, fd1, fd2);<br><br>    close(fd);<br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="149-fcntl-函数"><a class="markdownIt-Anchor" href="#149-fcntl-函数"></a> 1.4.9 fcntl 函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>; <br><span class="hljs-comment">// 复制文件描述符</span><br><span class="hljs-comment">// 设置/获取文件的状态标志</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>;<br>    参数：<br>        fd : 表示需要操作的文件描述符<br>        cmd: 表示对文件描述符进行如何操作<br>            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）<br>                <span class="hljs-type">int</span> ret = fcntl(fd, F_DUPFD);<br><br>            - F_GETFL : 获取指定的文件描述符文件状态flag<br>              获取的flag和我们通过open函数传递的flag是一个东西。<br><br>            - F_SETFL : 设置文件描述符文件状态flag<br>              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改<br>              可选性：O_APPEND, O)NONBLOCK<br>                O_APPEND 表示追加数据<br>                NONBLOK 设置成非阻塞<br>        <br>        阻塞和非阻塞：描述的是函数调用的行为。<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fcntl.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.复制文件描述符</span><br>    <span class="hljs-comment">// int fd = open("1.txt", O_RDONLY);</span><br>    <span class="hljs-comment">// int ret = fcntl(fd, F_DUPFD);</span><br><br>    <span class="hljs-comment">// 2.修改或者获取文件状态flag</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"1.txt"</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取文件描述符状态flag</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"fcntl"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    flag |= O_APPEND;   <span class="hljs-comment">// flag = flag | O_APPEND</span><br><br>    <span class="hljs-comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span><br>    <span class="hljs-type">int</span> ret = fcntl(fd, F_SETFL, flag);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"fcntl"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">"nihao"</span>;<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 1 Linux系统编程入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.完全二叉树的节点个数</title>
      <link href="/posts/32913/"/>
      <url>/posts/32913/</url>
      
        <content type="html"><![CDATA[<h1 id="1-222完全二叉树的节点个数"><a class="markdownIt-Anchor" href="#1-222完全二叉树的节点个数"></a> 1 222.完全二叉树的节点个数</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">力扣题目链接</a></p><p>给出一个完全二叉树，求出该树的节点个数。</p><p>示例 1：</p><ul><li>输入：root = [1,2,3,4,5,6]</li><li>输出：6</li></ul><p>示例 2：</p><ul><li>输入：root = []</li><li>输出：0</li></ul><p>示例 3：</p><ul><li>输入：root = [1]</li><li>输出：1</li></ul><p>提示：</p><ul><li>树中节点的数目范围是[0, 5 * 10^4]</li><li>0 &lt;= Node.val &lt;= 5 * 10^4</li><li>题目数据保证输入的树是 完全二叉树</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本篇给出按照普通二叉树的求法以及利用完全二叉树性质的求法。</p><h2 id="21-普通二叉树的解法"><a class="markdownIt-Anchor" href="#21-普通二叉树的解法"></a> 2.1 普通二叉树的解法</h2><p>后序遍历(左右中): 到了最下层 “左右” 后返回 0, 到了"中"时 返回  1 + 左 +<br>右, 然后不断的向上递归返回<br>递归解法</p><!-- basicblock-start oid="ObsOXRInsha0Vue1rp2L1jJl" --> <p>后序遍历, 最后有个 return 操作是怎么回事::<br>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">countNodes</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> count = left + right + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> count; <span class="hljs-comment">// 💡每得到一个节点的 count 值都会返回一次.不断更新处理到最后一个节点</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftcount = <span class="hljs-built_in">countNodes</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightcount = <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> nodecount = leftcount + rightcount + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> nodecount;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>迭代解法</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>只要模板少做改动，加一个变量result，统计节点数量就可以了<br>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                result++;   <span class="hljs-comment">// 每弹出一个节点就记录一下, 这样全都记录了</span><br>                <br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> nodeCount = <span class="hljs-number">0</span>;<span class="hljs-comment">// ❗️需要放到 while 函数外边, 放到里边用完就销毁了</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br><br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                nodeCount++;<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br><br>        }<br>        <span class="hljs-keyword">return</span> nodeCount;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-完全二叉树的解法"><a class="markdownIt-Anchor" href="#22-完全二叉树的解法"></a> 2.2 完全二叉树的解法</h2><p>![[1. 二叉树理论基础#1 2 完全二叉树]]</p><p>整体思路是:<br>先得到每个节点下所的完全二叉树个数,  返回上一层: “左 + 右 + 1”<br>然后不断重复此过程, 直至返回到根节点, 就得到了所有的节点个数</p><p>完全二叉树的节点情况分两种情况: 1. 满二叉树, 2. 非满二叉树</p><ol><li>节点下边是满二叉树可以直接用:  2^树深度 - 1 , 得到该个数.</li><li>非满二叉树, 一直向下递归找满二叉树, 最差找到叶子节点呗, 得到个数.</li><li>上一层的个数是 “左 + 右 + 1”</li></ol><p>v1 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>,  rightDepth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left){<br>            left = left-&gt;left;<br>            leftDepth++;<br>        }<br>        <span class="hljs-keyword">while</span>(right){<br>            right = right-&gt;right;<br>            rightDepth++;<br>        }<br>        <span class="hljs-keyword">if</span>(rightDepth == leftDepth){<br>            <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0, 如果初始化为 1 的话就多了个幂次</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span> ;<span class="hljs-comment">// 求得了一个满二叉树的节点个数</span><br>        }<br>        <span class="hljs-comment">// 该节点下边子树不是满二叉树, 继续递归查找</span><br>        <span class="hljs-comment">// ❓不是很懂</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<span class="hljs-comment">// 返回结果到上一层</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsulZddtgbSOiRG5o1XM7mj" --> <p><code>2&lt;&lt;leftDepth</code> 是什么意思::<br>// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0, 如果初始化为 1 的话就多了个幂次<br><code>2&lt;&lt;leftDepth</code>: 如果 leftDepth = 1 → 2^2, 所以如果想要 2 ^leftDepth, 和 leftDepth 保持一直, 就要初始化为 0<br>例子是上边代码</p><!-- basicblock-end --><p>v2,通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 获取左右子树的长度</span><br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left){<br>            left = left-&gt;left;<br>            leftDepth++;<br>        }<br>        <span class="hljs-keyword">while</span>(right){<br>            right = right-&gt;right;<br>            rightDepth++;<br>        }<br>        <span class="hljs-keyword">if</span>(rightDepth == leftDepth){<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-comment">// 如果不是满二叉树, 递归寻找下两个节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(log n × log n)</li><li>空间复杂度：O(log n)</li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsxAwKJskKRlGQCpHXaufXe" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::11.完全二叉树的节点个数.md" --> <p>#历史记录::<br>2022/09/06🌵11.完全二叉树的节点个数 : 普通解法很简单, 完全二叉树解法还不太懂.⏱1-10<br>2022/09/08🌵三种解法都写了一遍 ,前两个解法很熟练了, 完全二叉树解法最后一步需要背一下⏱0-28</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 .二叉树的最小深度</title>
      <link href="/posts/11176/"/>
      <url>/posts/11176/</url>
      
        <content type="html"><![CDATA[<h1 id="1-111二叉树的最小深度"><a class="markdownIt-Anchor" href="#1-111二叉树的最小深度"></a> 1 111.二叉树的最小深度</h1><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从<strong>根节点到最近叶子节点的最短路径上的节点数量。</strong></p><p>说明:&nbsp;叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树&nbsp;[3,9,20,null,null,15,7],</p><p><img src="https://img-blog.csdnimg.cn/2021020315582586.png" alt="111.二叉树的最小深度1"></p><p>返回它的最小深度 2.</p><!-- basicblock-start oid="ObsxAijR3dtBDY0TsdiJIFbj" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>![[10 .二叉树的最小深度 2022-09-04 21.13.57.excalidraw]]</p><!-- basicblock-end --><h2 id="21-代码"><a class="markdownIt-Anchor" href="#21-代码"></a> 2.1 代码</h2><p><strong>二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2022/9/4🌵10 .二叉树的最小深度,处理好左子树或者右子树为空的情况就行, 看代码备注</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span></span>{<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;left); <span class="hljs-comment">//   左</span><br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;right);<span class="hljs-comment">//  右</span><br>        <span class="hljs-comment">// 取到了节点的两个孩子的信息,                  中</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth; <span class="hljs-comment">// 这里返回的是上一层</span><br>        }<br>        <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth;<span class="hljs-comment">// 这里返回的是上一层</span><br>        }<br>        <span class="hljs-comment">// 下面是两个孩子为空, 或者两个孩子都不为空的情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(leftDepth, rightDepth) ;<span class="hljs-comment">// 这里返回的是上一层</span><br><br>        <br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYPyAApLHAakFE2OSvWxJR" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::10 .二叉树的最小深度.md" --> <p>#历史记录::<br>2022/9/4🌵10 .二叉树的最小深度,处理好左子树或者右子树为空的情况就行, 看代码备注⏱1.38<br>2022/09/05🌵: v2, ⏱0-12</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 二叉树的最大深度</title>
      <link href="/posts/25077/"/>
      <url>/posts/25077/</url>
      
        <content type="html"><![CDATA[<h1 id="1-104二叉树的最大深度"><a class="markdownIt-Anchor" href="#1-104二叉树的最大深度"></a> 1 104.二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p><p>返回它的最大深度 3</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-层序遍历"><a class="markdownIt-Anchor" href="#21-层序遍历"></a> 2.1 层序遍历</h2><p>[[5. 二叉树的层序遍历#3 9 104 二叉树的最大深度]]</p><h2 id="22-递归遍历"><a class="markdownIt-Anchor" href="#22-递归遍历"></a> 2.2 递归遍历</h2><!-- basicblock-start oid="Obs9EZaNm8XMZm0YfjfeCoze" --> <p>二叉树的高度和深度::<br>![[9. 二叉树的最大深度 2022-09-04 19.59.06.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObswhABnljcw5OZTk71GpUMW" --> <p>思路::<br>用后序遍历求最大深度, 左中右, 先获取到左右孩子的高度, 那么父节点就是" 1 + max(左右孩子高度) ", 然后逐层返回父节点</p><!-- basicblock-end -->                    <!-- basicblock-start oid="ObsSO8HawpB9c1etxyG3uioF" --> <h3 id="221-代码"><a class="markdownIt-Anchor" href="#221-代码"></a> 2.2.1 代码::</h3><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(treenode* node)</span> </span>{<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 💡因为最后一层的孩子是 NULL, 高度为 0</span><br>        <span class="hljs-type">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);       <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);     <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth); <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> depth;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(root);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftDepth, rightDepth);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="3-拓展题目"><a class="markdownIt-Anchor" href="#3-拓展题目"></a> 3 拓展题目</h1><h2 id="31-559n叉树的最大深度"><a class="markdownIt-Anchor" href="#31-559n叉树的最大深度"></a> 3.1 559.n叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">力扣题目链接</a></p><p>给定一个 n 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 3叉树 :我们应返回其最大深度，3。<br><img src="https://img-blog.csdnimg.cn/2021020315313214.png" alt="559.n叉树的最大深度"></p><!-- basicblock-start oid="ObsFKYfVGEDD0vDqi8Zr81qG" --> <p>N叉树最大深度思路::</p><pre><code class="hljs">二叉树最大深度: 从最下层开始找到左右孩子的高度的最大值, 然后+1 返回给上一层. </code></pre><p>N叉树的最大深度：比较多个孩子的最大值, 然后"+1"返回给上一层</p><!-- basicblock-end --><!-- basicblock-start oid="ObsGWBYwdE46PteMIqVCwmaW" --> <p>如何操做 N叉树的所有孩子::<br>二叉树直接可以用 node-&gt;left, node-&gt;right. 因为只有两孩子. 所以好操作<br>N 叉树</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.size(); i++){ <span class="hljs-comment">// 遍历每个孩子</span><br>node-&gt;children[i] <span class="hljs-comment">// 具体操作每个一个孩子</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="ObstwUhG4JxAiSUAPVl4VIBS" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::9. 二叉树的最大深度.md" --> <h2 id="32-代码"><a class="markdownIt-Anchor" href="#32-代码"></a> 3.2 代码::</h2><!-- basicblock-end --><p>通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(Node* node)</span></span>{<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++){<br>            depth = <span class="hljs-built_in">max</span>(depth, <span class="hljs-built_in">getdepth</span>(node-&gt;children[i]));<br>        }<br>        <span class="hljs-keyword">return</span> depth+<span class="hljs-number">1</span>;<br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(root);<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObssIwbunz9uwD7YWpg3gxSl" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::9. 二叉树的最大深度.md" --> <p>#历史记录::<br>2022/09/04🌵9. 二叉树的最大深度, 用递归(后序遍历)实现, 获取最后一层的节点的高度, 然后"+1"逐层返回到上一层⏱0.68<br>2022/09/12🌵9. 二叉树的最大深度:  正常复习, 不难⏱0-20</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. 对称二叉树</title>
      <link href="/posts/32421/"/>
      <url>/posts/32421/</url>
      
        <content type="html"><![CDATA[<h1 id="1-对称二叉树"><a class="markdownIt-Anchor" href="#1-对称二叉树"></a> 1 对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">力扣题目链接</a></p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p><img src="https://img-blog.csdnimg.cn/20210203144607387.png" alt="101. 对称二叉树"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>什么类型的函数用后序遍历: 需要收集孩子信息向上一层返回  ^ui0nki</p><p>![[8. 对称二叉树 2022-09-04 16.04.53.excalidraw]]</p><p>为什么要采用后序遍历 ::<br>![[8. 对称二叉树 2022-09-04 16.26.21.excalidraw]]<br>[[前中后序的遍历的方式]]</p><!-- basicblock-start oid="ObsrxE8zGdPPk6MXPA8B1R5R" --> <h2 id="21-代码"><a class="markdownIt-Anchor" href="#21-代码"></a> 2.1 代码::</h2><!-- basicblock-end --><p>carl</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> {<br>        <span class="hljs-comment">// 首先排除空节点的情况</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 排除了空节点，再排除数值不相同的情况, 不然操作空指针了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-comment">// 💡同时遍历两个二叉树</span><br>        <span class="hljs-type">bool</span> outside = compare(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br>        <span class="hljs-type">bool</span> inside = compare(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中 （逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br><br>    }<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> {<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> compare(root-&gt;left, root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^4yh3i4</p><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>{<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);<br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);<br>        <span class="hljs-keyword">return</span> outside &amp;&amp; inside; <br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="3-100-相同的树"><a class="markdownIt-Anchor" href="#3-100-相同的树"></a> 3 100. 相同的树</h1><p><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a><br>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt=""></p><p>输入：p = [1,2,3], q = [1,2,3]<br>输出：true</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt=""></p><p>输入：p = [1,2], q = [1,null,2]<br>输出：false</p><!-- basicblock-start oid="ObsQFGnGMkgPOOGfz2GgeH7d" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::8. 对称二叉树.md" --> <h1 id="4-思路"><a class="markdownIt-Anchor" href="#4-思路"></a> 4 思路::</h1><!-- basicblock-end --><p>[[8. 对称二叉树]], 稍作修改即可<br>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* tree1, TreeNode* tree2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree1 != <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree1-&gt;val != tree2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 注意这里我没有使用else</span><br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-type">bool</span> compareLeft = <span class="hljs-built_in">compare</span>(tree1-&gt;left, tree2-&gt;left);       <span class="hljs-comment">// 左子树：左、 右子树：左</span><br>        <span class="hljs-type">bool</span> compareRight = <span class="hljs-built_in">compare</span>(tree1-&gt;right, tree2-&gt;right);    <span class="hljs-comment">// 左子树：右、 右子树：右</span><br>        <span class="hljs-type">bool</span> isSame = compareLeft &amp;&amp; compareRight;                  <span class="hljs-comment">// 左子树：中、 右子树：中（逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(p, q);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v1 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span> <span class="hljs-params">(TreeNode* tree1 , TreeNode* tree2)</span></span>{<br>        <span class="hljs-keyword">if</span>(tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree1 != <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// ❗️不要忘了两个都是空的情况, ❗️要在比较 val 值的上边, 不然下边操作空指针了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree1-&gt;val != tree2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><br>        <span class="hljs-type">bool</span> compareleft = <span class="hljs-built_in">compare</span>(tree1-&gt;left, tree2-&gt;left);<span class="hljs-comment">// 💡比较他俩相同位置的节点</span><br>        <span class="hljs-type">bool</span> compareright = <span class="hljs-built_in">compare</span>(tree1-&gt;right, tree2-&gt;right);<br>        <span class="hljs-type">bool</span> isSame = compareleft &amp;&amp; compareright;<br>        <span class="hljs-keyword">return</span> isSame;<span class="hljs-comment">// 💡每一个节点得到结果都返回一次 </span><br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(p ,q);<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsLIfxrLW7CkjIqMFGKnXBf" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::8. 对称二叉树.md" --> <p>#历史记录::<br>2022/09/03🌵8. 对称二叉树: 学习了同时遍历两个二叉树. ⏱1-12<br>2022/09/12🌵8. 对称二叉树:  有点忘了, 又复习一遍吧, 不算难⏱0-10</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 反转二叉树</title>
      <link href="/posts/42763/"/>
      <url>/posts/42763/</url>
      
        <content type="html"><![CDATA[<h1 id="1-226翻转二叉树"><a class="markdownIt-Anchor" href="#1-226翻转二叉树"></a> 1 226.翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/">力扣题目链接</a></p><p>翻转一棵二叉树。</p><p><img src="https://img-blog.csdnimg.cn/20210203192644329.png" alt="226.翻转二叉树|500"></p><p>这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObshhkVMOq4kC0ciGlKLWXHb" --> <h2 id="21-层序遍历广度优先遍历"><a class="markdownIt-Anchor" href="#21-层序遍历广度优先遍历"></a> 2.1 层序遍历(广度优先遍历)::</h2><p>[[5. 二叉树的层序遍历#2 思路]]</p><p>层序遍历的时候, 逐个弹出元素本层元素的同时, 在把弹出的元素左右孩子做一个交换<br>因为是从第一层开始的, 每一层的节点的左右孩子的都会被交换.</p><h3 id="211-代码"><a class="markdownIt-Anchor" href="#211-代码"></a> 2.1.1 代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="hljs-comment">// 弹出元素的同时, 在把该节点的左右孩子交换一下, 下边然后在加入</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obs1K0yTTEWvKbJJunPhh7NM" --> <h2 id="22-深度优先遍历"><a class="markdownIt-Anchor" href="#22-深度优先遍历"></a> 2.2 深度优先遍历::</h2><!-- basicblock-end --><!-- basicblock-start oid="ObsYblbWEkEb1kEuJd6f8n6R" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::6. 反转二叉树.md"--><ul><li>&amp; <strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong><br>![[6. 反转二叉树 2022-09-05 11.05.02.excalidraw]]</li></ul><!-- basicblock-end --><p><strong>前序遍历过程</strong></p><p>用前序或后序递归遍历, 到中间节点的时候, 把节点的左右孩子给交换一下. <mark>中</mark>左右: <mark>中</mark>其实是处理逻辑, 因为每个节点都会遍历到. 自然交换了所有节点的左右孩子.</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnakm26jtog30e409s4qp.gif" alt="翻转二叉树"></p><ul><li>!</li></ul><p>我们来看一下递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。</p><p>返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为<code>TreeNode*</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">TreeNode* <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode* root)</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>确定终止条件</li></ol><p>当前节点为空的时候，就返回</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>确定单层递归的逻辑</li></ol><p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">swap(root-&gt;left, root-&gt;right);<br>invertTree(root-&gt;left);<br>invertTree(root-&gt;right);<br></code></pre></td></tr></tbody></table></figure><p>基于这递归三步法，代码基本写完，C++代码如下：</p><h3 id="221-代码"><a class="markdownIt-Anchor" href="#221-代码"></a> 2.2.1 代码</h3><p>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);        <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invert</span> <span class="hljs-params">(TreeNode* node)</span></span>{ <span class="hljs-comment">// ❗️返回类型是 TreeNode*, 不是 void, 💡只是操作树, 不需要返回信息用 TreeNode*</span><br><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// ❓必须要 return node, 因为返回值是TreeNode 类型</span><br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-built_in">invert</span>(node-&gt;left);<br>        <span class="hljs-built_in">invert</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> node;  <span class="hljs-comment">// ❓这里不懂</span><br>    }<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">invert</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invert</span> <span class="hljs-params">(TreeNode* node)</span></span>{ <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// NULL 意思是空节点呗, ❓然后自动返回上一层</span><br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-built_in">invert</span>(node-&gt;left);<br>        <span class="hljs-built_in">invert</span>(node-&gt;right);<br>        <span class="hljs-comment">//函数返回时就表示当前这个节点，以及它的左右子树</span><br><span class="hljs-comment">//都已经交换完了, ❓然后就到上一层了?</span><br>        <span class="hljs-keyword">return</span> node;  <span class="hljs-comment">// 💡每个节点交换完都返回一次, 直至处理到最后一个节点</span><br>    }<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">invert</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v4, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode*  <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* node)</span></span>{<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span> ;<span class="hljs-comment">// ❗️返回值类型为 TreeNode* 的, 返回值是 node 或者 NULL</span><br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-built_in">invertTree</span>(node-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> node;<br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obsy1jpTtYeUXshW3JwWnfWQ" --> <p>返回值类型为 TreeNode* 时 ,应当 return 什么::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode*  <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* node)</span></span>{<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span> ;<span class="hljs-comment">// ❗️返回值类型为 TreeNode* 的, 返回值起码是 NULL, 普通的就是二叉树指针</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsqQ3qh1SYiiESPsf4ZuD01" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::6. 反转二叉树.md" --> <p>#历史记录::<br>2022/09/03🌵6. 反转二叉树: ⏱1.45<br>1. 用前序或后序递归遍历, 到中间节点的时候, 把节点的左右孩子给交换一下. <mark>中</mark>左右: <mark>中</mark>其实是处理逻辑, 因为每个节点都会遍历到. 自然交换了所有节点的左右孩子.<br>- &amp; 不能用中序遍历, 会导致左右两个孩子交换两次<br>2.  用层序遍历模板, 就是弹出本层元素的同时, 在把该节点的左右孩子互换一下即可<br>2022/09/05🌵6. 反转二叉树: 递归代码v3有疑问待解决 ⏱1-10<br>2022/09/07🌵6. 反转二叉树: anki 复习, v3 还是感觉有点迷糊, 可能动写一下代码就好一些<br>2022/09/07🌵6. 反转二叉树: v4, 进一步熟悉了, ⏱0-14</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 二叉树的层序遍历</title>
      <link href="/posts/11836/"/>
      <url>/posts/11836/</url>
      
        <content type="html"><![CDATA[<h1 id="1-102二叉树的层序遍历"><a class="markdownIt-Anchor" href="#1-102二叉树的层序遍历"></a> 1 102.二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">力扣题目链接</a></p><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><img src="https://img-blog.csdnimg.cn/20210203144842988.png" alt="102.二叉树的层序遍历"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><!-- basicblock-start oid="ObsgsmEX6qkHg62d5cXh9pUS" --> <p>广度优先遍历::<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif" alt="102二叉树的层序遍历"></p><ol><li>加入本层元素,</li><li>获取本层元素个数,</li><li>逐个弹出本层元素, 弹出的同时并把该节点的左右孩子加入进来, 直至弹完本层元素</li><li>反复2, 3, (用 while 包住2, 3)</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 加入第一层元素</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<span class="hljs-comment">// 结果集</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//  获取本层元素个数, </span><br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<span class="hljs-comment">// / ❗️不能放到 while 外边,每进行一次大while 都会重置 vec, 放到大 while 外边就一直往里添东西了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) { <span class="hljs-comment">// 逐个弹出本层元素, 并把每个弹出节点的左右孩子加入进来, 直至弹完本层元素</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<span class="hljs-comment">// for 循环出来后, que 中已经是下层元素了. 在进行一次 while 循环后会在获得这层元素, 反复如此, 直至队列为空</span><br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>其余的十个题</p><h2 id="31-102二叉树的层序遍历本题"><a class="markdownIt-Anchor" href="#31-102二叉树的层序遍历本题"></a> 3.1 102.二叉树的层序遍历(本题)</h2><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<span class="hljs-comment">// ❓不用 push "-&gt;val"吗, 💡需要-&gt;val</span><br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsWz1HABndPRea0MXtrAFi0" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="32-107二叉树的层次遍历ii"><a class="markdownIt-Anchor" href="#32-107二叉树的层次遍历ii"></a> 3.2 107.二叉树的层次遍历II::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">力扣题目链接</a><br>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><img src="https://img-blog.csdnimg.cn/20210203151058308.png" alt="107.二叉树的层次遍历II"></p><p>最后反转一下 result 数组即可</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 已通过</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>) que.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">// 💡que 是 push</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){ <span class="hljs-comment">// ❗️要有!, 是不为空的情况</span><br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// ❗️要加入, 别忘了</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp; <span class="hljs-comment">// ❗️不能放到 while 外边, 下边的 while 每用一次都要重置的, 放到大 while 外边就一直往里添东西了</span><br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right)que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsA2W3ZqyHLnpReggeqt34B" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="33-199二叉树的右视图"><a class="markdownIt-Anchor" href="#33-199二叉树的右视图"></a> 3.3 199.二叉树的右视图::</h2><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">力扣题目链接</a></p><!-- basicblock-end --><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><img src="https://img-blog.csdnimg.cn/20210203151307377.png" alt="199.二叉树的右视图"></p><p>思路：</p><p>层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 💡只需要一个元素, 就只是一维数组就行了</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == (size - <span class="hljs-number">1</span>)) result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 💡最后一个元素, 因为下标从 0 开始的</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">if</span>(i == size<span class="hljs-number">-1</span>) result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right)que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obsa7NpoMu4TG6L5hqHuQmvD" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="34-637二叉树的层平均值"><a class="markdownIt-Anchor" href="#34-637二叉树的层平均值"></a> 3.4 637.二叉树的层平均值::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">力扣题目链接</a><br>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p><img src="https://img-blog.csdnimg.cn/20210203151350500.png" alt="637.二叉树的层平均值"></p><p>思路:</p><p>本题就是层序遍历的时候把一层求个总和在取一个均值<br>已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        vector&lt;<span class="hljs-type">double</span>&gt; result;<span class="hljs-comment">// ❗️此时的 result 不是 int, 返回值是 double</span><br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">// ❗️返回值是 double 变量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                sum += node-&gt;val;<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(sum/size);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsuDmsEzy8x7UlnbeXhtogm" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="35-429n叉树的层序遍历"><a class="markdownIt-Anchor" href="#35-429n叉树的层序遍历"></a> 3.5 429.N叉树的层序遍历::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">力扣题目链接</a></p><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://img-blog.csdnimg.cn/20210203151439168.png" alt="429. N叉树的层序遍历|500"></p><p>返回其层序遍历:</p><p>[ [1], [3,2,4], [5,6] ]</p><p>思路:</p><p>这道题依旧是模板题，只不过一个节点有多个孩子了<br>把一个节点的所有孩子都加入队列里边就行了</p><!-- basicblock-start oid="ObsbS4edLzulGab31MsUvZ7Z" --> <p>将 n 叉树的所有节点加入到队列中::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 将节点所有孩子加入队列</span><br>              <span class="hljs-keyword">if</span> (node-&gt;children[i]) que.<span class="hljs-built_in">push</span>(node-&gt;children[i]);<span class="hljs-comment">// if(node-&gt;left)</span><br>          }<br></code></pre></td></tr></tbody></table></figure><p>多叉树的孩子用<code>-&gt;children</code>表示, 孩子个数用<code>-&gt;children.size()</code><br>平时是用-&gt;left ,-&gt;right</p><!-- basicblock-end --><p>已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(Node* root) {<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">while</span>(size--){<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++){<br>                    <span class="hljs-keyword">if</span>(node-&gt;children[i]) que.<span class="hljs-built_in">push</span>(node-&gt;children[i]);<br>                }<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(Node* root) {<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++){<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;children[i]); <span class="hljs-comment">// 💡这个更好 : if (node-&gt;children[i]) que.push(node-&gt;children[i]);</span><br>                }<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    }<br>};```<br><br><br><br><br>## <span class="hljs-number">3.6</span> <span class="hljs-number">515.</span>在每个树行中找最大值<br>[力扣题目链接](https:<span class="hljs-comment">//leetcode.cn/problems/find-largest-value-in-each-tree-row/)</span><br><br><br>您需要在二叉树的每一行中找到最大的值。<br><br>![<span class="hljs-number">515.</span>在每个树行中找最大值](https:<span class="hljs-comment">//img-blog.csdnimg.cn/20210203151532153.png)</span><br><br>思路：<br><br>层序遍历，取每一层的最大值<br><br><br><br>```c++<br><span class="hljs-keyword">class</span> Solution {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">largestValues</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> maxValue = INT_MIN;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                maxValue = node-&gt;val &gt; maxValue ? node-&gt;val : maxValue; <span class="hljs-comment">// 💡该层的每一个数都来比较</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(maxValue);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs4VpTv34hro3xfMo7mbyWl" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="36-116填充每个节点的下一个右侧节点指针"><a class="markdownIt-Anchor" href="#36-116填充每个节点的下一个右侧节点指针"></a> 3.6 116.填充每个节点的下一个右侧节点指针::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">力扣题目链接</a></p><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span><br>  <span class="hljs-type">int</span> val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br></code></pre></td></tr></tbody></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有&nbsp;next 指针都被设置为 NULL。</p><p><img src="https://img-blog.csdnimg.cn/20210203152044855.jpg" alt="116.填充每个节点的下一个右侧节点指针|600"><br>思路:<br>本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让记录节点的 next 指针指下一个节点就可以了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node* node = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首元素</span><br>que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 连接</span><br><span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) node-&gt;next = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时的 front 是之前的第二个</span><br></code></pre></td></tr></tbody></table></figure><p>❓那是怎么指向 null 的呢<br>💡初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code>。(题目说的), 本题中最右侧的节点的 next本来就指向 NULL</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/">力扣官方题解不错, 看第一种</a></p><h3 id="361-使用层次遍历"><a class="markdownIt-Anchor" href="#361-使用层次遍历"></a> 3.6.1 使用层次遍历</h3><p>没用代码随想录, 用力扣官方题解, 已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>{<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历这一层的所有节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                Node* node = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首元素</span><br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 连接</span><br>                <span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) node-&gt;next = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时的 front 是之前的第二个, 💡最后一个 node 的 next 本身就是指向 null</span><br>                <span class="hljs-comment">// 扩展下一层节点</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="362-使用已有的-next-指针"><a class="markdownIt-Anchor" href="#362-使用已有的-next-指针"></a> 3.6.2 使用已有的 next 指针</h3><p>暂时不做</p><!-- basicblock-start oid="ObsHHyGbzS6j99xXRZdsDUR2"  deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md"--> <h2 id="37-117填充每个节点的下一个右侧节点指针ii"><a class="markdownIt-Anchor" href="#37-117填充每个节点的下一个右侧节点指针ii"></a> 3.7 117.填充每个节点的下一个右侧节点指针II::</h2><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">力扣题目链接</a></p><!-- basicblock-end --><p>思路：</p><p>这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道<br>同我上边写的, 编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>{<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i &lt; size - <span class="hljs-number">1</span>) node-&gt;next = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 💡重点</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObslzGeoh1X4WX2aMKWO18Bd" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="38-104二叉树的最大深度"><a class="markdownIt-Anchor" href="#38-104二叉树的最大深度"></a> 3.8 104.二叉树的最大深度::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，<br><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度|600"></p><p>返回它的最大深度 3 。</p><p>最大的深度就是二叉树的层数, 在记录每一层size 的下边在记录层数. <strong>每次弹出完一层就+1</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>          <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>          depth++; <span class="hljs-comment">// 记录深度, for 循环出来就是弹完一层了 </span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) { <br>              TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>              que.<span class="hljs-built_in">pop</span>();<br>              <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>              <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>          }<br></code></pre></td></tr></tbody></table></figure><p>代码如下: 已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> depth;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsNTlSW223rhUXzpmYNUaGz" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="39-111二叉树的最小深度"><a class="markdownIt-Anchor" href="#39-111二叉树的最小深度"></a> 3.9 111.二叉树的最小深度::</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣题目链接</a></p><p>相对于 104.二叉树的最大深度 ，本题还也<strong>继续使用层序</strong>遍历的方式来解决，思路是一样的。<br>❓不是很懂, 💡画图解决了看下边</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) { <span class="hljs-comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br>    <span class="hljs-keyword">return</span> depth;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong><br>![[5. 二叉树的层序遍历 2022-09-05 22.47.29.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录遍历的层数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) { <span class="hljs-comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br>                    <span class="hljs-keyword">return</span> depth;<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> depth;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start --> <p>如何判断左右节点是否为空::</p><ol><li>不为空: <code>if(node-&gt;left) que.push(node-&gt;left</code>), ❓💡node-&gt;left 如果不是空, 会返回 1</li><li>为空:     <code>if (!node-&gt;left &amp;&amp; !node-&gt;right) return depth</code>, 💡同理</li></ol><!-- basicblock-end --><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsrJa0fCCW6D2bZN7WD0iw7" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <p>#历史记录::<br>2022/09/02: 5. <a href="http://xn--4kq24jzfy32af2chru20x4x9b.md">二叉树的层序遍历.md</a>: 思路挺简单的, 多练吧<br>2022/09/05: 比较顺利, 中间干了其他一些事, 所以时间长了, 下次把其余九道题, 单独做成文件 deck (2022/09/08 已做)⏱0-20<br>2022/09/12🌵5. <a href="http://xn--4kq24jzfy32af2chru20x4x9b.md">二叉树的层序遍历.md</a>:  复习, 跟着 anki 过了一遍, 很熟悉了 ⏱0-37</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 二叉树的统一迭代法</title>
      <link href="/posts/7027/"/>
      <url>/posts/7027/</url>
      
        <content type="html"><![CDATA[<p>前中后序遍历可以写出来一个统一的迭代法格式</p><p><strong>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif" alt="中序遍历迭代（统一写法）"><br>可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRm8eBdwkQAzFhq7vFhDhI" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::4. 二叉树的统一迭代法.md" --> <p>#历史记录::<br>2022/9/2: 4. <a href="http://xn--4gq1mwi06ozq3ahlgzjs6xpzg0b.md">二叉树的统一迭代法.md</a>, 第一次创建. 感觉不太好写, 不学这个, 只用递归法就行⏱0.3</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 二叉树的迭代遍历</title>
      <link href="/posts/8180/"/>
      <url>/posts/8180/</url>
      
        <content type="html"><![CDATA[<p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></p><!-- basicblock-start oid="ObsnXiRU0AMeO0AokNDOO4DN" --> <h1 id="1-前序遍历迭代法"><a class="markdownIt-Anchor" href="#1-前序遍历迭代法"></a> 1 前序遍历(迭代法)::</h1><p>先将根节点放入栈中<strong>后弹出</strong>，然后<strong>先加入右孩子</strong>入栈<strong>后弹出</strong>，<strong>后加入左孩子后弹出</strong>。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p>动画如下：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p><h2 id="11-代码"><a class="markdownIt-Anchor" href="#11-代码"></a> 1.1 代码</h2><p>carl: 这其实就是层序遍历嘛</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()){ <span class="hljs-comment">// 💡用层序遍历但不需要记录每层的个数,即不需要把每层的数据弹出</span><br>            TreeNode* node = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 💡que是 front();</span><br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 先加右孩子</span><br>            <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);   <span class="hljs-comment">// 在加左孩子</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>等等</p><!-- basicblock-end --><h1 id="2-中序遍历"><a class="markdownIt-Anchor" href="#2-中序遍历"></a> 2 中序遍历</h1><p>无法与上面的前序遍历通用</p><p>因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p><h1 id="3-后序遍历"><a class="markdownIt-Anchor" href="#3-后序遍历"></a> 3 后序遍历</h1><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序"></p><p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</strong></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsn0AKlkxnVHJ8jU2mSk6rW" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::3. 二叉树的迭代遍历.md" --> <p>#历史记录::<br>2022/09/02: 第一次创建. 感觉不重要, 没有太注重, 重点学习递归法⏱1.28<br>2022/09/05:&nbsp;层序遍历但不需要记录每层的个数, 也不用只把一层的数据弹出. 先只做了前序遍历⏱0-22</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac快捷键</title>
      <link href="/posts/20705/"/>
      <url>/posts/20705/</url>
      
        <content type="html"><![CDATA[<p>![[mac快捷键 2022-09-01 11.49.24.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs3RVbRUxTdUnQWdwOYiwy6" deck = "🚀技能::mac快捷键.md" --> <p>#历史记录::<br>2022/9/1: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT 演讲要点</title>
      <link href="/posts/60276/"/>
      <url>/posts/60276/</url>
      
        <content type="html"><![CDATA[<p>2022/08/31: 开题报告感悟::</p><ol><li>分章节页时做一个, 章节导图<ol><li>要有段落感</li><li>增加逻辑性</li></ol></li></ol><p>讲话时要语气随和放松,  这样显示的有自信感</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsN4HF5ARs0gPxNYhRgcokw" deck = "🚀技能::PPT 演讲要点.md" --> <p>#历史记录::<br>2022/8/31: 第一次创建, 开题报告</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整体实验流程</title>
      <link href="/posts/43974/"/>
      <url>/posts/43974/</url>
      
        <content type="html"><![CDATA[<ol><li>设置限位, 放入圆环</li><li>将工件和冲模润滑,  工件放入顶盖的中心孔洞中</li><li>顶盖上方先放垫块,  后放入冲模. 启动液压机下压</li><li>下压到限位停止, 用千斤顶将冲模起开并拿出</li><li>放入第二段冲模, 计算机压力值为 0 时停止.</li><li>取出二段冲模和底部圆棒, 打开顶盖取出圆盘</li></ol><p>工件在通道中被冲模下压后, 到达挤压部件处. 挤压块设计有倒角, 且整体通道直径比上部的通道小. 工件一部分会通过倒角侧向流动变成圆盘. 剩余部分会下压到挤压块通道成为圆棒.</p><p>考虑到冲模下压的过程中, 会跟材料产生粘结. 先用垫板放置冲模下方. 在液压机达到限位时, 方便用千斤顶将第一段冲模起开.<br>放入第二段冲模, 将圆棒压入底部. 后取出</p><p>问松青的问题</p><ol><li>润滑脂是什么:</li><li>液压机的速度: 1mm / s</li><li>通道的直径: 上通道是 10mm ,  挤压块是 6mm</li><li>挤压原理是什么, 为什么会侧向挤出就成了梯度材料 : 看俞宁和邹工的毕业论文</li><li></li></ol><p>![[整体实验流程 2022-08-30 20.06.31.excalidraw]]</p><h1 id="1-铜环的尺寸"><a class="markdownIt-Anchor" href="#1-铜环的尺寸"></a> 1 铜环的尺寸</h1><p>材料: 纯铜 ;<br>厚度: 2mm<br>制作铜环尺寸: 内径mm * 外径mm</p><table><thead><tr><th>内外径差 10</th><th>内外径差 12</th><th>内外径差 14</th></tr></thead><tbody><tr><td>22 * 32</td><td>22  *  34</td><td>22 * 36</td></tr><tr><td>24 * 34</td><td>24  * 36</td><td>24 * 38</td></tr><tr><td>26 * 36</td><td>26  * 38</td><td>26 * 40</td></tr><tr><td>28 * 38</td><td>28  * 40</td><td>28 * 42</td></tr><tr><td>30 * 40</td><td></td><td></td></tr></tbody></table><p>每种尺寸各做3 个</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsmA1UeJy3WYPadethDm7hz" deck = "👨🏻‍🎓科研::整体实验流程.md" --> <p>#历史记录::<br>2022/8/30: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 二叉树的递归遍历</title>
      <link href="/posts/64675/"/>
      <url>/posts/64675/</url>
      
        <content type="html"><![CDATA[<p>此时大家可以做一做leetcode上三道题目，分别是：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li></ul><!-- basicblock-start oid="Obsb25gx4GWeO7grQWjmEPTa" --> <h1 id="1-递归三部曲"><a class="markdownIt-Anchor" href="#1-递归三部曲"></a> 1 递归三部曲::</h1><ol><li><p><strong>确定递归函数的参数和返回值：</strong></p><ol><li>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，</li><li>并且还要明确每次递归的返回值是什么, 进而确定递归函数的返回类型。<br><strong>二叉树: 一般是传入一个根节点, 传入一个数组(用来放我们的结果)</strong><br>一般是 void, 因为我们把想要的结果都放到参数了</li></ol></li><li><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><!-- basicblock-end --><h1 id="2-前序遍历的递归写法"><a class="markdownIt-Anchor" href="#2-前序遍历的递归写法"></a> 2 前序遍历的递归写法</h1><ol><li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br></code></pre></td></tr></tbody></table></figure><p>完整代码<br>前序遍历：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：</p><p>[[前中后序的遍历的方式]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Traversal</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span>{ <span class="hljs-comment">// ❗️必须是引用类型才能持续添加</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 直接返回上一层</span><br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// ❗️push_back的是root-&gt;val, 而不是 root, root 是个指针</span><br>        <span class="hljs-built_in">Traversal</span>(root-&gt;left, vec); <span class="hljs-comment">// ❗️函数有两个参数, 不要只传一个</span><br>        <span class="hljs-built_in">Traversal</span>(root-&gt;right, vec);<br><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">Traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYYhSQUKMhGa1ZN3yNUWcg" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::2. 二叉树的递归遍历.md" --> <p>#历史记录::<br>2022/08/29: 第一次创建<br>2022/09/05: v2, ⏱0-20</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前中后序的遍历的方式</title>
      <link href="/posts/59941/"/>
      <url>/posts/59941/</url>
      
        <content type="html"><![CDATA[<p>前中后序指的就是中间节点的位置</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>![[前中后序的遍历的方式 2022-08-29 16.44.58.excalidraw]]</p><h1 id="1-后序遍历"><a class="markdownIt-Anchor" href="#1-后序遍历"></a> 1 后序遍历</h1><p>![[8. 对称二叉树#^ui0nki]]</p><h1 id="2-其他"><a class="markdownIt-Anchor" href="#2-其他"></a> 2 其他</h1><!-- basicblock-start oid="ObstNNjBlLJYieagw6RMA4WP" --> <p>同时遍历两个二叉树::<br>![[8. 对称二叉树#^4yh3i4]] ^4c6589</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsAAU5EsbLCKVvoebIdwqiw" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::前中后序的遍历的方式.md" --> <p>#历史记录::<br>2022/08/29: 第一次创建<br>2022/09/12: anki 复习</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 二叉树理论基础</title>
      <link href="/posts/33244/"/>
      <url>/posts/33244/</url>
      
        <content type="html"><![CDATA[<h1 id="1-二叉树的种类"><a class="markdownIt-Anchor" href="#1-二叉树的种类"></a> 1 二叉树的种类</h1><p>在我们解题过程中二叉树有两种主要的形式：<strong>满二叉树和完全二叉树。</strong></p><!-- basicblock-start oid="ObskteVaQKFKXP6YheO3U5di" --> <h2 id="11-满二叉树"><a class="markdownIt-Anchor" href="#11-满二叉树"></a> 1.1 满二叉树::</h2><p>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><ul><li>&amp;  度: 节点孩子的个数<br><img src="https://img-blog.csdnimg.cn/20200806185805576.png" alt="|500"></li></ul><!-- basicblock-end --><!-- basicblock-start oid="ObsNzJMUsBYRGzsjCpabCitj" --> <h2 id="12-完全二叉树"><a class="markdownIt-Anchor" href="#12-完全二叉树"></a> 1.2 完全二叉树::</h2><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~&nbsp;2^(h-1) &nbsp;个节点.<br>![[1. 二叉树理论基础 2022-08-29 16.10.03.excalidraw]]<br><strong>之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong>[[小顶锥和大顶锥的原理]]  ^zkccuh</p><!-- basicblock-end --><!-- basicblock-start oid="Obs7bvG62xLqJrNcziFSYUW5" --> <h2 id="13-二叉搜索树"><a class="markdownIt-Anchor" href="#13-二叉搜索树"></a> 1.3 二叉搜索树::</h2><p>![[二叉搜索树]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsVtHzP3EQQzapSwfu2jGuz" --> <h2 id="14-平衡二叉搜索树"><a class="markdownIt-Anchor" href="#14-平衡二叉搜索树"></a> 1.4 平衡二叉搜索树::</h2><p>平衡二叉搜索树(红黑树)：又被称为AVL（Adelson-Velsky and&nbsp;Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>![[1. 二叉树理论基础 2022-08-29 16.19.19.excalidraw]]<br><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn ^bew6dm</p><blockquote><p>[[map]]</p></blockquote><!-- basicblock-end --><!-- basicblock-start oid="ObsQfaa14FMYHw83FWKOmdqh" --> <h1 id="2-二叉树的存储方式"><a class="markdownIt-Anchor" href="#2-二叉树的存储方式"></a> 2 二叉树的存储方式 ::</h1><!-- basicblock-end --><p>链式存储方式就用指针， 顺序存储的方式就是用数组。</p><h2 id="21-链式存储"><a class="markdownIt-Anchor" href="#21-链式存储"></a> 2.1 链式存储</h2><p><img src="https://img-blog.csdnimg.cn/2020092019554618.png" alt="|600"></p><h2 id="22-顺序存储"><a class="markdownIt-Anchor" href="#22-顺序存储"></a> 2.2 顺序存储</h2><p>![[1. 二叉树理论基础 2022-08-29 16.31.41.excalidraw]]</p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p><!-- basicblock-start oid="ObsNYOEsmvwlhRsRWieqgHEk" --> <h1 id="3-二叉树的遍历方式"><a class="markdownIt-Anchor" href="#3-二叉树的遍历方式"></a> 3 二叉树的遍历方式::</h1><p>二叉树主要有两种遍历方式：</p><h2 id="31-深度优先遍历先往深走遇到叶子节点再往回走"><a class="markdownIt-Anchor" href="#31-深度优先遍历先往深走遇到叶子节点再往回走"></a> 3.1 深度优先遍历：先往深走，遇到叶子节点再往回走。</h2><ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul><p>[[前中后序的遍历的方式]]</p><h2 id="32-广度优先遍历一层一层的去遍历"><a class="markdownIt-Anchor" href="#32-广度优先遍历一层一层的去遍历"></a> 3.2 广度优先遍历：一层一层的去遍历。</h2><ul><li>层次遍历(迭代法)</li></ul><!-- basicblock-end --><!-- basicblock-start oid="ObsmI7M2pZvBxBxvtlaAwJ7h" --> <h1 id="4-遍历的实现方式"><a class="markdownIt-Anchor" href="#4-遍历的实现方式"></a> 4 遍历的实现方式::</h1><ol><li>深度优先遍历: 优先向下查找, 在返回上一层<br>实现前中后序的遍历都是用的深度优先遍历</li></ol><ul><li>&amp; <strong>栈其实就是递归的一种是实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</li></ul><ol start="2"><li>广度优先遍历: 从左至右的一层层来遍历二叉树<br>用队列<br>由队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树</li></ol><!-- basicblock-end --><!-- basicblock-start oid="Obset5wB2iODDSEmmzMV7TFz" --> <h1 id="5-二叉树的定义"><a class="markdownIt-Anchor" href="#5-二叉树的定义"></a> 5 二叉树的定义::</h1><p>链式存储的二叉树节点的定义方式。<br>C++代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> {<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) {}<br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>{</span><br><span class="hljs-type">int</span> val;<br>TreeNode* left;<br>TreeNode* right;<br>TreeNode(<span class="hljs-type">int</span> x) : val(x), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) {}<br>}<br></code></pre></td></tr></tbody></table></figure><p>大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p><p>这里要提醒大家要注意二叉树节点定义的书写方式。</p><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsL85uzhm7rdY1Odw8fGakA" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::1. 二叉树理论基础.md" --> <p>#历史记录::<br>2022/8/29: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识星球</title>
      <link href="/posts/7468/"/>
      <url>/posts/7468/</url>
      
        <content type="html"><![CDATA[<p>卡哥，我想问一下，在面试的时候，面试官问我平时都是怎么学习知识的？这个该怎么回答才合适呢？我一般是这样回答的：主要通过哔哩哔哩，哔哩哔哩上有很多不错的讲解视频，还通过一些书籍等等，然后做项目，在项目中巩固。 因为我是非科班，面试被问好几次了，我也不知道怎么回答才能让面试官满意，还麻烦卡哥指点一下😁。然后还想问科班的同学，你们也会遇到这种提问吗::</p><p>通过 哔哩哔哩 其实体现不出你的自学能力。 而且这种学习速度太慢。 书都是 一门技术成熟好多年了，才会有书，那如果是新技术怎么办。<br>面试官可能换个方式问你，一个项目要立刻开发了，项目使用了你不会的编程语言，要求你快速上手，你怎么做？</p><p>你要是说 去看B站看视频学，那项目可能都凉了。 你可以说：<strong>学习编程语言，应用框架直接看官网，写demo直接github找项目， 遇到不懂的 去查 StackOverflow</strong>。</p><p>这些回答 逼格就比较高，但面试官可能 会进一步说让你 举一个你这么学哪种技术的例子，如果你没有这样的学习经历，很容易翻车。 所以可以适当 参考我的说法，但结合一下自己情况，就怕面试官往深问让你举个例子。</p><ul><li><blockquote><p>评论</p></blockquote></li></ul><ol><li>臻昊：然后说每天都会去看一些博客文章，了解一些新技术，然后去官网详细学习一下</li><li>Forget：原来大佬的学习方法是这样的，直接看官网！以后往这方面靠近<img src="https://wx.zsxq.com/dweb2/assets/images/emoji/expression_31.png" alt="" title="奋斗"></li></ol><!-- basicblock-end --> <!-- basicblock-start oid="Obs0jwYkHQBec0yQg8HnKf61" --> <p>面试时怎么反问::</p><p><strong>技术面反问：</strong></p><ol><li>项目组技术方向，技术栈都有哪些，团队分工。</li><li>例如自己表现的如何，后序学习建议，一般 来说不要问了，面试官也不会说但有的面试官还真会给你点建议，这个分人。</li></ol><p><strong>HR反问：</strong></p><ol><li>部门业务方向，加班情况（也表明一下 自己对加班一点都不反感，可以疯狂加班），</li><li>然后再说说和 技术面面试官聊得很好，夸一夸技术面试官技术很强，部门技术氛围好。</li></ol><p>剩下的也没啥了，不用那么纠结，就了解一下部门情况就可以了，这都不是最重要的环节。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209010911960.png" alt="|300"></p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsTS0Bw4p8DFvUebm4u07um" deck = "👨🏻‍💻code::0突发奇想::知识星球.md" --> <p>#历史记录::<br>2022/8/29: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 0突发奇想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识星球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小顶锥和大顶锥的原理</title>
      <link href="/posts/20437/"/>
      <url>/posts/20437/</url>
      
        <content type="html"><![CDATA[<h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1 原理</h1><p>小顶锥和大顶锥的原理<br>两个顶锥本质是由完全二叉树结构储存的<br>小顶锥: 父节点 比 两个子节点都小,  <strong>每次弹出父节点</strong><code>(数值小的)</code><br>大顶锥: 父节点 比 两个子节点都大,  <strong>每次弹出父节点</strong><code>(数值大的)</code></p><blockquote><p>大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），</p></blockquote><p>用 priority_queue 实现大小顶锥,从小到大排就是小顶堆，从大到小排就是大顶堆。</p><blockquote><p>底层实现都是一样的，<br>![[1. 二叉树理论基础#^zkccuh]]</p></blockquote><!-- basicblock-start oid="ObsF6VU6LIvMaliQq6chN6am" --> <p>为什么左 &gt; 右就会建立小顶堆，左 &lt; 右建立大顶堆 ? ::</p><p>我们在写快排的cmp函数的时候，<code>return left&gt;right</code> 是从大到小，<code>return left&lt;right</code> 是从小到大。</p><p>优先级队列的定义正好反过来了，可能和优先级队列的源码实现有关（我没有仔细研究），我估计是底层实现上优先队列队首指向后面，队尾指向最前面的缘故！</p><!-- basicblock-end --><h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码</h1><p>用 map 结构定义小顶锥</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span>{ <span class="hljs-comment">// 左 &gt; 右 是小顶锥, 与平时的感觉相反</span><br>      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>{<br>          <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>      }<br>  };<br><br><span class="hljs-comment">// 💡定义小顶锥</span><br>  priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br></code></pre></td></tr></tbody></table></figure><p>获取元素<br>获取大小顶锥的首元素的key: <code>pri_que.top().first;</code></p><p>函数<br>pop(),<br>push(), 可用指针指向 map元素, push(* it)</p><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsV80wGc56rec03HFVDqEHK" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::小顶锥和大顶锥的原理.md" --> <p>#历史记录<br>::<br>2022/08/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 栈与队列总结</title>
      <link href="/posts/41579/"/>
      <url>/posts/41579/</url>
      
        <content type="html"><![CDATA[<p>测试一下</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyFLyz0FAcU76F13ryLCZD" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::9. 栈与队列总结.md" --> <p>#历史记录::<br>2022/08/23: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8. 前K个高频元素</title>
      <link href="/posts/40341/"/>
      <url>/posts/40341/</url>
      
        <content type="html"><![CDATA[<h1 id="1-347前-k-个高频元素"><a class="markdownIt-Anchor" href="#1-347前-k-个高频元素"></a> 1 347.前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">力扣题目链接</a></p><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><ul><li>输入: nums = [1,1,1,2,2,3], k = 2</li><li>输出: [1,2]</li></ul><p>示例 2:</p><ul><li>输入: nums = [1], k = 1</li><li>输出: [1]</li></ul><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>将元素存入 map 结构, 得到元素的频率</li><li>用小顶锥结构求出前K个高频元素<ol><li>将所有频率将入到堆中，如果堆的大小大于K了，就将元素从堆顶弹出(<code>每次弹出的是数值小的, 也就是频率低的)</code></li></ol></li><li>倒序输出小顶锥的元素<br>![[8. 前K个高频元素 2022-08-23 18.30.49.excalidraw]]</li></ol><h2 id="21-小顶锥和大顶锥的原理"><a class="markdownIt-Anchor" href="#21-小顶锥和大顶锥的原理"></a> 2.1 ![[小顶锥和大顶锥的原理]]</h2><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// v1, 对着抄, 熟悉函数 ,未通过</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span>{ <span class="hljs-comment">// 左 &gt; 右 是小顶锥, 与平时的感觉相反</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>{<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        }<br>    };<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>{<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            map[nums[i]]++;<br>        }<br>        <span class="hljs-comment">/*for(int a : nums){</span><br><span class="hljs-comment">            map[a]++;</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 💡定义小顶锥</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-comment">// for 循环的一种</span><br>        <span class="hljs-keyword">for</span>(unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; :: iterator it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++){<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k){<br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            }<br>        }<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsSq7XuI4azCAHBSWexq7Y5" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::8. 前K个高频元素.md" --> <p>#历史记录 ::<br>8. 前K个高频元素: 完成思路部分, 期间干了其他事⏱1.73👨🏻‍💻2022/08/23<br>2022/08/24: 完成代码部分,添加了很多函数知识: ⏱0.63</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 滑动窗口最大值</title>
      <link href="/posts/22934/"/>
      <url>/posts/22934/</url>
      
        <content type="html"><![CDATA[<h1 id="1-滑动窗口最大值"><a class="markdownIt-Anchor" href="#1-滑动窗口最大值"></a> 1 滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">力扣题目链接</a></p><p>给定一个数组 nums，有一个大小为&nbsp;k&nbsp;的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k&nbsp;个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt=""></p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^4&nbsp;&lt;= nums[i]&nbsp;&lt;= 10^4</li><li>1 &lt;= k&nbsp;&lt;= nums.length</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>设计一个单调队列 :  每次只维护窗口中的最大值</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li><li>getMaxValue: 每次获取滑动窗口的最大值, 即队头元素</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><p>为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsxJKt98XgV1tsTlwG6NK7X" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::7. 滑动窗口最大值.md" --> <p>#历史记录 ::<br>7. 滑动窗口最大值: 抄代码的. ⏱1.38👨🏻‍💻2022/08/23</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.逆波兰表达式求值</title>
      <link href="/posts/18516/"/>
      <url>/posts/18516/</url>
      
        <content type="html"><![CDATA[<h1 id="1-逆波兰表达式求值"><a class="markdownIt-Anchor" href="#1-逆波兰表达式求值"></a> 1 逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接</a></p><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括&nbsp;+ ,&nbsp; - ,&nbsp; * ,&nbsp; /&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例&nbsp;1：</p><ul><li>输入: [“2”, “1”, “+”, “3”, " * "]</li><li>输出: 9</li><li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li></ul><p>示例&nbsp;2：</p><ul><li>输入: [“4”, “13”, “5”, “/”, “+”]</li><li>输出: 6</li><li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li></ul><p>示例&nbsp;3：</p><ul><li><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, " * ", “/”, " * ", “17”, “+”, “5”, “+”]</p></li><li><p>输出: 22</p></li><li><p>解释:该算式转化为常见的中缀算术表达式为：</p><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">((10 * (6 / ((9 <span class="hljs-code">+ 3) * -11))) +</span> 17) + 5       <br><span class="hljs-section">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="hljs-section">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="hljs-section">= ((10 * 0) + 17) + 5     </span><br><span class="hljs-section">= (0 + 17) + 5    </span><br><span class="hljs-section">= 17 + 5    </span><br><span class="hljs-section">= 22    </span><br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。</strong><br>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * )</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：<strong>遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</strong></li></ul><ol><li>遇到数字则入栈</li><li>遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"><br>类似于之前的相邻字符串的消除, 只不过本题不要相邻元素做消除了，而是做运算！</p><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsBriKG6hJEoGFTNObFlWSv" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::6.逆波兰表达式求值.md" --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 删除字符串中的所有相邻重复项</title>
      <link href="/posts/15/"/>
      <url>/posts/15/</url>
      
        <content type="html"><![CDATA[<blockquote><p>匹配问题都是栈的强项</p></blockquote><h1 id="1-删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#1-删除字符串中的所有相邻重复项"></a> 1 删除字符串中的所有相邻重复项</h1><p>给出由小写字母组成的字符串&nbsp;S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：“abbaca”</li><li>输出：“ca”</li><li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 仅由小写英文字母组成。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>把字符串顺序放到一个栈中</li><li>相同则弹出</li><li>弹出最后的元素, 在反转一下(因为最后从栈里弹出的元素是倒序)</li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>{<br>        stack&lt;<span class="hljs-type">char</span>&gt; st; <span class="hljs-comment">// ❗️类型可不是一成不变的 int </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s){<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != c){<br>                st.<span class="hljs-built_in">push</span>(c);<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                st.<span class="hljs-built_in">pop</span>();<br>            }<br>        }<br>        <span class="hljs-comment">// ❗️下边写错了</span><br>        <span class="hljs-comment">/*for(int i = 0; i &lt; s.size(); i++){</span><br><span class="hljs-comment">            st.push(s[i]);</span><br><span class="hljs-comment">            if(st.top() == s[i+1]) st.pop();</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">        */</span><br>      <br>        <span class="hljs-type">int</span> len = st.<span class="hljs-built_in">size</span>();<br>        string result ;<br>        <span class="hljs-keyword">while</span>(len--){<br>            result.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());<br>            st.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsXXSNkbbFnCYjGBWHvHhA9" deck= "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::5. 删除字符串中的所有相邻重复项.md" --> <p>#历史记录 ::<br>2022/08/24: 添加deck 数组</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录总结</title>
      <link href="/posts/38592/"/>
      <url>/posts/38592/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dataview">table  tags, date<br><br>from #数组 or #链表 or #哈希表 or #字符串 or #双指针 or #栈与队列 <br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsBcF8Pw6LGxPVA6UjqEWPx" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::总结.md" --> <p>#历史记录 ::<br>2022/08/24: 第一次修改</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 有效的括号</title>
      <link href="/posts/48343/"/>
      <url>/posts/48343/</url>
      
        <content type="html"><![CDATA[<h1 id="1-有效的括号"><a class="markdownIt-Anchor" href="#1-有效的括号"></a> 1 有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接</a></p><p>给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’&nbsp;的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>示例 1:</p><ul><li>输入: “()”</li><li>输出: true</li></ul><p>示例&nbsp;2:</p><ul><li>输入: “()[]{}”</li><li>输出: true</li></ul><p>示例&nbsp;3:</p><ul><li>输入: “(]”</li><li>输出: false</li></ul><p>示例&nbsp;4:</p><ul><li>输入: “([)]”</li><li>输出: false</li></ul><p>示例&nbsp;5:</p><ul><li>输入: “{[]}”</li><li>输出: true</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li><p>在创建一个栈用来放 右括号</p></li><li><p>创建的栈与原来的栈比较右括号</p></li><li><p>先分析不匹配的情况</p><ol><li>左括号多余导致不匹配</li><li>括号没有多余, 但括号类型不匹配</li><li>右括号多余导致不匹配</li></ol><ul><li><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号|500"></li></ul></li></ol><p>[vs](file:///Users/yibeikongqiu/Desktop/Documents/code/代码随想录/栈与队列/4. 有效的括号.cpp)</p><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsXQ4Otf7c3MKoVHKXI4l2D" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::4. 有效的括号.md" --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列总结</title>
      <link href="/posts/18350/"/>
      <url>/posts/18350/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dataview">table tags,date<br>from #栈与队列<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obszwi46x2QRmzvre0TvhxoC" --> <h1 id="1-队列与栈函数"><a class="markdownIt-Anchor" href="#1-队列与栈函数"></a> 1 队列与栈函数::</h1><p>按熟悉程度排序<br>栈也可以是这样的, que 换成 stack</p><p>定义队列: <code>queue&lt;int&gt; que;</code><br>que.front(): 返回队列的一个元素<br>que.back(): 返回队列的最后一个元素<br>que.push(x): 队头添加元素 ❓应该是队尾添加元素吧<br>que.pop(x): 队头元素弹出<br>que.size(): 返回队列的个数<br>que.empty(): 返回队列是否为空, 返回是 bool 值(true || false)</p><!-- basicblock-end --> #card<h1 id="2-注意"><a class="markdownIt-Anchor" href="#2-注意"></a> 2 注意</h1><p>每次要操作队列前要看是否为空, 不能操作空队列<br>eg: <code>if (!que.empty() &amp;&amp; value == que.front()) {</code></p><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsAGsuQf82L3Fyt8Q9k2z7Z" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::栈与队列总结.md"--> <p>#历史记录 ::<br>2022/08/24: 添加deck 数组</p><!-- basicblock-end --> <p>／</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>callout blocks</title>
      <link href="/posts/7909/"/>
      <url>/posts/7909/</url>
      
        <content type="html"><![CDATA[<p>Callout呼出框使用指南</p><p>注：请将本文稿粘贴到Obsidian后阅读</p><p>在Obsidian的0.14版本更新中，官方更新了一个叫“Callout Blocks”的功能。善用这个功能可以让我们把内容编写地更美观，也能在需要的地方给我们提供足够显眼的强调。</p><p>Callout Blocks的基本语法如下：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!类型] 标题</span><br><br><span class="hljs-quote">&gt; Hello world!</span><br><br><span class="hljs-quote">&gt; 正文</span><br><br><span class="hljs-quote">&gt; 正文<span class="hljs-strong">**依然支持Markdown语法和双链功能**</span></span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!INFO] 标题<br>Hello world!<br>正文<br>正文<strong>依然支持Markdown语法和双链功能</strong></p></blockquote><p>不难发现“Callout Blocks”本质上只是一个<code>&gt; 引用块</code>，并且由三部分组成——类型、标题和正文。</p><h1 id="1-callout-blocks的类型"><a class="markdownIt-Anchor" href="#1-callout-blocks的类型"></a> 1 Callout Blocks的类型</h1><p>Callout Blocks原生支持以下类型——</p><blockquote><p>[!note]</p></blockquote><blockquote><p>[!abstract]</p></blockquote><blockquote><p>[!info]</p></blockquote><blockquote><p>[!tip]</p></blockquote><blockquote><p>[!success]</p></blockquote><blockquote><p>[!question]</p></blockquote><blockquote><p>[!caution]</p></blockquote><blockquote><p>[!fail]</p></blockquote><blockquote><p>[!error]</p></blockquote><blockquote><p>[!bug]</p></blockquote><blockquote><p>[!example]-</p></blockquote><blockquote><p>[!quote]</p></blockquote><ul><li>question</li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-bullet">-</span> note<br><br><span class="hljs-bullet">-</span> abstract/summary/tldr<br><br><span class="hljs-bullet">-</span> info/todo<br><br><span class="hljs-bullet">-</span> tip/hint/important<br><br><span class="hljs-bullet">-</span> success/check/done<br><br><span class="hljs-bullet">-</span> question/help/faq<br><br><span class="hljs-bullet">-</span> warning/caution/attention<br><br><span class="hljs-bullet">-</span> failure/fail/missing<br><br><span class="hljs-bullet">-</span> danger/error<br><br><span class="hljs-bullet">-</span> bug<br><br><span class="hljs-bullet">-</span> example<br><br><span class="hljs-bullet">-</span> quote/cite<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!quote] 标题<br>正文<br>引言</p></blockquote><p>可以自定义新种类的Callout Blocks，但本文不做详细说明。</p><p>在创建Callout Block的时候，我们首先需要按照<code>&gt; 引用块</code>的Markdown格式，在文本编辑器中输入<code>&gt;</code>（<strong>注意别漏了空格</strong>），然后使用<code>[!类型]</code>的语法，在半角方括号中输入半角惊叹号，然后输入我们想要的类型，再空格，写标题。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Tip]</span><br><br><span class="hljs-quote">&gt; 你的大脑更擅长思考，而不是记忆。</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Tip]<br>你的大脑更擅长思考，而不是记忆。</p></blockquote><h1 id="2-callout-blocks的标题"><a class="markdownIt-Anchor" href="#2-callout-blocks的标题"></a> 2 Callout Blocks的标题</h1><p>在指定Callout Block的类型后，再敲击一个空格，然后输入该Callout Block的标题。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Tip] 阅读《搞定》的启示</span><br><br><span class="hljs-quote">&gt; 你的大脑更擅长思考，而不是记忆。</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Tip]- 阅读《搞定》的启示<br>你的大脑更擅长思考，而不是记忆。</p></blockquote><p>除此之外，在<code>&gt; [!类型]</code>和<code>内容</code>之间插入“+”和“-”可以将这个Callout Block变成折叠方块。其中——</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">// 中间无括号<br><span class="hljs-quote">&gt; [!类型]- 标题 %%代表该方块默认折叠</span><br><br><span class="hljs-quote">&gt; [!类型]+ 标题 %%代表该方块默认展开</span><br><br></code></pre></td></tr></tbody></table></figure><p>具体的效果还请各位读者到Obsidian当中自行实践。</p><h1 id="3-callout-blocks的正文"><a class="markdownIt-Anchor" href="#3-callout-blocks的正文"></a> 3 Callout Blocks的正文</h1><p>Callout Blocks内部的正文依然支持Markdown语法和双链功能，各位读者可以在方块内部肆意挥发自己的创意。</p><p>这里需要提醒的一点是，在<code>&gt; 引用块</code>的编辑状态下，如果你想要在下一个段落前额外添加一个空行，那么你很有可能会连续按下两次回车键，但这将退出<code>&gt; 引用块</code>的编辑——在引用块、有序列表、无序列表的空行上再次敲击回车会消除该行的格式。因此正确的做法是“Shift+回车”——这将继续向下创造新的空行，原有的空行将保持原有的格式。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Tip] 阅读《搞定》的启示</span><br><br><span class="hljs-quote">&gt; 你的大脑更擅长思考，而不是记忆。</span><br><br><span class="hljs-quote">&gt; %% 这里按“Shift+回车”</span><br><br><span class="hljs-quote">&gt; 2分钟之内能搞定的事就不要拖延，马上去做！</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Tip] 阅读《搞定》的启示<br><strong>你的大脑更擅长思考，而不是记忆。</strong></p><p>2分钟之内能搞定的事就不要拖延，马上去做！</p></blockquote><h1 id="4-应用"><a class="markdownIt-Anchor" href="#4-应用"></a> 4 应用</h1><p>Callout Blocks的基本用法就是这么简单，而关于工具的应用，则完全取决于你的思想、方法和创意。</p><p>你可以像这样做笔记的例题——</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Example]- 例1: 计算行列式 $$\begin{vmatrix}</span><br><br><span class="hljs-quote">&gt; a &amp; b \\</span><br><br><span class="hljs-quote">&gt; c &amp; d \\</span><br><br><span class="hljs-quote">&gt; \end{vmatrix}$$</span><br><br><span class="hljs-quote">&gt; </span><br><span class="hljs-quote"></span><br><span class="hljs-quote">&gt; <span class="hljs-strong">**解:**</span> $$</span><br><br><span class="hljs-quote">&gt; \begin{vmatrix}</span><br><br><span class="hljs-quote">&gt; a &amp; b \\</span><br><br><span class="hljs-quote">&gt; c &amp; d \\</span><br><br><span class="hljs-quote">&gt; \end{vmatrix}</span><br><br><span class="hljs-quote">&gt; =ad-bc</span><br><br><span class="hljs-quote">&gt; $$</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Example]- 例1: 计算行列式 $$\begin{vmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{vmatrix}$$</p><p><strong>解:</strong> $$<br>\begin{vmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{vmatrix}<br>=ad-bc</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p></blockquote><p>也可以做一个这样的总结概括——</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Summary] 本文主要内容</span><br><br><span class="hljs-quote">&gt; 1. Callout Blocks的基本语法</span><br><br><span class="hljs-quote">&gt; 2. 方块类型</span><br><br><span class="hljs-quote">&gt; 3. 标题与折叠</span><br><br><span class="hljs-quote">&gt; 4. 正文</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Summary] 本文主要内容</p><ol><li>Callout Blocks的基本语法</li><li>方块类型</li><li>标题与折叠</li><li>正文</li></ol></blockquote><p>总之，<strong>工具是次要的，思想和方法才是主要的</strong>。现在你掌握了工具的基本用法，接下来你要思考的是如何利用这些工具去更好的生活、学习和工作。</p><p>祝各位读者在有限的人生中，都能用简单的工具创造无限的可能。 作者：高级玩家_锌一-Strik0r <a href="https://www.bilibili.com/read/cv17972102?from=note">https://www.bilibili.com/read/cv17972102?from=note</a> 出处：bilibili</p><hr><p><strong>参考资料</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> obsidian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 用队列实现栈</title>
      <link href="/posts/4522/"/>
      <url>/posts/4522/</url>
      
        <content type="html"><![CDATA[<h1 id="1-225用队列实现栈"><a class="markdownIt-Anchor" href="#1-225用队列实现栈"></a> 1 225.用队列实现栈</h1><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作-- 也就是&nbsp;push to back, peek/pop from front, size, 和&nbsp;is empty&nbsp;这些操作是合法的。</li><li>你所使用的语言也许不支持队列。&nbsp;你可以使用 list 或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>用一个队列来模拟栈</p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p><p>![[3. 用队列实现栈 2022-08-22 09.28.54.excalidraw]]</p><p>![[3. 用队列实现栈.cpp]]</p><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="Obsfym3vu4RzKRrR90p42ZoC" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::3. 用队列实现栈.md" --> <p>#历史记录 ::<br>2022/08/24: 第一次修改</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn Git---2</title>
      <link href="/posts/32208/"/>
      <url>/posts/32208/</url>
      
        <content type="html"><![CDATA[<h1 id="1-git-clone"><a class="markdownIt-Anchor" href="#1-git-clone"></a> 1 git clone</h1><p>直到现在, 教程都聚焦于<strong>本地</strong>仓库的操作（branch、merge、rebase 等等）。但我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 <code>git clone</code>。 从技术上来讲，<code>git clone</code> 命令在真实的环境下的作用是在<strong>本地</strong>创建一个远程仓库的拷贝（比如从 <a href="http://github.com">github.com</a>）。 但在我们的教程中使用这个命令会有一些不同 —— 它会在远程创建一个你本地仓库的副本。显然这和真实命令的意思刚好相反，但是它帮咱们把本地仓库和远程仓库关联到了一起，在教程中就凑合着用吧。</p><p>![[Learn G’i’t—2 2022-08-20 00.14.03.excalidraw]]</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=8e7c76fb-e269-49fb-b27e-09f50b0da5f0">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 用栈实现队列</title>
      <link href="/posts/1958/"/>
      <url>/posts/1958/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工作上一定没人这么搞，但是考察对栈、队列理解程度的好题</p></blockquote><h1 id="1-232用栈实现队列"><a class="markdownIt-Anchor" href="#1-232用栈实现队列"></a> 1 232.用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接</a></p><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p><p>示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 返回 false</span><br></code></pre></td></tr></tbody></table></figure><p>说明:</p><ul><li>你只能使用标准的<strong>栈</strong>操作 – 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>用两个栈来实现, 一个输入栈, 一个输出栈</p><ol><li>push 数据时直接放入输入栈</li><li>pop 数据时<ol><li>输出栈如果为空，就把输入栈中的数据<strong>全部导入</strong>进来,，再从输出栈弹出数据，</li><li>如果输出栈不为空，则直接从出栈弹出数据就可以了。为空转 1</li></ol></li><li>如何判断队列为空:  <strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsOpBnXkvGy59WE0PV5c1o1" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::2. 用栈实现队列.md" --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表总结</title>
      <link href="/posts/43768/"/>
      <url>/posts/43768/</url>
      
        <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObseaQ6eQ8nOP5So8eGpBAWU" --> <h1 id="1-移动链表指针的方式"><a class="markdownIt-Anchor" href="#1-移动链表指针的方式"></a> 1 移动链表指针的方式::</h1><ol><li>指针走完整个链表</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 获取长度</span><br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>判断两个指针相遇</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(index1 != index2){<br>index1 = index1-&gt;next;<br>index2 = index2-&gt;next;<br>} <br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=f87c6654-5015-4464-a6b1-47f484927688">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn Git</title>
      <link href="/posts/43943/"/>
      <url>/posts/43943/</url>
      
        <content type="html"><![CDATA[<p>github git 流程</p><p>git init<br>git add <a href="http://README.md">README.md</a><br>git commit -m “first commit”<br>git branch -M main<br>git remote add origin <a href="https://github.com/zeefan1555/myblog.git">https://github.com/zeefan1555/myblog.git</a><br>git push -u origin main<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208192343602.png" alt=""></p><!-- basicblock-start oid="Obso0XVAmfT8aQUtIodnEGAE" --> <h1 id="1-git-add-git-commit"><a class="markdownIt-Anchor" href="#1-git-add-git-commit"></a> 1 git add;  git commit::</h1><!-- basicblock-end --><p>git add 文件 : 加入暂存区<br>git commit -m “提交信息”</p><h2 id="11-原理"><a class="markdownIt-Anchor" href="#11-原理"></a> 1.1 原理</h2><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p><p>关于提交记录太深入的东西咱们就不再继续探讨了，现在你可以把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！</p><p>![[Learn Git 2022-08-18 21.36.48.excalidraw]]</p><!-- basicblock-start oid="ObsKeJLyaq1yOseGn8ZnhteZ" --> <h1 id="2-git-branch-git-checkout"><a class="markdownIt-Anchor" href="#2-git-branch-git-checkout"></a> 2 git branch, git checkout::</h1><!-- basicblock-end --><p>git checkout -b “branch name”: 创建分支 , 并切换</p><h2 id="21-原理"><a class="markdownIt-Anchor" href="#21-原理"></a> 2.1 原理</h2><p>Git 的分支也非常轻量。它们只是筒单地指向某个提交纪录仅此而已。所以许多 Git 爱好者传颂：<br><strong>早建分支！多用分支！</strong><br>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。<br>![[Learn Git 2022-08-18 21.39.58.excalidraw]]</p><!-- basicblock-start oid="ObsVAkLZbaOR71Cub5FUYro8" --> <h1 id="3-git-merge"><a class="markdownIt-Anchor" href="#3-git-merge"></a> 3 git merge::</h1><!-- basicblock-end --><p>git merge xxx: 就把 xxx分支 合并到 当前分支, 即使一个分支包含所有我们修改的内容<br>将 bugFix 合并到 main 中<br>git checkout main<br>git merge bugFix</p><ul><li>相同分支下:<ul><li>当前分支在子分支, git merge 父分支, 子分支多一个指向上边就行</li><li>当前分支在父分支, git merge 子分支 , 两者就合并</li></ul></li></ul><h2 id="31-分支与合并"><a class="markdownIt-Anchor" href="#31-分支与合并"></a> 3.1 分支与合并</h2><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。<br>咱们先来看一下第一种方法 —— <code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”<br>通过图示更容易理解一些，咱们到下一页看一下。</p><p>![[Learn Git 2022-08-18 21.57.05.excalidraw]]</p><h1 id="4-git-rebase"><a class="markdownIt-Anchor" href="#4-git-rebase"></a> 4 git rebase</h1><p>Rebase 实际上就是取出一系列的提交记录，"<strong>复制</strong>”它们搞出一个副本，然后在另外一个地方,逐个的放下去。原先本来的会隐藏掉</p><ul><li><strong>不同分支下</strong>: git rebase 谁 , 就移到 “谁” 的底部:<ul><li>eg : 当前分支为 bugFix, 运行git rebase main, 会将 bugFix 放到 main 底部</li></ul></li><li><strong>相同分支下</strong>: 当前分支在父分支, git rebase 子分支 , 两者就合并<ul><li>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git 只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</li></ul></li></ul><h2 id="41-原理"><a class="markdownIt-Anchor" href="#41-原理"></a> 4.1 原理</h2><p>第二种合并分支的方法是 <code>git rebase</code><br>Rebase 实际上就是取出一系列的提交记录，"复制”它们，然后在另外一个地方,逐个的放下去。<br>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交<br>历史将会变得异常清晰。<br>![[Learn Git 2022-08-18 21.07.57.excalidraw]]</p><ul><li>$ 高级篇</li></ul><!-- basicblock-start oid="ObsKcDpYuxBIirA1BDUYdxam" --> <h1 id="5-head"><a class="markdownIt-Anchor" href="#5-head"></a> 5 HEAD::</h1><!-- basicblock-end --><p>通过切换当前对象, 可以改变 HEAD 指针: 用 git checkout xxx</p><p>git checkout HEAD~1 : 单独操作 HEAD 指针往上一位</p><h2 id="51-定义"><a class="markdownIt-Anchor" href="#51-定义"></a> 5.1 定义</h2><p>我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。<br>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。<br>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p><h2 id="52-分离的-head"><a class="markdownIt-Anchor" href="#52-分离的-head"></a> 5.2 分离的 HEAD</h2><p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：</p><p>HEAD -&gt; main -&gt; C1</p><p>HEAD 指向 main， main 指向 C1</p><p>head 指针会默认在当前激活的分支上</p><p>原理<br>![[Learn Git 2022-08-18 22.36.50.excalidraw]]</p><h1 id="6-相对引用"><a class="markdownIt-Anchor" href="#6-相对引用"></a> 6 相对引用</h1><p>![[Learn Git 2022-08-18 22.52.32.excalidraw]]</p><h1 id="7-~操作符"><a class="markdownIt-Anchor" href="#7-~操作符"></a> 7 “~”操作符::</h1><p>单独移动 HEAD 指针: git checkout HEAD~4  (向上移动 4 个节点)</p><p>强制改变分支位置:<br>1. 直接指定分支位置: git branch -f main C6 (可不提前激活 main 位置)<br>1. 并不移动 HEAD 指针<br>2.指定移动几个位置git branch -f main HEAD~3, 前提是先在激活 main 位置(即 HEAD 指针与 main 先结合起来)</p><p><strong>原理</strong><br>![[Learn Git 2022-08-18 23.03.06.excalidraw]]</p><h1 id="8-撤销变更-git-reset-git-revert"><a class="markdownIt-Anchor" href="#8-撤销变更-git-reset-git-revert"></a> 8 撤销变更 :: git reset 🌵 git revert</h1><p>本地版本撤销: git  reset  xxx: 直接回退到xxx 的父节点<br>远程版本撤销: git revert  xxx : 再创建一个新的提交记录, 而这个提交记录是与 xxx 的父节点一样的</p><p>原理<br>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。<br>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。接下来咱们逐个进行讲解。<br>![[Learn Git—1 2022-08-21 23.50.51.excalidraw]]</p><h1 id="9-git-cherry-pick"><a class="markdownIt-Anchor" href="#9-git-cherry-pick"></a> 9 Git Cherry-pick</h1><p>将一些提交复制到当前所在的位置（<code>HEAD</code>）: <code>git cherry-pick &lt;提交号&gt;...</code><br>原理<br>![[Learn Git—1 2022-08-28 20.39.47.excalidraw]]</p><h1 id="10-交互式的-rebase"><a class="markdownIt-Anchor" href="#10-交互式的-rebase"></a> 10 交互式的 rebase</h1><p>将一些提交复制到当前所在的位置:<br>这个位置可用头指针来表示:<br>1. HEAD~4(当前位置往上数 4 位)<br>2. Cx: 指定的位置</p><p>git rebase -i HEAD~x: 可以用当前指针的前几位来复制<br>git rebase -i Cx : 也可以指定到某次提交记录</p><p>原理<br>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。<br>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了<br>咱们具体来看一下……<br>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code><br>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。<br>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。<br>当 rebase UI界面打开时, 你能做3件事:<br>-   调整提交记录的顺序（通过鼠标拖放来完成）<br>-   删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）<br>-   合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。<br>- ![[Learn Git—1 2022-08-28 20.44.54.excalidraw]]</p><h1 id="11-本地栈式提交"><a class="markdownIt-Anchor" href="#11-本地栈式提交"></a> 11 本地栈式提交</h1><p>将两个提交记录复制合并一个新记录</p><ol><li>git rebase -i 截止位置  (在挑选不要的, 和调整顺序)</li><li>git rebse 当前位置 合并位置(" * "号会自动跑到合并位置处)</li></ol><p>题目<br>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p><p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p><p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……<br>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p><ul><li><code>git rebase -i</code></li><li><code>git cherry-pick</code></li></ul><p>来达到目的。<br>由于我们刚刚闯过类似的关卡，所以要不要再尝试一次就看你自己了。但是如果你想试一把的话，确保 <code>main</code> 分支能得到 <code>bugFix</code> 分支上的相关提交。<br>![[Learn Git—1 2022-08-28 21.07.11.excalidraw|600]]</p><h1 id="12-提交的技巧-1"><a class="markdownIt-Anchor" href="#12-提交的技巧-1"></a> 12 提交的技巧 #1</h1><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p><p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p>我们可以通过下面的方法来克服困难：</p><ul><li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li><li>然后用 <code>git commit --amend</code> 来进行一些小修改</li><li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li><li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li></ul><p>当然完成这个任务的方法不止上面提到的一种（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。 最后有必要说明一下目标状态中的那几个<code>'</code> —— 我们把这个提交移动了两次，每移动一次会产生一个 <code>'</code>；而 C2 上多出来的那个是我们在使用了 amend 参数提交时产生的，所以最终结果就是这样了。</p><p>也就是说，我在对比结果的时候只会对比提交树的结构，对于 <code>'</code> 的数量上的不同，并不纳入对比范围内。只要你的 <code>main</code> 分支结构与目标结构相同，我就算你通过。<br>![[Learn Git—1 2022-08-28 21.35.35.excalidraw]]</p><h1 id="13-提交的技巧-2"><a class="markdownIt-Anchor" href="#13-提交的技巧-2"></a> 13 提交的技巧 #2</h1><p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p><p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 <code>git cherry-pick</code> 是怎么做的吧</p><p><strong>要在心里牢记 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。</strong></p><p>![[Learn Git—1 2022-08-28 21.50.49.excalidraw]]</p><h1 id="14-git-tags"><a class="markdownIt-Anchor" href="#14-git-tags"></a> 14 Git Tags</h1><p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p><p>你可能会问了：有没有什么可以_永远_指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p><p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p><p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p>咱们来看看标签到底是什么样<br>![[Learn Git—1 2022-08-28 22.12.15.excalidraw]]</p><h1 id="15-git-describe"><a class="markdownIt-Anchor" href="#15-git-describe"></a> 15 Git Describe</h1><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p><p><code>git describe</code> 语法是：</p><p><code>git describe &lt;ref&gt;</code></p><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><p><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><p>![[Learn Git—1 2022-08-28 22.20.04.excalidraw]]</p><h1 id="16-多分支-rebase"><a class="markdownIt-Anchor" href="#16-多分支-rebase"></a> 16 多分支 rebase</h1><p>哥们儿，我们准备了很多分支！咱们把这些分支 rebase 到 main 上吧。</p><p>但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 <code>C6'</code> 在 <code>C7'</code> 上面， <code>C5'</code> 在 <code>C6'</code> 上面，依此类推。</p><p>即使你搞砸了也没关系，用 <code>reset</code> 命令就可以重新开始了。记得看看我们提供的答案，看你能否使用更少的命令来完成任务！<br>![[Learn Git—1 2022-08-28 22.24.22.excalidraw]]</p><h1 id="17-参考资料"><a class="markdownIt-Anchor" href="#17-参考资料"></a> 17 参考资料</h1><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 栈与队列理论基础</title>
      <link href="/posts/64870/"/>
      <url>/posts/64870/</url>
      
        <content type="html"><![CDATA[<p>e</p><h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1 原理:</h1><p>栈是先进后出, 队列是先进先出。<br>![[1. 栈与队列理论基础 2022-08-22 14.08.54.excalidraw]]<br><img src="https://img-blog.csdnimg.cn/20210104235346563.png" alt="栈与队列理论1"></p><h1 id="2-深层问题"><a class="markdownIt-Anchor" href="#2-深层问题"></a> 2 深层问题</h1><h2 id="21-我们使用的stack是属于哪个版本的stl"><a class="markdownIt-Anchor" href="#21-我们使用的stack是属于哪个版本的stl"></a> 2.1 我们使用的stack是属于哪个版本的STL？</h2><p>首先大家要知道 栈和队列是STL（C<ins>标准库）里面的两个数据结构。<br>C</ins>标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p><p>那么来介绍一下，三个最为普遍的STL版本：</p><ol><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li></ol><p>接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。</p><p>来说一说栈，栈先进后出，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210104235434905.png" alt="栈与队列理论2"></p><!-- basicblock-start oid="ObsgF7IKoRIJ3RL36K7MNQaa" --> <h2 id="22-stack-提供迭代器来遍历stack空间么"><a class="markdownIt-Anchor" href="#22-stack-提供迭代器来遍历stack空间么"></a> 2.2 stack 提供迭代器来遍历stack空间么？::</h2><p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。<br>不像是set 或者map 提供迭代器iterator来遍历所有元素。(这里可能说的是 set, map 里类似的 find 函数)</p><!-- basicblock-end --> #card<!-- basicblock-start oid="ObslJ1WRHO7RLJlybQvTbPjU" --> <h2 id="23-c中stack-是容器么-stack-的原理是什么"><a class="markdownIt-Anchor" href="#23-c中stack-是容器么-stack-的原理是什么"></a> 2.3 C++中stack 是容器么🌵 stack 的原理是什么</h2><p>::<br><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong><br>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）</p><p>栈的底层实现可以是<strong>vector，deque，list</strong> 都是可以的，<br>一般都是用 deque, 因为 deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。<br><img src="https://img-blog.csdnimg.cn/20210104235459376.png" alt="栈与队列理论3|600"></p><p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong><br><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p><p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; third;  <span class="hljs-comment">// 使用vector为底层容器的栈</span><br></code></pre></td></tr></tbody></table></figure><p>刚刚讲过栈的特性，对应的队列的情况是一样的。<br>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong><br>也可以指定list 为起底层实现，初始化queue的语句如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; third; <span class="hljs-comment">// 定义以list为底层容器的队列</span><br></code></pre></td></tr></tbody></table></figure><p>所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。</p><!-- basicblock-end --> <hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsWq2mgFS7FgFOnIMQTTp3Y" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::1. 栈与队列理论基础.md" --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 栈与队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针目录</title>
      <link href="/posts/23871/"/>
      <url>/posts/23871/</url>
      
        <content type="html"><![CDATA[<h1 id="1-通过快慢指针给新数组赋值快指针指向元素-慢指针指向下标"><a class="markdownIt-Anchor" href="#1-通过快慢指针给新数组赋值快指针指向元素-慢指针指向下标"></a> 1 <strong>通过快慢指针给新数组赋值</strong>(快指针指向元素, 慢指针指向下标)</h1><ol><li>快指针找新数组的元素 (查找 n 次, 即 O(n)的时间复杂度)</li><li>快指针给<strong>慢指针对应的新数组的下标</strong>赋值<ol><li>常规赋值: [[4. 有序数组的平方]] [[3. 移除元素]]</li><li>需要给新数组扩容的, 在赋值: [[3. 替换空格]]</li></ol></li></ol><h1 id="2-通过双指针构建滑动窗口"><a class="markdownIt-Anchor" href="#2-通过双指针构建滑动窗口"></a> 2 <strong>通过双指针构建滑动窗口</strong></h1><pre><code class="hljs">- .  起始指针 i , 终止指针 j, 通过操作 i 与 j 之间值来达到所需目的. eg: 求窗口之间的元素和 [[5. 长度最小的子数组]]</code></pre><h1 id="3-反转元素"><a class="markdownIt-Anchor" href="#3-反转元素"></a> 3 <strong>反转元素</strong></h1><pre><code class="hljs">1. 常规反转 reverse 原理: [[1. 反转字符串]]2. 多一些复杂规则的翻转 [[4. 翻转字符串里的单词]]3. 两个指针挨着的翻转链表[[4. 翻转链表]]</code></pre><h1 id="4-其他"><a class="markdownIt-Anchor" href="#4-其他"></a> 4 <strong>其他</strong></h1><pre><code class="hljs">1. [[6.删除链表的倒数第N个节点]]: 通过两指针移动的步数不同, 来达到, slow 指针想到移动到的位置, 来实现删除链表元素2. [[7. 链表相交]]: 两个数组用两个指针来判断是不是有元素相同3. </code></pre><p>题目目录</p><ol><li>[[3. 移除元素]]</li><li>[[1. 反转字符串]]</li><li>[[3. 替换空格]]</li><li>[[4. 翻转字符串里的单词]]</li><li>[[4. 反转链表]]</li><li>[[6.删除链表的倒数第N个节点]]</li><li>[[7. 链表相交]]</li><li>[[8. 环形链表II]]: 通过两个指针的移动来判断是否达到题意, 需要一定的数学推导</li><li>[[8. 三数之和]]:</li><li>[[9. 四数之和]]: 不会</li></ol><p>除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将O(n^2)的时间复杂度，降为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=472c81a7-93e7-4242-a087-56c05baa6bf3">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 双指针法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 重复的子字符串</title>
      <link href="/posts/63102/"/>
      <url>/posts/63102/</url>
      
        <content type="html"><![CDATA[<h1 id="1-459重复的子字符串"><a class="markdownIt-Anchor" href="#1-459重复的子字符串"></a> 1 459.重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接</a><br>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:<br>输入: “aba”<br>输出: False</p><p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-kmp-算法"><a class="markdownIt-Anchor" href="#21-kmp-算法"></a> 2.1 kmp 算法</h2><ol><li><p>找到最小重复子串长度</p><ol><li>next[len - 1] != 0</li><li>len - next[len - 1]</li></ol></li><li><p>用总长度 / 最小重复子串的长度, 如果能整除, 即 == 0 就说明该字符串有重复的子字符串</p></li></ol><p>解:</p><ol><li>找到最小重复子串长度</li></ol><p>在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里那字符串s：abababab 来举例，ab就是最小重复单位，如图所示：<br>![[7. 重复的子字符串 2022-08-17 11.06.50.excalidraw]]<br>[[KMP 算法理论篇 2022-08-16 15.46.14.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-kmp"><a class="markdownIt-Anchor" href="#31-kmp"></a> 3.1 kmp</h2><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span> ( j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]){<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]){<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> next [len];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        std::cout&lt;&lt;next;<br>        <span class="hljs-type">int</span> Df = len - next[len - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % Df == <span class="hljs-number">0</span>){ <span class="hljs-comment">// ❗️是取余 不是 除</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=61a275a8-7cd1-44d9-9a0c-bf87fa7206e4">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 实现strStr()</title>
      <link href="/posts/59030/"/>
      <url>/posts/59030/</url>
      
        <content type="html"><![CDATA[<h1 id="1-实现-strstr"><a class="markdownIt-Anchor" href="#1-实现-strstr"></a> 1 实现 strStr()</h1><p><a href="https://leetcode.cn/problems/implement-strstr/">力扣题目链接</a></p><p>实现&nbsp;strStr()&nbsp;函数。</p><p>给定一个&nbsp;haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回&nbsp; -1。</p><p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p><p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p><p>说明: 当&nbsp;needle&nbsp;是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当&nbsp;needle&nbsp;是空字符串时我们应当返回 0 。这与C语言的&nbsp;strstr()&nbsp;以及 Java的&nbsp;indexOf()&nbsp;定义相符。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>先求 next 数组: [[KMP 算法理论篇]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>不懂 主函数里的操作</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]){<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]){<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>(), h = haystack.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>        <span class="hljs-type">int</span> next[n];<br>        <span class="hljs-built_in">getNext</span>(next, needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❓下边跟 next 数组的逻辑一样</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h; i++){<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]){<br>                j = next[j<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 找前一位的 next 数值</span><br>            }<br>            <span class="hljs-keyword">if</span>(haystack[i] == needle[j]){<br>            j++;<br>        }<br>        <span class="hljs-keyword">if</span>(j == n){ <span class="hljs-comment">// ❓</span><br>            <span class="hljs-keyword">return</span>(i - n + <span class="hljs-number">1</span>);<br>        }<br>      }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=c3492942-c29c-459c-8a33-e13b9179eaea">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP 算法理论篇</title>
      <link href="/posts/27202/"/>
      <url>/posts/27202/</url>
      
        <content type="html"><![CDATA[<p>题目: 要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>暴力匹配: for 循环发现不匹配, 则从头匹配.<br>暴力的解法显而易见是O(n × m)<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208161707423.gif" alt="|600"> ^zyqb9e</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-type">int</span> n = haystack.<span class="hljs-built_in">size</span>(), m = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + m &lt;= n; i++) {<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>                <span class="hljs-keyword">if</span> (haystack[i + j] != needle[j]) {<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>            }<br>            <span class="hljs-keyword">if</span> (flag) {<br>                <span class="hljs-keyword">return</span> i;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>KMP: 使用前缀表, 就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>什么是前缀和后缀<br>![[KMP 算法理论篇 2022-08-16 15.46.14.excalidraw]]</p><p><strong>为什么要对 next 数组进行一些变化</strong> ::<br>![[KMP 算法理论篇 2022-08-17 17.45.43.excalidraw]]</p><p>看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：<br><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"><br>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。<br>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p><blockquote><p>为什么前一位就是就是最长相等前后缀的数值? #疑问</p></blockquote><p>所以要看前一位的 前缀表的数值。<br>前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。<br>最后就在文本串中找到了和模式串匹配的子串了。</p><h1 id="1-时间复杂度分析"><a class="markdownIt-Anchor" href="#1-时间复杂度分析"></a> 1 时间复杂度分析</h1><p>其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。暴力的解法显而易见是O(n × m)，所以<strong>KMP在字符串匹配中极大的提高的搜索的效率。</strong><br>为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。</p><p>都知道使用KMP算法，一定要构造next数组</p><h1 id="2-构造-next-数组"><a class="markdownIt-Anchor" href="#2-构造-next-数组"></a> 2 构造 next 数组</h1><p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况<br>循环不变量: 遇见冲突看前一位的 next 数值, 然后回退到下标为 next 数值的位置继续比较<br>![[KMP 算法理论篇 2022-08-16 17.16.15.excalidraw]]<br><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"></li></ol><blockquote><p>注意next数组是新前缀表（旧前缀表统一减一了）。</p></blockquote><p><strong>背住过程</strong></p><ul><li><p>起始时，next[0]=0，j从0位置开始，i从1位置开始</p></li><li><p>如果s[i] != s[j] ：将j指针指向前一位置的 next 数组所对应的值，即j = next[j - 1]<br>这个过程是循环进行，直到s[i] == s[j] 或者 j=0<br>如果j == 0, s[i] 和 s[j] 还是不相等，则next[i] =0，i往后移动, j 不变</p></li><li><p>如果s[i] == s[j]：next[i] =j+1;  i和j同时后移（这个过程一直同样循环进行）</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) { <span class="hljs-comment">// 💡j要保证大于0，因为下面有取j-1作为数组下标的操作</span><br>            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 注意这里，是要找前一位的对应的回退位置了</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) {<br>            j++;<br>        }<br>        next[i] = j;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>总结<br>KMP 算法的应用范围要比 Manacher 算法广，Manacher 算法只能应用于「回文串」问题，相对比较局限，而「子串匹配」问题还是十分常见的。</p><p>背过这样的算法的意义在于：相当于大脑里有了一个时间复杂度为 O(n)的 api 可以使用，这个 api 传入一个原串和匹配串，返回匹配串在原串的位置。</p><p>因此，三叶十分建议大家在「理解 KMP」的基础上，对模板进行背过 ~</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=a778a134-dfdf-4f33-b8c0-164b33e56de4">ob</a><br><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=f2340d96e99780a96b50d8096ffaaf1a">帮你把KMP算法学个通透！（理论篇）_哔哩哔哩_bilibili</a><br><a href="https://leetcode.cn/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">【宫水三叶】简单题学 KMP 算法 - 实现 strStr() - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 左旋转字符串</title>
      <link href="/posts/528/"/>
      <url>/posts/528/</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目剑指offer58-ii左旋转字符串"><a class="markdownIt-Anchor" href="#1-题目剑指offer58-ii左旋转字符串"></a> 1 题目：剑指Offer58-II.左旋转字符串</h1><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接</a></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出:&nbsp;“cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出:&nbsp;“umghlrlose”</p><p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>[[4. 翻转字符串里的单词]]使用整体反转+局部反转就可以实现，反转单词顺序的目的。</p><p>这道题目也非常类似，依然可以通过局部反转+整体反转 达到左旋转的目的。</p><p>具体步骤为：</p><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><p>最后就可以得到左旋n的目的，而不用定义新的字符串，完全在本串上操作。</p><p>![[5. 左旋转字符串 2022-08-18 15.02.36.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end ; i &lt; j; i++, j--){<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]); <span class="hljs-comment">// ❗️ swap 后边记得有括号</span><br>        }<br>    }<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, n, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--){<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br><br><br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-comment">// reverse(s, s.begin(), s.begin() + n); ❗️这个是自带的库函数 与自己定义的冲突, 因为传入的参数是 int 型</span><br>        <span class="hljs-comment">// reverse(s, s.begin() + n, s.end());</span><br>        <span class="hljs-comment">// reverse(s, s.begin(), s.end());</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, n, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=4e9e41d7-1d6c-4069-b3d1-42fb0059d68d">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 翻转字符串里的单词</title>
      <link href="/posts/18478/"/>
      <url>/posts/18478/</url>
      
        <content type="html"><![CDATA[<h1 id="1-151翻转字符串里的单词"><a class="markdownIt-Anchor" href="#1-151翻转字符串里的单词"></a> 1 151.翻转字符串里的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出:&nbsp;“blue is sky the”</p><p>示例 2：<br>输入: " &nbsp;hello world! &nbsp;"<br>输出:&nbsp;“world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good &nbsp; example”<br>输出:&nbsp;“example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>移除多余空格  :<ol><li>移除所有的空格, 思想参考:[[3. 移除元素]]</li><li>除了第一个元素外, 在每个单词前边再加上一个空格</li></ol></li><li>将整个字符串反转</li><li>将每个单词反转</li></ol><p>举个例子，源字符串为："the sky is blue "</p><ol><li>移除多余空格 : “the sky is blue”</li><li>字符串整体反转：“eulb si yks eht”</li><li>单词反转：“blue is sky the”</li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷 : 未通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span> <span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--){<br>            <span class="hljs-type">char</span> temp = s[i];<span class="hljs-comment">// 这里用 swap 显示不行</span><br>            s[i] = s[j];<br>            s[j] = temp;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEtraSpace</span><span class="hljs-params">(string&amp; s)</span></span>{<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; fast &lt; s.<span class="hljs-built_in">size</span>(); fast++){<br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>                <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>){<span class="hljs-comment">// 2️⃣除了第一个单词外, 在单词前边加空格</span><br>                    s[slow] = <span class="hljs-string">' '</span>; <br>                    slow++;<br>                }<br>                <span class="hljs-keyword">while</span>(s[fast] != <span class="hljs-string">' '</span> &amp;&amp; fast &lt; s.<span class="hljs-built_in">size</span>()){ <span class="hljs-comment">// 1️⃣ 添加单词</span><br>                    s[slow] = s[fast];<br>                    fast++;<br>                    slow++;<br>                }<br>            }<br>        }<br>        s.<span class="hljs-built_in">resize</span>(slow - <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">removeEtraSpace</span>(s);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">' '</span>){ <span class="hljs-comment">// 找到单词后的空格</span><br>            <span class="hljs-built_in">reverse</span>(s, start, i);<br>            start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 下个单词的首元素下标</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>     <br>};<br><br></code></pre></td></tr></tbody></table></figure><p>一刷: 编译未通过<br>#疑问</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{ <span class="hljs-comment">// ❗️返回值是 void 即可, 因为是引用&amp;s, 所以 s 被修改了</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; i++, j--){<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remeveExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>        <span class="hljs-type">int</span> fast; <br>        <span class="hljs-type">int</span> slow;<br>        <span class="hljs-keyword">for</span>(fast = <span class="hljs-number">0</span>; fast &lt; s.<span class="hljs-built_in">size</span>(); fast++){<br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>){<br>                    s[slow] = <span class="hljs-string">' '</span>;<br>                    slow++;<br>                }<br>                <span class="hljs-keyword">while</span>(fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast]!=<span class="hljs-string">' '</span>){<br>                    s[slow] = s[fast];<br>                    slow++;<br>                    fast++;<br>                }<br>            }<br>        }<br>    }<br>    <br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">remeveExtraSpaces</span>(s);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">' '</span> || i == s.<span class="hljs-built_in">size</span>()){<br>                <span class="hljs-built_in">reverse</span>(s, start, i<span class="hljs-number">-1</span>);<br>                start = i+<span class="hljs-number">1</span>;<br><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>carl 代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{ <span class="hljs-comment">//翻转，区间写法：左闭又闭 []</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>; fast &lt; s.<span class="hljs-built_in">size</span>(); fast++) { <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (s[fast] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>                <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) {<br>                    s[slow] = <span class="hljs-string">' '</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>                    slow++;<br>                }<br>                <span class="hljs-keyword">while</span> (fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                    s[slow] = s[fast];<br>                    slow++;<br>                    fast++;<br>                }<br>            }<br>        }<br>        s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">removeExtraSpaces</span>(s); <span class="hljs-comment">// 去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">// removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">' '</span>) { <span class="hljs-comment">// 到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 翻转，注意是左闭右闭 []的翻转。</span><br>                start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新下一个单词的开始下标start</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=28a95bf0-8bc7-43c5-866d-a1721df3d4f0">ob</a><br>[[库函数]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 替换空格</title>
      <link href="/posts/27182/"/>
      <url>/posts/27182/</url>
      
        <content type="html"><![CDATA[<h1 id="1-剑指offer05替换空格"><a class="markdownIt-Anchor" href="#1-剑指offer05替换空格"></a> 1 剑指offer05.替换空格</h1><p>请实现一个函数，把字符串 s 中的每个空格替换成"%20"。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：“We%20are%20happy.”</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>双指针法:  用第一个指针新数组的新元素, 第二个指针在新数组中赋值</p><ol><li>首先扩充数组到每个空格替换成"%20"之后的大小。</li><li>快指针指向新长度的末尾，慢指针指向旧长度的末尾。然后从后向前替换空格，<ol><li>如果从前往后填充, 就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。<br>演示过程如下<br><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif" alt="替换空格"></li></ol></li></ol><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong><br>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。</li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> a : s){<br>            <span class="hljs-keyword">if</span>(a == <span class="hljs-string">' '</span>) count++;<br>        }<br>        <span class="hljs-type">int</span> fast = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * count);<br>        <span class="hljs-type">int</span> slow = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <br><br>        <span class="hljs-keyword">for</span>(;fast &gt;= <span class="hljs-number">0</span>; fast--){ <span class="hljs-comment">// ❗️应该 &gt;= 0 不是 &gt; 0, 因为 0 元素ize()</span><br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>                s[slow] = s[fast];<br>                slow--; <span class="hljs-comment">// 💡也可以在 内部控制 slow 的移动而不在 for 循环的条件中</span><br>            }<br>            <span class="hljs-keyword">else</span>{<br>                s[slow] = <span class="hljs-string">'0'</span>;<br>                s[slow - <span class="hljs-number">1</span>] = <span class="hljs-string">'2'</span>;<br>                s[slow - <span class="hljs-number">2</span>] = <span class="hljs-string">'%'</span>;<br>                slow -= <span class="hljs-number">3</span>; <br><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">' '</span>) {<br>                count++;<br>            }<br>        }<br>        <span class="hljs-type">int</span> sOldSize = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// ❗️要有减 1 操作啊</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * count);<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[库函数]]">[1]</span></a></sup></span><br>        <span class="hljs-type">int</span> sNewSize = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = sOldSize, j = sNewSize; i &gt;= <span class="hljs-number">0</span>; i--, j--){ <span class="hljs-comment">// ❗️是 &gt;= 不是&gt; 因为第一个元素也要赋值</span><br>            <span class="hljs-keyword">if</span>(s[i] != <span class="hljs-string">' '</span>) s[j] = s[i];<br>            <span class="hljs-keyword">else</span>{<br>                s[j] = <span class="hljs-string">'0'</span>; <span class="hljs-comment">// ❗️不是数组 0, 是'0', 下边同理</span><br>                s[j<span class="hljs-number">-1</span>] = <span class="hljs-string">'2'</span>;<br>                s[j<span class="hljs-number">-2</span>] = <span class="hljs-string">'%'</span>;<br>                j -= <span class="hljs-number">2</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=83d40fe9-2d12-48d3-8c1a-499661f2a473">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[库函数]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 反转字符串II</title>
      <link href="/posts/62802/"/>
      <url>/posts/62802/</url>
      
        <content type="html"><![CDATA[<h1 id="1-反转字符串ii"><a class="markdownIt-Anchor" href="#1-反转字符串ii"></a> 1 反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接</a></p><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>平时 for 循环中我们习惯写for(int i = 0; i &lt; nums.size(); i++) , 此时的 i 是一格格的移动, 但是此题可以让 i 每次移动 2k 个格子,然后判断是否需要有反转的区间。for(int i = 0; i &lt; nums.size(); <strong>i += 2k</strong>) ^6aghnj</p><p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[for 循环]]">[1]</span></a></sup><br>![[2. 反转字符串II 2022-08-15 23.08.30.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) {<br>            <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) {<br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + i + k );<span class="hljs-comment">// <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[有关字符要想到的操作]]">[2]</span></a></sup></span><br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">end</span>());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="31-错误代码"><a class="markdownIt-Anchor" href="#31-错误代码"></a> 3.1 错误代码</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; s.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++, j--) {<br>                <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i += <span class="hljs-number">2</span>*k){<br>            <span class="hljs-keyword">if</span>(i + k &lt;= s.<span class="hljs-built_in">length</span>()){<br>                <span class="hljs-built_in">reverse</span>(s, s[i], s[i+k]);<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                <span class="hljs-built_in">reverse</span>(s,s[i], s.<span class="hljs-built_in">end</span>());<br>            }<br>        }<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=da9f17e9-4db1-4c4f-84f7-794f88491943">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[for 循环]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[有关字符要想到的操作]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>库函数</title>
      <link href="/posts/49880/"/>
      <url>/posts/49880/</url>
      
        <content type="html"><![CDATA[<h1 id="1-reverse-反转字符串"><a class="markdownIt-Anchor" href="#1-reverse-反转字符串"></a> 1 reverse 反转字符串</h1><p>原理</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>           <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>       }<br>   }<br></code></pre></td></tr></tbody></table></figure><h1 id="2-swapa-b-交换元素"><a class="markdownIt-Anchor" href="#2-swapa-b-交换元素"></a> 2 swap(a, b) 交换元素</h1><p>swap可以有两种实现。</p><p>一种就是常见的交换数值：</p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int tmp <span class="hljs-operator">=</span> s[i]<span class="hljs-comment">;</span><br>s[i] <span class="hljs-operator">=</span> s[j]<span class="hljs-comment">;</span><br>s[j] <span class="hljs-operator">=</span> tmp<span class="hljs-comment">;</span><br><br></code></pre></td></tr></tbody></table></figure><p>一种就是通过位运算：</p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">s<span class="hljs-comment">[i]</span> ^= s<span class="hljs-comment">[j]</span>;<br>s<span class="hljs-comment">[j]</span> ^= s<span class="hljs-comment">[i]</span>;<br>s<span class="hljs-comment">[i]</span> ^= s<span class="hljs-comment">[j]</span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="3-resize-扩充数组-字符串的大小"><a class="markdownIt-Anchor" href="#3-resize-扩充数组-字符串的大小"></a> 3 resize, 扩充数组, 字符串的大小</h1><p>s.resize(s.size() +2) 扩充两个单位</p><h1 id="4-split-分隔单词"><a class="markdownIt-Anchor" href="#4-split-分隔单词"></a> 4 split 分隔单词</h1><h1 id="5-erase-移除元素"><a class="markdownIt-Anchor" href="#5-erase-移除元素"></a> 5 erase 移除元素</h1><p>时间复杂度 O(n)</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=1b4c552e-2bb7-4beb-899e-15ea5b950631">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 反转字符串</title>
      <link href="/posts/16762/"/>
      <url>/posts/16762/</url>
      
        <content type="html"><![CDATA[<h1 id="1-344反转字符串"><a class="markdownIt-Anchor" href="#1-344反转字符串"></a> 1 344.反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,“e”,“l”,“l”,“o”]<br>输出：[“o”,“l”,“l”,“e”,“h”]</p><p>示例 2：<br>输入：[“H”,“a”,“n”,“n”,“a”,“h”]<br>输出：[“h”,“a”,“n”,“n”,“a”,“H”]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>可以使用 reverse [[库函数]]</li></ol><blockquote><p>如果实现的主要功能的是库函数则不要使用</p></blockquote><ol start="2"><li>双指针法<br>fast从字符串前面，slow 从字符串后面，两个指针同时向中间移动，并交换元素。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp0fvi91pfg30de0akwnq.gif" alt="344.反转字符串"></li></ol><p>![[1. 反转字符串 2022-08-15 22.52.30.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> slow = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[有关字符要想到的操作#^ouvyxy]]">[2]</span></a></sup></span><br>        <span class="hljs-keyword">for</span>(; fast &lt; slow; fast++, slow--){<br>            <span class="hljs-built_in">swap</span>(s[fast], s[slow]);<span class="hljs-comment">//❗️ s[fast] = s[slow];</span><br>            <br>        }<br>        <span class="hljs-comment">// return s;, 不用 return, 因为是引用的, 直接就把 s 给修改了</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--){ <span class="hljs-comment">// 终止条件也可以是 i &lt; j  <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[库函数]]">[1]</span></a></sup></span><br>            <span class="hljs-type">char</span> temp = s[i]; <span class="hljs-comment">// = swap(s[i] , s[j])</span><br>            s[i] = s[j];<br>            s[j] = temp;<span class="hljs-comment">// ❗️不是 s[j]= s[i]</span><br>        }<br>        <span class="hljs-comment">// return  s;❗️ 不需要 return</span><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=836daa91-d685-4c82-9bf2-7cbca40d039b">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[库函数]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[有关字符要想到的操作#^ouvyxy]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 四数之和</title>
      <link href="/posts/1490/"/>
      <url>/posts/1490/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第18题-四数之和"><a class="markdownIt-Anchor" href="#1-第18题-四数之和"></a> 1 第18题. 四数之和</h1><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接</a></p><p>题意：给定一个包含&nbsp;n 个整数的数组&nbsp;nums&nbsp;和一个目标值&nbsp;target，判断&nbsp;nums&nbsp;中是否存在四个元素 a，b，c&nbsp;和 d&nbsp;，使得&nbsp;a + b + c + d&nbsp;的值与&nbsp;target&nbsp;相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><blockquote><p>[[8. 三数之和]]一样的道理，能解决四数之和 那么五数之和、六数之和、N数之和</p></blockquote><p>都是一用双指针法, 就是在[[8. 三数之和]]的基础上在嵌套一个 for 循环</p><p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。<br>但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。target &gt; 0不牵扯负数就可以进行剪枝</p><p>[[8. 三数之和]]的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。</p><p>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n<sup>2)，四数之和的时间复杂度是O(n</sup>3) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>没有自己写, 对着抄的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; nums.<span class="hljs-built_in">size</span>(); k++) {<br>            <span class="hljs-comment">// 剪枝处理</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="hljs-number">0</span> &amp;&amp; target &gt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>            }<br>            <span class="hljs-comment">// 对nums[k]去重</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>                <span class="hljs-comment">// 2级剪枝处理</span><br>                <span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; target &gt;= <span class="hljs-number">0</span>) {<br>                    <span class="hljs-keyword">break</span>;<br>                }<br><br>                <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">if</span> (i &gt; k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) {<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (right &gt; left) {<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) {<br>                        right--;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span><br>                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) {<br>                        left++;<br>                    } <span class="hljs-keyword">else</span> {<br>                        result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[k], nums[i], nums[left], nums[right]});<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                        <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                        right--;<br>                        left++;<br>                    }<br>                }<br><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=7c214b0c-3f43-4175-a620-53bc3e93119a">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8. 三数之和</title>
      <link href="/posts/7672/"/>
      <url>/posts/7672/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第15题-三数之和"><a class="markdownIt-Anchor" href="#1-第15题-三数之和"></a> 1 第15题. 三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接</a></p><p>给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> <strong>答案中不可以包含重复的三元组</strong>。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-哈希法"><a class="markdownIt-Anchor" href="#21-哈希法"></a> 2.1 哈希法</h2><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，<br>但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组</p><p><strong>哈希结构里都只是单元素的去重, 无法实现集合形式的去重</strong> ^l8megb</p><h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p><ol><li>首先将<strong>数组排序</strong>，</li><li>然后有一层for循环，i从下标0的地方开始，同时定一个下left 定义在i+1的位置上(第二小的数)，定义下标right 在数组结尾的位置上(最大的数)</li><li>映射a = nums[i]，b = nums[left]，c = nums[right], 依然还是在数组中找到 abc 使得a + b +c =0</li><li>如果整体大了<code>nums[i] + nums[left] + nums[right] &gt; 0</code> , 说明加的数需要<strong>变小</strong>(left 指向的元素无法再小), 即 right 指针左移;</li><li>如果整体小了 <code>nums[i] + nums[left] + nums[right] &lt; 0</code>, 说明加的数需要<strong>变大</strong>(right 指向的元素无法再大), left 指针右移</li><li>考虑 a 的去重<code>nums[i] == nums[i - 1] continue</code>;  bc 的去重: 向中间收缩时, 不能与之前的数相等,否则就重复了</li><li>循环往复, 直到left与right相遇为止(但不能相等, 因为相等就成两个数了)。</li></ol><p>时间复杂度：O(n^2)<br>![[8. 三数之和 2022-08-15 10.25.32.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++){<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// ❗️去重 a 放上边</span><br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = len <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right){ <span class="hljs-comment">// ❗️整体要在 while 循环的包裹下</span><br>           <br>            <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>){<br>                right--;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>){<br>                left++;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                result.<span class="hljs-built_in">push_back</span>({nums[i], nums[left], nums[right]});<br>                <span class="hljs-comment">// 💡去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[right] == nums[right<span class="hljs-number">-1</span>]) right--;<br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) left++;<br>                <span class="hljs-comment">// 找到答案时，双指针同时收缩, 如果同时收缩的同时,不去重的话, 就会导致相同的结果集</span><br>                left++;<br>                right--;<br>            }<br>    }<br>            <br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<span class="hljs-comment">// ❓为什么是二元数组💡题目定义的<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector#^1wjjr0]]">[2]</span></a></sup></span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">return</span> result;<br>            }<br>            <span class="hljs-comment">// 去重a</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left =i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <br>            <span class="hljs-keyword">while</span>(left &lt; right){<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>            <span class="hljs-keyword">else</span> {<br>                result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i], nums[left], nums[right]});<br>                  <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--; <span class="hljs-comment">// 已经找到了, 符合结果的 b c , 在有相同的 b c 也就重复了, 所以继续移动不添加</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩, 如果同时收缩的同时,不去重的话, 就会导致相同的结果集</span><br>                    right--;<br>                    left++;<br>            }<br>            <br>            <br>            }<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=cce04a65-4b7a-4cf7-a9db-d2259157b250">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[1. 哈希表理论基础]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[vector#^1wjjr0]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 赎金信</title>
      <link href="/posts/10848/"/>
      <url>/posts/10848/</url>
      
        <content type="html"><![CDATA[<h1 id="1-赎金信"><a class="markdownIt-Anchor" href="#1-赎金信"></a> 1 赎金信</h1><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接</a></p><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，但是这里需要注意两点。</p><ul><li><p>第一点“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思”&nbsp; 这里_说明杂志里面的字母<strong>不可重复使用</strong>。</p></li><li><p>第二点 “你可以假设两个字符串均只含有小写字母。” 说明只有<strong>小写字母</strong>，这一点很重要</p></li></ul><p>![[7. 赎金信 2022-08-15 16.34.44.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>{<br>        <span class="hljs-type">int</span> array[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; magazine.<span class="hljs-built_in">length</span>(); i++){ <span class="hljs-comment">// ❗️字符串长度用的是 length</span><br>            array[magazine[i] - <span class="hljs-string">'a'</span>]++;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ransomNote.<span class="hljs-built_in">length</span>(); i++){<br>            array[ransomNote[i] - <span class="hljs-string">'a'</span>]--;<br>            <span class="hljs-keyword">if</span> (array[ransomNote[i] - <span class="hljs-string">'a'</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 💡直接将 if 语句放入这里, 不用在用一个 for 循环了</span><br>        }<br>     <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=49ada40c-372a-4b11-8d1f-35c9917e32e0">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 四数相加II</title>
      <link href="/posts/56281/"/>
      <url>/posts/56281/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第454题四数相加ii"><a class="markdownIt-Anchor" href="#1-第454题四数相加ii"></a> 1 第454题.四数相加II</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><p>给定四个包含整数的数组列表&nbsp;A , B , C , D ,计算有多少个元组 (i, j, k, l)&nbsp;，使得&nbsp;A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度&nbsp;N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过&nbsp;2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>解释:</strong></p><p>两个元组如下:</p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题解题步骤：</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><p>![[6. 四数相加II 2022-08-14 17.20.57.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>{<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums1){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : nums2){<br>                map[a+b]++;<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[map]]">[1]</span></a></sup></span><br>            }<br>        }<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : nums3){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d: nums4){<br>                <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-c-d) != map.<span class="hljs-built_in">end</span>()){<br>                    count += map[<span class="hljs-number">0</span>-c-d]; <span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[map]]">[1]</span></a></sup></span><br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=77c9599b-05e7-4360-a3de-f8d766f09304">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[map]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map</title>
      <link href="/posts/43450/"/>
      <url>/posts/43450/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[!example]<br>[[6. 四数相加II]]</p></blockquote><!-- basicblock-start oid="Obsto9SToTNQ22dWM6KcNmYu" --> <h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><p>在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。<br>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p><p>有 key 和 value 对应的: 用 map<br>map 能在最快的时间内, 去查找这个 key 是否在 map<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208121703566.png" alt="|600"></p><p>红黑树可以自动排序<br>std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解</p><p>![[8. 三数之和#^l8megb]]<br>![[1. 二叉树理论基础#^bew6dm]]</p><!-- basicblock-start oid="ObsUHia8uLVbkzLiSsYrjhDO" --> <h1 id="2-unordered_map"><a class="markdownIt-Anchor" href="#2-unordered_map"></a> 2 unordered_map::</h1><!-- basicblock-end --><p>key 是主要的元素, value 是附属<br>不需要 key 有序的时候效率最高</p><!-- basicblock-start oid="Obspbw0byOHXD1bztoDaIKU1" --> <p>C++中如果使用::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::map或者std::multimap可以对key排序，但不能对value排序。<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h2 id="21-操作"><a class="markdownIt-Anchor" href="#21-操作"></a> 2.1 操作</h2><ul><li>创建元素: unordered_map&lt;int, int&gt; map;</li></ul><blockquote><p>[!question] 哪个是 key, 哪个是 value</p></blockquote><ul><li>插入元素:<ul><li>map.insert(<strong>pair&lt;int, int&gt;</strong>(a, b));</li><li><code>map[key]++</code>  //  存在key则 value 值++, 没有 key 则自动创造 key 在 value 值++[^1]</li></ul></li><li>获取元素:<ul><li><code>auto iter = map.find(x);</code>, <code>return iter-&gt;second</code>  lhs.second//  获取第二个元素</li><li><code>map[key]</code> = value // 获取第二个元素</li></ul></li><li>查找元素<br>-<code>if(map.find(x) != map.end())</code>:&nbsp;相当于找到 x 时进入 if 语句</li></ul><p>for 循环中映射 , it 是指针, 指向 map 的一个完整的元素包括key 和 value ,不是单一个元素<br><code>for(unordered_map&lt;int, int&gt; :: iterator it = map.begin(); it != map.end(); it++){}</code><br>^drp7wt</p><!-- basicblock-start oid="ObsMxwL9HOXX4c5s5L1CeDQa" --> <h1 id="3-其他"><a class="markdownIt-Anchor" href="#3-其他"></a> 3 其他::</h1><!-- basicblock-end --><p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在C<ins>11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C</ins>11标准之前民间高手自发造的轮子。<br><img src="https://img-blog.csdnimg.cn/20210104235134572.png" alt="哈希表6"></p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=4f623914-706e-4174-b798-c6e8b4ee184c">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set</title>
      <link href="/posts/44253/"/>
      <url>/posts/44253/</url>
      
        <content type="html"><![CDATA[<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><ul><li>数据范围大(上亿)的时候用 set</li><li>要查询的有: 0 , 5, 100000 . 此时如果用数组的就要开一个 100000 大小的,其实就查询 3 个数,这也是不合适的会造成空间浪费,这种情况也用 set</li></ul><p>局限: set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。:</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208121701377.png" alt="|600"></p><h1 id="1-unordered_set"><a class="markdownIt-Anchor" href="#1-unordered_set"></a> 1 unordered_set</h1><p>unoredered_set<br>在 set 的三种类型中查找效率最高, 映射效率最高, 取值操作效率也是最高的,<br>不需要对数据排序, 并且不会让数组重复(自带去重)</p><h2 id="11-性质"><a class="markdownIt-Anchor" href="#11-性质"></a> 1.1 性质</h2><ul><li>插入元素后自带去重. <code>eg:插入 100 个 2 , 最后也是一个 2.</code></li><li>无自动排序</li></ul><h2 id="12-操作"><a class="markdownIt-Anchor" href="#12-操作"></a> 1.2 操作</h2><p>结构: <code>nums_set: {[0] = 2, [1] = 1}</code>, [[3. 两个数组的交集]]</p><ul><li><p>插入操作: <code>unordered_set result; result.insert();</code></p><ul><li>每往里 insert 一个值, 对该值进行一个哈希运算,转变成另一个它内部存储的一个值, 然后还要开辟一个新的空间</li></ul></li><li><p>寻找操作:</p><ul><li><code>set1. find(2);</code>, 查找2，找到返回迭代器，失败返回set1.end()</li><li>时间复杂度为 O(m * n) [[KMP 算法理论篇#^zyqb9e]]</li></ul></li><li><p>初始化</p><ol><li>创建空的 set :<code>unordered_set&lt;int&gt; set1;</code></li><li>拷贝创建: <code>unordered_set&lt;int&gt; set2(set1);</code></li><li><strong>使用其他结构创建</strong>: <code>unordered_set&lt;int&gt; set3(set1.begin(), set1.end());</code></li></ol></li></ul><h1 id="2-set-multiset"><a class="markdownIt-Anchor" href="#2-set-multiset"></a> 2 set multiset</h1><p>set 和 multiset 因为底层实现是红黑树, 查找元素的之前还要进行向下寻找的操作, 所以效率低</p><ul><li>自动排序(红黑树具有自动排序的功能)<br>multiset 里边的元素可以重复</li></ul><p>红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=d03eac82-8097-46e1-a7cc-2fe3e5132195">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 两数之和</title>
      <link href="/posts/34993/"/>
      <url>/posts/34993/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p><p>给定一个整数数组 nums&nbsp;和一个目标值 target，请你在该数组中找出和为目标值的那&nbsp;两个&nbsp;整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。<br>i 查找第一个数, j 查找第二个数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target &amp;&amp; i != j){<br>                    <span class="hljs-keyword">return</span> {i,j};<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> {};<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-哈希表"><a class="markdownIt-Anchor" href="#22-哈希表"></a> 2.2 哈希表</h2><p>将遍历的数组元素存入 map , 下一次遍历的时候在 map 中查找差值</p><p>![[5. 两数之和 2022-08-13 22.10.31.excalidraw]]</p><p>本题: 我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<br><strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong><br>判断元素是否出现，这个元素就要作为key(查找的主要元素作为 key)，有key对应的就是value，value用来存下标。</p><p>map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target -nums[i]); <span class="hljs-comment">// 提前把变量设好, 为了获取 value 值</span><br>            <span class="hljs-keyword">if</span> ( iter != map.<span class="hljs-built_in">end</span>()){<br>                <span class="hljs-keyword">return</span> {iter-&gt;second, i};<br>            }<br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i));<br>        } <br>        <span class="hljs-keyword">return</span> {};<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=d64073dd-55d1-4f4b-829a-8680ac0b146e">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关数值要想到的操作</title>
      <link href="/posts/38142/"/>
      <url>/posts/38142/</url>
      
        <content type="html"><![CDATA[<h1 id="1-取各个位数"><a class="markdownIt-Anchor" href="#1-取各个位数"></a> 1 取各个位数</h1><p>取余_数是指整数除法中被除数未被除尽部分<br>eg: 199, 取<strong>其个位(%10</strong>), <s><strong>十位(%100)</strong>, <strong>百位(%1000)</strong></s><br>取十位可让, (199/10) %10</p><p>#疑问<br>![[有关数值要想到的操作 2022-08-13 10.19.03.excalidraw]]</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=2d35b970-9351-48dc-a461-bcf79e0d9ff3">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. 快乐数</title>
      <link href="/posts/35816/"/>
      <url>/posts/35816/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第202题-快乐数"><a class="markdownIt-Anchor" href="#1-第202题-快乐数"></a> 1 第202题. 快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接</a></p><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 可以变为&nbsp; 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现</strong>, 重复出现就代表着无法找到 sum = 1</p><p>用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p>[[有关数值要想到的操作]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span> <span class="hljs-params">(<span class="hljs-type">int</span> n )</span></span>{<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n){ <span class="hljs-comment">// ❓为什么不会死循环 💡 n &lt; 1 即为 0,<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]]">[1]</span></a></sup></span><br>                sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>                n /= <span class="hljs-number">10</span>;<br>            }<br>            <span class="hljs-keyword">return</span> sum;<br>        }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(sum) != set.<span class="hljs-built_in">end</span>()){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                set.<span class="hljs-built_in">insert</span>(sum);<br>            }<br>            n = sum; <span class="hljs-comment">// 更新 sum</span><br>        }<br><br>    }<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=84d58a22-ffee-4e83-8c37-a0bd4cedbcb5">ob</a><br><a href="https://www.programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 两个数组的交集</title>
      <link href="/posts/13727/"/>
      <url>/posts/13727/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两个数组的交集"><a class="markdownIt-Anchor" href="#1-两个数组的交集"></a> 1 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接</a></p><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p><img src="https://img-blog.csdnimg.cn/20200818193523911.png" alt="349. 两个数组的交集"></p><p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>![[3. 两个数组的交集 2022-08-12 18.44.19.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; result_set;<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">nums_set</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(nums2[i]) != nums_set.<span class="hljs-built_in">end</span>()){ <span class="hljs-comment">// ❓为什么是!=呢 💡如果找不到则返回 num_set.end()</span><br>                result_set.<span class="hljs-built_in">insert</span>(nums2[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector]]">[1]</span></a></sup></span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#_349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[vector]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关字符要想到的操作</title>
      <link href="/posts/30423/"/>
      <url>/posts/30423/</url>
      
        <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObsgS7hxap8HZGP55ZRbToXQ" --> <h1 id="1-取到字母字符对应数组下标值"><a class="markdownIt-Anchor" href="#1-取到字母字符对应数组下标值"></a> 1 取到字母字符对应数组下标值 ::</h1><p>![[c++中 - ‘0’ 以及 -‘a’ 的相减操作解释#1 取到字母字符对应的数字：a→0，b→1]]</p><!-- basicblock-end --><h1 id="2-找到字符下标对应的元素"><a class="markdownIt-Anchor" href="#2-找到字符下标对应的元素"></a> 2 找到字符下标对应的元素</h1><p>数组类的用的是 <code>nums[i]</code>, 最后一个元素: <code>nums[nums.size()- 1]</code><br>字符类的要用<code>s.begin() + i</code>,  最后一个元素用 <code>s.end()</code></p><h1 id="3-string"><a class="markdownIt-Anchor" href="#3-string"></a> 3 string</h1><p>在C语言中，把一个字符串存入一个数组时，也把结束符 '\0’存入数组，并以此作为该字符串是否结束的标志。<br>例如这段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> a[<span class="hljs-number">5</span>] = <span class="hljs-string">"asd"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; a[i] != <span class="hljs-string">'\0'</span>; i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>string 类会提供 size 接口, 用来判断 string 类字符是否结束, 不用’/0’来判断是否结束 , char 类型的也可用 .size(); ^ouvyxy</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string a = <span class="hljs-string">"asd"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么vector&lt; char &gt; 和 string 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。</p><p>所以想处理字符串，我们还是会定义一个string类型。</p><hr><p><strong>参考资料</strong></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 有效的字母异位词</title>
      <link href="/posts/33343/"/>
      <url>/posts/33343/</url>
      
        <content type="html"><![CDATA[<h1 id="1-242有效的字母异位词"><a class="markdownIt-Anchor" href="#1-242有效的字母异位词"></a> 1 242.有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例&nbsp;1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><p>#card</p><!-- basicblock-start oid="ObsBzRRXarQbR2XJrzGJdVyg" --> <p>字母异位词::<br>由相同的字母组成, 但位置可以不同</p><!-- basicblock-end --><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>将 s 的字母的对应的下标值变为 1 存入哈希表中(数组),<br>通过 t 对应的下标值在减 1 , 看数组是否全为0</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govxyg83bng30ds09ob29.gif" alt="242.有效的字母异位词"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[容器的使用]]<br>#疑问<br>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>{<br>        <span class="hljs-type">int</span> hash [<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// ❗️0 得有大括号</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            hash[s[i] - <span class="hljs-string">'a'</span>]++; <br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; t.<span class="hljs-built_in">size</span>(); j++){<br>            hash[t[j] - <span class="hljs-string">'a'</span>]--; <span class="hljs-comment">// ❗️不是 s 哦, 是 t 的字符串</span><br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++){ <span class="hljs-comment">// ❓为什么不能用i &lt; hash.size()💡还是用提前定义好变量, 思想:用空间换时间</span><br>            <span class="hljs-keyword">if</span> (hash[i] != <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#_242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. 哈希表理论基础</title>
      <link href="/posts/3799/"/>
      <url>/posts/3799/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><p><strong>哈希表是根据关键码的值而直接进行访问的数据结构</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>其实数组就是一张哈希表。<br>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210104234805168.png" alt="哈希表1|600"></p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><h1 id="2-哈希函数"><a class="markdownIt-Anchor" href="#2-哈希函数"></a> 2 哈希函数</h1><p><img src="https://img-blog.csdnimg.cn/2021010423484818.png" alt="哈希表2|600"><br>通过 hashCode 将名字转换为数值, 这样就把学生名字映射为哈希表的索引数字了<br>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>如果学生的数量大于哈希表的大小, 会出现几位同学同时映射到哈希表的同一个索引下标位置<br>就此引出哈希碰撞</p><h1 id="3-哈希碰撞"><a class="markdownIt-Anchor" href="#3-哈希碰撞"></a> 3 哈希碰撞</h1><p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p><img src="https://img-blog.csdnimg.cn/2021010423494884.png" alt="哈希表3|600"><br>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h2 id="31-拉链法"><a class="markdownIt-Anchor" href="#31-拉链法"></a> 3.1 拉链法</h2><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被<strong>存储在链表</strong>中。<br>这样我们就可以通过索引找到小李和小王了<br><img src="https://img-blog.csdnimg.cn/20210104235015226.png" alt="哈希表4|600"></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h2 id="32-线性探测法"><a class="markdownIt-Anchor" href="#32-线性探测法"></a> 3.2 线性探测法</h2><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210104235109950.png" alt="哈希表5|500"></p><h1 id="4-常见的三种哈希结构"><a class="markdownIt-Anchor" href="#4-常见的三种哈希结构"></a> 4 常见的三种哈希结构</h1><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p>这里数组就没啥可说的了，我们来看一下set。</p><h2 id="41-array"><a class="markdownIt-Anchor" href="#41-array"></a> 4.1 array</h2><p>数据范围不大的时候用数组, 能用数组都用数组<br>局限: 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</p><h2 id="42-set"><a class="markdownIt-Anchor" href="#42-set"></a> 4.2 [[set]]</h2><h2 id="43-map"><a class="markdownIt-Anchor" href="#43-map"></a> 4.3 [[map]]</h2><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. 环形链表II</title>
      <link href="/posts/51653/"/>
      <url>/posts/51653/</url>
      
        <content type="html"><![CDATA[<h1 id="1-42环形链表ii"><a class="markdownIt-Anchor" href="#1-42环形链表ii"></a> 1 42.环形链表II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。&nbsp;如果链表无环，则返回&nbsp;null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><p><img src="https://img-blog.csdnimg.cn/20200816110112704.png" alt="循环链表|600"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>#card</p><!-- basicblock-start oid="Obss3RRsOmOqv7rvijEgiIq0" --> <p>环型链表思路::</p><ol><li>fast slow 指向头结点, fast 每次走两步, slow 每次走一步.  记相遇节点  (Index1)</li><li>相遇节点(Index1) 与 头结点(Index2)在<strong>同步</strong>走, 在相遇便是入口节点</li></ol><!-- basicblock-end --><h2 id="21-判断是否有环"><a class="markdownIt-Anchor" href="#21-判断是否有环"></a> 2.1 判断是否有环</h2><p><strong>定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</strong></p><p>原因:</p><ol><li><strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的</strong>。</li><li>fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo4xglk9yg30fs0b6u0x.gif" alt="141.环形链表"></li></ol><h2 id="22-如何找入口"><a class="markdownIt-Anchor" href="#22-如何找入口"></a> 2.2 如何找入口</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif" alt="142.环形链表II（求入口）"></p><p>![[8. 环形链表II 2022-08-12 10.28.07.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head; <span class="hljs-comment">// ❗️要赋值啊</span><br>        ListNode* slow = head;<br>        ListNode* index1;<br>        ListNode* index2 = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️要把 fast != NULL 放到前边, 因为如果链表是空指针, 要先判断这个</span><br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow){<br>                index1 = fast;<br>                <span class="hljs-keyword">while</span>(index1 != index2){<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                }<br>                <span class="hljs-keyword">return</span> index1;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷:已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>){<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow){<br>                ListNode* index1 = fast; <span class="hljs-comment">// 定义相遇节点</span><br>                ListNode* index2 = head; <span class="hljs-comment">// 定义头结点</span><br>            <span class="hljs-keyword">while</span>(index1 != index2){ <span class="hljs-comment">// 💡让他俩同时出发,相遇时即为入口❗️index1 != NULL &amp;&amp; index1-&gt;next != NULL</span><br>            index1 = index1-&gt;next;  <br>            index2 = index2-&gt;next;<br>            }<br>            <span class="hljs-keyword">return</span> index1;<br>    }<br>}<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 链表相交</title>
      <link href="/posts/8965/"/>
      <url>/posts/8965/</url>
      
        <content type="html"><![CDATA[<h1 id="1-面试题-0207-链表相交"><a class="markdownIt-Anchor" href="#1-面试题-0207-链表相交"></a> 1 面试题 02.07. 链表相交</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接</a></p><p>给你两个单链表的头节点&nbsp;headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png" alt=""></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>示例 1：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png" alt=""></p><!-- basicblock-start oid="ObsIj67S95DLXBLeahoOf5qB" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><ol><li>获取两个链表长度, 长度长的在上面, 长度短的在下面</li><li>求出两个链表长度差, 使A 走到重合处. 即末端对齐</li><li>A 和 B 向后比较, 寻找相同的元素</li></ol><p>![[7. 链表相交 2022-08-12 16.32.24.excalidraw]]</p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lenB = <span class="hljs-number">0</span>;<br>        ListNode* curA = headA; <span class="hljs-comment">// 操作 headA</span><br>        ListNode* curB = headB;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 获取长度<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=": 获取链表长度::12345678// 不要操作原指针, 重新定义一个指针, 因为指针会不断的变化, 如果用原来的指针就破坏了原来的结构了        ListNode* curA = headA; // 操作 headA        int lenA = 0;        while(curA != NULL){   // 获取长度            curA = curA->next;            lenA++;        }">[1]</span></a></sup></span><br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>){ <br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        curA = headA;         <span class="hljs-comment">// 重新操作 headA</span><br>        curB = headB;<br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA){     <span class="hljs-comment">// 固定长度长的</span><br>            <span class="hljs-built_in">swap</span>(curA, curB);<br>            <span class="hljs-built_in">swap</span>(lenA, lenB);<br>        }<br>        <span class="hljs-type">int</span> gap = lenA - lenB; <span class="hljs-comment">// 获取差值</span><br>        <span class="hljs-keyword">while</span>(gap--){          <span class="hljs-comment">// 长短对齐 </span><br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 寻找相同</span><br>            <span class="hljs-keyword">if</span>(curA == curB){<br>                <span class="hljs-keyword">return</span> curA;<br>            }<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){<br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>){<br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-keyword">if</span>(lenB &gt; lenA){<br>            <span class="hljs-built_in">swap</span>(curB, curA);<span class="hljs-comment">// 反过来换也行, 因为是两两互换</span><br>            <span class="hljs-built_in">swap</span>(lenB, lenA);<br>        }<br>        <span class="hljs-type">int</span> gap = lenA - lenB; <span class="hljs-comment">// 换过之后一定是大的减小的</span><br>        <span class="hljs-keyword">while</span>(gap--){<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(lenB--){<br>            <span class="hljs-keyword">if</span>(curA != curB){ <span class="hljs-comment">// ❗️不用 curA-&gt;val != curB-&gt;val, 因为是指针指向同一个元素是相等的</span><br>                curA = curA-&gt;next;<br>                curB = curB-&gt;next;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                <span class="hljs-keyword">return</span> curB; <span class="hljs-comment">// 如果有交点, 后边也全相等 ❗️不用 curB-&gt;val</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3通过: 整体简单</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode* dummyHeadA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* dummyHeadB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHeadA-&gt;next = headA;<br>        dummyHeadB-&gt;next = headB;<br>        ListNode* curA = dummyHeadA;<br>        ListNode* curB = dummyHeadB;<br>        <span class="hljs-type">int</span> LenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA-&gt;next){<br>            curA = curA-&gt;next;<br>            LenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB-&gt;next){<br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        <span class="hljs-keyword">if</span>(LenA &lt; lenB){<br>            <span class="hljs-built_in">swap</span>(dummyHeadA, dummyHeadB);<br>            <span class="hljs-built_in">swap</span>(LenA, lenB);<br>        }<br>        <span class="hljs-type">int</span> gap = LenA - lenB;<br>        ListNode* curA2 = dummyHeadA;<br>        ListNode* curB2 = dummyHeadB;<br>        <span class="hljs-keyword">while</span>(gap--){<br>            curA2 = curA2-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(curA2){<br>            <span class="hljs-keyword">if</span>(curA2 == curB2) <span class="hljs-keyword">return</span> curA2; <span class="hljs-comment">// 💡这里 return 会直接跳出 while 循环</span><br>            curA2 = curA2-&gt;next;<br>            curB2 = curB2-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// ❗️不要忘了 NULL 的情况</span><br><br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v4</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode* dummyHeadA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* dummyHeadB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHeadA-&gt;next = headA;<br>        dummyHeadB-&gt;next = headB;<br>        ListNode* curA = dummyHeadA;<br>        ListNode* curB = dummyHeadB;<br><br>        <br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA-&gt;next){<br>            curA= curA-&gt;next;<br>            lenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB-&gt;next){<br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        curA = headA;<span class="hljs-comment">// ❗️不要重新定义</span><br>        curB = headB;<br><br>        <span class="hljs-keyword">if</span>(lenA &lt; lenB){<br>            <span class="hljs-built_in">swap</span>(lenA, lenB);<br>            <span class="hljs-built_in">swap</span>(curA, curB);<br>        }<br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br><br>        <span class="hljs-keyword">while</span>(gap--){<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(lenB--){ <span class="hljs-comment">// ❗️curB-&gt;next!= NULL, 不知道为啥这样不可以</span><br>            <span class="hljs-keyword">if</span>(curA == curB) <span class="hljs-keyword">return</span> curA;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p><!-- basicblock-start oid="ObsdrGEjg402bVGB7cFhuXak" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::7. 链表相交.md" --> <p>#历史记录::<br>2022/9/13🌵7. 链表相交 : v3通过: 整体简单⏱0-17</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>:<!-- basicblock-start oid="ObsHkPOI5H0zCs3HXDaIsScl" --> <p>获取链表长度::<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 不要操作原指针, 重新定义一个指针, 因为指针会不断的变化, 如果用原来的指针就破坏了原来的结构了</span><br>        ListNode* curA = headA; <span class="hljs-comment">// 操作 headA</span><br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 获取长度</span><br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.删除链表的倒数第N个节点</title>
      <link href="/posts/26499/"/>
      <url>/posts/26499/</url>
      
        <content type="html"><![CDATA[<h1 id="1-19删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#1-19删除链表的倒数第n个节点"></a> 1 19.删除链表的倒数第N个节点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接</a></p><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210510085957392.png" alt="19.删除链表的倒数第N个节点"></p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：</p><p>输入：head = [1], n = 1 输出：[]</p><p>示例 3：<br>输入：head = [1,2], n = 1 输出：[1]</p><!-- basicblock-start oid="ObsGBeuVT8skd0OCjzxKXOoD" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><ol><li>删除准备: 找到倒数第 n 个节点的前一个节点<ul><li>$ 用双指针: 让fast先移动n+1步，</li><li>$ 然后让fast和slow同时移动，直到fast指向<strong>NULL</strong>, 此时 slow 就指向了要删除结点的前一个节点</li></ul></li><li>删除操作: 前一个节点 next 指针指向 后边第二个节点</li></ol><ul><li>&amp;  这个总结的不如直接看 carl 的, 总结的不好<br>![[6.删除链表的倒数第N个节点 2022-09-25 11.45.47.excalidraw]]</li></ul><!-- basicblock-end --><p>![[6.删除链表的倒数第N个节点 2022-08-12 09.22.22.excalidraw|1500]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=": 构造虚拟头结点::">[1]</span></a></sup></span><br>        dummyHead-&gt;next = head;<br>        ListNode* fast = dummyHead;<span class="hljs-comment">// <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label=": 创建链表指针::">[2]</span></a></sup></span><br>        ListNode* slow = dummyHead; <br>        n++;<br>        <span class="hljs-keyword">while</span> (n-- &amp;&amp; fast != <span class="hljs-literal">nullptr</span>){<br>            fast = fast-&gt;next;<br>        }<br>        <span class="hljs-comment">// 如果在上面不用 n++, 在这里多写一个fast-&gt;next ,让 fast 多走一步</span><br>        <span class="hljs-comment">// 结果: n 若为 1000, 上面的 fast 就已经是空了, 而上一行让他多走一步就是操作空指针了</span><br>        <span class="hljs-comment">// 所以安全起见先 n++. 💡另外一个思路: 用空间换时间, 提前都把变量定义好</span><br>        <br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>){<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        ListNode* temp = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* fast = dummyHead;<br>        ListNode* slow = dummyHead;<br>        ListNode* temp;<br>        n += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n){<br>            fast = fast-&gt;next;<br>            n--; <span class="hljs-comment">// ❗️不要忘了控制 n, 也可以写成 while(n--)</span><br>        }<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>){<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        temp = slow-&gt;next ; <span class="hljs-comment">//❗️ 写反了</span><br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp; <span class="hljs-comment">// ❗️不需要括号 delete(temp)</span><br><br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3通过: 进一步理解了<br>v4, 通过, 较熟练</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <br>        dummyHead-&gt;next = head;<br>        ListNode* fast = dummyHead;<span class="hljs-comment">// ❗️不要 fast = head, 统一用虚拟头节点</span><br>        ListNode* slow = dummyHead;<br>        n += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️v4没有写 fast != NULL 条件, 💡这样也通过了</span><br>            fast = fast-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(fast){ <span class="hljs-comment">// 💡此时跳出循环的 fast 已经在 NULL 指针上了</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        }<br>        ListNode* temp = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <br>        <span class="hljs-built_in">delete</span>(temp); <span class="hljs-comment">// 💡可用括号, 可不用</span><br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next; <span class="hljs-comment">// ❗️不要返回 head, 要返回 dummyHead-&gt;next</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><p><code>ListNode* dummyHead = new ListNode(0);</code><br><code>dummyHead-&gt;next = head;</code></p><!-- basicblock-end --><p>ListNode* Index<br>创建二叉树也是一样的<br>TreeNode* node</p><!-- basicblock-end --><!-- basicblock-start oid="Obsli0iVIAJ1RLcnP8KGNujl" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::6.删除链表的倒数第N个节点.md" --> <p>#历史记录::<br>2022/9/13🌵6.删除链表的倒数第N个节点 :v3通过: 进一步理解了⏱0-49</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>:<!-- basicblock-start oid="ObsHPy8Rb5i91VNQZ5Jv20Wv" --> <p>构造虚拟头结点::<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></p></span></span></li><li><span id="fn:2" class="footnote-text"><span>:<p></p><!-- basicblock-start oid="Obsnv2tHjP49t8ASdRAMsF5a" --> <p>创建链表指针::<br><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></p></span></span></li></ol></div></section><p></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 两两交换链表中的节点</title>
      <link href="/posts/58812/"/>
      <url>/posts/58812/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#1-两两交换链表中的节点"></a> 1 两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="24.两两交换链表中的节点-题意|500"></p><!-- basicblock-start oid="Obsm7Zbax7XAcUZ1TeeM3sor" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>使用虚拟头结点</p><p>要想交换两个节点, 首先要把 cur 指针指向两节点的前一个节点</p><p>![[5. 两两交换链表中的节点 2022-08-11 23.49.26.excalidraw]]<br>有关 while 终止条件的判断<br>![[5. 两两交换链表中的节点 2022-08-12 00.20.24.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❗️dummyHead 前需要 ListNode*</span><br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next!=<span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>){ <br>        <span class="hljs-comment">// 💡如果是链表是偶数,最后cur跑到的下一位是 null,如果是奇数位,cur-&gt;next-&gt;next是 null. </span><br>        <span class="hljs-comment">// 两者的位置不能换,如果把 cur-&gt;next-&gt;next!=nullptr, 有可能忽视 cur-&gt;next!=nullptr 的情况</span><br><br>            ListNode* temp1 = cur-&gt;next;<br>            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next;<br><br>            cur-&gt;next = cur-&gt;next-&gt;next; <span class="hljs-comment">// ❗️不需要-&gt;val,cur-&gt;next-&gt;next-&gt;val 💡cur 连到 2</span><br>            cur-&gt;next-&gt;next = temp1;<span class="hljs-comment">// 💡2 连到 1</span><br>            temp1-&gt;next= temp2;<span class="hljs-comment">// ❗️1 连到 3,不能用 </span><br><br>            cur = cur-&gt;next-&gt;next; <span class="hljs-comment">// 移动两位 准备下一轮交换</span><br>        }<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过, 赋值的时候用 tem1. tem2 也行<br>v3, 通过 在纸上画出来那个图, 就好写</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp;&nbsp;cur-&gt;next-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 这样也可以: while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next){</span><br>            ListNode* temp1 = cur-&gt;next;<br>            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next;<br>            <br>            cur-&gt;next = temp1-&gt;next;<br>            temp1-&gt;next-&gt;next = temp1;<br>            temp1-&gt;next = temp2;<br>            <br>            cur = cur-&gt;next-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="Obst2RY54cHyIFOBYSYzWBnP" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::5. 两两交换链表中的节点.md" --> <p>#历史记录::<br>2022/9/13🌵5. 两两交换链表中的节点 :v2通过, 赋值的时候用 tem1. tem2 也行⏱0-17</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. 反转链表</title>
      <link href="/posts/32071/"/>
      <url>/posts/32071/</url>
      
        <content type="html"><![CDATA[<h1 id="1-206反转链表"><a class="markdownIt-Anchor" href="#1-206反转链表"></a> 1 206.反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><!-- basicblock-start oid="ObszBzLzJJYMnKT1ZE20GtzE" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>定义一个 cur 指针指向头结点<br>定义一个 pre 指针初始化为 null</p><!-- basicblock-start oid="ObsdHorCNRIzYgrekNFQjNvX" --> <p>把 cur-&gt;next的指针用 tmp 保存一下::<br>不保存的话一会操作 cur-&gt;next 指针, 原来 cur-&gt;next 连接的元素就会找不到</p><!-- basicblock-end --><ol><li>改变方向<ol><li>cur-&gt;next =  pre;# 2 思路:</li></ol></li><li>while 循环,.移动下一个位置, 直至cur 指向NULL(💡为了让 pre 走到最后一个元素)<ol><li>pre = cur;</li><li>cur = tmp<br>最后，cur 指针已经指向了null，💡pre 指向了最后一个元素(即是第一个节点)循环结束，return pre</li></ol></li></ol><p>![[4. 翻转链表 2022-08-11 21.51.33.excalidraw]]</p><ul><li>时间复杂度：O(n)，其中 nnn 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：O(1)。</li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-迭代法"><a class="markdownIt-Anchor" href="#31-迭代法"></a> 3.1 迭代法</h2><p>v1通过,  双指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* tmp;<br><br>        <span class="hljs-keyword">while</span>(cur){<br>            tmp = cur-&gt;next; <span class="hljs-comment">// ❗️cur-&gt;next = tmp; 目的要把 cur-&gt;next 指针先保存下来,而不是改变他</span><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head; <span class="hljs-comment">// ❗️链表指针的定义: ListNode*</span><br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        ListNode* temp;<br>        <span class="hljs-keyword">while</span>(cur){ <span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]] #历史记录::2022/9/13🌵4. 翻转链表 :“v3: 通过”, “递归法也看了, 很秒, 中间有疑问的” ⏱0-50">[1]</span></a></sup></span><br>            temp = cur-&gt;next; <span class="hljs-comment">// ❗️写反了, 是赋值操作</span><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre; <span class="hljs-comment">// ❗️pre 最后走到了第一个元素, cur 走向了 null</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><s>v3: 没通过, 思路是的对的, 力扣上的参数好像变了,  💡模式是 java 模式</s>~~~~~~~~<br>v3: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>: <br>     <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<span class="hljs-comment">// ❗️不需要虚拟头指针</span><br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur){<br>            ListNode* temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v4:  while 循环里怎么走又忘了, 总结在图里了, 2022/09/25</p><h2 id="32-递归法"><a class="markdownIt-Anchor" href="#32-递归法"></a> 3.2 递归法</h2><p>递归写法<br>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, tmp);<span class="hljs-comment">// ❗️前边还有 return, 把参数返回给下一层</span><br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">nullptr</span>, head);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsFtou7Uh8VHZEr09yW74ms" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::4. 翻转链表.md" --> <p>v2通过::在递归中要想返回 if语句中的返回值, 就在递归前直接加 return, 不要在下边再加操作(会导致回溯)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, temp);<span class="hljs-comment">// 💡没有回溯过程 直接执行的是 if 语句里的操作就退出了</span><br>        <br>        <span class="hljs-comment">// ❗️return pre; 放到 reverse 下边就回溯了, 会不断的回退 pre 指针 </span><br>        <span class="hljs-comment">// ❓有关栈中的操作还不太明白</span><br>        <br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">nullptr</span>, cur);<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<!-- basicblock-start oid="ObsPTlHFiqnNhfmgjUwEkUPi" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::4. 翻转链表.md" --> #历史记录::<br>2022/9/13🌵4. 翻转链表 :“v3: 通过”, “递归法也看了, 很秒, 中间有疑问的” ⏱0-50<!-- basicblock-end --><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 设计链表</title>
      <link href="/posts/40651/"/>
      <url>/posts/40651/</url>
      
        <content type="html"><![CDATA[<h1 id="1-707设计链表"><a class="markdownIt-Anchor" href="#1-707设计链表"></a> 1 707.设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第&nbsp;index&nbsp;个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为&nbsp;val&nbsp;的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为&nbsp;val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第&nbsp;index&nbsp;个节点<strong>之前</strong>添加值为&nbsp;val&nbsp; 的节点。如果&nbsp;index&nbsp;等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引&nbsp;index 有效，则删除链表中的第&nbsp;index 个节点。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200814200558953.png" alt="707示例"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>[[1.  链表理论基础#4 链表的操作]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1: 看 v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> {<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span>{<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>){}<br>    };<br><br>    <span class="hljs-built_in">MyLinkedList</span>() {<br>        _dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❗️不需要用 linkedHead* _dummyHead</span><br>        _size = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❓</span><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; (_size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>){ <span class="hljs-comment">// ❗️不懂_size-1, size 为链表的长度</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>        LinkedNode* cur = _dummyHead-&gt;next; <span class="hljs-comment">// 💡直接指向真实结点的第一个节点</span><br>        <span class="hljs-keyword">while</span>(index--){<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = _dummyHead-&gt;next;<span class="hljs-comment">// 💡虚拟节点的后一个节点才是第一个真实节点</span><br>        _dummyHead-&gt;next = newNode;<br>        _size++;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 添加节点连接后一个节点</span><br>        LinkedNode* cur = _dummyHead; <span class="hljs-comment">// 💡等于_dummyHead-&gt;next也无所谓,目的是找最后一个节点</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){ <span class="hljs-comment">// 找到最后一个节点</span><br>            cur = cur-&gt;next;<br>        }<br>        cur-&gt;next = newNode;<br>        _size++; <span class="hljs-comment">// ❗️不要忘了总长度+1</span><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>{ <span class="hljs-comment">// 是在第 index 前插入一个节点</span><br>        <span class="hljs-keyword">if</span> (index &gt; _size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead; <span class="hljs-comment">// 💡是在第 index 前插入一个节点,所以找的是 index 前的节点,如果是 dummyHead-&gt;next, 就找到了第 Index 的位置</span><br>        <span class="hljs-keyword">while</span>(index--){ <span class="hljs-comment">// 找到第 index 前号元素<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]] #历史记录::2022/9/13🌵3. 设计链表 :v2: 调整了一下顺序, 改变了了一下变量名字, 使代码更加好读了, 没有动手写一遍⏱0-25">[1]</span></a></sup></span><br>            cur = cur-&gt;next;<br>        }<br>        newNode-&gt;next = cur-&gt;next;<span class="hljs-comment">// ❗️注意不是 cur-&gt;next-&gt;next</span><br>        cur-&gt;next = newNode;<br>        _size++;<br><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>          <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* cur = _dummyHead;<span class="hljs-comment">// ❓</span><br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur -&gt;next;<br>        }<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        _size--;<br>    }<br><br>    <br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span> </span>{<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;<br>            cur = cur-&gt;next;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">private</span>: <span class="hljs-comment">// 放到 public 上面则编译不通过</span><br>    <span class="hljs-type">int</span> _size;<br>    LinkedNode* _dummyHead;<br><br>};<br></code></pre></td></tr></tbody></table></figure><p>v2: 调整了一下顺序, 改变了了一下变量名字, 使代码更加好读了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> {<br><span class="hljs-keyword">private</span>:<br><br>        <span class="hljs-comment">// 定义链表节点结构体</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span> {<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>){}<br>    };<br><br>    <span class="hljs-type">int</span> size;<br>    LinkedNode* dummyHead;<br><br><br><span class="hljs-keyword">public</span>:<br><br><br>    <span class="hljs-comment">// 初始化链表</span><br>    <span class="hljs-built_in">MyLinkedList</span>() {<br>        dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span><br>        size = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; (size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>        LinkedNode* cur = dummyHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(index--){ <span class="hljs-comment">// 如果--index 就会陷入死循环</span><br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    }<br><br>    <span class="hljs-comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = dummyHead-&gt;next;<br>        dummyHead-&gt;next = newNode;<br>        size++;<br>    }<br><br>    <span class="hljs-comment">// 在链表最后面添加一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){<br>            cur = cur-&gt;next;<br>        }<br>        cur-&gt;next = newNode;<br>        size++;<br>    }<br><br>    <span class="hljs-comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span><br>    <span class="hljs-comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span><br>    <span class="hljs-comment">// 如果index大于链表的长度，则返回空</span><br>    <span class="hljs-comment">// 如果index小于0，则置为0，作为链表的新头节点。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur-&gt;next;<br>        }<br>        newNode-&gt;next = cur-&gt;next;<br>        cur-&gt;next = newNode;<br>        size++;<br>    }<br><br>    <span class="hljs-comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt;= size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur -&gt;next;<br>        }<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        size--;<br>    }<br><br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span> </span>{<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;<br>            cur = cur-&gt;next;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<!-- basicblock-start oid="ObsMSRQ9GYQ6MckHgJGq5DWz" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::3. 设计链表.md" --> #历史记录::<br>2022/9/13🌵3. 设计链表 :v2: 调整了一下顺序, 改变了了一下变量名字, 使代码更加好读了, 没有动手写一遍⏱0-25<!-- basicblock-end --><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 移除链表元素</title>
      <link href="/posts/25411/"/>
      <url>/posts/25411/</url>
      
        <content type="html"><![CDATA[<h1 id="1-203移除链表元素"><a class="markdownIt-Anchor" href="#1-203移除链表元素"></a> 1 203.移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1：<br>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p><p>示例 2：<br>输入：head = [], val = 1<br>输出：[]</p><p>示例 3：<br>输入：head = [7,7,7,7], val = 7<br>输出：[]</p><!-- basicblock-start oid="ObsToulOLeqVDEnA8N2uNNiV" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>删除普通元素<br>使用 C, C++语言记得要清理删除的内存<br><img src="https://img-blog.csdnimg.cn/20210316095351161.png" alt="203_链表删除元素1|600"></p><p>删除头结点</p><ul><li><strong>设置一个虚拟头结点在进行删除操作。</strong>(不需要额外的操作)</li><li>直接使用原来的链表来进行删除操作。(需要额外的操作)</li></ul><p>![[2. 移除链表元素 2022-08-11 11.00.43.excalidraw|1500]]</p><h2 id="21-总结"><a class="markdownIt-Anchor" href="#21-总结"></a> 2.1 总结</h2><!-- basicblock-start oid="ObsSRgRVqGrwJjsLLBcm71oT" --> <p>如何设置一个虚拟头结点来操持一个统一的删除操作::</p><ol><li>先创建一个表头链表 dummyHead : <code>new ListNode(0</code>); <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[C++ new的用法]]">[1]</span></a></sup></li><li>在把 head 链表接到dummyhead 上 : dummyHead -&gt; next = head</li><li>创建一个新 cur 链表, 以后在 cur 链表上操作, 因为 cur 要不断变化, 不能让影响到原来的数组了</li></ol><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208111134829.gif" alt="|1100"></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>        ListNode* dummyHead  = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <br>        dummyHead-&gt;next = head; <br>        ListNode* cur  = dummyHead; <span class="hljs-comment">// 💡用了一个指针指向了 dummyHead 用来操作 dummyHead 中元素</span><br>        <span class="hljs-comment">// ❗️不能直接用 dummyHead-&gt;next, 因为只要就把 dummyHead 的链表改变了</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val){<span class="hljs-comment">// ❗️是cur-&gt;next-&gt;val,不是 cur-&gt;next</span><br>                ListNode* temp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> temp;<span class="hljs-comment">// 💡💡删除的是 dummyHead 的元素,因为操作的是指针</span><br>            }<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;next;<span class="hljs-comment">// 将下一个元素做为头结点</span><br><br>        } <br>        <span class="hljs-comment">// return cur // ❗️因为 cur 的链表是越来越小的</span><br>        head = dummyHead-&gt;next;<span class="hljs-comment">// 💡因为dummyHead 的一个元素是创造出来的</span><br>        <span class="hljs-keyword">delete</span> dummyHead;<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs2fSenrd948BZYQ4eNfI6H" --> <p>v2通过::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造虚拟头结点:   </span><br>ListNode* dummyHead = new ListNode(<span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️❗️不是 cur != NULL, 💡因为 往后移动是cur = cur-&gt;next, cur-&gt;next已经是 NULL 的时候就是到了最后一个元素了</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val){<br>                ListNode* temp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next; <span class="hljs-comment">// 💡也可以这样:cur-&gt;next = temp-&gt;next;</span><br>                <span class="hljs-keyword">delete</span> temp;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                cur = cur-&gt;next;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obsobgw1VATI68hRHB2QcVsT" --> <p>while(cur-&gt;next == NULL), 说明 cur到了链表的最后一个元素::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummyHead-&gt;next = head;<br>    ListNode* cur = dummyHead;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️❗️不是 cur != NULL, 💡因为 往后移动是cur = cur-&gt;next, cur-&gt;next已经是 NULL 的时候💡表明 cur已经到了最后一个元素了</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p><!-- basicblock-start oid="ObsngUPBW6FCyRYJz7EGM9UV" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::2. 移除链表元素.md" --> <p>#历史记录::<br>2022/9/13🌵2. 移除链表元素 : v2, 熟悉一下⏱0-25</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[C++ new的用法]]<p><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></p></span></span></li></ol></div></section><p></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.  链表理论基础</title>
      <link href="/posts/22854/"/>
      <url>/posts/22854/</url>
      
        <content type="html"><![CDATA[<h1 id="1-链表的类型"><a class="markdownIt-Anchor" href="#1-链表的类型"></a> 1 链表的类型::</h1><p><strong>链表由数据域和指针域组成</strong></p><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链接的入口节点称为链表的头结点也就是head。</p><p>![[1.  链表理论基础 2022-08-11 09.54.44.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="Obs6RXwhjLDgRAOHUFiOci9w" --> <h1 id="2-链表的存储方式"><a class="markdownIt-Anchor" href="#2-链表的存储方式"></a> 2 链表的存储方式::</h1><!-- basicblock-end --><p>数组是在内存中是连续分布的，<strong>链表是随机分布的,</strong> 他们通过指针来连接彼此,<br>散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。<br>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200806194613920.png" alt="链表3"><br>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p><!-- basicblock-start oid="ObsHVTAYsxhrbeARWSl3ATOM" --> <h1 id="3-链表的定义"><a class="markdownIt-Anchor" href="#3-链表的定义"></a> 3 链表的定义::</h1><!-- basicblock-end --><p>在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p><p>而在面试的时候，一旦要自己手写链表，就写的错漏百出</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) {}  <span class="hljs-comment">// 💡自己节点的构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>{</span><br><span class="hljs-type">int</span> val;<br>ListNode *next;<br>ListNode(<span class="hljs-type">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>){}<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。<br>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p><p>通过自己定义构造函数初始化节点：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></tbody></table></figure><p>使用默认构造函数初始化节点：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</strong></p><h1 id="4-链表的操作"><a class="markdownIt-Anchor" href="#4-链表的操作"></a> 4 链表的操作</h1><!-- basicblock-start oid="ObsgnxP8Llhuq4SUf4kQxCT7" --> <h2 id="41-删除结点"><a class="markdownIt-Anchor" href="#41-删除结点"></a> 4.1 删除结点::</h2><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"><br>将 C 的 next 指针指向 E💡将要删除的元素的一个 next 指针指向下下个元素</p><blockquote><p>提前保存 D, 不然找不到了</p></blockquote><p>时间复杂度: O(n)💡如果删除最后一个元素则需要从头结点查找到第 n - 1 个元素修改其 next 指针</p><p>D 节点依然留在内存里<br>在C++里最好是再手动释放这个D节点，释放这块内存。<br>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p><!-- basicblock-start oid="ObsB8Ic2s4aidibg9H5W3Vrz" --> <h2 id="42-添加节点"><a class="markdownIt-Anchor" href="#42-添加节点"></a> 4.2 添加节点::</h2><!-- basicblock-end --><p>![[1.  链表理论基础 2022-08-11 18.07.26.excalidraw]]<br>时间复杂度 O(1), 链表直接能够通过指针查找到元素. 相当于数组通过下标直接找到元素, 找到元素的操作只进行一次所以是 O(1)的时间复杂度</p><!-- basicblock-start oid="ObsU2bUkgfucsnlo2MMrjtJB" --> <h2 id="43-性能分析总结"><a class="markdownIt-Anchor" href="#43-性能分析总结"></a> 4.3 性能分析总结::</h2><!-- basicblock-end --><p>![[1.  链表理论基础 2022-09-20 09.59.14.excalidraw]]</p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7. 总结篇</title>
      <link href="/posts/60314/"/>
      <url>/posts/60314/</url>
      
        <content type="html"><![CDATA[<p>![[7. 总结篇 2022-09-13 09.36.58.excalidraw]]</p><hr><p><strong>参考资料</strong></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环不变量原则</title>
      <link href="/posts/53061/"/>
      <url>/posts/53061/</url>
      
        <content type="html"><![CDATA[<p>循环不变量, 不变量: 每次处理的规则::<br>[[2.  二分查找]] : 每次 for 循环中的处理区间都要按照原区间的方式, 那么左闭右闭, 那么左闭右开</p><blockquote><p>在循环中坚持对区间的定义</p></blockquote><p>[[6.螺旋矩阵II]]: 每次赋值的数量: 从起始元素到最后一个元素的前一个元素. 属于是左闭右开类型</p><!-- basicblock-end --><hr><p><strong>参考资料</strong></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.螺旋矩阵II</title>
      <link href="/posts/2078/"/>
      <url>/posts/2078/</url>
      
        <content type="html"><![CDATA[<h1 id="1-59螺旋矩阵ii"><a class="markdownIt-Anchor" href="#1-59螺旋矩阵ii"></a> 1 59.螺旋矩阵II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p>给定一个正整数&nbsp;n，生成一个包含 1 到&nbsp;n^2&nbsp;所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p>如果输入 4 , 则输出 4 * 4的矩阵, 输出的是正方形的螺旋矩阵.</p><!-- basicblock-start oid="Obs7dMcCKUKC9wvZVVJaT5g5" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>大家还记得我们在这篇文章<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">数组：每次遇到二分法，都是一看就会，一写就废</a><br>中讲解了二分法，提到如果要写出正确的二分法一定要坚持[[循环不变量原则]]。<br>循环不变量:  不变量是我们队每条边的一个处理规则</p><p>而求解本题依然是要坚持循环不变量原则。<br>不变量: <strong>每次只处理第一个元素到最后元素的前一个</strong></p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。<br>![[6.螺旋矩阵II 2022-08-10 16.27.14.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1</p><pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generateMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid  = n / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来控制长度</span>        <span class="hljs-keyword">int</span> loop  = n / <span class="hljs-number">2</span>;         <span class="hljs-keyword">while</span>(loop--){            <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// 设置成全局变量, 因为下面也要用</span>            <span class="hljs-keyword">int</span> j;             <span class="hljs-keyword">for</span>(j = startx; j &lt; n - offset; j++){                res[startx][j] = count;<span class="hljs-comment">// 可以成一行 count++</span>                count++;             }            <span class="hljs-keyword">for</span>(i = starty; i&lt; n - offset; i++){<span class="hljs-comment">// 💡上面 j已经+1 跳出了循环. 已经在边界了</span>                res[i][j] = count++;             }            <span class="hljs-keyword">for</span>(; j &gt; startx; j--){<span class="hljs-comment">// 要大于 startx 而不是 0, 因为下一层循环还要用</span>                res[i][j] = count++;             }             <span class="hljs-keyword">for</span>(; i &gt; starty; i--){                res[i][j] = count++;             }            startx++;             starty++;             offset += <span class="hljs-number">1</span>;         }         <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {            res[mid][mid] = count;        }        <span class="hljs-keyword">return</span> res;    }```v2: 思路好理解, 代码忘了, 又重新总结了一遍```c++<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generateMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>(n, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = n/<span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> loop = n/<span class="hljs-number">2</span>;        <span class="hljs-comment">// eg 3 * 3 矩阵</span>        <span class="hljs-keyword">while</span>(loop--){            <span class="hljs-keyword">int</span> i , j ;            <span class="hljs-keyword">for</span>(j = starty; j &lt; n - offset; j++){                res[startx][j] = count++; <span class="hljs-comment">// i: 第一行, j: 0 → 1 列 </span>            }            <span class="hljs-keyword">for</span>(i = startx; i &lt; n - offset; i++){                res[i][j] = count++; <span class="hljs-comment">// i: 0 → 1 行, j: 第2 列</span>            }            <span class="hljs-keyword">for</span>(; j &gt; starty; j--){                res[i][j] = count++; <span class="hljs-comment">// i:第 2 行, j: 2 → 1 列</span>            }            <span class="hljs-keyword">for</span>(; i  &gt; startx; i--){                res[i][j] = count++;<span class="hljs-comment">// i: 2 → 1 行, j: 0 列</span>            }            startx++;            starty++;            offset++;        }        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){            res[mid][mid] = count;        }        <span class="hljs-keyword">return</span> res;    }};```![[<span class="hljs-number">6.</span>螺旋矩阵II <span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-20</span> <span class="hljs-number">09.42</span><span class="hljs-number">.34</span>.excalidraw]]--- **参考资料** &lt;!-- basicblock-start oid=<span class="hljs-string">"ObshAxTPLS8lbxFjeyvrSbN9"</span> deck = <span class="hljs-string">"👨🏻‍💻code::数据结构与算法::代码随想录::数组::6.螺旋矩阵II.md"</span> --&gt; #历史记录:: <span class="hljs-number">2022</span>/<span class="hljs-number">9</span>/<span class="hljs-number">12</span>🌵<span class="hljs-number">6.</span>螺旋矩阵II :v2: 思路好理解, 代码忘了, 又重新总结了一遍⏱<span class="hljs-number">0</span><span class="hljs-number">-37</span>&lt;!-- basicblock-<span class="hljs-built_in">end</span> --&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针法总述</title>
      <link href="/posts/57173/"/>
      <url>/posts/57173/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>参考资料</strong></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 双指针法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5. 长度最小的子数组</title>
      <link href="/posts/31461/"/>
      <url>/posts/31461/</url>
      
        <content type="html"><![CDATA[<h1 id="1-209长度最小的子数组"><a class="markdownIt-Anchor" href="#1-209长度最小的子数组"></a> 1 209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p>给定一个含有&nbsp;n&nbsp;个正整数的数组和一个正整数&nbsp;s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组&nbsp;[4,3]&nbsp;是该条件下的长度最小的子数组。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p>两个 for 循环不断寻找符合条件的子序列, 时间复杂度: O(n^2), 空间复杂度 O(1)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">// 最终的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的数值之和</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 设置子序列起点为i</span><br>            sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) { <span class="hljs-comment">// 设置子序列终止位置为j</span><br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= s) { <span class="hljs-comment">// 一旦发现子序列和超过了s，更新result</span><br>                    subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 取子序列的长度</span><br>                    result = result &lt; subLength ? result : subLength;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br>                }<br>            }<br>        }<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-滑动窗口"><a class="markdownIt-Anchor" href="#22-滑动窗口"></a> 2.2 滑动窗口</h2><p>滑动窗口的本质还是双指针, 因为只取起始指针和终止指针范围内的值,所以称为滑动窗口</p><p>滑动窗口: <strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>只用一个 for 循环解决暴力循环中两个 for 循环的操作</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。<br>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？<br>此时难免再次陷入 暴力解法的怪圈。<br>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p><!-- basicblock-start oid="ObsWSJkFvX4JeAi5ct8r48Lr" --> <p>s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程::</p><ol><li>j指针去右边, i 不动; 找到符合条件的 i 向右, j 不动, 如果还符合条件, i 继续向右, 直至破坏条件啊改革￥</li><li>不符合条件，j 向右, 重复 1</li><li>直到找到最短的窗口长度<br><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></li></ol><p><img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209|600"></p><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)</strong></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>            sum += nums[j];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target){<br>                subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>                result = subLength &lt; result ? subLength : result;<br>                sum -= nums[i]; <span class="hljs-comment">// 缩短一个数之后的和</span><br>                i++; <span class="hljs-comment">// 缩短区间,💡i不断的++,直至能sum &lt; target 跳出 while 循环</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">0</span> : result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p><p>v2, 通过, 代码忘了, 重新抄了一遍</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>             sum += nums[j];<br>             <span class="hljs-keyword">while</span>(sum &gt;= target){<br>                 subLength = j - i + <span class="hljs-number">1</span>;<br>                 result = subLength &lt; result ? subLength : result;<br>                 sum -= nums[i];<br>                 i++;<br>             }<br>        }<br>        <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">0</span> : result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录</a></p><!-- basicblock-start oid="ObssZGKpwsPauoiKJmWNZfye" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::5. 长度最小的子数组.md" --> <p>#历史记录::<br>2022/09/12🌵5. 长度最小的子数组 : v2, 通过, 代码和思路都忘了, 重新抄了一遍</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器的使用</title>
      <link href="/posts/21713/"/>
      <url>/posts/21713/</url>
      
        <content type="html"><![CDATA[<h1 id="1-vector"><a class="markdownIt-Anchor" href="#1-vector"></a> 1 vector</h1><p>![[vector#1 1 初始化]]</p><h1 id="2-array"><a class="markdownIt-Anchor" href="#2-array"></a> 2 array</h1><p>int arrayName [arraySize] :<br>其中 arraySize <strong>不能是变量</strong>,必须是整型常数(如1 0 )或const值,也可以是常量表达式(如8 * sizeof ( int)</p><p>eg : int a [10] = {0}; // ❗️不是一个数的一个要有大括号</p><h1 id="3-deque"><a class="markdownIt-Anchor" href="#3-deque"></a> 3 deque</h1><p>![[容器的使用 2022-08-23 16.53.55.excalidraw]]<br>函数:<br>push_back(); 加到尾部<br>pop_front(); 弹出头部<br>pop_back(); 弹出尾部<br>deque.pop(); 首部元素</p><hr><p><strong>参考资料</strong>—</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4. 有序数组的平方</title>
      <link href="/posts/34285/"/>
      <url>/posts/34285/</url>
      
        <content type="html"><![CDATA[<h1 id="1-977有序数组的平方"><a class="markdownIt-Anchor" href="#1-977有序数组的平方"></a> 1 977.有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObsrBtXgtkLp1sP3ZfK1ov7B"  --> <h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法::</h2><p>每个数平方之后，排个序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) {<br>            A[i] *= A[i];<br>        }<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 快速排序</span><br>        <span class="hljs-keyword">return</span> A;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>for 循环中乘了 n 次, 时间复杂度为 O(n), <strong>sort 快速排序<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[时间复杂度分析]]">[1]</span></a></sup>O(nlogn)</strong>, 两个函数取大者,总体的时间复杂度为 O(nlogn)</p><blockquote><p>这个时间复杂度本质是 O(n + nlogn)， 取完大头为 O(nlogn)</p></blockquote><!-- basicblock-end --><!-- basicblock-start oid="ObsvJq0mwTJDUyANI6CdXJWo" --> <h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法::</h2><p>数组有序,数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>用两个指针指向头尾, 逐步向中间靠拢, 不断的寻找: <code>数组元素平方的第一大,</code> <code>第二大</code>, …<br>因为每次找的是最大值, 所以结果集中,从后往前赋值. 因为题目要求返回的是递增数组</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt=""></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[容器的使用]]<br>v1</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">sortedSquares</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> {<br>        <span class="hljs-comment">// int i = 0;</span><br>        <span class="hljs-comment">// int j = nums.size() - 1;</span><br>        <span class="hljs-comment">//💡 i 和 j 是要不断循环动的,要写在 for 循环中</span><br>    <br>        <span class="hljs-type">int</span> k = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">result</span><span class="hljs-params">(k+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        <span class="hljs-comment">// i 指向头, j 指向尾</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j = nums.size()<span class="hljs-number">-1</span>; i &lt;= j; ){ <span class="hljs-comment">// 要在元素平方的大小,控制 i,j 的移动</span><br>            <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j] ){<br>                result[k] = nums[i]*nums[i];<br>                k--;<span class="hljs-comment">// 以后要更新结果集的前一个数了,可以在上边直接写成 result[k--]</span><br>                i++;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                result[k] = nums[j]*nums[j];<br>                k--;<br>                j--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>v2,通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(k+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt;= j; ){ <span class="hljs-comment">// 💡在下边控制变量</span><br>            <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]){<br>                vec[k] = nums[i] * nums[i];<br>                k--;<br>                i++;<br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// ❗️不是 else if</span><br>                vec[k] = nums[j] * nums[j];<br>                k--;<br>                j--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> vec;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsXDGFP98ixtrzW0eTavVbh" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::4. 有序数组的平方.md" --> <p>#历史记录::<br>2022/9/11🌵4. 有序数组的平方v2: 复习了一下, 重点是在 for 循环语句里, 控制控制变量的大小⏱0-19</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[时间复杂度分析]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 移除元素</title>
      <link href="/posts/37506/"/>
      <url>/posts/37506/</url>
      
        <content type="html"><![CDATA[<h1 id="1-移除元素"><a class="markdownIt-Anchor" href="#1-移除元素"></a> 1 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><p>给你一个数组 nums&nbsp;和一个值 val，你需要 原地 移除所有数值等于&nbsp;val&nbsp;的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例&nbsp;2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObsQdeRr1Pcsq043uh3NKoQm" --> <p>为什么数组元素不能删除? ::</p><ul><li>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。</li><li>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。[[vector]]</li></ul><!-- basicblock-end --><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p><strong>发现需要移除的元素,就将数组集体向前移动一位</strong><br>两层 for 循环, 一个遍历数组,一个更新数组</p><p>时间复杂度: O(n^2) : 第一层for 循环找 n 次, 第二层 for 循环更新n 次, 总时间复杂度为 O(n^2)<br>空间复杂度:O(1): 没有新增空间</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif" alt="27.移除元素-暴力解法"><br>暴力解法</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++){ <span class="hljs-comment">// ❗️如果 i &lt; nums.size() 会导致超时, 还是能用常量用常量</span><br>           <span class="hljs-keyword">if</span>(nums[i] == val){<br>               <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;nums.<span class="hljs-built_in">size</span>(); j++){<br>                   nums[j<span class="hljs-number">-1</span>] =nums[j]; <span class="hljs-comment">// 💡从 i 后边的元素都往前覆盖</span><br>               }<br>                i--; <span class="hljs-comment">// ❓💡因为下标i以后的数值都向前移动了一位，所以i也向前移动一位, 会指向了移动后的元素, 继续判断</span><br>                len--;<br>           }<br><br>    }<br>    <span class="hljs-keyword">return</span> len;<br><br>    }  <br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obssbrg6qzSFSKw0WwpEgsBQ" --> <h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法::</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>快指针: 寻找新数组的元素 (查找 n 次, 即 O(n)的时间复杂度)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=": [[1.  链表理论基础#4 3 性能分析]]">[1]</span></a></sup><br>慢指针: 新数组的下标值<br>总结: 将快指针或者的元素赋给, 慢指针的所对应的下标值<br>![[双指针目录#1 通过快慢指针给新数组赋值 快指针指向元素 慢指针指向下标]]</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>一刷: 通过<br>双指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++){ <span class="hljs-comment">// 类似 int i ,i在不断的跑起来</span><br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val){<br>                nums[slowIndex] = nums[fastIndex]; <span class="hljs-comment">// 给新数组的下标赋值</span><br>                slowIndex++; <span class="hljs-comment">// 下次更新下一个位置</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> slowIndex;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; <br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(fastIndex; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++){<br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val){<br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            }<br>        }<br>        <span class="hljs-comment">// ❗️不能返回slowIndex + 1, 每添加一个元素 slow 就会 +1 , 最后当slow 就是新数组的长度</span><br>        <span class="hljs-keyword">return</span> slowIndex;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(fastIndex; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++){<br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val){<br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> slowIndex; <span class="hljs-comment">// 💡每加一个元素都+1, 即最后 slowIndex 就是长度</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p><!-- basicblock-start oid="ObshZuJ6iOHEpWtCNkhtdFTs" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::3. 移除元素.md" --> <p>#历史记录::<br>2022/9/11🌵3. 移除元素 : v3, 有点忘了, 又熟悉了一下⏱0-15</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>: [[1.  链表理论基础#4 3 性能分析]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 二分查找</title>
      <link href="/posts/42878/"/>
      <url>/posts/42878/</url>
      
        <content type="html"><![CDATA[<h1 id="1-704二分查找"><a class="markdownIt-Anchor" href="#1-704二分查找"></a> 1 704二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>给定一个&nbsp;n&nbsp;个元素有序的（升序）整型数组&nbsp;nums 和一个目标值&nbsp;target &nbsp;，写一个函数搜索&nbsp;nums&nbsp;中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [-1,0,3,5,9,12], target =<span class="hljs-number"> 9 </span>    <br>输出:<span class="hljs-number"> 4 </span>      <br>解释:<span class="hljs-number"> 9 </span>出现在 nums 中并且下标为<span class="hljs-number"> 4 </span>    <br></code></pre></td></tr></tbody></table></figure><p>示例&nbsp;2:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="hljs-section">输出: -1        </span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1        </span><br></code></pre></td></tr></tbody></table></figure><p>提示：</p><ul><li>你可以假设 nums&nbsp;中的所有元素是不重复的。</li><li>n&nbsp;将在&nbsp;[1, 10000]之间。</li><li>nums&nbsp;的每个元素都将在&nbsp;[-9999, 9999]之间。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObssiM911QvHWwBhMfNhzsy3" --> <p>二分法使用的前提::</p><ol><li>有序数组<ol><li>能够循环在左右区间内查找</li></ol></li><li>无重复的元素<ol><li>有重复的元素返回的下标不唯 1,</li></ol></li></ol><p>区间的定义决定了二分法的代码怎么写,<br><strong>记住一个原则更新区间端点的时候要保持同步,</strong></p><ul><li>左闭右闭要一直保持左闭右闭</li><li>左闭右开要一直保持左闭右开</li></ul><!-- basicblock-end --><!-- basicblock-start oid="Obsf8CaPBZHUma8XPIymDnOP" --> <h2 id="21-数组为左闭右闭区间-a-g"><a class="markdownIt-Anchor" href="#21-数组为左闭右闭区间-a-g"></a> 2.1 数组为左闭右闭区间: [a, … ,g] ::</h2><p>定义int 类型的 left(头), right(尾)<br>也就是target 在一个[left, right]数组中,left 可能等于 right</p><p>![[二分查找 2022-08-08 12.08.05.excalidraw|1500]]</p><p><strong>定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (target &lt; nums[middle] ) ,right 赋值middle - 1，因为当前这个nums[middle]一定不是target(已经大于了,当然不是) ，那么接下来要查找的左区间(小区间), 结束下标位置就是 middle - 1</li></ul><!-- basicblock-end --><h2 id="22-数组为左闭右开"><a class="markdownIt-Anchor" href="#22-数组为左闭右开"></a> 2.2 数组为左闭右开</h2><p>target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li><p>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</p></li><li><p>if (nums[middle] &gt; target) right 更新为 middle，因为是左闭右开区间,target 取不到 middle ,最多取到 middle 前一个值 ,因为 [left, middle)</p></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-左闭右闭"><a class="markdownIt-Anchor" href="#31-左闭右闭"></a> 3.1 左闭右闭</h2><p>v1,左闭右闭编译已通过,</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right){<br>            <span class="hljs-type">int</span> middle =  left + (right - left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//❗️ middle 要不断的更新所以要放到while里边去</span><br>            <span class="hljs-keyword">if</span> (target &lt; nums[middle]) { <span class="hljs-comment">// 在左区间里,更新右边界</span><br>            right = middle <span class="hljs-number">-1</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[middle]){ <span class="hljs-comment">// 在右区间里更新,更新左边界</span><br>            left = middle +<span class="hljs-number">1</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<span class="hljs-comment">// ❗️返回下标值,前边要加 else 不然直接返回 middle 了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right){<br>            <span class="hljs-type">int</span> middle = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[middle]) left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// ❗️不是 target &lt; middle 哦</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[middle]) right = middle - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 💡最后一个就是 target = middle 的情况</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-左开右开"><a class="markdownIt-Anchor" href="#32-左开右开"></a> 3.2 左开右开</h2><p>左闭右开的无法填入示例</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 整体区间要一直保持左闭右开</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right){<br>            <span class="hljs-type">int</span> middle =  left + (right - left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//💡 middle 要不断的更新所以要放到里边去</span><br>            <span class="hljs-keyword">if</span> (target &lt; nums[middle]) { <span class="hljs-comment">// 在左区间里,更新右边界</span><br>            right = middle; <span class="hljs-comment">// 保持右开</span><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[middle]){ <span class="hljs-comment">// 在右区间里更新,更新左边界</span><br>            left = middle +<span class="hljs-number">1</span>; <span class="hljs-comment">//保持左闭</span><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<span class="hljs-comment">// 💡返回下标值,前边要加 else 不然直接返回 middle 了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsjIzNqB6ALbk7VC1vTeqQq" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::2.  二分查找.md" --> <p>#历史记录::<br>2022/9/11🌵2. 二分查找 : 只看了左闭右闭 , 完成v2 代码⏱0-37</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/posts/35590/"/>
      <url>/posts/35590/</url>
      
        <content type="html"><![CDATA[<ul><li>10 进制逢 10 进 1,</li><li>2 进制逢 2 进 1</li><li>16 进制逢 16 进 1</li></ul><p>![[进制转换 2022-08-08 10.12.38.excalidraw]]</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208081030695.png" alt=""></p><hr><p><strong>参考资料</strong><br><a href="https://www.bilibili.com/video/BV1PK411g7vy/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">【最强干货】详解二进制，八进制，十进制，十六进制的相互转换_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1. 数组理论基础</title>
      <link href="/posts/52749/"/>
      <url>/posts/52749/</url>
      
        <content type="html"><![CDATA[<h1 id="1-一维数组"><a class="markdownIt-Anchor" href="#1-一维数组"></a> 1 一维数组::</h1><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong><br>数组可以方便的通过下标索引的方式获取到下标下对应的数据。<br><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png" alt="算法通关数组"></p><ul><li><mark><strong>数组下标都是从0开始的。</strong></mark></li><li><mark><strong>数组内存空间的地址是连续的</strong>, <strong>数组的元素是不能删的，只能覆盖。</strong></mark></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong><br>进行删除操作,后边的数据整体移动到了前边<br>❓移动数据的复杂度是多少 💡: O(n) [[1.  链表理论基础#4 3 性能分析总结]]</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png" alt="算法通关数组1|700"></p><p>而且大家如果使用C++的话，要注意vector 和 array(数组)的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector]]">[1]</span></a></sup></p><!-- basicblock-end --><!-- basicblock-start oid="ObsWUSn32Fd2altPLt8ZcpVE" --> <h1 id="2-二维数组"><a class="markdownIt-Anchor" href="#2-二维数组"></a> 2 二维数组::</h1><h2 id="21-c"><a class="markdownIt-Anchor" href="#21-c"></a> 2.1 C++</h2><p><strong>C++中二维数组是连续分布</strong>的</p><p>我们来做一个实验，C++测试代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_arr</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = {<br>{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>},<br>{<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}<br>    };<br>    cout &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] &lt;&lt; endl;<br>    cout &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_arr</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>测试地址为</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x7ffee4065820</span> <span class="hljs-number">0x7ffee4065824</span> <span class="hljs-number">0x7ffee4065828</span><br><span class="hljs-number">0x7ffee406582c</span> <span class="hljs-number">0x7ffee4065830</span> <span class="hljs-number">0x7ffee4065834</span><br></code></pre></td></tr></tbody></table></figure><p>注意地址为16进制<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label="[[进制转换]]</a></sup></p><a href="#fn:2" rel="footnote"></a><p><a href="#fn:2" rel="footnote">#历史记录::<br>2022/9/11: 第一次创建<br>"&gt;[2]</a>，可以看出二维数组地址是连续一条线的。</p><p>![[数组理论基础 2022-08-08 10.31.06.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsTa39d5VcQuvvfcvNEhPZP" --> <h2 id="22-java中的数据存放"><a class="markdownIt-Anchor" href="#22-java中的数据存放"></a> 2.2 java中的数据存放::</h2><!-- basicblock-end --><p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p><p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_arr</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span>[][] arr = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>}, {<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>}};<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    System.out.println(arr[<span class="hljs-number">1</span>]);<br>    System.out.println(arr[<span class="hljs-number">2</span>]);<br>    System.out.println(arr[<span class="hljs-number">3</span>]);<br>}<br></code></pre></td></tr></tbody></table></figure><p>输出的地址为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[I@<span class="hljs-number">7852e922</span><br>[I@<span class="hljs-number">4e25154f</span><br>[I@70dea4e<br>[I@5c647e05<br></code></pre></td></tr></tbody></table></figure><p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p><p>所以Java的二维数组可能是如下排列的方式：</p><p><img src="https://img-blog.csdnimg.cn/20201214111631844.png" alt="算法通关数组3|600"></p><p>这里面试中数组相关的理论知识就介绍完了。</p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[vector]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[进制转换]]<!-- basicblock-start oid="ObsjNmD39YUkPHmsEn4iue5d" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::1. 数组理论基础.md" --> #历史记录::<br>2022/9/11: 第一次创建<!-- basicblock-end --><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码内存消耗</title>
      <link href="/posts/60393/"/>
      <url>/posts/60393/</url>
      
        <content type="html"><![CDATA[<h1 id="1-不同语言的内存管理"><a class="markdownIt-Anchor" href="#1-不同语言的内存管理"></a> 1 不同语言的内存管理</h1><p>不同的编程语言各自的内存管理方式。</p><p><strong>-   C/C++这种内存堆空间的申请和释放完全靠自己管理</strong></p><ul><li>Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出</li><li>Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。</li></ul><p>例如Python万物皆对象，并且将内存操作封装的很好，<strong>所以python的基本数据类型所用的内存会要远大于存放纯数据类型所占的内存</strong>，例如，我们都知道存储int型数据需要四个字节，但是使用Python 申请一个对象来存放数据的话，所用空间要远大于四个字节。</p><h1 id="2-c的内存管理"><a class="markdownIt-Anchor" href="#2-c的内存管理"></a> 2 C++的内存管理</h1><p>以C++为例来介绍一下编程语言的内存管理。</p><p>如果我们写C++的程序，就要知道栈和堆的概念，程序运行时所需的内存空间分为 固定部分，和可变部分，如下：</p><p><img src="https://img-blog.csdnimg.cn/20210309165950660.png" alt="C++内存空间"></p><p>固定部分的内存消耗 是不会随着代码运行产生变化的， 可变部分则是会产生变化的</p><p>更具体一些，一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ul><li>栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。</li><li>堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回</li><li>未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量</li><li>初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量</li><li>程序代码区(Text)：存放函数体的二进制代码</li></ul><p>代码区和数据区所占空间都是固定的，而且占用的空间非常小，那么看运行时消耗的内存主要看可变部分。</p><p>在可变部分中，栈区间的数据在代码块执行结束之后，系统会自动回收，<strong>而堆区间数据是需要程序员自己回收，所以也就是造成内存泄漏的发源地。</strong></p><p><strong>而Java、Python的话则不需要程序员去考虑内存泄漏的问题，虚拟机都做了这些事情</strong>。</p><h1 id="3-如何计算程序占用多大内存"><a class="markdownIt-Anchor" href="#3-如何计算程序占用多大内存"></a> 3 如何计算程序占用多大内存</h1><p>想要算出自己程序会占用多少内存就一定要了解自己定义的数据类型的大小，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200804193045440.png" alt="C++数据类型的大小"><br><strong>Byte :字节</strong></p><p>注意图中有两个不一样的地方，为什么64位的指针就占用了8个字节，而32位的指针占用4个字节呢？</p><p><strong>1个字节占8个比特</strong>，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是4G空间的大小，即：<strong>4个Byte可以寻找4G空间大小的内存地址。</strong></p><p>大家现在使用的计算机一般都是64位了，所以编译器也都是64位的。</p><p>注意2^64是一个非常巨大的数，对于寻找地址来说已经足够用了。</p><h2 id="31-总结"><a class="markdownIt-Anchor" href="#31-总结"></a> 3.1 总结</h2><p>1 字节 = 8 比特</p><p>1 字节 = 8 比特(1 Byte = 8 bit), 4字节 = 32比特, 能够存放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个数据即4G内存, 就能够当寻址内存存放指针 #card<br>安装64位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，<strong>就已经不能寻址全部的内存地址</strong>，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。</p><!-- basicblock-start oid="ObsabGgePTB5wOAqIAICO3JP" --> <h1 id="4-内存对齐"><a class="markdownIt-Anchor" href="#4-内存对齐"></a> 4 内存对齐 ::</h1><!-- basicblock-end --><p>![[代码内存消耗 2022-08-07 18.01.47.excalidraw]]</p><ul><li><p>内存对齐:  <strong>一次寻址</strong><br>一字节的char占用了四个字节，空了三个字节的内存地址，int数据从地址4开始。<br>此时，直接将地址4，5，6，7处的四个字节数据读取到即可</p></li><li><p>非内存对齐 : <strong>两次寻址，一次合并</strong><br>char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：</p><ol><li>因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据</li><li>CPU读取4，5，6，7处的四个字节数据</li></ol></li></ul><p><strong>总结:</strong><br>虽然浪费内存,但是内存资源一般都是充足的,我们更希望提升运行速度<br><strong>编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响</strong>。</p><p>例子 #card</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// char 一字节, int 四字节</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>{</span><br>   <span class="hljs-type">int</span> num;<br>   <span class="hljs-type">char</span> cha;<br>}st;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span> b[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 4</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 400</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(b) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 100</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(st) &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 因为内存对齐,整个类的内存占用为 8 字节</span><br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 1.算法性能分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归思想</title>
      <link href="/posts/8679/"/>
      <url>/posts/8679/</url>
      
        <content type="html"><![CDATA[<p>递归思想是：分而治之</p><p>简单的递归：阶乘<br>将大问题不断的拆分为子问题拆到不可拆分之后，自底向上放入栈中<br>在自顶向下不断计算子问题，返回结果给下一层在计算，直至计算出最后一层</p><p>![[递归思想 2022-08-05 15.45.22.excalidraw|1100]]</p><p>使用递归相当于，程序为我们创建了一个栈，我们只需拆分问题放入栈，在分而治之<br>阶乘是线性结构可以直接自底向上的解决而不使<br>但是树的递归就不是了线性了，递归的思想是拆分子问题放入栈，在解决子问题在传递给下一层直至计算完毕<br><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是<code>Segmentation fault</code>（当然不是所有的<code>Segmentation fault</code> 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p><p>而且**在企业项目开发中，尽量不要使用递归！**在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong><br>![[递归思想 2022-08-05 17.04.12.excalidraw|1100]]</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV11h411h7nT?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">1-2 栈与深度优先遍历_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 1.算法性能分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1 macbook 罗技G502鼠标 g hub显示停用的解决办法</title>
      <link href="/posts/32256/"/>
      <url>/posts/32256/</url>
      
        <content type="html"><![CDATA[<p><mark>与karabiner原有冲突：就是这个原因！！！</mark></p><p>将karabiner中禁用掉G502即可</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">// 其他的错误尝试<br>解决办法<br>1. 卸载原有的g hub 应用<br>2. 在google 里搜索 g hub(最新版)下载。不在火狐里下载是因为中文的可能滞后<br><br><br>1. 本质原因是罗技驱动(g hub)没有做好苹果电脑的适配<br>比如苹果更新系统后，看似给了 g hub 辅助功能的权限实际没给<br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1ri4y1V7cf?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">M1 Mac 装罗技 Logitech G Hub 有问题? Mac OS 中罗技G502和G815在 G Hub中可以显示但不能设置？MacBook_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ new的用法</title>
      <link href="/posts/36172/"/>
      <url>/posts/36172/</url>
      
        <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObsReOPlSEcMgnDTfMU2S00r" --> <p>C++ new的用法 ::<br>new返回的都是指针(指向第一个元素)<br>eg：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">new <span class="hljs-type">int</span>;    <span class="hljs-comment">//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即**指针**）</span><br>new <span class="hljs-type">int</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个**指向该存储空间的地址**</span><br>new <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址</span><br>new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>);<span class="hljs-comment">//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址</span><br>new linklist; <span class="hljs-comment">//申请表头空间 </span><br><span class="hljs-type">float</span> *p=new <span class="hljs-type">float</span> (<span class="hljs-number">3.14159</span>);/开辟一个存放单精度数的空间，并指定该实数的初值为/<span class="hljs-number">3.14159</span>，将返回的该空间的地址赋给指针变量p.<br>   <br><span class="hljs-comment">// 💡例子</span><br><span class="hljs-number">1.</span>new <span class="hljs-type">int</span>[] 是创建一个<span class="hljs-type">int</span>型数组，数组大小是在[]中指定<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//申请一个整型数组，数组的长度为[]中的值</span><br><span class="hljs-number">2.</span>new <span class="hljs-title function_">int</span><span class="hljs-params">()</span>是创建一个<span class="hljs-type">int</span>型数，并且用<span class="hljs-params">()</span>括号中的数据进行初始化,例如：<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// p指向一个值为10的int数。</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空间复杂度分析</title>
      <link href="/posts/11552/"/>
      <url>/posts/11552/</url>
      
        <content type="html"><![CDATA[<h1 id="1-空间复杂度"><a class="markdownIt-Anchor" href="#1-空间复杂度"></a> 1 空间复杂度</h1><p>空间复杂度(Space Complexity)记作S(n)：S(n)=O(f(n))。依然使用大O来表示</p><ol><li>空间复杂度是考虑程序（可执行文件）的大小么？</li></ol><p><strong>空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。</strong><br>利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。</p><ol start="2"><li>空间复杂度是准确算出程序运行时所占用的内存么？<br>不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。</li></ol><p>所以空间复杂度是预先大体评估程序内存使用的大小。</p><p>空间复杂度O(1)： 所开辟的内存空间不会随着n的变化而变化，即空间复杂度为一个常量O(1)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) { <span class="hljs-comment">// n别超过 2^32 - 1就行。(int 的取值范围)</span><br>    j++;<br>}<br></code></pre></td></tr></tbody></table></figure><p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。<br>空间复杂度O(n)：消耗空间和输入参数n保持线性增长</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* a = new <span class="hljs-type">int</span>(n); <span class="hljs-comment">// a指向值为n的int数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    a[i] = i; <span class="hljs-comment">// 不断的扩大a的数组长度</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>new 函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>new <span class="hljs-type">int</span>[] 是创建一个<span class="hljs-type">int</span>型数组，数组大小是在[]中指定<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//申请一个整型数组，数组的长度为[]中的值</span><br><span class="hljs-number">2.</span>new <span class="hljs-title function_">int</span><span class="hljs-params">()</span>是创建一个<span class="hljs-type">int</span>型数，并且用<span class="hljs-params">()</span>括号中的数据进行初始化,例如：<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// p指向一个值为10的int数。</span><br></code></pre></td></tr></tbody></table></figure><p>这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)<br>O(n^2)， O(n^3)：即2 * 2,   3 * 3 矩阵</p><p>空间复杂度是<strong>logn</strong>的情况确实有些特殊，其实是在<strong>递归的时候，会出现空间复杂度为logn的情况</strong>。</p><h1 id="2-总结"><a class="markdownIt-Anchor" href="#2-总结"></a> 2 总结</h1><p>算法的世界里用空间换时间</p><ul><li>用户只关心程序的响应速度</li><li>程序运行完成以后空间可以重复使用</li></ul><p><strong>将经常使用的数据存成变量</strong></p><p>发现时间复杂度很高空间复杂度很低, 就是系统没有记住一些信息, 将常用的信息设置为变量. 以降低时间复杂度<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208111052182.png" alt=""></p><hr><p>[[C++ new的用法]]<br>[[时间复杂度分析]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 1.算法性能分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归算法的复杂度</title>
      <link href="/posts/9398/"/>
      <url>/posts/9398/</url>
      
        <content type="html"><![CDATA[<p><strong>同一道题目，同样使用递归算法，有的同学会写出了O(n)的代码，有的同学就写出了O(logn)的代码</strong>。<br>如果对递归的时间复杂度理解的不够深入的话，就会这样！</p><p>题目： 求x的n次方</p><p>for循环暴力求解</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求x的n次方</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意 任何数的0次方等于1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        result = result * x; <span class="hljs-comment">// result = x，x * x, x^2 * x, ........</span><br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>[[代码随想录视频]]</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 1.算法性能分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂度 </tag>
            
            <tag> 待解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法为什么会超时</title>
      <link href="/posts/26126/"/>
      <url>/posts/26126/</url>
      
        <content type="html"><![CDATA[<h1 id="从硬件配置看计算机的性能"><a class="markdownIt-Anchor" href="#从硬件配置看计算机的性能"></a> 从硬件配置看计算机的性能</h1><p>计算机的运算速度主要看CPU的配置，以2015年MacPro为例<br>CPU配置：2.7 GHz Dual-Core Intel Core i5 。<br>也就是 2.7 GHz 奔腾双核，i5处理器，GHz是指什么呢</p><ul><li>1GHz（兆赫）= 1000MHz（兆赫）</li><li>1MHz（兆赫）= 1百万赫兹</li></ul><p>1Hz = 1/s，<br>1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期）称之为为赫兹，</p><p>所以 <strong>1GHz = 10亿Hz</strong>，表示CPU可以一秒脉冲10亿次（有10亿个时钟周期），这里不要简单理解一个时钟周期就是一次CPU运算。</p><p>例如1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。</p><p>而且计算机的cpu也不会只运行我们自己写的程序上，同时cpu也要执行计算机的各种进程任务等等，我们的程序仅仅是其中的一个进程而已。</p><p><mark>Apple M1具有Apple M-Series的 L1 缓存，基本/<strong>最大CPU频率</strong>为2.06 - 3.20 GHz</mark><br>“英特尔发布 i9-12900KS：最高睿频 5.5GHz，全大核 5.2 GHz”</p><h1 id="测试1s能处理多少个数据"><a class="markdownIt-Anchor" href="#测试1s能处理多少个数据"></a> 测试1s能处理多少个数据</h1><p>算法4里面的一段话：</p><ul><li>火箭科学家需要大致知道一枚试射火箭的着陆点是在大海里还是在城市中；</li><li>医学研究者需要知道一次药物测试是会杀死还是会治愈实验对象；<br><strong>任何开发计算机程序员的软件工程师都应该能够估计这个程序的运行时间是一秒钟还是一年</strong>。</li></ul><p>在写测试程序测1s内处理多大数量级数据的时候，有三点需要注意：</p><ul><li>CPU执行每条指令所需的时间实际上并不相同，例如CPU执行加法和乘法操作的耗时实际上都是不一样的。</li><li>现在大多计算机系统的内存管理都有缓存技术，所以频繁访问相同地址的数据和访问不相邻元素所需的时间也是不同的。</li><li>计算机同时运行多个程序，每个程序里还有不同的进程线程在抢占资源。</li></ul><p>实现三个函数，时间复杂度分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，使用加法运算来统一测试。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> chrono;<br><span class="hljs-comment">// O(n) 简单的for循环加法 0-n</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        k++;<br>    }<br>}<br><br><span class="hljs-comment">// O(n^2) for循环嵌套：循环体内部复杂度相乘 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {<br>            k++;<br>        }<br>    }<br><br>}<br><span class="hljs-comment">// O(nlogn)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> j = <span class="hljs-number">1</span>; j &lt; n; j = j*<span class="hljs-number">2</span>) { <span class="hljs-comment">// 注意这里j=1；j = 1，2,4,8,16(两倍递增)</span><br>            k++;<br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n; <span class="hljs-comment">// 数据规模</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>        cout &lt;&lt; <span class="hljs-string">"输入n："</span>;<br>        cin &gt;&gt; n;<br>        milliseconds start_time = <span class="hljs-built_in">duration_cast</span>&lt;milliseconds &gt;(<br>            system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()<br>        );<br>        <span class="hljs-built_in">function1</span>(n);<br><span class="hljs-comment">//        function2(n);</span><br><span class="hljs-comment">//        function3(n);</span><br>        milliseconds end_time = <span class="hljs-built_in">duration_cast</span>&lt;milliseconds &gt;(<br>            system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()<br>        );<br>        cout &lt;&lt; <span class="hljs-string">"耗时:"</span> &lt;&lt; <span class="hljs-built_in">milliseconds</span>(end_time).<span class="hljs-built_in">count</span>() - <span class="hljs-built_in">milliseconds</span>(start_time).<span class="hljs-built_in">count</span>()<br>            &lt;&lt;<span class="hljs-string">" ms"</span>&lt;&lt; endl;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>O(n)：1s大概能处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">1^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>  的数据，O(n<sup>2)的数量级为O(n)开根号，O(nlogn)比O(n</sup>2)多一点，因为复杂度比它小一点。但比O(n)还是<strong>少一个</strong>数量级<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021618668.png" alt=""></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/On%E7%9A%84%E7%AE%97%E6%B3%95%E5%B1%85%E7%84%B6%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%9A%84n%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A4%9A%E5%A4%A7%EF%BC%9F.html#%E5%81%9A%E4%B8%AA%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C">On的算法居然超时了，此时的n究竟是多大？ | 代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 1.算法性能分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LaTex 环境配置</title>
      <link href="/posts/1424/"/>
      <url>/posts/1424/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><h3 id="latex-数学公式"><a class="markdownIt-Anchor" href="#latex-数学公式"></a> LaTeX 数学公式</h3><p>Hexo 5.0 以上，可尝试 Hexo 官方的 <a href="https://github.com/hexojs/hexo-math">hexo-math</a><br>插件，支持更多定制化参数，使用方式参照仓库内的文档，以下介绍的是主题内置的 LaTeX 功能。</p><p>当需要使用 <a href="https://www.latex-project.org/help/documentation/">LaTeX</a><br>语法的数学公式时，可手动开启本功能，需要完成三步操作：</p><p><strong>1. 设置主题配置</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></tbody></table></figure><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p><code>engine</code>: 公式引擎，目前支持 <code>mathjax</code> 或 <code>katex</code>。</p><p><strong>2. 更换 Markdown 渲染器</strong></p><p>由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。</p><p>先卸载原有渲染器：</p><p><code>npm uninstall hexo-renderer-marked --save</code></p><p>然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p><p>mathjax（可选）:<code>npm install hexo-renderer-pandoc --save</code> <strong>并且还需<a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">安装 Pandoc</a></strong></p><p>katex（必须）: <code>npm install @upupming/hexo-renderer-markdown-it-plus --save</code></p><p><strong>3. 安装完成后执行 <code>hexo clean</code></strong></p><p>书写公式的格式：</p><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>E=mc^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></tbody></table></figure><p>WARNING</p><p>如果公式没有被正确渲染，请仔细检查是否符合上面三步操作。</p><p>不可以同时安装多个渲染插件，包括 <code>hexo-math</code> 或者 <code>hexo-katex</code> 这类插件，请注意检查 <code>package.json</code>。</p><p>如果更换公式引擎，对应渲染器也要一并更换。</p><p>另外不同的渲染器，可能会导致一些 Markdown 语法不支持。</p><p>自定义页面默认不加载渲染，如需使用，需在 Front-matter 中指定 <code>math: true</code></p><p>不同的公式引擎有不同的优缺点。</p><p><strong>MathJax</strong></p><p>优点</p><ul><li>对 LaTeX 语法支持全面</li><li>右键点击公式有扩展功能</li></ul><p>缺点</p><ul><li>需要加载 JS，页面加载会比较慢</li></ul><p><strong>KaTeX</strong></p><p>优点</p><ul><li>没有 JS 不会影响页面加载</li></ul><p>缺点</p><ul><li>小部分 LaTeX 不支持</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">配置指南 | Hexo Fluid 用户手册</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex公式</title>
      <link href="/posts/4371/"/>
      <url>/posts/4371/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p>​ <a href="https://so.csdn.net/so/search?q=LaTeX&amp;spm=1001.2101.3001.7020">LaTeX</a>是一种基于ΤΕΧ的排版系统，而TeX是由著名的计算机科学家<a href="https://baike.baidu.com/item/%E5%94%90%E7%BA%B3%E5%BE%B7%C2%B7%E5%85%8B%E5%8A%AA%E7%89%B9?fromtitle=Donald+E.+Knuth&amp;fromid=2509519">Donald E. Knuth</a>发明的排版系统,可以了解一下他，LaTeX能够优美地生成数学公式且质量极高，本文简要记录其常用公式，以备自查。</p><h1 id="行内公式与行间公式及编号"><a class="markdownIt-Anchor" href="#行内公式与行间公式及编号"></a> 行内公式与行间公式及编号</h1><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span>f(x) = a+b<span class="hljs-built_in">$</span><br><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>f(x)=a+b+c<span class="hljs-keyword">\tag</span>{1.1}<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x) = a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">f(x)=a+b+c\tag{1.1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p>效果显然，使用<code>\tag{}</code> 对公式进行标号</p><h1 id="多项式上下标-根号-分式-对数"><a class="markdownIt-Anchor" href="#多项式上下标-根号-分式-对数"></a> 多项式（上下标）、根号、分式、对数</h1><p>上下标分别用 _{ }和 ^{ } 来标记，{}内为值，可以是公式等等</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span>f(x)=a<span class="hljs-built_in">_</span>{1}<span class="hljs-built_in">^</span>{1-x}+a<span class="hljs-built_in">^</span>{2-x}<span class="hljs-built_in">_</span>{2}+a<span class="hljs-built_in">^</span>{3-x}<span class="hljs-built_in">_</span>{3}<span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>a</mi><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>x</mi></mrow></msubsup><mo>+</mo><msubsup><mi>a</mi><mn>2</mn><mrow><mn>2</mn><mo>−</mo><mi>x</mi></mrow></msubsup><mo>+</mo><msubsup><mi>a</mi><mn>3</mn><mrow><mn>3</mn><mo>−</mo><mi>x</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">f(x)=a_{1}^{1-x}+a^{2-x}_{2}+a^{3-x}_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>\sqrt{ }</strong> 表示平方根，<strong>\sqrt[n]{ }</strong> 表示n次方根，<strong>\frac{ }{ }</strong> 表示分式，两个{}先分子，后分母，对数用 <strong>\log_{2}{343}</strong> 表示</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-keyword">\sqrt</span>{x}+<span class="hljs-keyword">\sqrt</span>[3]{2-x}-<span class="hljs-keyword">\sqrt</span>[x]{<span class="hljs-keyword">\frac</span>{a<span class="hljs-built_in">^</span>x}{b<span class="hljs-built_in">^</span>x}}+<span class="hljs-keyword">\frac</span>{1}{x}+<span class="hljs-keyword">\log</span><span class="hljs-built_in">_</span>{2}{x}<span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mroot><mrow><mn>2</mn><mo>−</mo><mi>x</mi></mrow><mn>3</mn></mroot><mo>−</mo><mroot><mfrac><msup><mi>a</mi><mi>x</mi></msup><msup><mi>b</mi><mi>x</mi></msup></mfrac><mi>x</mi></mroot><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><mo>+</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">\sqrt{x}+\sqrt[3]{2-x}-\sqrt[x]{\frac{a^x}{b^x}}+\frac{1}{x}+\log_{2}{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.17444499999999996em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.736886em;"><span style="top:-2.914666em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8655550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span><span style="top:-2.825555em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17444499999999996em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.62276em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.571968em;"><span style="top:-2.856688em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.21724em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.80948em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.17724em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width="400em" height="1.8800000000000001em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10zM1001 80H400000v40H1013z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.62276em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span></span></p><h3 id="常用符号"><a class="markdownIt-Anchor" href="#常用符号"></a> 常用符号</h3><p><strong>+ - * /</strong> 等可以直接打出</p><p>乘号用\times,点乘用\cdot，除号用\div，不等号用\ne，恒等或同余号用\equiv，整除用\mid,取模用\mod，上取整用\lfloor x \rfloor，下取整用\lceil x \rceil</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\times</span>乘号 <span class="hljs-keyword">\cdot</span>点乘  <span class="hljs-keyword">\div</span>除号  <span class="hljs-keyword">\ne</span>不等号<span class="hljs-keyword">\equiv</span>恒等或同余号 <br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\mid</span>整除 <span class="hljs-keyword">\mod</span> 取模   <span class="hljs-keyword">\lfloor</span> x <span class="hljs-keyword">\rfloor</span> 和 <span class="hljs-keyword">\lceil</span> x <span class="hljs-keyword">\rceil</span><br></code></pre></td></tr></tbody></table></figure><p>\times乘号 \cdot点乘  \div除号  \ne不等号\equiv恒等或同余号<br>\mid整除 \mod 取模   \lfloor x \rfloor 和 \lceil x \rceil</p><p><strong>ps</strong>: \ \ 是分行</p><p>小于号用\lt，大于号用\gt，小于等于号用\le，大于等于号用\ge</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\lt</span>小于号     <span class="hljs-keyword">\gt</span>大于号    <span class="hljs-keyword">\le</span>小于等于号    <span class="hljs-keyword">\ge</span>大于等于号<br></code></pre></td></tr></tbody></table></figure><p>&lt; 小 于 号 &gt; 大 于 号 ≤ 小 于 等 于 号 ≥ 大 于 等 于 号 \lt小于号 \gt大于号 \le小于等于号 \ge大于等于号 &lt;小于号&gt;大于号≤小于等于号≥大于等于号</p><p>集合运算符号</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cup</span>并运算 <span class="hljs-keyword">\quad</span>  <span class="hljs-keyword">\cap</span>交运算 <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\subset</span> 和 <span class="hljs-keyword">\supset</span>  <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\subseteq</span> 和 <span class="hljs-keyword">\supseteq</span> <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\in</span> 和 <span class="hljs-keyword">\notin</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\emptyset</span> 空集<br></code></pre></td></tr></tbody></table></figure><p>∪ 并 运 算 ∩ 交 运 算 ⊂ 和 ⊃ ⊆ 和 ⊇ ∈ 和 ∉ ∅ 空 集 \ \cup并运算 \quad \cap交运算 \qquad \subset 和 \supset \ \subseteq 和 \supseteq \qquad \in 和 \notin \qquad \emptyset 空集 ∪并运算∩交运算⊂和⊃⊆和⊇∈和∈/​∅空集</p><p><strong>ps</strong>: \qquad是空格</p><p>三角符号用\bigtriangleup，三角符号类似\sin,度数用上标^{\cric}表示，角用\angle</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\bigtriangleup</span>三角 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\angle</span> 角<br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\tan</span>90<span class="hljs-built_in">^</span>{<span class="hljs-keyword">\circ</span>}和<span class="hljs-keyword">\sin</span> x和<span class="hljs-keyword">\cos</span> x三角函数及度数表示 <br></code></pre></td></tr></tbody></table></figure><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span><span class="hljs-keyword">\rightarrow</span>和<span class="hljs-keyword">\Rightarrow</span><br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\leftrightarrow</span>和<span class="hljs-keyword">\Leftrightarrow</span><br><span class="hljs-keyword">\\</span><span class="hljs-keyword">\vee</span>和<span class="hljs-keyword">\wedge</span><br><span class="hljs-keyword">\\</span><span class="hljs-keyword">\because</span>和<span class="hljs-keyword">\therefore</span><br><span class="hljs-keyword">\\</span>因为所以<br></code></pre></td></tr></tbody></table></figure><p>→ 和 ⇒ ↔ 和 ⇔ ∨ 和 ∧ ∵ 和 ∴ 因 为 所 以 \ \rightarrow和\Rightarrow \ \leftrightarrow和\Leftrightarrow \ \vee和\wedge \ \because和\therefore \ 因为所以 →和⇒↔和⇔∨和∧∵和∴因为所以</p><p>特殊符号</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\otimes</span>和<span class="hljs-keyword">\oplus</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\nearrow</span>和<span class="hljs-keyword">\searrow</span> <span class="hljs-keyword">\qquad</span><br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\sim</span>和<span class="hljs-keyword">\approx</span>  <span class="hljs-keyword">\qquad</span><span class="hljs-keyword">\ldots</span>和<span class="hljs-keyword">\cdots</span> 不同对齐的省略号<br></code></pre></td></tr></tbody></table></figure><p>⊗ 和 ⊕ ↗ 和 ↘ ∼ 和 ≈ … 和 ⋯ 不 同 对 齐 的 省 略 号 \ \otimes和\oplus \qquad \nearrow和\searrow \qquad \ \sim和\approx \qquad \ldots和\cdots 不同对齐的省略号 ⊗和⊕↗和↘∼和≈…和⋯不同对齐的省略号</p><h3 id="积分-极限-求和-乘积-求导"><a class="markdownIt-Anchor" href="#积分-极限-求和-乘积-求导"></a> 积分、极限、求和、乘积、求导</h3><p>\int表示积分，\lim表示极限， \sum表示求和，\prod表示乘积，<em>’</em> 表示求导，微分中的dx用\mathrm{d}x表示，\to表示箭头，\infty表示无穷</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>{0}<span class="hljs-built_in">^</span>{x}{x<span class="hljs-built_in">^</span>2}<span class="hljs-keyword">\mathrm</span>{d}x +<span class="hljs-keyword">\lim</span><span class="hljs-built_in">_</span>{x <span class="hljs-keyword">\to</span> <span class="hljs-keyword">\infty</span>}{<span class="hljs-keyword">\frac</span>{<span class="hljs-keyword">\sin</span> x}{x}}<br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>{i=1}<span class="hljs-built_in">^</span>{n}{a<span class="hljs-built_in">_</span>ib<span class="hljs-built_in">_</span>i}+<span class="hljs-keyword">\prod</span><span class="hljs-built_in">_</span>{i=1}<span class="hljs-built_in">^</span>{n}{(a<span class="hljs-built_in">_</span>i+b<span class="hljs-built_in">_</span>i)}+f(x)''<br></code></pre></td></tr></tbody></table></figure><p>∫ 0 x x 2 d x + lim ⁡ x → ∞ sin ⁡ x x ∑ i = 1 n a i b i + ∏ i = 1 n ( a i + b i ) + f ( x ) ′ ′ \ \int_{0}<sup>{x}{x</sup>2}\mathrm{d}x +\lim_{x \to \infty}{\frac{\sin x}{x}} \ \sum_{i=1}<sup>{n}{a_ib_i}+\prod_{i=1}</sup>{n}{(a_i+b_i)}+f(x)’’ ∫0x​x2dx+x→∞lim​xsinx​i=1∑n​ai​bi​+i=1∏n​(ai​+bi​)+f(x)′′</p><h3 id="向量-组合数-矩阵"><a class="markdownIt-Anchor" href="#向量-组合数-矩阵"></a> 向量、组合数、矩阵</h3><p>向量用 <strong>\overrightarrow{ }</strong> 表示，组合数用 <strong>\binom{ }{ }</strong> ，其类似于分式</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\overrightarrow</span>{AB} <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\binom</span>{1}{2}<br></code></pre></td></tr></tbody></table></figure><p>A B → ( 1 2 ) \overrightarrow{AB} \qquad \binom{1}{2} AB</p><p>(21​)</p><p>矩阵以起始来规定，内部以&amp;分列，以\分行，括号里可填matrix，bmatrix，pmatrix，vmatrix，分别对应示例(1)(2)(3)(4)</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span> <span class="hljs-keyword">\begin</span>{matrix}<br>0 <span class="hljs-built_in">&amp;</span> 1 <span class="hljs-keyword">\\</span><br>1 <span class="hljs-built_in">&amp;</span> 0 <br><span class="hljs-keyword">\end</span>{matrix} <span class="hljs-built_in">$</span>   <br></code></pre></td></tr></tbody></table></figure><p>0 1 1 0</p><p>01​10​ [ 0 1 1 0 ]</p><p>[01​10​] ( 0 1 1 0 )</p><p>(01​10​) ∣ 0 1 1 0 ∣</p><p>∣∣∣∣​01​10​∣∣∣∣​</p><p>( 1 ) ( 2 ) ( 3 ) ( 4 ) (1)\qquad(2)\qquad(3)\qquad(4) (1)(2)(3)(4)</p><h3 id="方框加粗-上下标记-空格-更大更小的字符"><a class="markdownIt-Anchor" href="#方框加粗-上下标记-空格-更大更小的字符"></a> 方框加粗、上下标记、空格、更大更小的字符</h3><p>\boxed命令给公式加一个方框，\mathbf将字体加粗，\overline, \underline 分别在表达式上、下方画出水平线，\quad和\qquad是空格，\large 或 \small能使字符变大变小</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\boxed</span>{<span class="hljs-keyword">\large</span>{<span class="hljs-keyword">\mathbf</span>{E=mc<span class="hljs-built_in">^</span>2}}}<br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\overline</span>{a+<span class="hljs-keyword">\underline</span>{b+<span class="hljs-keyword">\small</span>{N}}}<br></code></pre></td></tr></tbody></table></figure><p>E = m c 2 a + b + N ‾ ‾ \ \boxed{\large{\mathbf{E=mc^2}}} \ \overline{a+\underline{b+\small{N}}} E=mc2​a+b+N​​</p><h3 id="希腊字母"><a class="markdownIt-Anchor" href="#希腊字母"></a> 希腊字母</h3><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\alpha</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\beta</span>  <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Delta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\zeta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\varepsilon</span> <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\eta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\theta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\lambda</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\mu</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\xi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\pi</span>  <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\rho</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\sigma</span>  <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\upsilon</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Phi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\phi</span> <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\Psi</span>  <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\psi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\omega</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Omega</span> <span class="hljs-keyword">\qquad</span> O<br></code></pre></td></tr></tbody></table></figure><p>α β Δ ζ ε η θ λ μ ξ π ρ σ υ Φ ϕ Ψ ψ ω Ω O \ \alpha \qquad \beta \qquad \Delta \qquad \zeta \qquad \varepsilon \ \eta \qquad \theta \qquad \lambda \qquad \mu \qquad \xi \qquad \pi \ \rho \qquad \sigma \qquad \upsilon \qquad \Phi \qquad \phi \ \Psi \qquad \psi \qquad \omega \qquad \Omega \qquad O αβΔζεηθλμξπρσυΦϕΨψωΩO</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>​ LaTeX是非常有用的，是非常严谨优美的， 在此对<a href="https://baike.baidu.com/item/%E5%94%90%E7%BA%B3%E5%BE%B7%C2%B7%E5%85%8B%E5%8A%AA%E7%89%B9?fromtitle=Donald+E.+Knuth&amp;fromid=2509519">Donald E. Knuth</a>表示敬意。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://blog.csdn.net/weixin_42755533/article/details/113132619?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165940495016781683972226%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165940495016781683972226&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113132619-null-null.142%5Ev37%5Epc_search_v2&amp;utm_term=latex%20%E5%85%AC%E5%BC%8F&amp;spm=1018.2226.3001.4187">LaTeX常用公式_ywlcode的博客-CSDN博客_latex 整除</a></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技能 </tag>
            
            <tag> 已迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++零基础99题》</title>
      <link href="/posts/57305/"/>
      <url>/posts/57305/</url>
      
        <content type="html"><![CDATA[<p>文章简介：学习资源来自B站UP主：英雄哪里出来</p><span id="more"></span><h1 id="开根号"><a class="markdownIt-Anchor" href="#开根号"></a> 开根号</h1><p>(int) sqrt(x)：函数前面加(int) 就是强转，注意()<br>sqrt平方根函数</p><h1 id="367有效的完全平方数"><a class="markdownIt-Anchor" href="#367有效的完全平方数"></a> 367.有效的完全平方数</h1><p>完全平方数：该数能开根号<br>不能用sqrt，从0开始找数一个个遍历，相乘是否等于num，<br>两数相乘的强转不能加括号，eg：(long long) (i * i)  最后会编译出错<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021728939.png" alt=""></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1da411M798?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">01 函数_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 英雄哪里出来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用hexo s 引发的一些错误</title>
      <link href="/posts/54162/"/>
      <url>/posts/54162/</url>
      
        <content type="html"><![CDATA[<h1 id="1-不要把没有ymal-字段-的文章放入post文件夹中否则会编译出错"><a class="markdownIt-Anchor" href="#1-不要把没有ymal-字段-的文章放入post文件夹中否则会编译出错"></a> 1 不要把没有ymal 字段 的文章放入post文件夹中，否则会编译出错</h1><p>此处把零散笔记文件夹放入post中<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281050271.png" alt="|600"></p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281055164.png" alt="|600"><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021056860.png" alt=""><br>source 文件夹中的md文件都会被hexo s 编译，所以杂项也不能放入source 文件夹中</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281115268.png" alt="|400"></p><p>用hexo s 时，在myblog(存放hexo整体的文件中)进行命令操作</p><h1 id="2-validationerror-null-is-not-a-string"><a class="markdownIt-Anchor" href="#2-validationerror-null-is-not-a-string"></a> 2 <strong>ValidationError: ‘null’ is not a string!</strong></h1><p>错误说明<br>一般都是因为文章无内容，可能是因为在这篇博客文章中，有某些属性没有填写，比如author属性，tag属性，categories属性等，导致该属性是空的，即<code>null</code>，所以报错。</p><hr><p>自用ob链接：<a href="obsidian://advanced-uri?vault=myblog&amp;uid=858032de-484b-4d7f-a45f-5bab2ca7bb2b">obsidian</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易云本地音乐怎么添加歌词</title>
      <link href="/posts/27260/"/>
      <url>/posts/27260/</url>
      
        <content type="html"><![CDATA[<p>准备本地的.mp3文件<br>和.mp3文件同名的.lrc文件<br>两者放在一个文件夹中，然后用网抑云云盘上传</p><p>如何制作lrc文件</p><ol><li>将MP3文件导入剪映，智能制作srt文件并导出</li><li>将srt转成lrc文件。转换网站：<a href="http://www.lrccon.com/convert.php">歌词字幕在线转换器 - 支持LRC SRT UTF KSC SSA ASS SMI SNC TXT格式在线转换</a></li></ol><p>问题<br>在手机端看不到歌词，在电脑端可以</p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19.零钱兑换II</title>
      <link href="/posts/48085/"/>
      <url>/posts/48085/</url>
      
        <content type="html"><![CDATA[<h1 id="1-518零钱兑换-ii"><a class="markdownIt-Anchor" href="#1-518零钱兑换-ii"></a> 1 518零钱兑换 II</h1><p><a href="https://leetcode.cn/problems/coin-change-2/">力扣题目链接</a></p><p>难度：中等</p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额)&nbsp;&lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>数量无限→立即想完全背包<br>本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总价值 ，而本题是要求凑成总金额的个数！</strong></p><p>组合不强调顺序，排列强调顺序<br>5 = 2 + 2 + 1<br>5 = 2 + 1 + 2<br>这是一种组合，都是 2 2 1。</p><p>弄清排列和组合问题与遍历顺序息息相关</p><h2 id="21-动归五部曲"><a class="markdownIt-Anchor" href="#21-动归五部曲"></a> 2.1 动归五部曲</h2><ol><li><p>dp[j] 的含义<br>凑成总金额j的货币<strong>组合</strong>数为dp[j]<br>j背包恰好有dp[j]种组合装满：即装满背包有几种方法</p></li><li></li></ol><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#_518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19.零钱兑换II</title>
      <link href="/posts/48085/"/>
      <url>/posts/48085/</url>
      
        <content type="html"><![CDATA[<h1 id="1-518零钱兑换-ii"><a class="markdownIt-Anchor" href="#1-518零钱兑换-ii"></a> 1 518零钱兑换 II</h1><p><a href="https://leetcode.cn/problems/coin-change-2/">力扣题目链接</a></p><p>难度：中等</p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额)&nbsp;&lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>数量无限→立即想完全背包<br>本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总价值 ，而本题是要求凑成总金额的个数！</strong></p><p>组合不强调顺序，排列强调顺序<br>5 = 2 + 2 + 1<br>5 = 2 + 1 + 2<br>这是一种组合，都是 2 2 1。</p><p>弄清排列和组合问题与遍历顺序息息相关</p><h2 id="21-动归五部曲"><a class="markdownIt-Anchor" href="#21-动归五部曲"></a> 2.1 动归五部曲</h2><ol><li><p>dp[j] 的含义<br>凑成总金额j的货币<strong>组合</strong>数为dp[j]<br>j背包恰好有dp[j]种组合装满：即装满背包有几种方法</p></li><li></li></ol><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#_518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18.完全背包理论基础</title>
      <link href="/posts/10752/"/>
      <url>/posts/10752/</url>
      
        <content type="html"><![CDATA[<p>01背包：每个物品只有一个(即只能被添加一次)<br>核心代码：先物品后背包，内层倒序(保证物品只被添加一次)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>完全背包：每个物品有无数个(即可以被添加多次)<br>核心代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<span class="hljs-comment">// j从weight[i]开始+，j- weight[]肯定是成立的</span><br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/oly9hwp3.bmp" alt="|500"><br>![[18.完全背包理论基础 2022-07-21 15.39.33.excalidraw|600]]</p><p>是否可以物品和背包的顺序颠倒 #card  #疑问<br>01背包中：先物品在背包，背包for循环倒序。只能<strong>先物品在背包</strong>的和<strong>倒序</strong>的原因是，要保证每一个物品只被添加一次<br>🌵<br>完成背包的含义是物品有无限一个，能够被多次放入。之前的01背包中的限制条件就消失了。即可以先遍历背包后遍历物品，内层for循环也不需要倒序。</p><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.一和零</title>
      <link href="/posts/31990/"/>
      <url>/posts/31990/</url>
      
        <content type="html"><![CDATA[<h1 id="1-474一和零"><a class="markdownIt-Anchor" href="#1-474一和零"></a> 1 474.一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接</a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/"></a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4</p><p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2： 输入：strs = [“10”, “0”, “1”], m = 1, n = 1 输出：2 解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><p>提示：</p><ul><li>1 &lt;= strs.length &lt;= 600</li><li>1 &lt;= strs[i].length &lt;= 100</li><li>strs[i]&nbsp;仅由&nbsp;‘0’ 和&nbsp;‘1’ 组成</li><li>1 &lt;= m, n &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>strs 数组里的元素就是物品，每个物品都是一个！</strong><br><strong>而m 和 n相当于是一个背包，两个维度的背包</strong>。<br>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。但本题是01背包</p><p>动归五部曲</p><ol><li><p>确定dp[j]含义<br><code>dp[i][j]</code>：最多有 i个0 和 j个1的strs的<strong>最大子集的大小</strong>为<code>dp[i][j]</code><br>两个背包，一个i，一个j</p></li><li><p>确定递推公式<br><code>dp[i][j]</code> 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p></li></ol><p><code>dp[i][j]</code> 就可以是 <code>dp[i - zeroNum][j - oneNum]</code> + 1。<br>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code><br>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。后边1 就是多了所求数组中又多一个元素</p><ol start="3"><li><p>dp数组初始化<br>物品价值不会是负数，初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</p></li><li><p>遍历顺序<br>先物品在背包<br>物品就是strs里的字符串，背包容量就是题目描述中的m和n。<br>这个题是背包有两个维度，内层的for循环有两个，还是倒序遍历</p></li><li><p>打印dp数组<br>以输入：[“10”,“0001”,“111001”,“1”,“0”]，m = 3，n = 3为例</p></li></ol><p>最后dp数组的状态如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" alt="474.一和零"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>参考：[[for 循环]]<br>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs){ <span class="hljs-comment">// 遍历改位置的字符串</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 保证到下一个位置的字符，这些one zero还会初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str){ <span class="hljs-comment">// 遍历字符串的每个字符 此时应该是str,而不是strs</span><br>            <span class="hljs-keyword">if</span> ( c == <span class="hljs-string">'0'</span>) zeroNum ++;<br>            oneNum++; <span class="hljs-comment">// 得到了该字符串的01数量</span><br>            }<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--){ <span class="hljs-comment">// 最多能装多少个1</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--){ <span class="hljs-comment">// 最多能装多少个0</span><br>                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-built_in">cout</span>&lt;&lt;dp[i][j];<br>                }<br>            }<br>           <br>            <br>        }<br>  <br>        <span class="hljs-keyword">return</span> dp[m][n];<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721151503.png" alt=""></p><p><strong>参考资料</strong></p><p><a href="https://www.programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#_474-%E4%B8%80%E5%92%8C%E9%9B%B6">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.一和零</title>
      <link href="/posts/31990/"/>
      <url>/posts/31990/</url>
      
        <content type="html"><![CDATA[<h1 id="1-474一和零"><a class="markdownIt-Anchor" href="#1-474一和零"></a> 1 474.一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接</a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/"></a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4</p><p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2： 输入：strs = [“10”, “0”, “1”], m = 1, n = 1 输出：2 解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><p>提示：</p><ul><li>1 &lt;= strs.length &lt;= 600</li><li>1 &lt;= strs[i].length &lt;= 100</li><li>strs[i]&nbsp;仅由&nbsp;‘0’ 和&nbsp;‘1’ 组成</li><li>1 &lt;= m, n &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>strs 数组里的元素就是物品，每个物品都是一个！</strong><br><strong>而m 和 n相当于是一个背包，两个维度的背包</strong>。<br>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。但本题是01背包</p><p>动归五部曲</p><ol><li><p>确定dp[j]含义<br><code>dp[i][j]</code>：最多有 i个0 和 j个1的strs的<strong>最大子集的大小</strong>为<code>dp[i][j]</code><br>两个背包，一个i，一个j</p></li><li><p>确定递推公式<br><code>dp[i][j]</code> 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p></li></ol><p><code>dp[i][j]</code> 就可以是 <code>dp[i - zeroNum][j - oneNum]</code> + 1。<br>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code><br>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。后边1 就是多了所求数组中又多一个元素</p><ol start="3"><li><p>dp数组初始化<br>物品价值不会是负数，初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</p></li><li><p>遍历顺序<br>先物品在背包<br>物品就是strs里的字符串，背包容量就是题目描述中的m和n。<br>这个题是背包有两个维度，内层的for循环有两个，还是倒序遍历</p></li><li><p>打印dp数组<br>以输入：[“10”,“0001”,“111001”,“1”,“0”]，m = 3，n = 3为例</p></li></ol><p>最后dp数组的状态如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" alt="474.一和零"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>参考：[[for 循环]]<br>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs){ <span class="hljs-comment">// 遍历改位置的字符串</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 保证到下一个位置的字符，这些one zero还会初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str){ <span class="hljs-comment">// 遍历字符串的每个字符 此时应该是str,而不是strs</span><br>            <span class="hljs-keyword">if</span> ( c == <span class="hljs-string">'0'</span>) zeroNum ++;<br>            oneNum++; <span class="hljs-comment">// 得到了该字符串的01数量</span><br>            }<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--){ <span class="hljs-comment">// 最多能装多少个1</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--){ <span class="hljs-comment">// 最多能装多少个0</span><br>                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-built_in">cout</span>&lt;&lt;dp[i][j];<br>                }<br>            }<br>           <br>            <br>        }<br>  <br>        <span class="hljs-keyword">return</span> dp[m][n];<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721151503.png" alt=""></p><p><strong>参考资料</strong></p><p><a href="https://www.programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#_474-%E4%B8%80%E5%92%8C%E9%9B%B6">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.目标和</title>
      <link href="/posts/60439/"/>
      <url>/posts/60439/</url>
      
        <content type="html"><![CDATA[<h1 id="1-目标和"><a class="markdownIt-Anchor" href="#1-目标和"></a> 1 目标和</h1><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号&nbsp;+&nbsp;和&nbsp;-。对于数组中的任意一个整数，你都可以从&nbsp;+&nbsp;或&nbsp;-中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>假设加法总和为x， → 减法总和 = sum - x。<br>目标和 = 加法总和 - 减法总和 → S = x - (sum - x)<br>→ x = (S + sum) / 2</p><p>此时化为 ：就是从数组中挑几个数加起来正好等于x</p><p><strong>特例判断</strong></p><ol><li>假设加法和是非整数，即 (S + sum) / 2 除不尽，说明有余数，又因为加法和是整数，有余数不可能符合等号条件。所以：</li></ol><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">0</span>; // 此时没有方案<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</li></ol><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>动归五部曲</p><ol><li><p>确定dp[j]的含义<br>恰好装满背包容量为j的背包，一共有dp[j]种方法</p></li><li><p>确定递推公式<br>先记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为： #card #疑问</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[j] = dp[j] + dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><p>dp数组的初始化<br>dp[0] = 1，显然装满容量为0的背包，有1种方法，就是装0件物品。<br>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出<code>dp[j] = dp[j] + dp[j - nums[i]];</code>，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p></li><li><p>确定遍历顺序<br>先物品在背包，背包for循环倒序</p></li><li><p>举例推导dp数组</p></li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> {<br>        <span class="hljs-type">int</span> bagsize;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br>        bagsize = (sum + target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagsize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagsize; j &gt;= nums[i]; j--){<br>                dp[j] = dp[j] + dp[j - nums[i]];<br>        <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[target];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720234829.png" alt=""></p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.目标和</title>
      <link href="/posts/60439/"/>
      <url>/posts/60439/</url>
      
        <content type="html"><![CDATA[<h1 id="1-目标和"><a class="markdownIt-Anchor" href="#1-目标和"></a> 1 目标和</h1><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号&nbsp;+&nbsp;和&nbsp;-。对于数组中的任意一个整数，你都可以从&nbsp;+&nbsp;或&nbsp;-中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>假设加法总和为x， → 减法总和 = sum - x。<br>目标和 = 加法总和 - 减法总和 → S = x - (sum - x)<br>→ x = (S + sum) / 2</p><p>此时化为 ：就是从数组中挑几个数加起来正好等于x</p><p><strong>特例判断</strong></p><ol><li>假设加法和是非整数，即 (S + sum) / 2 除不尽，说明有余数，又因为加法和是整数，有余数不可能符合等号条件。所以：</li></ol><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">0</span>; // 此时没有方案<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</li></ol><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>动归五部曲</p><ol><li><p>确定dp[j]的含义<br>恰好装满背包容量为j的背包，一共有dp[j]种方法</p></li><li><p>确定递推公式<br>先记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为： #card #疑问</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[j] = dp[j] + dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><p>dp数组的初始化<br>dp[0] = 1，显然装满容量为0的背包，有1种方法，就是装0件物品。<br>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出<code>dp[j] = dp[j] + dp[j - nums[i]];</code>，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p></li><li><p>确定遍历顺序<br>先物品在背包，背包for循环倒序</p></li><li><p>举例推导dp数组</p></li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> {<br>        <span class="hljs-type">int</span> bagsize;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br>        bagsize = (sum + target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagsize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagsize; j &gt;= nums[i]; j--){<br>                dp[j] = dp[j] + dp[j - nums[i]];<br>        <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[target];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720234829.png" alt=""></p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.动归周总结</title>
      <link href="/posts/47640/"/>
      <url>/posts/47640/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> <strong>参考资料</strong></h2><p>自用跳转链接：🈚</p><p>也添加在11-14的文档中</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obsidian flashcard 插件</title>
      <link href="/posts/11266/"/>
      <url>/posts/11266/</url>
      
        <content type="html"><![CDATA[<p>插件：flashcard的使用方法：<a href="https://github.com/reuseman/flashcards-obsidian/wiki">Home · reuseman/flashcards-obsidian Wiki · GitHub</a></p><h1 id="1-简单配置"><a class="markdownIt-Anchor" href="#1-简单配置"></a> 1 简单配置</h1><p>anki connect 添加</p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c">{<br>    <span class="hljs-string">"apiKey"</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">"apiLogPath"</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">"webBindAddress"</span>: <span class="hljs-string">"127.0.0.1"</span>,<br>    <span class="hljs-string">"webBindPort"</span>: <span class="hljs-number">8765</span>,<br>    <span class="hljs-string">"webCorsOrigin"</span>: <span class="hljs-string">"http://localhost"</span>,<br>    <span class="hljs-string">"webCorsOriginList"</span>: [<br>        <span class="hljs-string">"http://localhost"</span>,<br>        <span class="hljs-string">"app://obsidian.md"</span>   <span class="hljs-meta">## 添加这一个</span><br>    ] <br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-无法添加的解决方法"><a class="markdownIt-Anchor" href="#2-无法添加的解决方法"></a> 2 无法添加的解决方法</h1><ol><li>anki 不能在浏览页面</li><li>删除id后，anki牌组不能有之前文件</li><li>问题前面加一个标题，添加后，然后在删掉就行</li><li>yaml字段自动生成的card-deck 字段，相对(valut)的路径不应太长，否则就只能添加Default</li></ol><p>小问题<br>根据文件夹创建目录，如果文件夹的层级太多就会失效</p><h1 id="3-使用"><a class="markdownIt-Anchor" href="#3-使用"></a> 3 使用</h1><h2 id="31-分隔符"><a class="markdownIt-Anchor" href="#31-分隔符"></a> 3.1 分隔符</h2><ol><li>::</li></ol><center> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721165055.png"> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721165345.png"> </center><center> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721164811.png"> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721164922.png"> </center><ol start="2"><li>:::<br><img src="" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> obsidian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已迁移 </tag>
            
            <tag> obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.最后一块石头的重量 II</title>
      <link href="/posts/62628/"/>
      <url>/posts/62628/</url>
      
        <content type="html"><![CDATA[<h1 id="1-11049最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1-11049最后一块石头的重量-ii"></a> 1 11049.最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;x 和&nbsp;y，且&nbsp;x &lt;= y。那么粉碎的可能结果如下：</p><p>如果&nbsp;x == y，那么两块石头都会被完全粉碎； 如果&nbsp;x != y，那么重量为&nbsp;x&nbsp;的石头将会完全粉碎，而重量为&nbsp;y&nbsp;的石头新重量为&nbsp;y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>1049.最后一块石头的重量 II 为什么能转化为 01背包问题 #card #疑问 #已解决<br>自顶向下的考虑，算出所有石头的重量和，如果能分成一半一半，那说明正好可以撞完<br>如果不能恰好分成一半一半，让分成的两大块尽量靠近一半。一边大一边小，相减也得到碰撞后的最小重量<br>问题就变成了：创造一个sum/2的背包。在这个背包里尽量装满。<br>如果背包装的满即表示能分成一半一半，也就是最后能撞完。<br>如果没装完，(sum- 装的重量) - 装的重量= half<sup>+</sup>  - half<sup>-</sup> = 相撞后的重量<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720164608.png" alt=""></p><p>本题物品的重量为store[i]，物品的价值也为store[i]。重量和价值是一样的<br>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p><ol><li><p>确定dp[j]的含义<br>j背包下最多可以装dp[j]的重量</p></li><li><p>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li><p>dp数组的初始化 #card #疑问<br>为什么要要一半<br>题目如下要求，最多重量是30000</p></li></ol><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000<br>我们只需要计划总重量的一半<br>dp数组的大小为15000，都初始化为0：<code>vector&lt;int&gt; dp(15001, 0);</code> 从0开始，要多一位</li></ul><ol start="4"><li><p>遍历顺序<br>先物品在背包，背包循环倒序</p></li><li><p>打印dp数组<br>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：<br>用store[1]遍历时<br>dp[4] = max(dp[4], dp[4 - store[1]]+ store[1]) =max(2, 2+2)<br><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p></li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> {<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>,<span class="hljs-number">0</span>)</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            sum += stones[i];<br>        }<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--){<br>                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> (sum - dp[target]) - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>本题与[[13.分割等和子集]]一个类型，不同之处是前者要求能装多少装多，后者要求正好装满</p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1G3411E7oX?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode1049 最后一块石头的重量II 题解_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.最后一块石头的重量 II</title>
      <link href="/posts/62628/"/>
      <url>/posts/62628/</url>
      
        <content type="html"><![CDATA[<h1 id="1-11049最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1-11049最后一块石头的重量-ii"></a> 1 11049.最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;x 和&nbsp;y，且&nbsp;x &lt;= y。那么粉碎的可能结果如下：</p><p>如果&nbsp;x == y，那么两块石头都会被完全粉碎； 如果&nbsp;x != y，那么重量为&nbsp;x&nbsp;的石头将会完全粉碎，而重量为&nbsp;y&nbsp;的石头新重量为&nbsp;y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>1049.最后一块石头的重量 II 为什么能转化为 01背包问题 #card  #已解决<br>自顶向下的考虑，算出所有石头的重量和，如果能分成一半一半，那说明正好可以撞完<br>如果不能恰好分成一半一半，让分成的两大块尽量靠近一半。一边大一边小，相减也得到碰撞后的最小重量<br>问题就变成了：创造一个sum/2的背包。在这个背包里尽量装满。<br>如果背包装的满即表示能分成一半一半，也就是最后能撞完。<br>如果没装完，(sum- 装的重量) - 装的重量= half<sup>+</sup>  - half<sup>-</sup> = 相撞后的重量<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720164608.png" alt=""></p><p>本题物品的重量为store[i]，物品的价值也为store[i]。重量和价值是一样的<br>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p><ol><li><p>确定dp[j]的含义<br>j背包下最多可以装dp[j]的重量</p></li><li><p>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li><p>dp数组的初始化 #card #疑问<br>为什么要要一半<br>题目如下要求，最多重量是30000</p></li></ol><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000<br>我们只需要计划总重量的一半<br>dp数组的大小为15000，都初始化为0：<code>vector&lt;int&gt; dp(15001, 0);</code> 从0开始，要多一位</li></ul><ol start="4"><li><p>遍历顺序<br>先物品在背包，背包循环倒序</p></li><li><p>打印dp数组<br>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：<br>用store[1]遍历时<br>dp[4] = max(dp[4], dp[4 - store[1]]+ store[1]) =max(2, 2+2)<br><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p></li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> {<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>,<span class="hljs-number">0</span>)</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            sum += stones[i];<br>        }<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--){<br>                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> (sum - dp[target]) - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>本题与[[13.分割等和子集]]一个类型，不同之处是前者要求能装多少装多，后者要求正好装满</p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1G3411E7oX?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode1049 最后一块石头的重量II 题解_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床的设置</title>
      <link href="/posts/25586/"/>
      <url>/posts/25586/</url>
      
        <content type="html"><![CDATA[<p>前期设置参考以下文章<br><a href="https://blog.csdn.net/qq_38163244/article/details/110637898?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165814246716781790729080%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165814246716781790729080&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-110637898-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Etag_show&amp;utm_term=%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">阿里云搭建图床_理科男同学的博客-CSDN博客_阿里云图床</a></p><p>picgo如何添加设置<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220718191920.png" alt=""><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/cf534d30e5f74c2b2bbf1545bfb68f3.png" alt=""></p><p>LTAI5tLUoXsgd7XWbdxf9ig2<br>lRXSiwrDFzVeqOsECPaIH9viKeof3p</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.分割等和子集</title>
      <link href="/posts/38902/"/>
      <url>/posts/38902/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分割等和子集"><a class="markdownIt-Anchor" href="#1-分割等和子集"></a> 1 分割等和子集</h1><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接</a></p><p>题目难易：中等</p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p><p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例&nbsp;2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>1 &lt;= nums[i] &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p><p>只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p><p>背包的总容量为 sum/2，每个物品的价值就是他们数组值(应该是这样咯)</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的物品（集合里的元素）重量为 元素的数值，价值也为元素的数值(重量与价值相等)</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。(01背包：每个物品只放一次)</li></ul><ol><li><p>确定dp数组以及下的含义<br>01背包中，dp[j] 表示： 容量为j的背包，所背的物品最大价值为dp[j]。<br><strong>套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]</strong></p></li><li><p>确定递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p></li><li><p>dp数组如何初始化<br>全部初始化为0</p></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br><span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序<br>先物品在背包，for循环第二层倒序</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 开始 01背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>dp[j]的数值一定是小于等于j的。因为dp[j]是价值，j是背包容量</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，即价值=容量，理解这一点很重要。</strong></p><blockquote><p>因为按本题来说：价值等于背包容量</p></blockquote><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210110104240545.png" alt="416.分割等和子集2"></p><p>一层一层的，从后往前赋值的</p><p>最后dp[11] == 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> target;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){<br>            sum += nums[i];<br>        }<br>        target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;=nums[i]; j--){<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-nums[i]]+nums[i]); <br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (dp[target]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[13.mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/动态规划/13.分割等和子集.mp4)</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.0-1背包理论基础（二）</title>
      <link href="/posts/38995/"/>
      <url>/posts/38995/</url>
      
        <content type="html"><![CDATA[<h1 id="1-滚动数组思路"><a class="markdownIt-Anchor" href="#1-滚动数组思路"></a> 1 滚动数组思路</h1><p>滚动数组，就是把二维dp降为一维dp<br><strong>如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p><blockquote><p>上一次的i,j 的值存在max里边，不断的比较得到最大值</p></blockquote><p>滚动数组：在同一层中，不断的进行覆盖然后刷新</p><p>动规五部曲分析如下：</p><h2 id="11-确定dp数组的定义"><a class="markdownIt-Anchor" href="#11-确定dp数组的定义"></a> 1.1 确定dp数组的定义</h2><p>dp[j]：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><h2 id="12-一维dp数组的递推公式"><a class="markdownIt-Anchor" href="#12-一维dp数组的递推公式"></a> 1.2 一维dp数组的递推公式</h2><p>整体思路： 想想如何从前面的数推过来</p><p>dp[j]有两个选择，<br>不放物品i：dp[j]， 未覆盖的值</p><p>放物品i：dp[j - weight[i]] + value[i]，覆盖后的值<br>(总重量 - 要放物品的重量)的最大价值+要放物品的价值<br>除去要放物品的背包 的价值 + 要放物品的价值<br>Q：万一放不了呢，之前二维数组是有一个判断语句，一维中没有啊？<br>A：<code>for(int j = bagWeight; j &gt;= weight[i]; j--)</code>。一维中也有判断语句，进入for循环的条件是背包容量大于所放物品i的重量</p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[j]</span> = max(dp<span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[j - weight<span class="hljs-comment">[i]</span>]</span> + value<span class="hljs-comment">[i]</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="13-一维dp数组如何初始化"><a class="markdownIt-Anchor" href="#13-一维dp数组如何初始化"></a> 1.3 一维dp数组如何初始化</h2><p>dp[0]=0：背包容量为0所背的物品的最大价值是0<br>其他的值都初始为0就行，因为递推公式中会赋值<br>不能初始化太大的值，防止取最大值的时候覆盖掉真实结果<br><strong>总结</strong>：其实全部初始化为0即可</p><h2 id="14-一维dp数组遍历顺序"><a class="markdownIt-Anchor" href="#14-一维dp数组遍历顺序"></a> 1.4 一维dp数组遍历顺序</h2><p><strong>只能先物品后背包</strong><br>如果顺序被颠倒，那么dp数组中记录的都是一个物品的数值了<br><strong>倒序遍历：保证物品只放入一次</strong><br>看下面的例子</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品，二维数组的行，反复覆盖</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// j = 背包容量，也不要忘了=（背包容量等于重量时也可以加入的）</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<span class="hljs-comment">// 不断更新该行的列向量</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么不能正序遍历：例子<br>?<br><code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code><br>物品0的重量<strong>weight[0] = 1</strong>，价值<strong>value[0] = 15</strong><br>如果正序遍历，此时//  [[for 循环]]</p><p>正序循环中的第二for循环的条件应该怎么写  #card #已解决</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 先遍历物品，再遍历背包，内层for循环正序遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>dp[1] = dp[1 - weight[0]] + value[0] = 15<br>dp[2] = dp[2 - weight[0]] + value[0] = 30<br>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历<br>说白了，当前dp[i]要使用上一层左侧的dp值，正序覆盖了上一层左侧的dp值，倒叙避免了覆盖</p><p>倒序遍历：<br><code>vector&lt;int&gt; dp(bagWeight + 1, 0);</code> 原来的初始化是0<br>dp[2] = dp[2 - weight[0]] + value[0] = 15</p><blockquote><p>倒序计算时，由于 dp 数组初始化为 0，所以 dp[2-1] 为 0，所以 dp[2] 为 15</p></blockquote><p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p><h2 id="15-举例推导dp数组"><a class="markdownIt-Anchor" href="#15-举例推导dp数组"></a> 1.5 举例推导dp数组</h2><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p><h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_1_wei_bag_problem</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    <span class="hljs-built_in">cout</span> &lt;&lt; dp[bagWeight] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    test_1_wei_bag_problem();<br>}<br></code></pre></td></tr></tbody></table></figure><p>一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了，<strong>空间复杂度还降了一个数量级</strong><br>推荐用一维数组</p><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3 总结</h1><h2 id="31-面试问题"><a class="markdownIt-Anchor" href="#31-面试问题"></a> 3.1 面试问题</h2><p>要求先实现一个纯二维的01背包,如果写出来了,然后再问为什么两个for循环的嵌套顺序这么写?反过来写行不行 #card<br>第一种是先物品后背包的遍历，根据状态转移方程可得，当前值由该位置的上方和左上上方来确定，首先初始化了第一行和第一列的值，这种先物品后背包的方式，是从左到右的一个个行遍历赋值。遍历到<code>dp[i][j]</code>时，它的上方和左上方都赋值完毕，可以推导出来<br>第二种是先背包后物品的遍历，遍历方式是从上到下的一列一列的遍历赋值。遍历到<code>dp[i][j]</code>时，它的整个左部分都赋值完毕，上方也赋值了。同理可推导出来。<br>所以反过来写是可以的</p><p>[[讲一讲01背包初始化的逻辑。]]</p><p>一维数组的01背包，两个for循环的顺序反过来写行不行 #card #疑问<br>不行，</p><p>注意以上问题都是在候选人把代码写出来的情况下才问的。</p><hr><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a></p><p>[[测试deck]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名失效问题</title>
      <link href="/posts/62729/"/>
      <url>/posts/62729/</url>
      
        <content type="html"><![CDATA[<p>本地source文件添加一个文件：CNAME文件(不要任何的后缀)</p><p>下一次hexo d 就会传上去</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub如何取消域名绑定</title>
      <link href="/posts/14830/"/>
      <url>/posts/14830/</url>
      
        <content type="html"><![CDATA[<p>删除本地source下的CNAME和GitHub上的CNAME文件<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121716990.png" alt=""></p><p>清楚浏览器缓冲<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121715979.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo如何创建短的url</title>
      <link href="/posts/15258/"/>
      <url>/posts/15258/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/rozbo/hexo-abbrlink2">GitHub - rozbo/hexo-abbrlink2</a></p><p>安装插件→添加config信息</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度分析</title>
      <link href="/posts/30256/"/>
      <url>/posts/30256/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1 概念</h1><h2 id="11-定义sup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-label关于时间复杂度你不知道的都在这里-代码随想录"><a class="markdownIt-Anchor" href="#11-定义sup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-label关于时间复杂度你不知道的都在这里-代码随想录"></a> 1.1 定义<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label="关于时间复杂度，你不知道的都在这里！ | 代码随想录</a></sup></h2><a href="#fn:1" rel="footnote"></a><p><a href="#fn:1" rel="footnote">"&gt;[1]</a></p><p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。<br>估计程序运行时间：通常会估算算法的<strong>操作单元数量</strong>来代表程序消耗的时间</p><blockquote><p>这里默认CPU的每个单元运行消耗的时间都是相同的。</p></blockquote><p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p><p>时间复杂度对应的是物理上的加速度<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="1-4 初识时间复杂度_哔哩哔哩_bilibili">[2]</span></a></sup><br>![[时间复杂度分析 2022-08-05 17.27.42.excalidraw]]</p><h2 id="12-复杂度分析"><a class="markdownIt-Anchor" href="#12-复杂度分析"></a> 1.2 复杂度分析</h2><p>复杂度分析只考虑最坏的情况<br><strong>大O用来表示上界的</strong>，它作为算法的最坏情况运行时间的上界</p><p>我们主要关心的还是一般情况下的数据形式。</p><p><strong>面试中说道算法的时间复杂度是多少，指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p><h2 id="13-不同数据规模的差异"><a class="markdownIt-Anchor" href="#13-不同数据规模的差异"></a> 1.3 不同数据规模的差异</h2><p><img src="https://img-blog.csdnimg.cn/20200728191447384.png" alt="时间复杂度，不同数据规模的差异|500"></p><p><strong>我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^{2})&lt;O(2^{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208051803308.png" alt=""></p><p>但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了<br>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）</p><h2 id="14-ologn中的log是以什么为底"><a class="markdownIt-Anchor" href="#14-ologn中的log是以什么为底"></a> 1.4 O(logn)中的log是以什么为底？</h2><p><strong>logn，也就是忽略底数的描述</strong>。也可以是以10为底n的对数，也可以是以20为底n的对数，等等<br><code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code>。<br>而以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121533152.png" alt="|500"></p><h1 id="2-常见的时间复杂度"><a class="markdownIt-Anchor" href="#2-常见的时间复杂度"></a> 2 常见的时间复杂度</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121507462.png" alt="|600"><br>快速排序：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> : sort 函数[[sort函数]]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208051803308.png" alt=""></p><h1 id="3-计算时间复杂度"><a class="markdownIt-Anchor" href="#3-计算时间复杂度"></a> 3 计算时间复杂度</h1><p>时间复杂的是看<strong>次数</strong><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="">[3]</span></a></sup><br>![[时间复杂度分析 2022-08-05 18.11.16.excalidraw]]</p><h2 id="31-普通类型"><a class="markdownIt-Anchor" href="#31-普通类型"></a> 3.1 普通类型</h2><p><s>乘法：乘法操作的时间复杂度 = O(1) ：O(n) 就是乘n次</s><br><s>加法：一般忽略，但从0加到n的为O(n)的复杂度</s></p><h2 id="32-函数类型"><a class="markdownIt-Anchor" href="#32-函数类型"></a> 3.2 函数类型</h2><ol><li>for循环嵌套：循环</li><li>if else：选择分支内最大的复杂度</li><li>[[递归算法的复杂度]]：递归次数 * 每次递归的操作次数</li></ol><h2 id="33-其他类型"><a class="markdownIt-Anchor" href="#33-其他类型"></a> 3.3 其他类型</h2><ol><li>两端算法相加时，取两者最大值：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>O</mi><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>O</mi><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)+T_2(n)=max(Of_1(n),Of_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，eg：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>5</mn></msup><mo>+</mo><mi>n</mi><mo>=</mo><msup><mi>n</mi><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n^5+n=n^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li>两段算法嵌套时：为两者相乘：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)*T_2(n)=O(f_1(n)*f_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，eg：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^{2}*n^{2}=n^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></li><li>有两算法时,本质是时间复杂度为两个函数相加, 但最终结果还是取的大头<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[4. 有序数组的平方]]">[4]</span></a></sup></li></ol><h1 id="4-例子"><a class="markdownIt-Anchor" href="#4-例子"></a> 4 例子</h1><h2 id="41-找出n个字符串中相同的两个字符串假设这里只有两个相同的字符串"><a class="markdownIt-Anchor" href="#41-找出n个字符串中相同的两个字符串假设这里只有两个相同的字符串"></a> 4.1 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。</h2><p>先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。</p><p>那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。</p><h2 id="42-01背包"><a class="markdownIt-Anchor" href="#42-01背包"></a> 4.2 01背包</h2><p>暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里的n表示物品数量。</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">关于时间复杂度，你不知道的都在这里！ | 代码随想录</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV11h411h7nT?p=4&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">1-4 初识时间复杂度_哔哩哔哩_bilibili</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>[[4. 有序数组的平方]]<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 1.算法性能分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.0-1背包理论基础</title>
      <link href="/posts/8980/"/>
      <url>/posts/8980/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p><h1 id="1-01-背包"><a class="markdownIt-Anchor" href="#1-01-背包"></a> 1 01 背包</h1><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题|600"><br><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p><p>01 背包：一个商品只能放入一次<br>完全背包：即物品无限个，可多次放入背包<br>多重背包：每个物品，数量不同</p><p>原始可用暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><h1 id="2-二维dp数组01背包"><a class="markdownIt-Anchor" href="#2-二维dp数组01背包"></a> 2 二维dp数组01背包</h1><p>背包最大重量为4。</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><ol><li>确定dp数组以及下标的含义<br>对于背包问题，有一种写法， 是使用二维数组，<strong>即<code>dp[i][j]</code> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1|600"></li><li>递推公式<br>有两个方向推出来<code>dp[i][j]</code>，</li></ol><ul><li><strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>、头顶格子</li></ul><blockquote><p>(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)<br>i-1是指：只能选择的物品范围是 i-1，而不是真的放了i-1个物品</p></blockquote><ul><li><strong>放物品i</strong>：<code>dp[i - 1][j - weight[i]] + value[i]</code> ，左上方格子</li></ul><blockquote><p>某一列中缺失掉哪一个物品</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719160159.png" alt=""></p><p>从两个方向推出来：1.头顶上一格  2.左上角的一块地方(不是左上角一格)</p><p>所以递归公式：</p><p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs col">```<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155624.png)<br><br>以`dp[1] [3]`为例<br>`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`<br>`dp[1][3] = max(dp[0][3], dp[0][3 - weight[1]] + value[1]);`<br><br>头顶格子：20之前那的值是15，原因是背包重量不够装物品1，即为`dp[i - 1][j]`，`dp[1 -1= 0][3]` ：即头顶格子<br>左上方格子：`dp[0][3 - weight[1]] + value[1]`=`dp[0][0] + value[1]`：(减去要装的重量)的价值 + 要装的价值<br>为什么要取最大值呢<br>?<br>因为装了物品i，有可能会导致前边的一些物品丢弃掉。而丢弃的物品可能价值很大。所以要比较他们的最大值<br><br><br><br><br><br>3.  dp数组如何初始化<br>初始化第一行，第一列。剩下元素即可都推出来<br>从两个方向推出来：1.头顶上一格  2.左上方(不是左上角)<br><br><br>第一列：背包容量为0，一个也装不了，总价值当然为0<br>第一行：物品0的重量为1，所以背包容量&gt;1都可以装物品0一个，所以价值是15<br>![动态规划-背包问题7|600](https://img-blog.csdnimg.cn/20210110103109140.png)<br>其余未赋值的都保持默认0即可，反正最后都会被覆盖掉<br>[[vector]]<br>```c<br>// 初始化 dp<br>vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));<br>for (int j = weight[0]; j &lt;= bagweight; j++) {<br>    dp[0][j] = value[0];<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序<br>有两个遍历的维度：物品与背包重量</li></ol><p><strong>先遍历 物品还是先遍历背包重量都可以</strong><br>先物品在背包，就是一行一行的遍历(从左到右)，遍历到20时，他的左上方和上方都有值<br>先背包在物品，就是一列一列的遍历(从上到下)，遍历到20时，他的左边全部有值(即左上面有值)，上方也全都有值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs col">![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155624.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155536.png)<br></code></pre></td></tr></tbody></table></figure><p><strong>先遍历物品更好理解</strong>，如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];  <span class="hljs-comment">// i的重量太大，放不下</span><br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>先遍历背包</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_2_wei_bag_problem1</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagweight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 二维数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    }<br><br>    <span class="hljs-comment">// weight数组的大小 就是物品个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>        }<br>    }<br><br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_2_wei_bag_problem1</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">带你学透0-1背包问题！| 关于背包问题，你不清楚的地方，这里都讲了！| 动态规划经典问题 | 数据结构与算法_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术蛋老师(git)</title>
      <link href="/posts/29642/"/>
      <url>/posts/29642/</url>
      
        <content type="html"><![CDATA[<p>文章简介：git 怎么用</p><span id="more"></span><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121133310.png" alt=""></p><p>先用git clone 与文件夹创建联系<a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=871.798444">14:31</a><br>git remote add origin <a href="https://gitee.com/liuqingzheng/test.git">https://gitee.com/liuqingzheng/test.git</a> 添加远程仓库<br>git remote -v 查看本地仓库与哪些远程仓库有联系 <a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=914.211131">15:14</a></p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Git工作流和核心原理 | GitHub基本操作 | VS Code里使用Git和关联GitHub_哔哩哔哩_bilibili</a><br>自用跳转连接：🈚️</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.不同的二叉搜索树</title>
      <link href="/posts/45809/"/>
      <url>/posts/45809/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——96.不同的二叉搜索树</p><span id="more"></span><h1 id="1-96不同的二叉搜索树"><a class="markdownIt-Anchor" href="#1-96不同的二叉搜索树"></a> 1 96.不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接</a></p><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121031374.png" alt=""></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>[[二叉搜索树]]</p><p>五部曲</p><ol><li><p>确定dp数组（dp table）以及下标的含义<br><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p></li><li><p>确定递推公式<br>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121051970.png" alt=""></p></li></ol><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量<br>所以是<strong>求和</strong><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121103402.png" alt=""></p><ol start="3"><li><p>dp数组如何初始化<br>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树<br>dp[0] = 1<br>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p></li><li><p>确定遍历顺序<br>顺序遍历<br>dp[i] += dp[j - 1] * dp[i - j]可以看出，<strong>节点数为i的状态是依靠 i之前节点数的状态</strong>。</p></li><li><p>举例推导dp数组<br>n为5时候的dp数组状态如图：</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"><br>[[vector]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){ <span class="hljs-comment">// 从3开始赋值,如果没有上面的if就会 i = 3  ，i &lt;= 1，就错了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++){<span class="hljs-comment">// j从第二个数开始才能划分左右部分，所以是1</span><br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Qf4y1K72t?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode96题 不同的二叉搜索树_哔哩哔哩_bilibili</a><br><a href="https://www.programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.整数拆分</title>
      <link href="/posts/5255/"/>
      <url>/posts/5255/</url>
      
        <content type="html"><![CDATA[<h1 id="1-343整数拆分"><a class="markdownIt-Anchor" href="#1-343整数拆分"></a> 1 343.整数拆分</h1><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接</a></p><p>给定一个正整数&nbsp;n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><ul><li>输入: 2</li><li>输出: 1</li><li>解释: 2 = 1 + 1, 1 × 1 = 1。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: 10</li><li>输出: 36</li><li>解释: 10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。</li><li>说明: 你可以假设&nbsp;n&nbsp;不小于 2 且不大于 58。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-动态规划"><a class="markdownIt-Anchor" href="#21-动态规划"></a> 2.1 动态规划</h2><p>将数的拆分想象成块的切分<br>2,3不切分，因为切分来会变小<br>如果不用去写dp初始值，可以在转移方程里面再加上一个和j * i-j的最大值比较<br>两个for循环是标准的动归写法</p><ol><li>确定dp数组（dp table）以及下标的含义<br>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</li><li>确定递推公式<br>下面这样写需要提前定义2,3不可拆定义出来他们的dp值，因为他俩不用拆是最大<br>dp[i] = max({dp[i],dp[j] * dp[i-j] );<br>dp[i]是随着i的值在一直变化的，max 中有dp[i]就是保证，不断变化中的值取最高的那一个<br>j是切的位置，把一个数切成两部分，而这左右两部分又可以在切。也就是dp[j]，dp[i-j]，也是默认将一个数强制拆成4份以及4份以上了。</li></ol><p>或者这样，不用提前定义dp[2]，dp[3]<br>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));<br>3. dp的初始化<br>dp[0] dp[1]无意义，没法拆，所以不赋值。从dp[2] = 1开始，把dp[3] = 2。<br>2，3不用拆是最大的</p><h2 id="22-贪心算法"><a class="markdownIt-Anchor" href="#22-贪心算法"></a> 2.2 贪心算法</h2><p>数学已证明过：<strong>每次拆成n个3，如果剩下是4，则保留4，然后相乘</strong><br>尽量切3，最后切2，2和3是最稳定最稳定不可拆分质数</p><blockquote><p>1，2，3不划分最大，一划分反而变小了</p></blockquote><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-动态规划"><a class="markdownIt-Anchor" href="#31-动态规划"></a> 3.1 动态规划</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){ <span class="hljs-comment">// 应该从数字4开始，对应的下标是5 </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){ <span class="hljs-comment">// 切一半就行，另一半是对称的</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j*(i-j), j*dp[i-j])); <span class="hljs-comment">// 后一个max中是数的相乘 和 数和上一次的最优结果相乘</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 2，3不切分，要这样赋值下面才能通过</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]*dp[i-j]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果递归公式是 dp[i] = max(dp[i], dp[i - j] * dp[j]);，就一定要这么初始化。递推公式没毛病，但初始化解释不通！</p><p>虽然代码在初始位置有一个判断if (n &lt;= 3) return 1 * (n - 1);，保证n&lt;=3 结果是正确的，但代码后面又要给dp[1]赋值1 和 dp[2] 赋值 2，<strong>这其实就是自相矛盾的代码，违背了dp[i]的定义！</strong></p><p>我举这个例子，其实就说做题的严谨性，上面这个代码也可以AC，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112130227.png" alt=""><br>// 错了的原因是dp[1]是0，必须定义dp[1] = 1,另外还有其他的原因</p><h2 id="32-贪心"><a class="markdownIt-Anchor" href="#32-贪心"></a> 3.2 贪心</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 要有 = 4的判断，不然4的没法输出</span><br>                <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;，<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">4</span>){<br>            result *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        }<br>        <span class="hljs-keyword">return</span> result * n;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112032423.png" alt=""></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Nt4y1D7gh?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">LeetCode每日打卡.343.整数拆分_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.不同路径 II</title>
      <link href="/posts/13413/"/>
      <url>/posts/13413/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——63. 不同路径 II</p><span id="more"></span><h1 id="1-63不同路径-ii"><a class="markdownIt-Anchor" href="#1-63不同路径-ii"></a> 1 63.不同路径 II</h1><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑<strong>网格中有障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20210111204901338.png" alt=""></p><p><strong>网格中的障碍物和空位置分别用 1 和 0 来表示。</strong></p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210111204939971.png" alt=""></p><ul><li>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</li><li>输出：2 解释：</li><li>3x3 网格的正中间有一个障碍物。</li><li>从左上角到右下角一共有 2 条不同的路径：<ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/20210111205857918.png" alt=""></p><ul><li>输入：obstacleGrid = [[0,1],[0,0]]</li><li>输出：1</li></ul><p>提示：</p><ul><li>m ==&nbsp;obstacleGrid.length</li><li>n ==&nbsp;obstacleGrid[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>相比[[6.不同路径]]不同的是多了障碍，遇到障碍<code>dp[i][j]</code>保持0就可以了：表示过不去</p><p>两个地方需要跳过赋值</p><ol><li>初始值(第一行第一列)，跳过有障碍的地方在赋值</li><li>递推公式中(除了第一行第一列的)，跳过有障碍的地方在赋值</li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[j][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">0</span>){ <span class="hljs-comment">// if (obstacleGrid[i][j] == 1) continue;</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.不同路径</title>
      <link href="/posts/31702/"/>
      <url>/posts/31702/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——62.不同路径</p><span id="more"></span><h1 id="1-62不同路径"><a class="markdownIt-Anchor" href="#1-62不同路径"></a> 1 62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p><p>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt=""></p><ul><li>输入：m = 3, n = 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m = 2, n = 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m = 7, n = 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m = 3, n = 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-图论"><a class="markdownIt-Anchor" href="#21-图论"></a> 2.1 图论</h2><p>暂定</p><h2 id="22-数论"><a class="markdownIt-Anchor" href="#22-数论"></a> 2.2 数论</h2><p>暂定</p><h2 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h2><p>m✖️n：行✖️列<br>按照动规五部曲来分析：</p><p><strong>1. 确定dp数组（dp table）以及下标的含义</strong><br><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。<br><strong>2. 确定递推公式</strong><br>机器人只能向下或向右移动<br>所以<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。(上面，左面)<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为只能从上面或者左面过来<br><strong>3.  dp数组的初始化</strong><br>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。<br>所以初始化代码为：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>4.  确定遍历顺序</strong><br>这里要看一下递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套</p><p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p><p><strong>5.  举例推导dp数组</strong></p><p>如图所示：<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[2][2] = dp[1][2] + dp[2][1]</code>，<code>dp[3][7] = dp[2][7] + dp[3][6]</code> 上面/左面<br><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-二维数组解法编译已通过"><a class="markdownIt-Anchor" href="#31-二维数组解法编译已通过"></a> 3.1 二维数组解法，编译已通过</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){ <span class="hljs-comment">// 从(1,1)开始的</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>              dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>          }<br>      }<br>      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 因为下标从0开始，所以-1</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-一维数组"><a class="markdownIt-Anchor" href="#32-一维数组"></a> 3.2 一维数组</h2><p>编译已通过<br>用一维数组的前提是：二维数组的第一行和第一列是相同的值，这样才能保证滚动数组的初始值是一样的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span> <span class="hljs-params">(n,<span class="hljs-number">1</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;m; i++){<span class="hljs-comment">// 为什么要从1开始呢，因为0行全是1(已经赋值了)，所以从第1行开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;n; j++){<span class="hljs-comment">// 因为第一列是1，从第二列开始赋值的</span><br>                dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 从第0行开始的，差了一个1</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>![[6.不同路径 2022-07-13 18.05.50.excalidraw|600]]<br>滚动数组写法模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp********">void test_1_wei_bag_problem() {<br>    vector&lt;int&gt; weight = {1, 3, 4};<br>    vector&lt;int&gt; value = {15, 20, 30};<br>    int bagWeight = 4;<br><br>    // 初始化<br>    vector&lt;int&gt; dp(bagWeight + 1, 0);<br>    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品<br>        for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量<br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br>int main() {<br>    test_1_wei_bag_problem();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a><br>原理 <a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=225.736626">03:45</a></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.不同路径</title>
      <link href="/posts/31702/"/>
      <url>/posts/31702/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——62.不同路径</p><span id="more"></span><h1 id="1-62不同路径"><a class="markdownIt-Anchor" href="#1-62不同路径"></a> 1 62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p><p>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt=""></p><ul><li>输入：m = 3, n = 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m = 2, n = 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m = 7, n = 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m = 3, n = 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-图论"><a class="markdownIt-Anchor" href="#21-图论"></a> 2.1 图论</h2><p>暂定</p><h2 id="22-数论"><a class="markdownIt-Anchor" href="#22-数论"></a> 2.2 数论</h2><p>暂定</p><h2 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h2><p>m✖️n：行✖️列<br>按照动规五部曲来分析：</p><p><strong>1. 确定dp数组（dp table）以及下标的含义</strong><br><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。<br><strong>2. 确定递推公式</strong><br>机器人只能向下或向右移动<br>所以<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。(上面，左面)<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为只能从上面或者左面过来<br><strong>3.  dp数组的初始化</strong><br>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。<br>所以初始化代码为：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>4.  确定遍历顺序</strong><br>这里要看一下递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套</p><p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p><p><strong>5.  举例推导dp数组</strong></p><p>如图所示：<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[2][2] = dp[1][2] + dp[2][1]</code>，<code>dp[3][7] = dp[2][7] + dp[3][6]</code> 上面/左面<br><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-二维数组解法编译已通过"><a class="markdownIt-Anchor" href="#31-二维数组解法编译已通过"></a> 3.1 二维数组解法，编译已通过</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){ <span class="hljs-comment">// 从(1,1)开始的</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>              dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>          }<br>      }<br>      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 因为下标从0开始，所以-1</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-一维数组"><a class="markdownIt-Anchor" href="#32-一维数组"></a> 3.2 一维数组</h2><p>编译已通过<br>用一维数组的前提是：二维数组的第一行和第一列是相同的值，这样才能保证滚动数组的初始值是一样的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span> <span class="hljs-params">(n,<span class="hljs-number">1</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;m; i++){<span class="hljs-comment">// 为什么要从1开始呢，因为0行全是1(已经赋值了)，所以从第1行开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;n; j++){<span class="hljs-comment">// 因为第一列是1，从第二列开始赋值的</span><br>                dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 从第0行开始的，差了一个1</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>![[6.不同路径 2022-07-13 18.05.50.excalidraw|600]]<br>滚动数组写法模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp********">void test_1_wei_bag_problem() {<br>    vector&lt;int&gt; weight = {1, 3, 4};<br>    vector&lt;int&gt; value = {15, 20, 30};<br>    int bagWeight = 4;<br><br>    // 初始化<br>    vector&lt;int&gt; dp(bagWeight + 1, 0);<br>    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品<br>        for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量<br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br>int main() {<br>    test_1_wei_bag_problem();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a><br>原理 <a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=225.736626">03:45</a></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.使用最小花费爬楼梯</title>
      <link href="/posts/27967/"/>
      <url>/posts/27967/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解—— 746. 使用最小花费爬楼梯</p><span id="more"></span><h1 id="1-使用最小花费爬楼梯"><a class="markdownIt-Anchor" href="#1-使用最小花费爬楼梯"></a> 1 使用最小花费爬楼梯</h1><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接</a></p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值&nbsp;cost[i]（下标从 0 开始）。</p><p><strong>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</strong></p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例&nbsp;1：</p><p>输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 &nbsp;示例 2：</p><blockquote><p>第一次不要钱，爬上了15，支付15后可以爬一层到楼顶，那我从10开始支付10爬两层不是更好吗</p></blockquote><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>提示：</p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong></p><p>动归五部曲</p><p><font color="#F36208">1.  确定dp数组以及下标的含义</font><br><strong>dp[i]的定义：到达第i个台阶所花费的最<br>少体力为dp[i]</strong>。<br>注意这里认为是第一步一定是要花费：<br>dp[0] = cost[0];<br>dp[1] = cost[1];<br><strong>dp[2] = min(dp[0], dp[1]) + cost[2];</strong><br><font color="#F36208">2.  确定递推公式</font><br><strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong>。</p><blockquote><p>一旦支付当前下边相应的体力值，就可向上爬一个或者两个楼梯</p></blockquote><p><strong>dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</strong><br>爬上台阶i，可能是从 i - 1 层，i-2层爬上来的，然后在离开台阶i 又在需要花费cost[i]<br><font color="#F36208">3. dp数组初始化</font><br>题目说：可以选择从下标为 0 或 1 的元素作为初始阶梯。<br>从下标0处离开需要cost[0]，下标1同理</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br></code></pre></td></tr></tbody></table></figure><p><font color="#F36208">4. 遍历顺序</font><br>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。<br><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。<br><font color="#F36208">5. 举例推导dp数组</font></p><table><thead><tr><th>cost</th><th>10</th><th>15</th><th>20</th></tr></thead><tbody><tr><td>dp[i]</td><td>10</td><td>15</td><td>30</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2021010621363669.png" alt="746.使用最小花费爬楼梯"><br>为什么选择最后两位的最小值呢<br>?<br>最后两位支付该值都可以到下一层，假设所求是第N层的最小开销，只需要计算min(谁能到N层)，到了N层后又不到下一层，所以相当于最后一步不用花费，就停止到那了，不用+cost[i]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++){<span class="hljs-comment">// 这里不用&lt;=，因为下标从0开始，取不到cost.size()||从第三个元素开始，下标是2</span><br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[cost.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>], dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1fq4y1T7Uo?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode-746.使用最小花费爬楼梯_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.爬楼梯</title>
      <link href="/posts/34749/"/>
      <url>/posts/34749/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——70. 爬楼梯</p><span id="more"></span><h1 id="1-爬楼梯"><a class="markdownIt-Anchor" href="#1-爬楼梯"></a> 1 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。<strong>你有多少种不同的方法</strong>可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><ul><li>输入： 2</li><li>输出： 2</li><li>解释： 有两种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶</li><li>2 阶</li></ul></li></ul><p>示例 2：</p><ul><li>输入： 3</li><li>输出： 3</li><li>解释： 有三种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul></li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。<br>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。<br>第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。<br>dp[3] = dp[2] + dp[1] = 2+1 =3</p><p>动归五部曲：</p><ol><li>确定dp数组以及下标的含义<br>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li><li>确定递推公式<br>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。<br>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么<br>dp[i] = dp[i - 1] + dp[i - 2] 。</li><li>dp数组如何初始化<br>不考虑dp[0]，dp[1] = 1， dp[2] = 2</li></ol><blockquote><p>dp[0]没有意义，i从3 开始递推</p></blockquote><ol start="4"><li>确定遍历顺序<br>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</li><li>举推导dp数组<br>举例当n为5的时候，dp table（dp数组）应该是这样的<br><img src="https://img-blog.csdnimg.cn/20210105202546299.png" alt="70.爬楼梯"></li></ol><blockquote><p>本质就是斐波那契数列，就是没有讨论dp[0] 的情况</p></blockquote><p>#面试<br>有的题解是把dp[0]初始化为1，然后遍历的时候i从2开始遍历，这样是可以解题的，然后强行解释一波dp[0]应该等于1的含义。<br>一个严谨的思考过程，应该是初始化dp[1] = 1，dp[2] = 2，然后i从3开始遍历，<br>这个可以是面试的一个小问题，考察候选人对dp[i]定义的理解程度。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>优化一下空间复杂度</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">2</span>] + dp [<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">2</span>] = sum;<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>]; <br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-加强版爬楼梯"><a class="markdownIt-Anchor" href="#4-加强版爬楼梯"></a> 4 加强版爬楼梯</h1><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 把m换成2，就可以AC爬楼梯这道题</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试，哈哈</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。</p><p>我在<a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html">通过一道面试题目，讲一讲递归算法的时间复杂度！</a><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html"></a><br>中，以我自己面试别人的真实经历，通过求x的n次方 这么简单的题目，就可以考察候选人对算法性能以及递归的理解深度，录友们可以看看，绝对有收获！</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5 参考资料</h1><p><a href="https://www.programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.斐波那契数</title>
      <link href="/posts/33325/"/>
      <url>/posts/33325/</url>
      
        <content type="html"><![CDATA[<p>文章简介：LeetCode 题解 ——509. 斐波那契数</p><span id="more"></span><h1 id="1-509-斐波那契数"><a class="markdownIt-Anchor" href="#1-509-斐波那契数"></a> 1 509. 斐波那契数</h1><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接</a></p><p>斐波那契数，通常用&nbsp;F(n) 表示，形成的序列称为 斐波那契数列 。该数列由&nbsp;0 和 1 开始，<strong>后面的每一项数字都是前面两项数字的和</strong>。也就是： F(0) = 0，F(1)&nbsp;= 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1：</p><ul><li>输入：2</li><li>输出：1</li><li>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</li></ul><p>示例 2：</p><ul><li>输入：3</li><li>输出：2</li><li>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</li></ul><p>示例 3：</p><ul><li>输入：4</li><li>输出：3</li><li>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</li></ul><p>提示：</p><ul><li>0 &lt;= n &lt;= 30</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 因为下标从0开始，要总长度所以+1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++){ <span class="hljs-comment">// 是≤，要把n也算上，因为最后输出的是n</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<span class="hljs-comment">// vector的返回和使用都要用[]</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=9fc19dba-4edb-4f3d-8d7e-22b7c2462fc7">obsidian</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.动态规划理论基础</title>
      <link href="/posts/31294/"/>
      <url>/posts/31294/</url>
      
        <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p>动态规划，英文：Dynamic Programming，简称DP<br><strong>动态规划中每一个状态一定是由上一个状态推导出来的</strong>，贪心是局部最优推导全局最优</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><h1 id="1-动态规划解题步骤"><a class="markdownIt-Anchor" href="#1-动态规划解题步骤"></a> 1 动态规划解题步骤</h1><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组<br><strong>一些情况是递推公式决定了dp数组要如何初始化！</strong></li></ol><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。<br>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。<br><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><h2 id="11-debug"><a class="markdownIt-Anchor" href="#11-debug"></a> 1.1 debug</h2><p><strong>如果代码写出来了，一直AC不了，灵魂三问：</strong></p><ol><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ol><p>哈哈，专治各种代码写出来了但AC不了的疑难杂症。</p><h1 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2 参考资料</h1><p><a href="https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">代码随想录</a><br>自用跳转连接：🈚️</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24.监控二叉树</title>
      <link href="/posts/43575/"/>
      <url>/posts/43575/</url>
      
        <content type="html"><![CDATA[<p>文章简介：968.监控二叉树</p><span id="more"></span><h1 id="1-968监控二叉树"><a class="markdownIt-Anchor" href="#1-968监控二叉树"></a> 1 968.监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20201229175736596.png" alt=""></p><ul><li>输入：[0,0,null,0,0]</li><li>输出：1</li><li>解释：如图所示，一台摄像头足以监控所有节点。</li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/2020122917584449.png" alt=""></p><ul><li>输入：[0,0,null,0,null,0,null,null,0]</li><li>输出：2</li><li>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</li></ul><p>提示：</p><ul><li>给定树的节点数的范围是 [1, 1000]。</li><li><strong>每个节点的值都是 0</strong>。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>为什么不从头结点开始看起呢，为啥要从叶子节点看呢<br>?<br>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。<br><strong>局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，<br>整体最优：全部摄像头数量所用最少！</strong></p><p>大体思路就是：从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点</p><p>每个节点可能有几种状态：<br>有如下三种：</p><ul><li>该节点无覆盖</li><li>本节点有摄像头</li><li>本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051425661.png" alt=""></p><h1 id="3-参考资料"><a class="markdownIt-Anchor" href="#3-参考资料"></a> 3 参考资料</h1><p><a href="https://www.programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转连接：🈚️</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验设计</title>
      <link href="/posts/65372/"/>
      <url>/posts/65372/</url>
      
        <content type="html"><![CDATA[<p>镁合金设置温度分布<br>挤压角度：100°，110，120，130，140</p><blockquote><p>110， 120 的圆盘成形效果最好，140的圆棒成形效果最好<br>因为110°的倾角小</p></blockquote><p>![[实验设计 2022-07-09 16.42.40.excalidraw|600]]</p><p>镁合金AZ31B 直径：9.90~9.95，长度40mm<br>![[退火#^ckuxll]]<br>考虑到现场加热会导致热胀, 不一定能够放入模具中, 先订购一批不同尺寸的工件来试试</p><p>我现在有16个镁合金圆棒<br>7月份的实验</p><ul><li><p>控制角度变温度</p><ul><li>110°挤压块性能最好 100°→400°的做7个</li><li>120°挤压块同理7个</li><li>在做一个无加热的，对比实验，主要是拍照片</li><li>综上测出性能最好的角度和温度，确定好最合适的温度</li></ul></li><li><p>控制温度变角度</p><ul><li>先确定一个最合适的温度</li><li>在用该温度做其他挤压块的角度 (5个：100°→140°)</li><li></li></ul></li></ul><p><a href="https://zeefan.notion.site/b7ef71846ce04735a7c3319ea5143a18?v=c8f779be7dee48979931444cb7d77ada">Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.</a></p><hr><p>试验温度为室温和100, 150, 200, 250, 300, 350, 400 ℃<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[1]</span></a></sup><br>200°时，得到最好的性能</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/F62253DC-5296-4BB8-A7BF-97F9BD2553CF">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>23.买卖股票的最佳时机含手续费</title>
      <link href="/posts/9689/"/>
      <url>/posts/9689/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>力扣题解：714. 买卖股票的最佳时机含手续费</p><span id="more"></span><h1 id="1-买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#1-买卖股票的最佳时机含手续费"></a> 1 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接</a></p><p>给定一个整数数组&nbsp;prices，其中第&nbsp;i&nbsp;个元素代表了第&nbsp;i&nbsp;天的股票价格 ；非负整数&nbsp;fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。<strong>如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</strong></p><p><strong>返回获得利润的最大值。</strong></p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><blockquote><p>相当于买入和卖出</p></blockquote><p>示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8</p><p>解释: 能够达到的最大利润: 在此处买入&nbsp;prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润:&nbsp;((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p><p>注意:</p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-6-买卖股票的最佳时机ii"><a class="markdownIt-Anchor" href="#21-6-买卖股票的最佳时机ii"></a> 2.1 [[6. 买卖股票的最佳时机II]]</h2><p>![[6. 买卖股票的最佳时机II#2 思路]]<br>与 6的区别是多了个手续费<br>有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。<br>用贪心策略，就是最低值买，最高值（减去手续费还盈利）就卖。</p><p>找到两个点</p><ul><li>买入日期：其实很好想，遇到更低点就记录一下。</li><li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li></ul><p>做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（<strong>不是真正的卖出，相当于持有股票</strong>），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><h3 id="211-思路总结"><a class="markdownIt-Anchor" href="#211-思路总结"></a> 2.1.1 思路总结</h3><ol><li>不断的寻找最低点，在最低点时买入</li><li>寻找有利润的时候买入，更新下一次的买入位置在循环卖出</li><li>对所有利润加和</li></ol><h2 id="22-断点调试"><a class="markdownIt-Anchor" href="#22-断点调试"></a> 2.2 断点调试</h2><p>[23.买卖股票的最佳时机含手续费](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4)</p><p>[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=10.471542) 情况三：现在的价格不是最低的，并且卖出的话亏本</p><p>[00:28](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=28.795416)<br>#疑问 #已解决<br>为什么要minPrice = prices[i]- fee呢，如果去掉了- fee 则结果不对<br><s>因为在该下标处已经交过了一次手续费，不需要在交了？？？</s></p><p>输入：prices = [1,3,7,5,10,3], fee = 3<br>输出：6<br>相当于：1时买入，10时卖出(10-1-3 = 6)<br>并不是：1时买入，7时卖出，5时买入，10时卖出(7-1-3  +  10 - 5 -3 = 5)<br>minprice = price[i] - fee  有正利润就假装卖了，先收集利润，- fee 的作用是如果后边的还有利润更高的，则这次其实是不卖的<br>eg：7时有正利润的先收集起来(7-1-3=3)<br>但此时的minPrice = 7-3  =&nbsp;4， 4是后边的最小的，接下来的利润是10-4-3= 3<br>总利润就是3+3 = 6，而不是像上边计算的5，这个作用就是，看似在7处卖了，实际没卖，最后是在10的位置卖的</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =&nbsp;<span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];<br>            <span class="hljs-keyword">if</span> (prices[i] &gt; minPrice &amp;&amp; prices[i] - minPrice - fee &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (prices[i] - minPrice - fee &gt; <span class="hljs-number">0</span>){<br>                result += prices[i] -minPrice - fee;<br>                minPrice = prices[i] - fee; <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-知识点"><a class="markdownIt-Anchor" href="#4-知识点"></a> 4 知识点</h1><p>[[continue]]</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22.单调递增的数字</title>
      <link href="/posts/17411/"/>
      <url>/posts/17411/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>力扣题解： 738.单调递增的数字</p><span id="more"></span><h1 id="1-738单调递增的数字"><a class="markdownIt-Anchor" href="#1-738单调递增的数字"></a> 1 738.单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接</a></p><p>给定一个非负整数&nbsp;N，找出小于或等于&nbsp;N&nbsp;的最大的<strong>整数</strong>，同时这个整数需要满足其<strong>各个位数上</strong>的数字是单调递增。</p><p>（当且仅当每<strong>个相邻位数上的数字&nbsp;x&nbsp;和&nbsp;y&nbsp;满足&nbsp;x &lt;= y</strong>&nbsp;时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>输入: N = 10</li><li>输出: 9</li></ul><p>示例 2:</p><ul><li>输入: N = 1234</li><li>输出: 1234</li></ul><p>示例 3:</p><ul><li>输入: N = 332</li><li>输出: 299</li></ul><p>说明: N&nbsp;是在&nbsp;[0, 10^9]&nbsp;范围内的一个整数。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>找≤ N，的最大单增的整数<br>如果不递增，就把除最后一位每一位都减1，这样保证了减过数比原数小。然后在把除了第一个位(因为第一个位最大不能变，变了会使得比原来的数大)，后边的位数全部令为9，这样就得到了最大的整数。<br>代码：一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9</p><p>例如<br>332 → 222→299<br>753 → 643 → 699</p><h2 id="21-断点调试"><a class="markdownIt-Anchor" href="#21-断点调试"></a> 2.1 断点调试</h2><p>[22.单调递增的数字(carl:332).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl).mp4)<br>[00:07](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=7.519521) 前一个数大于后一个数则让前一个数减1</p><blockquote><p>从后往前遍历，for (i = num.size () - 1; i &gt; 0; i–) [[for 循环]]</p></blockquote><p>flag至少是1，因为i 不会取到0。这样就报证了至少从第二个2数开始赋9，直到到最后一个数</p><p>[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=10.337641) 只需要减1的原因是：让他的每一个位都比原来的数小，在把除了第一个位(因为第一个位最大)，后边的位数全部令为9，这样就得到了最大的整数</p><p>[22.单调递增的数字(carl/1234)](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl:1234).mp4)<br>1234 本身都是递增的，所以第一个for循环会跳过，第二for循环也不会执行</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        string strNum = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>() ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--){<br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>]&gt; strNum[i]){<br>                flag = i;<br>                strNum[i<span class="hljs-number">-1</span>]--;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++){<br>            strNum[i] = <span class="hljs-string">'9'</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span> (strNum);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>stoi函数 #flashcards/代码随想录<br>?<br>将数字字符串转为数字：“2147482” → 2147482</p><!--SR:!2022-07-07,3,250--><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">代码随想录</a><br>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=49dde99d-8015-4224-9c0b-96d9d0dae41a">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>材料内部结构</title>
      <link href="/posts/65236/"/>
      <url>/posts/65236/</url>
      
        <content type="html"><![CDATA[<p>滑移性能最好的晶格为：面心立方 &gt; 体心立方 &gt; 密排六方</p><blockquote><p>(塑性性能指标)</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206281433535.png" alt=""></p><blockquote><p>BCC是体心立方，上边写错了</p></blockquote><p>面心立方材料：铝（Al）、铜（Cu）、镍（Ni）、金（Au）、银（Ag）、γ-铁（γ-Fe,912℃~1394℃)</p><p>密排六方材料：Mg， Zn，铍<br>镁合金等密排六方晶格金属在 250~400℃之间成形,密排六方(hcp)金属滑移系少,主要靠孪生变形</p><p>V体：Fe Cr Mo</p><blockquote><p>V体是什么，等查一查</p></blockquote><p>自用跳转连接：<a href="marginnote3app://note/D9087A24-CEF0-4136-B1D1-42F789B404D2">黄珍媛老师</a>，<a href="marginnote3app://note/40F63EDC-2FA9-46FE-BC55-141C72946015">夏琴香老师讲塑性变形</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=b9ec2231-bc80-4831-9b86-5e112ada3bfb">ob</a>，<a href="http://localhost:4000/2022/06/28/ke-yan/cai-liao-nei-bu-jie-gou/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代制造工程</title>
      <link href="/posts/64386/"/>
      <url>/posts/64386/</url>
      
        <content type="html"><![CDATA[<p>[[现代制造工程–周驰]]</p><p><strong>2022-06-29(后记)：</strong></p><p><strong>简答题</strong>：5 * 5  =25</p><ol><li><p>电火花的原理是什么，不可缺少什么，适用于什么材料。</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291624610.png" alt="|600"></li></ol></li><li><p>化学沉积和物理沉积的定义与区别</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291626815.png" alt="|600"></li></ol></li><li><p>画个六点定位原理图</p></li><li><p>坐标变换(周驰作业题)</p></li><li><p>金属材料加热发生的变化(答5点)</p></li></ol><p><strong>辨析题</strong>：15+15 = 30</p><ol><li><p>从“生产规模，资源配置，生产技术”三方面来说现代制造工程的发展</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291622155.png" alt="|600"></li></ol></li><li><p>金属塑性成形的两种方式，冷塑性对金属材料内部和性能的影响</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291623008.png" alt="|600"></li></ol></li></ol><p>其余的都是选择(20个 1.5分)和判断(15个 15分)</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>notion函数详解</title>
      <link href="/posts/49277/"/>
      <url>/posts/49277/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.csdn.net/tags/NtzaggysMDE2OTctYmxvZwO0O0OO0O0O.html">notion多条件formula - CSDN</a></p><h1 id="1-一-属性列名-properties"><a class="markdownIt-Anchor" href="#1-一-属性列名-properties"></a> 1 一、属性（列名-properties）</h1><ol><li><p>prop(“属性”) 返回每个条目的“属性值”，点击即可用对应的格式插入到公式中。</p></li><li><p>公式中的四种方式</p><p>四 种 格 式 { 数 字 日 期 字 符 串 复 选 框 四种格式\begin{cases} 数字 &amp; \ 日期 &amp; \字符串 &amp;\复选框 &amp; \end{cases} 四种格式⎩⎪⎪⎪⎨⎪⎪⎪⎧​数字日期字符串复选框​​</p></li></ol><p>floor((prop(“小时”) + prop(“分钟”) / 60) * 100) / 100</p><h1 id="2-二-常量constants"><a class="markdownIt-Anchor" href="#2-二-常量constants"></a> 2 二、常量（constants）</h1><p>常 量 { e 自 然 对 数 的 底 数 p i 圆 周 率 t r u e 真 f l a s e 假 常量\begin{cases} e &amp;自然对数的底数 \ pi &amp;圆周率 \true &amp;真\flase &amp;假 \end{cases} 常量⎩⎪⎪⎪⎨⎪⎪⎪⎧​epitrueflase​自然对数的底数圆周率真假​</p><h1 id="3-三-基本运算"><a class="markdownIt-Anchor" href="#3-三-基本运算"></a> 3 三、基本运算</h1><ol><li><p>if语法（“<code>if</code>”）：进行条件判断，在两个选项（要为同一格式）中选择一个。</p><p>语法：</p><ul><li><code>boolean?value:value</code></li><li><code>if(boolean,value,value)</code></li></ul><p>补充：在"boolean"不能填写0或者1；value中，true（真）为1，false（假）为0；</p></li><li><p>加法（"<code>+</code>“或"<code>add</code>"）：把两个数字或字符串相加，并返回它们的值</p><p>语法：</p><ul><li><code>value+value</code></li><li><code>add(value,value)</code></li></ul><p>说明：value可以是数字或字符串，为字符串时要加上双引号</p></li><li><p>减法（”<code>-</code>“或“<code>subtract</code>”）：将两个数字相减，并返回它们的值</p><p>语法：</p><ul><li><code>number-number</code></li><li><code>subtract(number,number)</code></li></ul></li><li><p>乘法（”<code>*</code>“或“<code>multiply</code>”）：将两个数字相乘，并返回它们的值</p><p>语法：</p><ul><li><code>number*number</code></li><li><code>multiply(number,number)</code></li></ul></li><li><p>除法（”<code>/</code> “或"<code>divide</code>"）：将两个数字相乘，并返回他们的值</p><p>语法：</p><ul><li><code>number/number</code></li><li><code>divide(number,number)</code></li></ul></li><li><p>绝对值（"<code>abs</code>"）：返回数的绝对值</p><p>语法：<code>abs(number)</code></p></li><li><p>求余运算（”<code>%</code>“或"<code>mod</code>"）：把两个数进行求余运算，并返回它们的值</p><p>语法：</p><ul><li><code>number%number</code></li><li><code>mod(number,number)</code></li></ul></li><li><p>”四舍五入“（”<code>round</code>“）：对数字进行”四舍五入“</p><p>语法：<code>round(number)</code></p><p>说明：默认情况下只保留整数。要保留n位小数时，应使用</p><p>r o u n d ( n u m b e r ∗ 1 0 n ) / 1 0 n round(number*10<sup>n)/10</sup>n round(number∗10n)/10n</p></li><li><p>一元负数（”<code>unaryminus</code>“或“<code>-</code>”）：对一个数进行取它的负数</p><p>语法：</p><p><code>-number</code></p><p><code>unaryminus(number)</code></p><p>如：-3==unaryminus(3)</p></li><li><p>一元加号（“<code>+</code>”或“<code>unaryPlus</code>”）：将参数转化为数字。</p></li></ol><pre><code class="hljs">语法：`+value``unaryPlus(value)`补充：可以将true转化为1，false转化为0</code></pre><h1 id="4-四-关系逻辑判断"><a class="markdownIt-Anchor" href="#4-四-关系逻辑判断"></a> 4 四、关系逻辑判断</h1><ol><li>关系判断<ul><li>大于 &gt;</li><li>小于 &lt;</li><li>等于 ==</li><li>大于等于 &gt;=</li><li>小于等于 &lt;=</li><li>不等于 !=</li></ul></li><li>逻辑判断<ul><li><p>逻辑“<code>非</code>”：对逻辑参数进行否定</p><p>语法：</p><p><code>not boolean</code></p><p><code>not (boolean)</code></p></li><li><p>逻辑“<code>与</code>”：对逻辑参数进行“与”运算，<code>“一假全假”</code></p><p>语法：</p><p><code>boolean and boolean</code></p><p><code>and(boolean,boolean)</code></p></li><li><p>逻辑“或”：对逻辑参数进行“或”运算，<code>“一真全真”</code></p><p>语法：</p><p><code>boolean or boolean</code></p><p><code>or(boolean,boolean)</code></p></li></ul></li></ol><h1 id="5-五-字符串函数"><a class="markdownIt-Anchor" href="#5-五-字符串函数"></a> 5 五、字符串函数</h1><ol><li><p>连接函数（“<code>concat</code>”）：将字符串进行连接</p><p>语法：</p><p><code>concat(text...)</code></p><p><code>text+text+...</code></p></li><li><p>插符函数（“<code>join</code>”）：插入字符函数，在其余叁数之间插入第一个参数并返回它们的连接字符串</p><p>语法：<code>join(text...)</code></p><p>例如：join("-",“a”,“b”,“c”)==“a-b-c”</p></li><li><p>切片函数（”<code>slice</code>“）：从字符串中提取子字符串（包括开头索引，不包括结尾索引[start,end)）</p><p>语法：</p><ul><li><code>slice(text,number)</code></li><li><code>slice(text,number1,number2)</code></li></ul><p>说明:只有一个数字时，就是从这个索引数字开始到结束；当有两个数字时（第二个数要大于第一个数，不然不会显示），从字符串中提取子字符串，包含开头索引，不包含结束索引。</p><p>注意：字符串的索引值是从0开始的</p></li><li><p>长度函数（”<code>length</code>“）：返回字符串的长度，返回值是一个数值。</p><p>语法：<code>length(text)</code></p></li><li><p>转化函数（”<code>format</code>“）：将其他格式的参数转化为字符串。</p><p>语法：<code>format(value)</code></p></li><li><p>转化函数（”<code>toNumber</code>“）：将其他格式的参数转化数字</p><p>语法：<code>toNumber(value)</code></p><p>说明：</p><ul><li>可以把字符串类型转化为数字，如："123"到数字123</li><li>可以把日期类型转化时间戳，Jan 18, 2021 7:28 PM→1610969340000</li><li>可以把复选框类型转化为数字，true为1，false为0</li><li>也可以把数字类型转化为数字</li></ul></li><li><p>包含判断函数（”<code>contains</code>“）：包含判断函数，返回一个boolean值，</p><p>语法：<code>contains(text1,text2)</code></p><p>说明：如果text1中包含text2，则返回true；反之，返回false</p></li><li><p>替代函数：</p><ul><li><p>“<code>replace</code>”：用新值替换正则表达式的第一个匹配项</p><p>语法：<code>replace(number/text/boolean,text1,text2)</code></p><p>说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</p></li><li><p>"<code>replaceAll</code>”：用新值代替正则表达式的所有匹配项</p><p>语法：<code>replaceAll(number/text/boolean,text1,text2)</code></p><p>说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</p></li></ul></li><li><p>检验函数（“<code>test</code>”）：判断一个字符串是否与正则表达式匹配，返回一个boolean值</p><p>语法：<code>test(number/text/boolean,text)</code></p></li><li><p>“验空”函数（”<code>empty</code>“）：判断一个值是否为空</p></li></ol><pre><code class="hljs">语法：`empty(number/text/boolean/date)`说明：默认情况下，数字为0表示空，字符串以""表示空值，boolean值以false表示空值</code></pre><h1 id="6-六-数学函数"><a class="markdownIt-Anchor" href="#6-六-数学函数"></a> 6 六、数学函数</h1><ol><li><p>绝对值函数（“<code>abs</code>”)：返回一个数的绝对值</p><p>语法：<code>abs(number)</code></p></li><li><p>开算术平方根运算（”<code>sqrt</code>“）：返回一个数的算术平方根</p><p>语法：<code>sqrt(number)</code></p><p>说明：number要为非负数</p></li><li><p>开立方根（”<code>cbrt</code>“)：返回一个数的立方根</p><p>语法：<code>cbrt(number)</code></p></li><li><p>幂次运算（”<code>^</code>“或"<code>pow</code>"）：将两个数字进行指数运算，并返回它们的值</p><p>语法：</p><ul><li><code>number^number</code></li><li><code>pow(number,number)</code></li></ul><p>补充:</p><p>自然指数运算（”<code>exp</code>“）：返回e^x的值，其中x为参数，e为常数</p><p>语法：<code>exp(number)</code></p></li><li><p>对数运算：notion目前只支持三种对数运算</p><p>三 种 对 数 运 算 { l n ( n u m b e r ) 返 回 一 个 数 的 自 然 对 数 l o g 10 ( n u m b e r ) 返 回 这 个 数 以 10 为 底 对 数 的 值 l o g 2 ( n u m b e r ) 返 回 这 个 数 以 2 为 底 对 数 的 值 三种对数运算\begin{cases}ln(number) &amp;返回一个数的自然对数\log_{10}(number)&amp;返回这个数以10为底对数的值\log_2(number) &amp;返回这个数以2为底对数的值\end{cases} 三种对数运算⎩⎪⎨⎪⎧​ln(number)log10​(number)log2​(number)​返回一个数的自然对数返回这个数以10为底对数的值返回这个数以2为底对数的值​</p></li><li><p>向上取整函数（“<code>ceil</code>”）：返回大于或等于这个数字的最小整数</p><p>语法：<code>ceil(number)</code></p></li><li><p>向下取整函数（“<code>floor</code>”）：返回小于或等于这个数字的最大整数</p><p>语法：<code>floor(number)</code></p></li><li><p>最大/小值函数</p><ul><li><p>最大值函数（“<code>max</code>”）：返回数的最大值</p><p>语法：<code>max(number1,number2,...)</code></p></li><li><p>最小值函数（“<code>min</code>”）：返回数的最小值</p><p>语法：<code>min(number1,number2,...)</code></p></li></ul></li><li><p>符号函数（“<code>sign</code>”）：返回数的符号，指明数的符号是为正、负或零</p><p>语法：<code>sign(number)</code></p><p>说明：数字为正时，返回1；数字为负时，返回-1；数字为0时，返回0</p></li></ol><h1 id="7-七-日期函数"><a class="markdownIt-Anchor" href="#7-七-日期函数"></a> 7 七、日期函数</h1><ol><li><p>返回时间差函数（<code>dateBetween</code>）：返回两个日期之间的时间差，返回值是一个数字。</p><p>语法：<code>dateBetween(date,date,text)</code></p><p>说明：<code>date</code>表示日期；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。</p><p>t e x t 的 取 值 类 型 { " y e a r s " 表 示 以 “ 年 ” 为 基 本 单 位 " q u a r t e r s " 表 示 以 “ 季 ” 为 基 本 单 位 " m o n t h s " 表 示 以 “ 月 " 为 基 本 单 位 " w e e k s " 表 示 以 “ 周 ” 为 基 本 单 位 " d a y s " 表 示 以 “ 天 ” 为 基 本 单 位 " h o u r s " 表 示 以 “ 小 时 ” 为 基 本 单 位 " m i n u t e s " 表 示 以 “ 分 钟 ” 为 基 本 单 位 " s e c o n d s " 表 示 以 “ 秒 ” 为 基 本 单 位 " m i l l i s e c o n d " 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}“years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月"为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​"years"“quarters”“months”“weeks”“days”“hours”“minutes”“seconds”"millisecond"​表示以“年”为基本单位表示以“季”为基本单位表示以“月"为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</p></li><li><p>获取当前日期函数（<code>now</code>):返回当前的日期和时间</p><p>语法：<code>now()</code></p></li><li><p>日期范围开始函数（“<code>start</code>”）：返回一个日期范围的开始</p><p>语法：<code>start(date)</code></p></li><li><p>日期范围结束函数（“<code>end</code>”）：返回一个日期范围的结束</p><p>语法：<code>end(date)</code></p></li><li><p>日期到时间戳函数（“<code>timestamp</code>”）：返回来自Unix毫秒时间戳的整数，对应于自1970年1月1日起的毫秒数，返回值是<code>数值</code></p><p>语法：<code>timestamp(date)</code></p><p>说明：把日期格式的<code>日期转化</code>为数值类型的<code>时间戳</code></p></li><li><p>时间戳到日期函数（“<code>fromTimestamp</code>”）：返回由Unix毫秒时间戳构建的日期，对应于自1970年1月1日起的毫秒数，返回值是<code>日期</code></p><p>语法：<code>fromTimestamp(number)</code></p><p>说明：把数值类型的<code>时间戳转化为日期</code>类型的日期</p></li><li><p>增加日期判据（argument）函数（“<code>dateAdd</code>”）：增加到日期，最后一个是单位判据</p><p>语法：<code>dateAdd(date,number,text)</code></p><p>说明：<code>date</code>表示日期；number表示日期差；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。</p><p>t e x t 的 取 值 类 型 { " y e a r s " 表 示 以 “ 年 ” 为 基 本 单 位 " q u a r t e r s " 表 示 以 “ 季 ” 为 基 本 单 位 " m o n t h s " 表 示 以 “ 月 " 为 基 本 单 位 " w e e k s " 表 示 以 “ 周 ” 为 基 本 单 位 " d a y s " 表 示 以 “ 天 ” 为 基 本 单 位 " h o u r s " 表 示 以 “ 小 时 ” 为 基 本 单 位 " m i n u t e s " 表 示 以 “ 分 钟 ” 为 基 本 单 位 " s e c o n d s " 表 示 以 “ 秒 ” 为 基 本 单 位 " m i l l i s e c o n d " 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}“years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月"为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​"years"“quarters”“months”“weeks”“days”“hours”“minutes”“seconds”"millisecond"​表示以“年”为基本单位表示以“季”为基本单位表示以“月"为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</p></li><li><p>减少日期的日期函数（<code>“dateSubtract</code>”）：减少日期的日期，最后一个是判据</p><p>语法：<code>dateSubtract(date,number,text)</code></p><p>说明：类似上面的dateAdd函数。</p></li><li><p>设置日期格式函数（“<code>formatDate</code>”）：使用“时刻”标准时间格式字符串，设置日期格式，返回的是一个<code>字符串</code></p><p>语法：<code>formatDate(date,text)</code></p><p>例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MMMM D YYYY, HH:mm"</span>) == March <span class="hljs-number">30</span> <span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"YYYY/MM/DD, HH:mm"</span>) == <span class="hljs-number">2010</span>/<span class="hljs-number">03</span>/<span class="hljs-number">30</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MM/DD/YYYY, HH:mm"</span>) == <span class="hljs-number">03</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"HH:mm A"</span>) == <span class="hljs-number">12</span>:<span class="hljs-number">00</span> PM<br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"M/D/YY"</span>) == <span class="hljs-number">3</span>/<span class="hljs-number">30</span>/<span class="hljs-number">10</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>返回”给定日期“所用单位函数下的数字<br>所 用 的 单 位 函 数 { 分 钟 函 数 （ m i n u t e ） { 返 回 一 个 0 到 59 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 分 钟 数 语 法 ： m i n u t e ( d a t e ) 小 时 函 数 （ h o u r ） { 返 回 一 个 0 到 23 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 小 时 数 语 法 ： h o u r ( d a t e ) 星 期 函 数 （ d a y ） { 返 回 一 个 0 到 6 之 间 的 整 数 ， 对 应 于 给 定 的 日 期 。 0 代 表 星 期 日 ， 1 代 表 星 期 一 等 等 语 法 ： d a y ( d a t e ) 日 期 函 数 （ d a t e ） { 返 回 一 个 1 到 31 之 间 的 整 数 , 对 应 于 给 定 日 期 语 法 ： d a t e ( d a t e ) 月 函 数 （ m o n t h ） { 返 回 一 个 0 到 11 之 间 的 整 数 ， 0 对 应 于 1 月 ， 1 对 应 于 2 月 等 等 语 法 ： m o n t h ( d a t e ) 年 份 函 数 （ y e a r ） { 返 回 给 定 日 期 的 年 份 语 法 ： y e a r ( d a t e ) 所用的单位函数\begin{cases} 分钟函数（minute）\begin{cases}返回一个0到59之间的整数，对应于给定日期的分钟数\语法：minute(date)\end{cases}\ 小时函数（hour）\begin{cases}返回一个0到23之间的整数，对应于给定日期的小时数\语法：hour(date)\end{cases}\ 星期函数（day）\begin{cases}返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等\语法：day(date)\end{cases}\ 日期函数（date）\begin{cases}返回一个1到31之间的整数,对应于给定日期\语法：date(date)\end{cases}\ 月函数（month）\begin{cases}返回一个0到11之间的整数，0对应于1月，1对应于2月等等\语法：month(date)\end{cases}\ 年份函数（year）\begin{cases}返回给定日期的年份\语法：year(date)\\end{cases} \end{cases} 所用的单位函数⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​分钟函数（minute）{返回一个0到59之间的整数，对应于给定日期的分钟数语法：minute(date)​小时函数（hour）{返回一个0到23之间的整数，对应于给定日期的小时数语法：hour(date)​星期函数（day）{返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等语法：day(date)​日期函数（date）{返回一个1到31之间的整数,对应于给定日期语法：date(date)​月函数（month）{返回一个0到11之间的整数，0对应于1月，1对应于2月等等语法：month(date)​年份函数（year）{返回给定日期的年份语法：year(date)</p></li></ol><h1 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> notion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> notion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obsidian media 插件</title>
      <link href="/posts/42381/"/>
      <url>/posts/42381/</url>
      
        <content type="html"><![CDATA[<h1 id="1-media-插件"><a class="markdownIt-Anchor" href="#1-media-插件"></a> 1 media 插件</h1><p>本地视频打时间戳：<br>前边+file:// ，第三个"/"是users的,然后在阅读视图中打开，之后可以自动打时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221318976.png" alt="|600"></p><p>不在阅读视图中打开会自动跳转到默认应用打开，这样无法加时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221319732.png" alt="|600"></p><h1 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> obsidian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已迁移 </tag>
            
            <tag> obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语口语</title>
      <link href="/posts/13436/"/>
      <url>/posts/13436/</url>
      
        <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/899591b0dea9484cb76d44a26c1c4c61">英语口语考试周主题</a></p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=d3049095-bb89-43d6-872f-f36158106173">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fluid写文章好用的代码</title>
      <link href="/posts/15457/"/>
      <url>/posts/15457/</url>
      
        <content type="html"><![CDATA[<p>网站嵌套<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid">[1]</span></a></sup></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"topFrame"</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"yes"</span>  <span class="hljs-attr">noresize</span>=<span class="hljs-string">"noresize"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"topFrame"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>tag插件</p><iframe src="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6" width="100%" height="1000" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe><hr><p><strong>参考资料</strong>：</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/posts/fluid-write/#iframe-%E9%A1%B5%E9%9D%A2%E9%95%B6%E5%A5%97">搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最优化</title>
      <link href="/posts/37878/"/>
      <url>/posts/37878/</url>
      
        <content type="html"><![CDATA[<blockquote><p>红色为重点</p></blockquote><p>考试范围：<br>第二章的单纯形法不考</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507551.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507026.png" alt="|600"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507616.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171506250.png" alt="|600"></div></div></div><p>动态规划求解：<a href="https://www.bilibili.com/video/BV1DL4y1G7mp?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化理论与方法-动态规划2_哔哩哔哩_bilibili</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222221137.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227555.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227315.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222228222.png)<br><br></code></pre></td></tr></tbody></table></figure><p>总复习：<a href="https://www.bilibili.com/video/BV1AF411z7hg/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化计算方法计算题复习_哔哩哔哩_bilibili</a></p><hr><p>2022-06-24(后记)：</p><ol><li>实际问题求标准型的问题：把目标函数写出来，约束条件写出来就行</li><li>黄金分割法：但是略微有点不一样，函数值算出来是负的。没关系仍然采用，谁的函数值就删其区间的策略</li><li>K-T条件：常规题</li><li>内点罚函数：注意一下把约束条件化为标准型：&lt;=0</li><li>哈密顿法：书上13-3原题，初始条件变了一点，加粗的看不懂(x(0) = 0，<strong>t<sub>f</sub> = 2，x1(0) + x2(0) =&nbsp;5</strong> )</li><li>共轭梯度法：共有三种方法可以解(牛顿法，最速下降法，共轭梯度法)，但是题目要求共轭梯度法</li><li>遗传算法：要求精确到0.01，简单是初始只有两个变量x1，x2。<ol><li>注意一点：适度函数中的常数要取f(x1)，f(x2)的最大值。本题中x1，x2取负数才是最大值，我写错了</li></ol></li><li>动态规化求线性规化：要求<strong>顺序法</strong>解，逆序法不给分，老师专门在考前1分钟强调。(<font color="#C32E94">15分</font>)</li><li>A* 算法：画格子，只有<font color="#C32E94">5分</font></li><li>神经网络：先由m求W，给了初始的V<sup>T</sup>。求更新状态，求对应的E<ol><li>求W，W12=m1的第一行 * 第二行 + m2的第一行 * 第二行。w13同理…</li><li>求V<sup>T</sup>，更新几，V乘上对应的W列 - θ<sub>i</sub>，没有θ就当成0。如果结果 &gt;= 0 取1，&lt; 0 取0。更新几号只写那个数。其他的初始V<sup>T</sup>照抄<ol><li>如果是二分图的，更新完的话，如果正数和负数的个数不相等的话，还要在随机找一个数变一下。然后使正负的个数相等</li></ol></li></ol></li></ol><blockquote><p>未标注的只有10分</p></blockquote><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转链接：<a href="http://localhost:4000/2022/06/17/zui-you-hua/">blog</a>，<a href="obsidian://advanced-uri?vault=Documents&amp;uid=a70cadd5-066a-4186-a092-69cf233c1b6e">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>退火</title>
      <link href="/posts/16303/"/>
      <url>/posts/16303/</url>
      
        <content type="html"><![CDATA[<h1 id="1-摘要"><a class="markdownIt-Anchor" href="#1-摘要"></a> 1 摘要</h1><p><strong>是否退火</strong>：能够直接挤出就没必要退火，硬度低，比如纯铝，就没必要退火<br><strong>目的：</strong><br>提高成形后表面质量，<strong>提高它的塑性</strong>，便于改善成形效果，减少表面缺陷<br>退火主要是去应力，使材料组织回到初始状态，这样能保证挤压前每个工件的组织都一样<br>让晶粒均匀，能够好观察以后的梯度样貌<br><strong>成形要求</strong>：表面无缺陷，形状规整，就和松青挤出的纯铜差不多就行</p><h1 id="2-az13b镁合金-退火"><a class="markdownIt-Anchor" href="#2-az13b镁合金-退火"></a> 2 AZ13B镁合金 退火</h1><p><img src="https://s1.vika.cn/space/2022/06/15/07272ec877d24b698c8944d6a1296f0b" alt="|600"><br>150 ℃-240 min 退火后只有部分区域发生了再结晶(这不行)<br>在 300℃退火处理后,晶粒尺寸比较稳定,由平均晶粒尺寸为9.1μm 的再结晶组织组成<br>较高的温度(300℃)能够改善镁合金的塑性<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="margin">[1]</span></a></sup>。<br>AZ31B 镁合金轧制态板材经 300 ℃退火 60 min 后伸长率最高,为 27.3%。<br><img src="https://s1.vika.cn/space/2022/06/15/b41108bd01ba4924a6f8e98e64d285c6" alt="|600"><br><img src="https://s1.vika.cn/space/2022/06/15/d56b14c8de0348a292f42e2572ea922e" alt="|600"></p><h2 id="21-镁合金退火总结"><a class="markdownIt-Anchor" href="#21-镁合金退火总结"></a> 2.1 镁合金退火总结</h2><p>自己总结: 退火温度升至 300℃, 保温 60min，退火后炉内冷却取出 ^ckuxll<br>30 分钟升到 300 度, 保温 60min</p><p>将锻态镁合金在350°C、2h的条件下进行再结晶退火<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网">[2]</span></a></sup><br>退火处理工艺及参数为：加热温度为260°C，保温15min， 升温速率取 5°C/min，随炉冷却后取出工件<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金表面滚压强化研究 - 中国知网">[3]</span></a></sup><br>镁合金板材<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[4]</span></a></sup>：将A Z 3 1 B镁合金板分别在2 0 0, 3 0 0, 4 0 0 ℃下保温1 0m i n,<br>未 热 处 理 A Z 3 1 B镁 合 金 板的显微组 织 主 要 由 大 小 不 均 匀 的 等 轴 晶 粒 组 成, 晶粒 尺 寸 为1 0~4 0μm, 形 成 的β析 出 相 (M g 1 7 A l 1 2相) 较少[ 1 4]; 2 0 0 ℃热 处 理 后 的 显 微 组 织 变 化不大, 等轴晶粒尺寸仍为1 0~4 0μm, 析出相的 分布也 没 有 明 显 变 化; 当 热 处 理 温 度 达 到 3 0 0, 4 0 0 ℃时, 镁 合 金 板 的 显 微 组 织 发 生 了 明 显 的 变化, 主要表现为大尺寸晶粒的数量明显增 多, 晶 粒的最大尺寸达到了5 0μm, 且析出相的分布更加弥散。对比可知, 2 0 0 ℃为 A Z 3 1 B镁 合 金 板 较 为 理想的加热 温 度, 该 温 度 下 能 够 较 好 地 保 持 细 小 的显微组织。</p><blockquote><p>这个好像是先退火200,300,400后，在挤压后的晶相<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207042001235.png" alt=""></p></blockquote><h1 id="3-19号楼马弗炉加热操作"><a class="markdownIt-Anchor" href="#3-19号楼马弗炉加热操作"></a> 3 19号楼马弗炉加热操作</h1><h2 id="31-操作文档"><a class="markdownIt-Anchor" href="#31-操作文档"></a> 3.1 操作文档</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017876.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017391.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162018849.png" alt="|600"></div></div></div><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/78EE4419-7316-4B0F-9104-116415CFBD95">margin</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021900755.nh&amp;uniplatform=NZKPT&amp;v=5Rx9z0dEkJU4WzR6pCnp0XWyhQb8xRZ5iMRPNdPJBPVDo9CF-RagrxkNh-MQaLMa">AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021155229.nh&amp;uniplatform=NZKPT&amp;v=us7-K1qgCpj5f5QN9eOdchJ9P2om_2zkT5iLqRdK25tWa_Bp7kcv2OYETpRo6scL">AZ31B镁合金表面滚压强化研究 - 中国知网</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="marginnote3app://note/5D3F197F-7FDC-42A0-8C97-2618192A9CC2">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20.合并区间</title>
      <link href="/posts/14697/"/>
      <url>/posts/14697/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>力扣题解： 56. 合并区间</p><span id="more"></span><h1 id="1-56-合并区间"><a class="markdownIt-Anchor" href="#1-56-合并区间"></a> 1 56. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">力扣题目链接</a></p><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>输入: intervals = [ [1,3],[2,6],[8,10],[15,18] ]</li><li>输出: [ [1,6],[8,10],[15,18] ]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><p>示例&nbsp;2:</p><ul><li>输入: intervals = [ [1,4],[4,5] ]</li><li>输出: [ [1,5] ]</li><li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li><li>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</li></ul><p>提示：</p><ul><li>intervals[ i ]  [0] &lt;= intervals[ i ]  [ 1 ]</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>左边界排序后<br>局部最优：每次合并都取<strong>最大的右边界</strong>，这样就可以合并更多的区间了<br>整体最优：合并所有重叠的区间。<br>排序后：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，一定有重叠(包含或者交集)！</p><blockquote><p>第二个数组的头如果小于第一个数组的尾，那么一定有重复<br><img src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p></blockquote><h2 id="21-排序"><a class="markdownIt-Anchor" href="#21-排序"></a> 2.1 排序</h2><p>按左边界排序</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br></code></pre></td></tr></tbody></table></figure><h2 id="22-判断是否重叠-合并区间"><a class="markdownIt-Anchor" href="#22-判断是否重叠-合并区间"></a> 2.2 判断是否重叠 +合并区间</h2><h3 id="221-是否重叠"><a class="markdownIt-Anchor" href="#221-是否重叠"></a> 2.2.1 是否重叠</h3><p>for循环中判断重叠<br>第二个数组的头小于第一个数组的尾即为重叠<br><code>intervals[i][0] &lt;= intervals[i - 1][1]</code><br>定义出来两个数组的头和尾，这样下边写的更简洁</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下标从1开始，因为要比较：intervals[i][0] &lt;= intervals[i - 1][1]</span><br><span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始区间的左边界</span><br><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];   <span class="hljs-comment">// 初始区间的右边界</span><br></code></pre></td></tr></tbody></table></figure><h3 id="222-合并区间"><a class="markdownIt-Anchor" href="#222-合并区间"></a> 2.2.2 合并区间</h3><p>用[[while 循环]]合并区间：while循环是if 和 for 循环的结合体<br>比较第一个数组和第二数组的尾部谁更大，更新数组的尾部就行<br>同时要控制i的增加，如果合并了，那么进行一次i++, 出去while 循环后，for又进行一次i++，这样就控制了跳过了合并区间👉🏻[[20.合并区间#^hcnuf7]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 比较第一个数组和第二数组的尾部</span><br></code></pre></td></tr></tbody></table></figure><p>整体代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) { <span class="hljs-comment">// 判断重叠</span><br>          <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    <span class="hljs-comment">// 初始为i-1区间的左边界</span><br>          <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];      <span class="hljs-comment">// 初始i-1区间的右边界</span><br>          <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end) { <span class="hljs-comment">// 合并区间</span><br>              end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 不断更新右区间</span><br>              <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 最后一个区间也合并了</span><br>              i++;                                <span class="hljs-comment">// 继续合并下一个区间</span><br>          }<br></code></pre></td></tr></tbody></table></figure><h2 id="23-放入result结果集"><a class="markdownIt-Anchor" href="#23-放入result结果集"></a> 2.3 放入result结果集</h2><p>取合并区间的头和尾作为一个新的数组加入到result数组中，<code>result.push_back({start, end});</code><br>如果没有合并就把原数组加入result</p><p><strong>注意</strong>：<br>还要单独判断最后一个数组是否合并了，如果合并了，正常加入就如result就行<br>如果没合并要单独的把最后一个数组加入result</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-代码随想录断点调试"><a class="markdownIt-Anchor" href="#31-代码随想录断点调试"></a> 3.1 代码随想录断点调试</h2><p>carl<br>[20.合并区间(carl).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/20.合并区间(carl).mp4)<br>[00:19](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=19.133532) ：i++<br>如果合并了第二区间，那么自然i不能从第二个区间在开始，要从第三个位置开始，while循环中有个i++，到了for循环中还有个i++, i到时候等于3，就跳过了合并的区间在开始<br>[00:29](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=29.228653)：此时i 等于3，从合并区间的下个区间在开始进行 ^hcnuf7</p><h2 id="32-carl-自写"><a class="markdownIt-Anchor" href="#32-carl-自写"></a> 3.2 carl 自写</h2><p>编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 只比较左位置，所以不用二维数组</span><br>    }<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) {<br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<span class="hljs-comment">// 此时result为空</span><br>        <span class="hljs-type">int</span> length = intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不要定义在for循环中</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++){<br>            <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end){ <span class="hljs-comment">// 不要忘记=，“=”是头尾相等</span><br>                end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;<br>                i++;<br>            }<br>            result.<span class="hljs-built_in">push_back</span> ({start,end}); <span class="hljs-comment">// 如果没合并就是单独的，如果合并了也更新了。</span><br>                                            <span class="hljs-comment">// 每一次的循环都在加入result数组，所以在for循环中</span><br>        }<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>) {<br>            result.<span class="hljs-built_in">push_back</span>({intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]});<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><sub>自用跳转链接</sub>：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=88f96891-7092-4c04-a067-349995d05800">ob</a>，<a href="http://localhost:4000/2022/06/16/20.he-bing-qu-jian/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>notion函数公式</title>
      <link href="/posts/11772/"/>
      <url>/posts/11772/</url>
      
        <content type="html"><![CDATA[<p>notion函数公式</p><h1 id="1-时间公式"><a class="markdownIt-Anchor" href="#1-时间公式"></a> 1 时间公式</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">开始的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>))<br>结束的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))<br><br>开始的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br>结束的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br><br><br>相减的分钟数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))<br>相减的小时数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)))<br><br>小时+分钟：<br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span> <br><br><br><span class="hljs-comment">//不借位</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//借位</span><br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span><br><br><br><span class="hljs-comment">//时间计算总函数：已通过</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) + <span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>)<br><br><span class="hljs-comment">//时间范围改造函数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)))+ <span class="hljs-string">"h"</span> + format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))) +<span class="hljs-string">"m"</span> , <span class="hljs-string">"0"</span>)<br></code></pre></td></tr></tbody></table></figure><p>时间范围</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><span class="hljs-comment">//不借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><br><span class="hljs-comment">//借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br></code></pre></td></tr></tbody></table></figure><p>写notion公式的心得：把零件找出来，在组装</p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> notion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> notion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
      <link href="/posts/12294/"/>
      <url>/posts/12294/</url>
      
        <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="Obsjxsm7GHlDNaFEJ8JDaRpy" --> <p>c++中 - ‘0’ 的相减操作解释::</p><p>将数字字符转为整形变量</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将str 字符串"1234"里的各个数字字符转成整型，存入整型数组x：</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"1234"</span>;<br><span class="hljs-type">int</span> x[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++) x[i] = str[i] - <span class="hljs-string">'0'</span>; <br></code></pre></td></tr></tbody></table></figure><blockquote><p>数字字符减去‘0’就得到了该数字。减去字符0，也就是减去0的ASCII码值48。</p></blockquote><!-- basicblock-end --><p>#card</p><!-- basicblock-start oid="Obsi6n6UMJL06B3xTO9d9jTl" --> <p>c++中 -‘a’ 的相减操作解释::</p><h1 id="1-取到字母字符对应的数字a0b1"><a class="markdownIt-Anchor" href="#1-取到字母字符对应的数字a0b1"></a> 1 取到字母字符对应的数字：a→0，b→1…</h1><p><strong>原理：a - ‘a’ = 0, b - ‘a’ = 1 …</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<br>S = <span class="hljs-string">"ababcbacadefegdehijhklij"</span><span class="hljs-comment">// S[0] - 'a'= 0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) { <br>            hash[S[i] - <span class="hljs-string">'a'</span>] = i; <span class="hljs-comment">//</span><br>        }<br></code></pre></td></tr></tbody></table></figure><p>eg :[[19.划分字母区间#^dhg2oc]]  , [[2. 有效的字母异位词]]<br>[01:03](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835)<br>S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - ‘a’=&nbsp;S[6] - ‘a’ = 0</p><h1 id="2-将字母由小写转为大写"><a class="markdownIt-Anchor" href="#2-将字母由小写转为大写"></a> 2 将字母由小写转为大写</h1><p>字母字符- 'a’得到 该字母下的下标</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 把字符串中字母，小写变大写</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"aBcxYz"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(str); i++)<br><span class="hljs-keyword">if</span> (str[i] &gt;=<span class="hljs-string">'a'</span> &amp;&amp; str[i] &lt;=<span class="hljs-string">'z'</span>) str[i] = str[i] -<span class="hljs-string">'a'</span> + <span class="hljs-string">'A'</span>;<br></code></pre></td></tr></tbody></table></figure><p>本质是减去 a 的 ASII 值, 在加上 A 的 ASII 值. 改变了字母的 起始 ASII 值</p><!-- basicblock-end --><p>[[有关字符要想到的操作]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
      <link href="/posts/12295/"/>
      <url>/posts/12295/</url>
      
        <content type="html"><![CDATA[<p>执行continue 函数相当于又调到了函数的开头[00:04](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=4.619299)<br>作用：能够控制for循环中，跳过一些代码段，然后又使i不断前进<br>[23.买卖股票的最佳时机含手续费](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4)</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>while 循环</title>
      <link href="/posts/36387/"/>
      <url>/posts/36387/</url>
      
        <content type="html"><![CDATA[<p>链表的指针移动用 while, 没法用 for 循环</p><p>while循环是if 和 for 循环的结合体，<br>只要在while循环中增加跳出语句就行</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(i){<br> i++<br>}<br><br>等于<br><br><span class="hljs-keyword">if</span>(){<br><span class="hljs-keyword">for</span>()<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="1-while-x"><a class="markdownIt-Anchor" href="#1-while-x"></a> 1 while (x)</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(i){ <span class="hljs-comment">// i 不能是变量; 可以直接写成 while(i--)</span><br>i--<br>}<br><br><br><span class="hljs-keyword">while</span>(n) <span class="hljs-comment">//  n &lt; 1 即可为 0, eg: n = 0.1 就会跳出循环</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19.划分字母区间</title>
      <link href="/posts/22082/"/>
      <url>/posts/22082/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>力扣题解：763.划分字母区间</p><span id="more"></span><h1 id="1-763划分字母区间"><a class="markdownIt-Anchor" href="#1-763划分字母区间"></a> 1 763.划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">力扣题目链接</a></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><ul><li>输入：S = “ababcbacadefegdehijhklij”</li><li>输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</li></ul><p>提示：</p><ul><li>S的长度在[1, 500]之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’ 。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>总共分为两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点<br><img src="https://img-blog.csdnimg.cn/20201222191924417.png" alt="763.划分字母区间|900"></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-carl断点调试"><a class="markdownIt-Anchor" href="#31-carl断点调试"></a> 3.1 carl断点调试</h2><p>[19.划分字母区间(carl).MP4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/19.划分字母区间(carl).mp4)<br>以后可以监听几个变量：S[i]，right - left +1<br>[[c++中 - ‘0’ 以及 -‘a’ 的相减操作解释]]<br>S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>[00:12](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=12.709769)<br>S = “a<mark>b</mark>abcbacadefegdehijhklij”，相当于将b对应1，这个数存在了hash里<br>hash[S[1] - ‘a’] =&nbsp;1，即hash[2] = 1<br>[01:03](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835)<br>S = “==<strong>a</strong><mark>babcbac</mark><strong>a</strong>==defegdehijhklij”<br>将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - ‘a’=&nbsp;S[9] - ‘a’ = 0 (第一个区间)<br>[01:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=70.392045)<br>此使 right = max(0, 8)，之道i 到下标8才会进入if 循环语句，它在下标8之前一直在比较有没有比8更大值，有的话说明第一个分割点更远<br>[01:53](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=113.069755)<br>到达第一分割点下标8(i =&nbsp;8)处，开始push_back结果，并且更新下一个区间<br>right  - left + 1  = 8-0+1= 9 第一个区间相当于：尾 - 头 + 1<br>下个区间要在更新一下头即left = i+1 =&nbsp;9</p><h3 id="311-代码"><a class="markdownIt-Anchor" href="#311-代码"></a> 3.1.1 代码</h3><p>自写 编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>{<br>       <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<span class="hljs-comment">// 数组初始化必须是列表，不能是单纯的0</span><br>       <span class="hljs-comment">//int hash[S.size()] = {0}; // S.size 可变动的，错误：可变大小的对象可能未初始化</span><br><br>       <span class="hljs-comment">//hash数组中写入每个字母的所对应的最远下标值</span><br>       <span class="hljs-comment">//因每个字母的S[i] - 'a'是不变的，所以可以一直更新最远下标</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           hash[S[i] - <span class="hljs-string">'a'</span>] = i;<br>       }<br>       <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>       vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// vector 能够不断往里加数据</span><br>       <span class="hljs-comment">// 不断的找分割区间</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           right = <span class="hljs-built_in">max</span> (right, hash[S[i] - <span class="hljs-string">'a'</span>]); <span class="hljs-comment">// 确定区间的尾部 不是hash[i], 是每个字母对应的最远下标</span><br>           <span class="hljs-keyword">if</span>(i == right){<br>               result.<span class="hljs-built_in">push_back</span>(right - left +<span class="hljs-number">1</span>); <span class="hljs-comment">// 返回是字符串的长度所以+1</span><br>               left = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新下一个区间头部，现在i是上一区间的尾，所以下个头部为 i+1</span><br>           }<br>       }<br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=13b04b05-d8f9-4a57-a909-3b6b3af97825">ob</a>，<a href="http://localhost:4000/2022/06/15/19.hua-fen-zi-mu-qu-jian/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切割材料+制样</title>
      <link href="/posts/47598/"/>
      <url>/posts/47598/</url>
      
        <content type="html"><![CDATA[<h1 id="1-切割"><a class="markdownIt-Anchor" href="#1-切割"></a> 1 切割</h1><h2 id="11-圆盘"><a class="markdownIt-Anchor" href="#11-圆盘"></a> 1.1 圆盘</h2><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208301948279.png" alt="|600"></p><h2 id="12-圆棒"><a class="markdownIt-Anchor" href="#12-圆棒"></a> 1.2 圆棒</h2><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208301952524.png" alt="|600"></p><h1 id="2-切割"><a class="markdownIt-Anchor" href="#2-切割"></a> 2 切割</h1><p>切割圆棒和圆盘分离处12mm范围内，<br><img src="https://s1.vika.cn/space/2022/06/14/2d7ff49ea0c8442ab6e80f41c0f30a32" width="500" height="500"></p><h1 id="3-制样"><a class="markdownIt-Anchor" href="#3-制样"></a> 3 制样</h1><p>第一次溶液做点稀点：一次性杯子，倒4分之一的水(配套粉的)，4勺粉。搅拌至拉丝<br>倒到模具当中，先倒一点(3分之一)，然后用镊子在把材料拿起在压下去</p><blockquote><p>主要让切割材料底下溶液渗透均匀<br><img src="https://s1.vika.cn/space/2022/06/14/7139d0510c9e43e2a3bcc0b7816cfbe8" alt="|400"></p></blockquote><p>第二次溶液做点稠点：一次性杯子，倒3分之一的水(配套粉的)，7勺粉。搅拌至拉丝<br>这次把模具倒满</p><hr><p>跳转回ob：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=0a90dfa0-acef-4bf3-bb8b-0b72eb035933">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PPT技巧-文字高亮</title>
      <link href="/posts/36733/"/>
      <url>/posts/36733/</url>
      
        <content type="html"><![CDATA[<p>注意事项：</p><p>按住Shift 用来垂直或水平移动<br>如果上下两个文字没有在同一位置，无法实现文字滚动效果</p><hr><p>参考资料：<br><a href="https://www.bilibili.com/video/BV1pv4y1G7Qp/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">keynote 教程 有手就行系列 024 苹果发布会分解教学_哔哩哔哩_bilibili</a></p><hr><p>下一篇：[[切割材料+制样]]</p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自然辩证法考试重点</title>
      <link href="/posts/60394/"/>
      <url>/posts/60394/</url>
      
        <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/832c73b10a1849e49262e0d8eb1b505b">自然辩证法重点-notion.</a></p><p><a href="https://skinny-girl-067.notion.site/de438994556a4d8fb3c7aa7cbdec36d9">考前速记+考后整理.</a></p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>六级考试时间安排</title>
      <link href="/posts/35757/"/>
      <url>/posts/35757/</url>
      
        <content type="html"><![CDATA[<p>正式时间：15.00-17.25<br>报道时间：14.20</p><p>15.00前：发答题卡</p><p>15.00-15.10：开始发卷子</p><p>15.10-15.40：开始让动笔写作文👉 30分钟</p><p>15.40-16.10：听力👉 30分钟</p><p>16.10-16.15：暂停5分钟收答题卡1(作文和听力)</p><p>16.15-17.25：余下时间写卷至结束</p><p>下一篇：[[自然辩证法考试重点]]</p>]]></content>
      
      
      <categories>
          
          <category> 🏫学校 </category>
          
          <category> 研究生考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 六级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由hexo clean 问题引发的一些学习感想</title>
      <link href="/posts/19528/"/>
      <url>/posts/19528/</url>
      
        <content type="html"><![CDATA[<p>hexo 上传文章的固定流程：</p><p><code>hexo clean</code> → <code>hexo g</code> → <code>hexo s</code> → <code>hexo d</code></p><p>其实网上看了很多人这样写，但我一直把<code>hexo clean</code> 写成 <code>hexo c</code>。其实系统也一直都有在报错，但我从来都没有关注。因为终端窗口小，没能显示出来上边的错误信息，下面一堆英文的也不想看。每次都当成了顺利执行了。自己还沾沾自喜的觉得<code>hexo c</code> 写也可以，网上没人说自己发现了新大陆了。<br><img src="https://s1.vika.cn/space/2022/06/11/9106c9ae345a4543a36819fd0351132c" alt="|600"><br>后来在用hexo写文章的时候，换主主题总是有些问题(见下图)，自己困扰了很多天，每天拿出来很多时间来尝试解决问题，但都无果。其实就是因为没有用hexo clean 清除缓存导致的<br><img src="https://s1.vika.cn/space/2022/06/11/d2d6e3f8df354e7cad5a8cfa1b5d2983" alt="|800"></p><p>我为什么一直固执写 <code>hexo c</code> 呢，<br>我认为有以下方面原因：</p><ol><li><strong>自以为是</strong>。觉得很多都可以简写，那这个命令应该也可以。自己试了试看到终端输出信息了。就觉得可以了，但其实根本没认真看出来的信息</li><li><strong>嫌麻烦</strong>。觉得是英文的，根本静不下来心去看。</li></ol><p>希望以后在这两方面加强自己</p><p>下一篇：[[六级考试时间安排]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 0突发奇想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科研材料总结</title>
      <link href="/posts/52144/"/>
      <url>/posts/52144/</url>
      
        <content type="html"><![CDATA[<p>硬度单位<br>洛氏硬度：HR；布氏硬度：HB；维氏硬度：HV</p><p>自用<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="ob">[2]</span></a></sup></p><h1 id="1-镁合金"><a class="markdownIt-Anchor" href="#1-镁合金"></a> 1 镁合金</h1><h2 id="11-硬度"><a class="markdownIt-Anchor" href="#11-硬度"></a> 1.1 硬度</h2><p>镁合金型号：<strong>AZ31B(HR70)</strong> AZ61 AZ91  ZK60 WE40<br>镁合金的hv：45~75不等</p><p>纯铜：HB85，50~65HV<br>纯铝：HB28<br>7075铝合金：退火后的HV140</p><p><strong>硬度低于纯铜的材料：</strong><br><strong>纯铜</strong>：HB：85，HV：50~65<br>退火(软)铜硬度为：50HV</p><p>304不锈钢：<br>淘宝：硬度在HBW85左右(淘宝)<br>网上：HB187，HRB90，HV200</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207041914021.png" alt=""></p><h1 id="2-模具材料硬度"><a class="markdownIt-Anchor" href="#2-模具材料硬度"></a> 2 模具材料硬度</h1><p>skh51 热处理淬火后硬度可以达到64HRC</p><p>skd11 热处理后硬度58~60HRC</p><h1 id="3-退火"><a class="markdownIt-Anchor" href="#3-退火"></a> 3 [[退火]]</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:2" class="footnote-text"><span><a href="obsidian://advanced-uri?vault=Documents&amp;uid=c94962a5-c07b-4fe5-b5c1-4d72c4fb033a">ob</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18.无重叠区间</title>
      <link href="/posts/34584/"/>
      <url>/posts/34584/</url>
      
        <content type="html"><![CDATA[<p>文章简介：<br>力扣题解：435. 无重叠区间</p><span id="more"></span><h1 id="1-无重叠区间"><a class="markdownIt-Anchor" href="#1-无重叠区间"></a> 1 无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">力扣题目链接</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><blockquote><p>返回需要移除的区间个数(交叉区间 = 总个数-非交叉区间的个数)</p></blockquote><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><ul><li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li><li>输出: 1</li><li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li></ul><p>示例 2:</p><ul><li>输入: [ [1,2], [1,2], [1,2] ]</li><li>输出: 2</li><li>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</li></ul><p>示例 3:</p><ul><li>输入: [ [1,2], [2,3] ]</li><li>输出: 0</li><li>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>从左向右遍历，优先选择右边界小的数组(因为右边界越小，留给下一个区间的空间就越大)</p><blockquote><p><img src="https://s1.vika.cn/space/2022/06/10/6830dccb02804260a38ac29d8641f9f8" alt="|600"></p></blockquote><p><strong>局部最优</strong>：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。<br><strong>全局最优</strong>：选取最多的非交叉区间。<br><img src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间|600"></p><blockquote><p>选择1就把2，3pass了，选择4就把5pass了</p></blockquote><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-carl"><a class="markdownIt-Anchor" href="#31-carl"></a> 3.1 carl</h2><h3 id="311-解法1"><a class="markdownIt-Anchor" href="#311-解法1"></a> 3.1.1 解法1</h3><p>自写代码已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<span class="hljs-comment">// 按右边界排序</span><br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">//记录非交叉区间的个数</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录第一个区间的尾部</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(end &lt;= intervals[i][<span class="hljs-number">0</span>]){<span class="hljs-comment">// 如果头尾没有重合，即不重叠</span><br>                end = intervals[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新end为下一个没有重合的尾部，不断for循环在</span><br>                count++;<span class="hljs-comment">// 记录不重合的个数</span><br>            }<br>        } <br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count; <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="312-解法2利用17用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#312-解法2利用17用最少数量的箭引爆气球"></a> 3.1.2 解法2：利用[[17.用最少数量的箭引爆气球]]</h3><p>弓箭的数量就相当于是<strong>非交叉区间</strong>的数量(因为交叉区间可以用一支箭射爆)，<br>只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1]，[1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间左边界从大到小排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) { <span class="hljs-comment">// 需要要把&gt; 改成 &gt;= 就可以了</span><br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {<br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1Uh41117SZ?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode  Python版每日一题（20201231）：435. 无重叠区间（想想罗志祥会怎么做）哔哩哔哩_bilibili</a></p><p>自用跳转连接：<a class="btn" href="http://localhost:4000/2022/06/10/18.wu-chong-die-qu-jian/" title="title">blog</a> <a class="btn" href="obsidian://advanced-uri?vault=Documents&amp;uid=6ef3123b-213a-456b-adba-e26f4a9b2215" title="title">ob</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.用最少数量的箭引爆气球</title>
      <link href="/posts/2006/"/>
      <url>/posts/2006/</url>
      
        <content type="html"><![CDATA[<p><strong>文章简介</strong>：<br>力扣题解：452用最少数量的箭引爆气球</p><span id="more"></span><h1 id="1-452用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#1-452用最少数量的箭引爆气球"></a> 1 452用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 &nbsp;xstart&nbsp;≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，<strong>返回引爆所有气球所必须射出的最小弓箭数。</strong></p><p>示例 1：</p><ul><li>输入：points = [ [10,16],[2,8],[1,6],[7,12] ]</li><li>输出：2</li><li>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li></ul><p>示例 2：</p><ul><li>输入：points = [ [1,2],[3,4],[5,6],[7,8] ]</li><li>输出：4</li></ul><p>示例 3：</p><ul><li>输入：points = [ [1,2],[2,3],[3,4],[4,5] ]</li><li>输出：2</li></ul><p>示例 4：</p><ul><li>输入：points = [ [1,2] ]</li><li>输出：1</li></ul><p>示例 5：</p><ul><li>输入：points = [ [2,3],[2,3] ]</li><li>输出：1</li></ul><p>提示：</p><ul><li>0 &lt;= points.length &lt;= 10^4</li><li>points[i].length == 2</li><li>-2^31 &lt;= xstart &lt;&nbsp;xend &lt;= 2^31 - 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-b站参考视频及笔记"><a class="markdownIt-Anchor" href="#21-b站参考视频及笔记"></a> 2.1 b站参考视频及笔记</h2><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br><img src="https://s1.vika.cn/space/2022/06/10/3141cfabb0c94275b7edf999b4b5197f" alt=""></p><p>从这里开始看即可</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=544.080526">09:04</a></p><p>先按左端点先排好序<br>不用管左端点，<strong>只关心右端点就行</strong>，因为只在右端点射击就行了<br>记录射击区间为第一个数组区间：[一左，一右]，<strong>其实只关心右端点就行了</strong></p><p>如果第二个数组的<strong>左端点</strong><mark>小于</mark>第一个数组的<strong>右端点</strong>(两个数组有重叠部分)<br>说明第二个数组在射击区间内，同时将射击区间更新为：[二左，一右] (重叠部分)，右端点无变化</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=617.733348">10:17</a><br>如果第二数组的右端点<mark>小于</mark>第一个数组的右端点 (说明要缩小射击区间)<br>射击区间为：[一左，二右]</p><p>如果第二数组的左端点大于第一个数组的<strong>右端点</strong>(两个数组<strong>没有</strong>重叠部分)，箭数+1(需要另一支箭才可以射完)<br>更新射击区间为：[二左，二右] (第二个数组区间)</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=765.508572">12:45代码结果</a></p><h2 id="22-代码随想录"><a class="markdownIt-Anchor" href="#22-代码随想录"></a> 2.2 代码随想录</h2><p><strong>局部最优</strong>：当气球出现重叠，一起射，所用弓箭最少。</p><p><strong>全局最优</strong>：把所有气球射爆所用弓箭最少。</p><blockquote><p>按照气球的起始位置排序，从前向后遍历气球数组，靠左尽可能让气球重复，重复的用一个箭射</p></blockquote><p><strong>如果气球重叠了，重叠气球中最小右边界， 之前的区间一定需要一个弓箭</strong></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，<br>气球3的<strong>左边界大于</strong>了第一组重叠气球的<strong>最小右边界</strong>，所以再需要一支箭来射气球3了。</p><blockquote><p>此时箭数+1</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="https://img-blog.csdnimg.cn/20201123101929791.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title class_">Solution</span>&nbsp;{<br><br><span class="hljs-keyword">private</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">static</span>&nbsp;<span class="hljs-type">bool</span>&nbsp;<span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;a,&nbsp;<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;b)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;a[<span class="hljs-number">0</span>]&nbsp;&lt;&nbsp;b[<span class="hljs-number">0</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span class="hljs-keyword">public</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">int</span>&nbsp;<span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;&nbsp;points)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points.<span class="hljs-built_in">size</span>()&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-number">0</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),&nbsp;points.<span class="hljs-built_in">end</span>(),&nbsp;cmp);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">int</span>&nbsp;result&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;<span class="hljs-comment">//&nbsp;points&nbsp;不为空至少需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-type">int</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;i&nbsp;&lt;&nbsp;points.<span class="hljs-built_in">size</span>();&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points[i][<span class="hljs-number">0</span>]&nbsp;&gt;&nbsp;points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1不挨着，注意这里不是&gt;=</span><br><span class="hljs-comment">//points: {{1, 6}, {2, 8}, {7, 12}, {10, 16}} if (points[i][0] &gt; points[i - 1][1])</span><br><span class="hljs-comment">//eg：points[1][0] &gt; points[0][1]：第二个元素的第0号位置 &gt;第一个元素的第1号位置 2&gt;6 (if 语句跳过)看图更容易懂</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result++;&nbsp;<span class="hljs-comment">//&nbsp;需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span>&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1挨着</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points[i][<span class="hljs-number">1</span>]&nbsp;=&nbsp;<span class="hljs-built_in">min</span>(points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],&nbsp;points[i][<span class="hljs-number">1</span>]);&nbsp;<span class="hljs-comment">//&nbsp;更新重叠气球最小右边界</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;result;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>图解<br><img src="https://s1.vika.cn/space/2022/06/10/a494349688e74c7ebe4ce80e4b26d1bc" alt="|700"></p><h2 id="31-自写编译已通过b站三天动画版"><a class="markdownIt-Anchor" href="#31-自写编译已通过b站三天动画版"></a> 3.1 自写编译已通过(b站三天动画版)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rarrow = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 射击区间的右端点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= rarrow){ <span class="hljs-comment">// 有重叠部分，这里必须小于等于因为也要找到挨着但不重叠的，最后是用射击右端点来判别的</span><br>                <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">1</span>] &lt; rarrow){ <span class="hljs-comment">// 如果第二数组的右端点比第一个数组的右端点小，就缩小射击区间</span><br>                rarrow = points[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新右端点</span><br>                }<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                rarrow = points[i][<span class="hljs-number">1</span>];<br>                arrow ++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> arrow;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-自写编译已通过carl-推荐"><a class="markdownIt-Anchor" href="#32-自写编译已通过carl-推荐"></a> 3.2 自写编译已通过(carl) 推荐</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">// 有气球至少需要一个箭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>        <span class="hljs-comment">// 如果有重叠或者挨着就可以用一支箭射爆(因为射爆的区间是大区间，重叠的是子区间),右边界就是射爆的位置</span><br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]){<span class="hljs-comment">// 2的左边界比1的右边界小说明重叠了</span><br>                    points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span> (points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新右边界与(变成重叠区间)，与下一个比,看下一个的位置是否在重叠区间内，不在则需要另外的箭</span><br>                }<br><br>            <span class="hljs-keyword">else</span> arrow++;<br>            } <br><br><br>            <span class="hljs-keyword">return</span> arrow;<br>            <br>        }<br>   <br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=ae2b0ee3-99ee-4a44-906e-5a2a66bf5f40">ob</a>，<a href="http://localhost:4000/2022/06/10/17.yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BAB</title>
      <link href="/posts/29968/"/>
      <url>/posts/29968/</url>
      
        <content type="html"><![CDATA[<p>BetterAndBetter手势操作助记<br>右键按压手势<br>![[BAB手势 2022-06-09 17.21.49.excalidraw]]</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=2254a3a7-a5e7-412b-88d2-f1a712755b28">ob</a>，<a href="http://localhost:4000/2022/06/09/bab/">blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>obsidian templater 插件</title>
      <link href="/posts/36637/"/>
      <url>/posts/36637/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文件类"><a class="markdownIt-Anchor" href="#1-文件类"></a> 1 文件类</h1><h2 id="11-获取文件的相对路径"><a class="markdownIt-Anchor" href="#11-获取文件的相对路径"></a> 1.1 获取文件的相对路径</h2><p>eg: card-deck: &lt;% tp.file.path(true) %&gt;<br><a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/file-module.html#tpfilepathrelative-boolean--false"><code>tp.file.path(relative: boolean = false)</code></a><br>检索文件在系统上的绝对路径<br><code>relative</code>：如果设置为 true，则仅检索 Vault 的相对路径。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/file-module.html#arguments-9">tp.file - Templater</a></p>]]></content>
      
      
      <categories>
          
          <category> 🚀技能 </category>
          
          <category> obsidian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 已迁移 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.根据身高重建队列</title>
      <link href="/posts/21392/"/>
      <url>/posts/21392/</url>
      
        <content type="html"><![CDATA[<h1 id="1-406根据身高重建队列"><a class="markdownIt-Anchor" href="#1-406根据身高重建队列"></a> 1 406.根据身高重建队列</h1><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">力扣题目链接</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><ul><li>输入：people = [ [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] ]</li><li>输出：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]</li><li>解释：<ul><li>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</li><li>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</li><li>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>因此 [ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ] 是重新构造后的队列。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：people = [ [6,0],[5,0],[4,0],[3,2],[2,2],[1,4] ]</li><li>输出：[ [4,0],[5,0],[2,2],[3,2],[1,4],[6,0] ]</li></ul><p>提示：</p><ul><li>1 &lt;= people.length &lt;= 2000</li><li>0 &lt;= hi &lt;= 10^6</li><li>0 &lt;= ki &lt; people.length</li></ul><p>题目数据确保队列可以被重建</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。<br><strong>如果两个维度一起考虑一定会顾此失彼</strong></p><p>先按身高h来排序(从大到小)，身高相同的k小的站前面<br>在按k的大小进行<strong>插入</strong>操作，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。<br><img src="https://img-blog.csdnimg.cn/20201216201851982.png" alt="406.根据身高重建队列|800"><br>插入的过程：</p><ul><li>插入[7,0]：[ [7,0] ]// 插入0下标</li><li>插入[7,1]：[ [7,0],[7,1] ]// 插入1下标</li><li>插入[6,1]：[ [7,0],[6,1],[7,1] ]// 插入1下标</li><li>插入[5,0]：[ [5,0],[7,0],[6,1],[7,1] ]// 插入0下标</li><li>插入[5,2]：[ [5,0],[7,0],[5,2],[6,1],[7,1] ]// 插入2下标</li><li>插入[4,4]：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]// 插入4下标</li></ul><p>如果先按k来排序，会发现k的排列不符合条件，身高也不符合条件，两个维度一个也没确定下来</p><p>在按照身高从大到小排序后：<br><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong><br><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><h3 id="211-关联知识点"><a class="markdownIt-Anchor" href="#211-关联知识点"></a> 2.1.1 关联知识点</h3><p>[[vector]]，[[sort函数]]，[[insert函数]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[14.根据身高重建队列(carl链表).mp4]]<br>[[14.根据身高重建队列(carl vector).mp4]]<br>[[14.根据身高重建队列(carl 排序).mp4]]</p><p>vector的代码看懂了</p><p>排序完的people： [ [7,0], [7,1], [6,1], [5,0], [5,2]，[4,4] ]<br><code>people[i][1]</code>：eg <code>people[2][1]</code>=1：第二元素的第一个位置的值即{7, 1}中的1</p><p>自写,编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 没看懂，看视频：传进来的是数组eg[7,0]</span><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people){<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要放到for循环里边</span><br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 要插入的是que里，不要成people.begin()</span><br>        }<br>        <span class="hljs-keyword">return</span> que;<br>      }   <br>};<br><br></code></pre></td></tr></tbody></table></figure><p>链表的代码没看懂  #疑问</p><p>[[科研材料总结]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>begin,end</title>
      <link href="/posts/18356/"/>
      <url>/posts/18356/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>};<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);<br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);<br></code></pre></td></tr></tbody></table></figure><p>begin函数返回指向数组的<strong>首元素的指针</strong>，end函数返回指向数组<strong>尾元素的下一个位置的指针</strong>，<br>这两个函数都被定义在iterator的头文件中。使用begin和end函数就可以很好地处理数组中的元素</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insert函数</title>
      <link href="/posts/44424/"/>
      <url>/posts/44424/</url>
      
        <content type="html"><![CDATA[<h1 id="1-在字符串中插入"><a class="markdownIt-Anchor" href="#1-在字符串中插入"></a> 1 在字符串中插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"All that exists is what's ahead."</span>)</span></span>;<br>    string a, b;<br>    a = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-string">"sky"</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串sky</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">//输出All skythat exists is what's ahead.</span><br> <br>    str = <span class="hljs-string">"All that exists is what's ahead."</span>;<br>    b = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">'x'</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串5个字符x</span><br>    cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//输出 All xxxxxthat exists is what's ahead.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-在数组下标处插入"><a class="markdownIt-Anchor" href="#2-在数组下标处插入"></a> 2 在数组下标处插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 在下标position处插入people[i]</span><br></code></pre></td></tr></tbody></table></figure><p>[[begin,end]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/posts/54708/"/>
      <url>/posts/54708/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用法"><a class="markdownIt-Anchor" href="#1-用法"></a> 1 用法</h1><h2 id="11-初始化"><a class="markdownIt-Anchor" href="#11-初始化"></a> 1.1 初始化</h2><p><strong>一维数组的初始化</strong><br>vector的长度不能是变量,必须是常量</p><ol><li><code>vector&lt;int&gt; a(10)</code>; 默认是0</li><li><code>vector&lt;int&gt; a(10,1)</code>;(10个变量每个为1)</li><li><code>vector&lt;int&gt; a(b)</code>; //用b向量来创建a向量，整体复制性赋值</li><li><code>vector&lt;int&gt; a(b.begin(),b.begin+3)</code>; //定义了a值为b中第0个到第2个（共3个）元素</li><li>int b[7]={1,2,3,4,5,9,8}; <code>vector&lt;int&gt; a(b,b+7);</code> //从数组中获得初值</li></ol><p><strong>二维数组的初始化</strong><br>初始化为0，0可变其他数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; vec(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (col,<span class="hljs-number">0</span>));<br><br></code></pre></td></tr></tbody></table></figure><p><code>{{1, 2, 3}, {3, 4, 5}......}</code>: 这种类型的是二维数组 ^1wjjr0</p><p>返回值和使用时：必须用 dp[ i ]，不能用dp(i)</p><p><strong>强转 vector 类型</strong><code>return vector&lt;int&gt;(result_set.begin(), result_set.end());</code><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[3. 两个数组的交集]]">[2]</span></a></sup></p><h2 id="12-操作"><a class="markdownIt-Anchor" href="#12-操作"></a> 1.2 操作</h2><ul><li>添加操作<ul><li><code>result.push_back(vector&lt;int&gt;{1, 2, 3});</code> = <code>{{1, 2, 3}, 还可以往里再加}</code></li></ul></li></ul><h1 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2 原理</h1><p>普通数组 int a [10]，一旦定义了就不能改变了，这个数组最多只能放10个元素了<br>动态数组vector，不用关心初始的大小，可以随意的添加数据</p><p><strong>vector的底层实现也是普通数组</strong>。</p><blockquote><p>vector的底层实现是array，严格来讲vector是容器，不是数组。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[1. 数组理论基础]]">[1]</span></a></sup></p></blockquote><p>vector的大小有两个维度一个是size一个是capicity，<br>size就是我们平时用来遍历vector时候用的，例如：<code>for (int i = 0; i &lt; vec.size(); i++)</code><br>而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size<br>当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴露的size其实仅仅是+1而已，剩下的位置还是空闲的</p><p>C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上，然后在释放原数组内存。<br>eg：<br>原vector中的size和capicity相同都是3，初始化为1 2 3，此时要push_back一个元素4。<br>那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存，<br><strong>注意图中底层数组的内存起始地址已经变了</strong>。<br><img src="https://img-blog.csdnimg.cn/20201218185902217.png" alt="vector原理|800"></p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n<sup>2)了，甚至可能拷贝好几次，就不止O(n</sup>2)了。</p><p>解决办法：可以采用链表来进行插入操作<br>eg：<code>vector&lt;vector&lt;int&gt;&gt; que：[[7,0],[7,1]]</code> →<code>list&lt;vector&lt;int&gt;&gt; que：[7,0]→[7,1]</code></p><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><p><a href="https://blog.csdn.net/wkq0825/article/details/82255984?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165701148116781683956725%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165701148116781683956725&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82255984-null-null.142%5Ev30%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=vector%2Bc%2B%2B%2B%E7%94%A8%E6%B3%95&amp;spm=1018.2226.3001.4187">C++ vector的用法（整理）_一个幽默且帅气的程序员的博客-CSDN博客_c++ vector</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[1. 数组理论基础]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[3. 两个数组的交集]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.分发糖果</title>
      <link href="/posts/43465/"/>
      <url>/posts/43465/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分发糖果"><a class="markdownIt-Anchor" href="#1-分发糖果"></a> 1 分发糖果</h1><p><a href="https://leetcode-cn.com/problems/candy/">力扣题目链接</a></p><p>老师想给孩子们分发糖果，有 N&nbsp;个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例&nbsp;1:</p><ul><li>输入: [1,0,2]</li><li>输出: 5</li><li>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: [1,2,2]</li><li>输出: 4</li><li>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>先比较每一个孩子的右边或者左边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>rate：评分；candyVec：糖果个数</p><p><strong>右边</strong>：从前往后遍历<br>局部最优：如果右比左大，右边孩子就多一个糖果。<br>全局最优：总体中评分高的右孩子比左孩子多一个糖果<br><img src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果|700"><br><strong>左边</strong>：从后往前遍历<br>局部最优：如果左比右大，左边孩子就多一个糖果。<br>全局最优：总体中评分高的左孩子比右孩子多一个糖果<br>#flashcards/代码随想录<br>为什么不能从前往后遍历<br>?<br>因为如果继续从前向后遍历，就无法利用上一次得出的candyVec的数组了</p><!--SR:!2022-07-31,27,250--><p>eg：<br><img src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1|700"><br>如果是图中这样的话，就没必要用max函数了啊 #疑问</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写代码已通过，没有用max函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span></span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>] &gt; ratings[i]) {<br>            candyVec[i+<span class="hljs-number">1</span>] = candyVec[i]+<span class="hljs-number">1</span>;<br>            }<br>       }<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- ) { <span class="hljs-comment">// 从倒数第二位置开始比</span><br>        <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]){<br>            candyVec[i] = candyVec[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            }<br>       }<br>       <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : candyVec) result += a; <span class="hljs-comment">// 分号后边只需要变量名就行</span><br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>参考资料<br>[[for 循环]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.柠檬水找零</title>
      <link href="/posts/52728/"/>
      <url>/posts/52728/</url>
      
        <content type="html"><![CDATA[<h1 id="1-860柠檬水找零"><a class="markdownIt-Anchor" href="#1-860柠檬水找零"></a> 1 860.柠檬水找零</h1><p><a href="https://leetcode-cn.com/problems/lemonade-change/">力扣题目链接</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;5&nbsp;美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回&nbsp;true&nbsp;，否则返回 false&nbsp;。</p><p>示例 1：</p><ul><li>输入：[5,5,5,10,20]</li><li>输出：true</li><li>解释：<ul><li>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</li><li>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</li><li>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</li><li>由于所有客户都得到了正确的找零，所以我们输出 true。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：[5,5,10]</li><li>输出：true</li></ul><p>示例 3：</p><ul><li>输入：[10,10]</li><li>输出：false</li></ul><p>示例 4：</p><ul><li>输入：[5,5,10,10,20]</li><li>输出：false</li><li>解释：<ul><li>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</li><li>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</li><li>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</li><li>由于不是每位顾客都得到了正确的找零，所以答案是 false。</li></ul></li></ul><p>提示：</p><ul><li>0 &lt;= bills.length &lt;= 10000</li><li>bills[i]&nbsp;不是&nbsp;5&nbsp;就是&nbsp;10&nbsp;或是&nbsp;20</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5<br>用新型for循环 for (int bill : bills)，逐一对元素进行判断就行[[for 循环]]</li></ul><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？<br><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>局部最优：逐一对元素进行判断<br>全局最优：完成全部账单的找零</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写，已编译成功</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>{<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>, twenty = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) { <span class="hljs-comment">// 顺序遍历数组,先从第一个元素开始</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>){<br>                five ++;<br>            }<br>            <span class="hljs-comment">// else return false; 不需要这行代码因为5肯定能收</span><br><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>){<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span>) {<br>                    five--;<br>                    ten++;<br>                }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>            }<br><br>            <span class="hljs-keyword">if</span>(bill == <span class="hljs-number">20</span>){<br>                <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>){<br>                    ten--;<br>                    five--;<br>                }<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( five &gt;= <span class="hljs-number">3</span>){ <span class="hljs-comment">// 一定要用else if 下边也用else，这样这三个函数才能成为整体</span><br>                    five -= <span class="hljs-number">3</span>;<br>                }<br>                <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放在整体for循环外</span><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for 循环</title>
      <link href="/posts/28967/"/>
      <url>/posts/28967/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h1><p>for(变量i; 判断条件; 变化变量i)<br>for循环中第二条件是判断条件，破坏了该条件则会退出for循环</p><h1 id="2-遍历函数"><a class="markdownIt-Anchor" href="#2-遍历函数"></a> 2 遍历函数</h1><h2 id="21-基本形式"><a class="markdownIt-Anchor" href="#21-基本形式"></a> 2.1 基本形式</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本 1 </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){  <span class="hljs-comment">// 从前往后遍历</span><br>   <span class="hljs-comment">// 操作到最后一个元素时不会取到最后一个下标的后一位(也就是长度)</span><br>        }<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = num.<span class="hljs-built_in">size</span> () - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){ <span class="hljs-comment">// 从后往前遍历, 记得有=0</span><br><br>}<br><br></code></pre></td></tr></tbody></table></figure><p>i++是每次移动一个格子, 也可以根据题目的不同每次多移动距离<br>![[2. 反转字符串II#^6aghnj]]</p><h2 id="22-新形式"><a class="markdownIt-Anchor" href="#22-新形式"></a> 2.2 新形式</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本二</span><br><span class="hljs-type">int</span> A[<span class="hljs-number">10</span>] = {<span class="hljs-number">0</span>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) { <span class="hljs-comment">// 遍历每一个字符</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><p>❗️ 有关 vector容器的数据就不要用这种 for 循环了</p><h2 id="23-指针形式"><a class="markdownIt-Anchor" href="#23-指针形式"></a> 2.3 指针形式</h2><p>有关 map 结构的遍历: 通过指针来指向元素<br>![[map#^drp7wt]]</p><h1 id="3-数组求和"><a class="markdownIt-Anchor" href="#3-数组求和"></a> 3 数组求和</h1><h2 id="31-第一种写法"><a class="markdownIt-Anchor" href="#31-第一种写法"></a> 3.1 第一种写法</h2><p>for (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体<br>应用：对数组求和，a会从第一个元素开始遍历到最后一个元素</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A是数组，for循环对数组求和</span><br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A)  result += a; <span class="hljs-comment">// int a 类似于int i:后只需数组名即可</span><br></code></pre></td></tr></tbody></table></figure><h2 id="32-第二种写法"><a class="markdownIt-Anchor" href="#32-第二种写法"></a> 3.2 第二种写法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br></code></pre></td></tr></tbody></table></figure><p>n%2 == 1什么意思 #card<br>n%2就是对n求：n除以2后的余数，这里余数只有两种情况就是0或者是1<br>eg：5%2=1</p><h1 id="4-其他"><a class="markdownIt-Anchor" href="#4-其他"></a> 4 其他</h1><!-- basicblock-start oid="ObsF4xGaGV2tjW18kQsFj492" --> <p>for 循环比较两个元素值的时候用 i = 1 ::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// ❗️不能i=0, vec[i] &gt;= vec[i+1], 因为 i+1 已经超过了范围</span><br>    <span class="hljs-keyword">if</span>(vec[i<span class="hljs-number">-1</span>] &gt;= vec[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// ❗️要有'='号</span><br></code></pre></td></tr></tbody></table></figure><p>[[23. 验证二叉搜索树#^44p3md]]</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯铝的性能指标</title>
      <link href="/posts/25410/"/>
      <url>/posts/25410/</url>
      
        <content type="html"><![CDATA[<p><a href="marginnote3app://note/3AE993AE-E623-4E05-BDD8-A7A400FEE1A2">margin</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=1eb5db61-b344-4a33-a07a-7a34f51a00d0">ob</a></p><h1 id="1-梯度结构纯铝的形貌"><a class="markdownIt-Anchor" href="#1-梯度结构纯铝的形貌"></a> 1 梯度结构纯铝的形貌</h1><h2 id="11-成形效果"><a class="markdownIt-Anchor" href="#11-成形效果"></a> 1.1 成形效果</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs col">![](https://s1.vika.cn/space/2022/06/02/bca77150b3084c549a77bf090cb2ce2e)<br>挤出长度跟出口厚度成反比<br><br>![](https://s1.vika.cn/space/2022/06/02/6b18b35cc90944fcb6872a47dc51dec5)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="12-原始纯铝与梯度纯铝的微观组织"><a class="markdownIt-Anchor" href="#12-原始纯铝与梯度纯铝的微观组织"></a> 1.2 原始纯铝与梯度纯铝的微观组织</h2><p><img src="https://s1.vika.cn/space/2022/06/02/e1b9812b60f64c419b2299c54afa3da3" alt="|600"><br><img src="https://s1.vika.cn/space/2022/06/02/a666e2c8fa314ef4b4be704418324067" alt="|600"><br>B侧细化 A侧基本没变，成梯度材料</p><h2 id="13-微观组织演变机制"><a class="markdownIt-Anchor" href="#13-微观组织演变机制"></a> 1.3 微观组织演变机制</h2><p><img src="https://s1.vika.cn/space/2022/06/02/bdf90acd645c4bd490a1c54d6111f285" alt="|600"></p><h1 id="2-梯度结构纯铝的力学性能"><a class="markdownIt-Anchor" href="#2-梯度结构纯铝的力学性能"></a> 2 梯度结构纯铝的力学性能</h1><h2 id="21-梯度结构纯铝的硬度梯度"><a class="markdownIt-Anchor" href="#21-梯度结构纯铝的硬度梯度"></a> 2.1 梯度结构纯铝的硬度梯度</h2><p>原材料32HV，梯度材料44HV<br>B测最高，到A测减少，因为晶粒细化，但靠近A侧硬度平稳且有所提升，是产生了材料硬化<br>金属材料的硬度与其晶粒大小成反比,即<strong>晶粒越细,材料的硬度越高</strong><br><img src="https://s1.vika.cn/space/2022/06/02/d74d109525504da5b0b60ac6c71974c2" alt="|600"></p><h2 id="22-梯度结构纯铝的拉伸性能"><a class="markdownIt-Anchor" href="#22-梯度结构纯铝的拉伸性能"></a> 2.2 梯度结构纯铝的拉伸性能</h2><p>梯度材料拉伸强度达到了160MPa，是原件的一倍多<br><img src="https://s1.vika.cn/space/2022/06/02/6591bb51508e4f82bf050a2253d22844" alt="|600"><br>随着厚度的增加, 梯度样品的抗拉强度逐渐下降,而延展性逐渐增强</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://s1.vika.cn/space/2022/06/02/9d767470c48f4318941bd9b40ca940a4)<br><br>![](https://s1.vika.cn/space/2022/06/02/f98676a6b6414cb4bb655c06d5ecbcb3)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="23-拉伸断口分析"><a class="markdownIt-Anchor" href="#23-拉伸断口分析"></a> 2.3 拉伸断口分析</h2><p>人们希望韧性断裂，而不是脆性断裂。通过观察端口来进行分析</p><p>怎么分析端口是韧性断裂还是塑性断裂<br>?<br>韧窝的尺寸越大,材料的塑性越好，韧窝的尺寸大小也不均匀,既有 10 μm 左右的大韧窝,也有 2 μm 左右的小韧窝,这是由于在拉伸变形过程中,小韧窝不断拉长、聚合成大韧窝,同时也有小韧窝不断萌生</p><p>纯铝原材料的拉伸断口呈现出典型的韧性断裂特征是<strong>韧性断裂</strong></p><p><img src="https://s1.vika.cn/space/2022/06/02/9434e67a2f554ef2a718b05c74d585b1" alt="|600"><br>梯度材料纯铝也是<strong>韧性断裂</strong>，韧窝也主要分布在纤维区和剪切唇的部分区域<br><img src="https://s1.vika.cn/space/2022/06/02/a99078324c754506acf4df4755369ad6" alt="|600"></p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍🎓科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 材料性能 </tag>
            
            <tag> 塑性流动挤出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort 函数</title>
      <link href="/posts/4/"/>
      <url>/posts/4/</url>
      
        <content type="html"><![CDATA[<p>时间复杂度:nlogn<br>sort函数默认从小到大排列，如需自定义需要额外写个函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b); <span class="hljs-comment">// 返回绝对值大的</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="1-应用"><a class="markdownIt-Anchor" href="#1-应用"></a> 1 应用</h1><h2 id="11-按照绝对值从大到小排列"><a class="markdownIt-Anchor" href="#11-按照绝对值从大到小排列"></a> 1.1 按照绝对值从大到小排列，</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br></code></pre></td></tr></tbody></table></figure><h2 id="12-从大到小排列14根据身高重建队列"><a class="markdownIt-Anchor" href="#12-从大到小排列14根据身高重建队列"></a> 1.2 从大到小排列：[[14.根据身高重建队列]]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 身高从大到小排（身高相同k小的站前面）</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br></code></pre></td></tr></tbody></table></figure><p>bool 值好像是规定的 #疑问</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 第三个参数不用出入参数这是规则</span><br></code></pre></td></tr></tbody></table></figure><p>[[static 关键字]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9. K次取反后最大化的数组和</title>
      <link href="/posts/15628/"/>
      <url>/posts/15628/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1005k次取反后最大化的数组和"><a class="markdownIt-Anchor" href="#1-1005k次取反后最大化的数组和"></a> 1 1005.K次取反后最大化的数组和</h1><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接</a></p><p>1131</p><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i&nbsp;并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p>示例 1：</p><ul><li>输入：A = [4,2,3], K = 1</li><li>输出：5</li><li>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</li></ul><p>示例 2：</p><ul><li>输入：A = [3,-1,0,2], K = 3</li><li>输出：6</li><li>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。</li></ul><p>示例 3：</p><ul><li>输入：A = [2,-3,-1,5,-4], K = 2</li><li>输出：13</li><li>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。</li></ul><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>1 &lt;= K &lt;= 10000</li><li>-100 &lt;= A[i] &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>局部最优：让绝对值大的负数变成正数<br>整体最优：整个数组求和变最大</p><p>如果将负数都转变为正数了，K依然大于0，就把绝对值最小的数变为负数</p><p>本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完<ul><li>如果k是偶数则相当于没有变，因为可以对一个数重复两次操作</li><li>如果是奇数，只需要操作一个数，剩下的就是偶数也不用管了<ul><li>即<code>if (K % 2 == 1) A[A.size() - 1] *= -1;</code></li></ul></li></ul></li><li>第四步：求和</li></ul><p>相关知识点<br>[[sort函数]]<br>[[for 循环]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写：编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);    <br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span></span>{<br>    <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 第一步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i != A.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// 第二步</span><br>        <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>){<br>            A[i] *= <span class="hljs-number">-1</span>;<br>            K--;<br>        }<br>    }<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){ <span class="hljs-comment">// 第三步</span><br>            A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;<br>        }<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a; <span class="hljs-comment">// 注意是小a(A中的每个元素)</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsqKSWuWANGrwYnjt12tsd7" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::贪心算法::9. K次取反后最大化的数组和.md" --> <p>#历史记录::<br>2022/9/23🌵9. K次取反后最大化的数组和 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6. 买卖股票的最佳时机II</title>
      <link href="/posts/38547/"/>
      <url>/posts/38547/</url>
      
        <content type="html"><![CDATA[<p>文章简介<br>力扣题解：</p><span id="more"></span><h1 id="1-122买卖股票的最佳时机ii"><a class="markdownIt-Anchor" href="#1-122买卖股票的最佳时机ii"></a> 1 122.买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接</a></p><p>给定一个数组，它的第&nbsp;i 个元素是一支<strong>给定股票</strong>第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><ul><li>输入: [7,1,5,3,6,4]</li><li>输出: 7</li><li>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</li></ul><p>示例 2:</p><ul><li>输入: [1,2,3,4,5]</li><li>输出: 4</li><li>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</li></ul><p>示例&nbsp;3:</p><ul><li>输入: [7,6,4,3,1]</li><li>输出: 0</li><li>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</li></ul><p>提示：</p><ul><li>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</li><li>0 &lt;= prices[i] &lt;= 10 ^ 4</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>最终利润是可以分解的</strong>，<strong>把利润分解为每天为单位的维度</strong><br>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。<br>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p><p><strong>把整体利润拆为每天的利润</strong><br>每天的利润序列：(prices[i] - prices[i - 1])+…+(prices[1] - prices[0])<br><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II|650"><br>第一天没利润，利润表比股票价格表少一位</p><p>局部最优：求得每天的正利润，</p><p>全局最优：求和每天的正利润</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[for 循环]]</p><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != prices.<span class="hljs-built_in">size</span>(); i++){<br>            result += <span class="hljs-built_in">max</span>(prices[i+<span class="hljs-number">1</span>] - prices[i],<span class="hljs-number">0</span>);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static 关键字</title>
      <link href="/posts/37179/"/>
      <url>/posts/37179/</url>
      
        <content type="html"><![CDATA[<p>static 关键字有三种用法</p><ol><li>static 修饰局部变量 → 静态局部变量<ol><li>改变局部变量的生命周期，下次使用该局部变量是上次使用完后的值，而不是初始值</li></ol></li><li>static 修饰全局变量 →静态全局变量<ol><li>只能在本文件内使用，不能在其他文件中访问，extern外边声明也不行(无static时默认是可以被外部访问的)</li></ol></li><li>static 修饰函数 →静态函数<ol><li>只能在本文件中<strong>调用</strong>，同2<br>// 静态可以不用对象调用，直接类名加点方法，不是静态需要创建对象然后调用, 不用 static 无法创建对象</li></ol></li></ol><p>static 修饰的类, 不会随着大类一块加载进内存, 只有当调用的时候, 才会加载进内存[[单例模式的类别#^ougi2n]]</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> C++ </category>
          
          <category> C++ primer plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.摆动序列</title>
      <link href="/posts/74/"/>
      <url>/posts/74/</url>
      
        <content type="html"><![CDATA[<h1 id="1-摆动序列"><a class="markdownIt-Anchor" href="#1-摆动序列"></a> 1 摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">力扣题目链接</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如，&nbsp;[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)&nbsp;是正负交替出现的。相反, [1,4,7,2,5]&nbsp;和&nbsp;[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><ul><li>输入: [1,7,4,9,2,5]</li><li>输出: 6</li><li>解释: 整个序列均为摆动序列。</li></ul><p>示例 2:</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例 3:</p><ul><li>输入: [1,2,3,4,5,6,7,8,9]</li><li>输出: 2</li></ul><blockquote><p>后一个数减前一个数的值，正负交替</p></blockquote><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><img src="https://s1.vika.cn/space/2022/05/28/1af591dff4b846a3999e21e948dd6e70" alt=""></p><p>局部最优：变成没有坡度的峰<br>整体最优：尽可能有最多的<strong>没有坡度的峰</strong></p><p>最左面和最右面的峰值不好统计<br>可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0</p><p>定义变量：<br>左坡度：preDiff &gt;= 0 或者preDiff &lt;= 0也行，(等于0是最左面的情况)<br>右坡度：curDiff &lt; 0 或者cur &gt;0,<br>result：统计百度序列的个数</p><blockquote><p>反正左坡度和右坡度需要异号，并且左坡度可以 = 0；<br><img src="https://s1.vika.cn/space/2022/05/28/f1551bf99b894ba08967e7dd87387603" alt=""></p></blockquote><p>result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p><blockquote><p>问：这样话直接把result初始为2不行吗？<br>答：要用到前一对和后一对的差值。只有有两个数就可以有这两个差值，所以nums.size() &lt;= 1 即可返回</p></blockquote><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span>( nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 长度不超过1</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right =&nbsp;<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){ <span class="hljs-comment">// 这样写更好</span><br>            right =&nbsp;nums[i] - nums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt;= <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span> &amp;&amp; left &gt;= <span class="hljs-number">0</span>){ <span class="hljs-comment">// 两边要异号啊</span><br>                result++;<br>                left = right;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心</strong>。<br>有什么方法想到贪心→多做</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brew安装</title>
      <link href="/posts/4339/"/>
      <url>/posts/4339/</url>
      
        <content type="html"><![CDATA[<p><img src="https://s1.vika.cn/space/2022/05/28/0b3ffbfe5ad64d388d02bceff24ab6a0" alt=""></p><p>用官网安装出现以下错误：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">curl: (<span class="hljs-number">7</span>) Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> raw.githubusercontent.com port <span class="hljs-number">443</span>: <span class="hljs-keyword">Connection</span> refused<br></code></pre></td></tr></tbody></table></figure><p>原因是：<strong>github 的一些域名的 DNS 解析被污染</strong>，导致DNS 解析过程无法通过域名取得正确的IP地址</p><p>换成国内下载地址即可</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>zsh -c <span class="hljs-string">"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"</span><br></code></pre></td></tr></tbody></table></figure><p>根据终端反应输入即可，过程中有中文提示</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> hexo blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac下软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 生成ssh密钥</title>
      <link href="/posts/18965/"/>
      <url>/posts/18965/</url>
      
        <content type="html"><![CDATA[<p>linux命令<br>查看密钥是否生成：ls -l ~/.ssh</p><p>生成密钥：ssh-keygen&nbsp;-t&nbsp;rsa (一路回车)</p><p>密钥所在目录：<br>cd ~/.ssh</p><p>私钥：id_rsa<br>公钥：id_rsa.pub</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.分发饼干</title>
      <link href="/posts/42003/"/>
      <url>/posts/42003/</url>
      
        <content type="html"><![CDATA[<h1 id="1-455分发饼干"><a class="markdownIt-Anchor" href="#1-455分发饼干"></a> 1 455.分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">力扣题目链接</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值&nbsp;<strong>g[i]</strong>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <strong>s[j]</strong>&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例&nbsp;1:</p><ul><li>输入: g = [1,2,3], s = [1,1]</li><li>输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: g = [1,2], s = [1,2,3]</li><li>输出: 2</li><li>解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</li></ul><p>提示：</p><ul><li>1 &lt;= g.length &lt;= 3 * 10^4</li><li>0 &lt;= s.length &lt;= 3 * 10^4</li><li>1 &lt;= g[i], s[j] &lt;=&nbsp;2^31 - 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>局部最优：大饼干喂给胃口大的孩子(尽量充分利用饼干)<br>全局最优：喂饱尽可能多的小孩</p><p>将饼干数组和小孩数组拍个序<br><strong>从后向前遍历</strong>，即大饼干满足胃口的大孩子，<strong>并</strong>统计满足小孩数量<br><img src="https://s1.vika.cn/space/2022/05/27/1c68ab105c2d4666a72ac61ebbca6600" alt="|700"><br>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><h1 id="3-力扣代码"><a class="markdownIt-Anchor" href="#3-力扣代码"></a> 3 力扣代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 饼干数组的最后一个元素</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计孩子的数</span><br>        <span class="hljs-comment">//因为想从后往前遍历对比，所以用i-- ，而不用i++，g.size() - 1是孩子数组的最后一个元素，</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>  ; i--){ <span class="hljs-comment">// ”=“号为对比到最后一个孩子 </span><br>            <span class="hljs-keyword">if</span> (index  &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]){<br>                result++;<br>                index--;<br>            }<br>        } <br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.贪心算法理论基础</title>
      <link href="/posts/29776/"/>
      <url>/posts/29776/</url>
      
        <content type="html"><![CDATA[<p>[[9. K次取反后最大化的数组和#^fb00f8]]</p><h1 id="1-贪心算法的题目大纲"><a class="markdownIt-Anchor" href="#1-贪心算法的题目大纲"></a> 1 贪心算法的题目大纲</h1><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"> ^d14613</p><h1 id="2-什么是贪心算法"><a class="markdownIt-Anchor" href="#2-什么是贪心算法"></a> 2 什么是贪心算法</h1><p>局部最优推出全局最优<br>eg：一堆钱里只能拿10张，如何拿到最大。每一次都拿的最大(局部最优)→总共拿的最大(全局最优)</p><h1 id="3-什么时候用贪心算法"><a class="markdownIt-Anchor" href="#3-什么时候用贪心算法"></a> 3 什么时候用贪心算法</h1><p>看到题目时，感受到能够：<strong>局部最优→全局最优，且想不到反例</strong>。就试一试贪心.<br>感觉贪心算法更看直觉能不能用</p><h1 id="4-贪心算法的套路"><a class="markdownIt-Anchor" href="#4-贪心算法的套路"></a> 4 贪心算法的套路</h1><ol><li>将总问题划分为子问题</li><li>找到合适的最优解法</li><li>对子问题进行最优求解</li><li>将子问题堆积成总问题</li></ol><p>实际上解题没有这么细，因为贪心算法还与其他知识联合在一起</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsPQ6JVnlN6crGDTNlVISLh" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::贪心算法::1.贪心算法理论基础.md" --> <p>#历史记录::<br>2022/9/23🌵1.贪心算法理论基础 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21.解数独</title>
      <link href="/posts/5566/"/>
      <url>/posts/5566/</url>
      
        <content type="html"><![CDATA[<p>N皇后是每一行找一个位置放皇后<br>数独是<strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法</strong></p><p>void backtracking(参数) {<br>startIndex：控制下一层的起始位置<br>去重(从下一层的第一个位置开始：backtracking(…, i+1))<br>排列问题不用startIndex<br>used[]：去重(从下一层的起始位置开始：backtracking(…, 0))<br>if (终止条件) {<br>存放结果;<br>return;<br>要取树上所有节点时不要加return<br>}<br>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>处理节点;<br>backtracking(路径，选择列表); // 递归<br>回溯，撤销处理结果<br>}<br>}</p><h1 id="1-回溯三部曲"><a class="markdownIt-Anchor" href="#1-回溯三部曲"></a> 1 回溯三部曲</h1><p>定义一些变量</p><h2 id="11-确定回溯函数参数返回值"><a class="markdownIt-Anchor" href="#11-确定回溯函数参数返回值"></a> 1.1 确定回溯函数参数返回值</h2><p>数独和N皇后的返回值用bool值</p><h2 id="12-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#12-终止条件-存放结果-return"></a> 1.2 终止条件, 存放结果, return</h2><p>不需要终止条件，等数填满了，棋盘自然终止</p><h2 id="13-单层搜索过程"><a class="markdownIt-Anchor" href="#13-单层搜索过程"></a> 1.3 单层搜索过程</h2><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><h3 id="131-判断棋盘是否合法"><a class="markdownIt-Anchor" href="#131-判断棋盘是否合法"></a> 1.3.1 判断棋盘是否合法</h3><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>#flashcards/代码随想录 #疑问<br>二维数组的行数与列数<br>?<br>int array[2]  [3]；二行三列<br>int row = array.size();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行数&nbsp;&nbsp;&nbsp;<br>int col = array[0].size();  列数</p><!--SR:!2022-08-02,29,250-->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手</title>
      <link href="/posts/61990/"/>
      <url>/posts/61990/</url>
      
        <content type="html"><![CDATA[<p>三次握手的目的是保证双方互相之间建立了连接<br>三次握手发生在客户端连接的时候，当调用connect()函数时，底层会通过TCP协议进行三次握手。</p><p>seq：序号<br>ACK：标志位<br>ack(AcK)：确认序号，只有当 ACK=1 时确认序号才有用<br>TCP是用字节流传输，会为每个字节分配一个序号</p><h1 id="1-三次握手"><a class="markdownIt-Anchor" href="#1-三次握手"></a> 1 三次握手</h1><p>时序图<br><img src="https://s1.vika.cn/space/2022/05/26/9e8848db48ec40d2a865d364ed1dfe16" alt=""></p><p>牛客总结<br>第一次握手：<br>1.客户端将SYN标志位置为1，向服务端请求建立连接，<br>2.生成一个随机(<font color="#F36208">其实是有固定算法的</font>)的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>1.服务端将<font color="#F36208">标志位</font><font color="#F36208">ACK</font>置为1，接收客户端的连接。<br>并且回发一个确认序号：ack=客户端的序号 +  数据长度+ SYN/FIN（按一个字节算）<br>2.服务器端会向客户端发起连接请求：SYN=1<br>3.服务器会生成一个随机序号(<font color="#F36208">其实是有固定算法的</font>)：seq = K<br>第三次握手：<br>1.客户单应答服务器的连接请求：ACK=1<br>2.客户端回复收到了服务器端的数据：ack=服务端的序号 +数据长度 + SYN/FIN（按一个字节算）<br>自己总结<br><font color="#F36208">第一次握手：客户端发起连接</font><br>1.客户端将标志位SYN置位1，表示向服务端请求连接。2.并且根据算法生成一个客户端序号cseq：J<br><font color="#F36208">第二次握手：服务端回复请求，发起连接</font><br>1.服务端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 客户端的序号(J) + 数据字节个数 + SYN/FIN(算一个字节)<br>3.服务端将标志位SYN置位1，表示向客户端请求连接。4.并且根据算法生成一个服务端序号sseq：K<br><font color="#F36208">第三次握手：客户端回复请求</font><br>1.客户端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 服务端的序号(K) + 数据字节个数 + SYN/FIN(算一个字节)</p><p>第一次握手(客户端→服务端)：客户端请求连接<br>客户端与服务端还没有建立连接，不能发数据<br>第二次握手(客户端←服务端)：服务端同意连接+请求与客户端连接<br>第三次握手(客户端→服务端)：客户端同意连接<br>此时客户端已经和服务端已经建立了连接，这次客户端的握手已经可以携带数据了<br>之后服务端与客户端都互相建立了连接，可以互相自由通信</p><h2 id="11-三次握手实例"><a class="markdownIt-Anchor" href="#11-三次握手实例"></a> 1.1 三次握手实例</h2><p><img src="https://s1.vika.cn/space/2022/05/26/e1cbc619a8b445c5a3cb9282c0d21c21" alt=""></p><h2 id="12-为什么不能两次握手"><a class="markdownIt-Anchor" href="#12-为什么不能两次握手"></a> 1.2 为什么不能两次握手</h2><p>因为要确保客户端能<font color="#C32E94">收发</font>消息，服务端能<font color="#C32E94">收发</font>消息，3次握手正好少一次都不行<br><img src="https://s1.vika.cn/space/2022/05/26/7f7c22713cf345368d2778005723b9b1" alt=""></p><p>四次握手也是可以的，服务端的ACK和SYN连在一起发了，拆开发就是四次握手<br>保证可靠连接的最小次数是三次握手</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/posts/36408/"/>
      <url>/posts/36408/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><p>I/O 多路复用使得程序能同时监听多个文件描述符,能够提高程序的性能,<br>I：输入，从文件当中把数据写入内存<br>O: 输出，把内存的数据读到文件里去<br>I/O 操作相当于对socket的缓冲区的操作</p><blockquote><p>[!summary] 多路复用：多条路复用成一条</p></blockquote><p>多路复用的意思：之前有100个客户端，检测有无数据就要调用100次的read函数，<br>现在我用一个文件描述符表来委托内核来检测，在统一返回一个文件描述表。<br>这样100路就变成了1路(简称多路复用)</p><blockquote></blockquote><p><strong>Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll</strong>。</p><blockquote><p>[!summary] 阻塞等待<br>![[阻塞等待.excalidraw]]</p></blockquote><h1 id="2-阻塞等待的模型-bio模型"><a class="markdownIt-Anchor" href="#2-阻塞等待的模型-bio模型"></a> 2 阻塞等待的模型： BIO模型</h1><p><a href="marginnote3app://note/71666D96-F61F-43AE-9FC9-F7BC4206964A">margin</a><br>![[705a8cd54a58a4c1cd913f74ceb539d0.png|725]]<br>服务端创建socket，绑定IP和端口→监听→接受连接<br>如果只是一个进程，那么多个客户端来连接就会阻塞。<br>解决办法是：创建多线程来进行连接。accept前面应当有while循环</p><h1 id="3-非阻塞忙轮询"><a class="markdownIt-Anchor" href="#3-非阻塞忙轮询"></a> 3 非阻塞，忙轮询</h1><p><a href="marginnote3app://note/2D2CF553-A636-45BD-B61E-CA006C1D2812"></a><br>![[eb409ec1df657b8f2d1c348b4250884c.png|725]]<br>假设read没读到数据，让while循环一直让read函数去读取读缓冲区的数据</p><h1 id="4-nio模型"><a class="markdownIt-Anchor" href="#4-nio模型"></a> 4 NIO模型</h1><p>![[Pasted image 20220525170732.png|725]]<br>用一个while循环套accpet，用一个while循环套read，<br>让他俩不断循环的看有没有客户端连接进来，有没有数据写入了读缓冲区。<br>缺点：如果是1万个客户端想连接，就要循环1万次<br>如果1万客户端都连接了，其中只有一个客户端有数据发送过来，循环read函数9999次都是无效的</p><h1 id="5-epoll"><a class="markdownIt-Anchor" href="#5-epoll"></a> 5 [[epoll]]</h1><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsQFbMEsgLYIrX0RDC0rZQG" deck = "👨🏻‍💻code::项目::webserver::4 Linux网络编程::IO多路复用.md" --> <p>#历史记录:: <a href="marginnote3app://note/145A1C77-D798-4681-8AAE-0BD2FA6AD727">margin</a><br>2022-05-25🌵IO多路复用 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.N皇后</title>
      <link href="/posts/18499/"/>
      <url>/posts/18499/</url>
      
        <content type="html"><![CDATA[<p>[[1.贪心算法理论基础#^d14613]]</p><h1 id="1-第51题-n皇后"><a class="markdownIt-Anchor" href="#1-第51题-n皇后"></a> 1 第51题. N皇后</h1><p><a href="https://leetcode-cn.com/problems/n-queens/">力扣题目链接</a></p><p>n&nbsp;皇后问题 研究的是如何将 n&nbsp;个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的&nbsp;n&nbsp;皇后问题 的解决方案。</p><p>每一种解法包含一个不同的&nbsp;n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例 1：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211020232201.png" alt=""></p><ul><li>输入：n = 4</li><li>输出：[ [".Q…","…Q",“Q…”,"…Q."],["…Q.",“Q…”,"…Q",".Q…"] ]</li><li>解释：如上图所示，4 皇后问题存在两个不同的解法。</li></ul><p>示例 2：</p><ul><li>输入：n = 1</li><li>输出：[ [“Q”] ]</li></ul><p>皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>好吧</p><p>![[20.N皇后 2022-05-25 10.54.39.excalidraw]]</p><!-- basicblock-start oid="Obsw830Wj3I4apZIzvAcoVNG" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::20.N皇后.md"--><p>回溯的过程到底是什么样的，录视频 ，找一个简单的题录视频吧<br>目前看来是回溯到代码随想录那种图的第二层然后在往下走吧</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYXSPDjMuVzJRXPo8Ihy5h" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::20.N皇后.md" --> <p>#历史记录::<br>2022/9/23🌵20.N皇后 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>端口复用</title>
      <link href="/posts/55001/"/>
      <url>/posts/55001/</url>
      
        <content type="html"><![CDATA[<p>半关闭：</p><p>tcp_server.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> {<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    <br>    <span class="hljs-comment">//int optval = 1;</span><br>    <span class="hljs-comment">//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span><br><br>    <span class="hljs-type">int</span> optval = <span class="hljs-number">1</span>;<br>    setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="hljs-keyword">sizeof</span>(optval));<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"bind"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 监听</span><br>    ret = listen(lfd, <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"listen"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 接收客户端连接</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>    <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"accpet"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取客户端信息</span><br>    <span class="hljs-type">char</span> cliIp[<span class="hljs-number">16</span>];<br>    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="hljs-keyword">sizeof</span>(cliIp));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cliPort = ntohs(cliaddr.sin_port);<br><br>    <span class="hljs-comment">// 输出客户端的信息</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client's ip is %s, and port is %d\n"</span>, cliIp, cliPort );<br><br>    <span class="hljs-comment">// 接收客户端发来的数据</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">int</span> len = recv(cfd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"recv"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"客户端已经断开连接...\n"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, recvBuf);<br>        }<br><br>        <span class="hljs-comment">// 小写转大写，eg：hello -&gt; HELLO</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) { <br>            recvBuf[i] = <span class="hljs-built_in">toupper</span>(recvBuf[i]);<br>        }<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"after buf = %s\n"</span>, recvBuf);<br><br>        <span class="hljs-comment">// 大写字符串发给客户端</span><br>        ret = send(cfd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"send"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>    }<br>    <br>    close(cfd);<br>    close(lfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>tcp_client.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">seraddr</span>;</span><br>    inet_pton(AF_INET, <span class="hljs-string">"127.0.0.1"</span>, &amp;seraddr.sin_addr.s_addr);<br>    seraddr.sin_family = AF_INET;<br>    seraddr.sin_port = htons(<span class="hljs-number">9999</span>);<br><br>    <span class="hljs-comment">// 连接服务器</span><br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;seraddr, <span class="hljs-keyword">sizeof</span>(seraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">char</span> sendBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>        fgets(sendBuf, <span class="hljs-keyword">sizeof</span>(sendBuf), <span class="hljs-built_in">stdin</span>);<br><br>        write(fd, sendBuf, <span class="hljs-built_in">strlen</span>(sendBuf) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 接收</span><br>        <span class="hljs-type">int</span> len = read(fd, sendBuf, <span class="hljs-keyword">sizeof</span>(sendBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, sendBuf);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器已经断开连接...\n"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>![[Pasted image 20220525154320.png|825]]<br>optval = 1 表示要端口复用，0表示不要端口复用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys /types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys /socket.h&gt;</span></span><br><span class="hljs-comment">//设置套接字的属性（不仅仅能设置端口复用）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname， <span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> opt len)</span>；<br>參数：<br>sockfd：要操作的文件描述符<br>level：级别 - SOL_SOFKET （端口复用的级别）<br>optname：选项的名称<br>SO_REUSEADDR<br>SO_REUSEPORT<br>optval：端口复用的值（整形）<br>- 1：可以复用<br>- 0:不可以复用<br>optlen： optval參数的大小<br>端口复用，设置的时机是在服务器绑定端口之前。<br><span class="hljs-title function_">setsockopt</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 设置端口复用</span><br>bind()；<span class="hljs-comment">// 在进行绑定</span><br></code></pre></td></tr></tbody></table></figure><p>#liunx命令</p><p>常看网络相关信息的命令；net 网络，stat 状态<br>netstat -×<br>参数：<br>-a ：所有的socket<br>-p ：显示正在使用socket的程序的名称<br>-n ：直接使用 IP 地址，而不通过域名服务器</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start --> <p>#历史记录::<br>2022/10/20🌵端口复用 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="/posts/58780/"/>
      <url>/posts/58780/</url>
      
        <content type="html"><![CDATA[<h1 id="1-socket"><a class="markdownIt-Anchor" href="#1-socket"></a> 1 socket::</h1><p>在第一个写缓冲区中写然后封装过去，然后在解封装，在读缓冲区读出来<br>我们只用fd来进行写操作和读操作<br>![[socket 2022-10-11 20.37.52.excalidraw]]</p><p>套接字通信分两部分：</p><ul><li>服务器端：被动接受连接，一般不会主动发起连接</li><li>客户端：主动向服务器发起连接</li><li>Socket是一套通信的接口，Linux 和 windows 都有，但是有一些细微的差别。</li></ul><h1 id="2-套接字函数"><a class="markdownIt-Anchor" href="#2-套接字函数"></a> 2 [[套接字函数]]</h1><h1 id="3-本地套接字"><a class="markdownIt-Anchor" href="#3-本地套接字"></a> 3 本地套接字</h1><p>tcp, udp 通信都是网络套接字: 不同主机的通信</p><p>本地套接字的作用: 本地的进程间通信 (一个主机上的不同进程间的通信)<br>有关系的进程间的通信 (父子进程)<br>没有关系的进程间的通信</p><p>本地套接字实现流程和网络套接字类似，一般呢采用 TCP 的通信流程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 本地套接字通信的流程 - tcp</span><br><br><span class="hljs-comment">// 服务器端</span><br><span class="hljs-number">1.</span> 创建监听的套接字<br>    <span class="hljs-type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-number">1.</span> 第一个参数:协议族表示本地 <br>    <span class="hljs-number">2.</span> tcp<br><span class="hljs-number">2.</span>  监听的套接字绑定本地的套接字文件 -&gt; server端<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br>    <span class="hljs-comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span><br>     bind(lfd, addr, len);<br><span class="hljs-number">3.</span> 监听<br>    listen(lfd, <span class="hljs-number">100</span>);<br><span class="hljs-number">4.</span> 等待并接受连接请求<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">cliaddr</span>;</span><br>    <span class="hljs-type">int</span> cfd = accept(lfd, &amp;cliaddr, len);<span class="hljs-comment">// 第二参数是本机的地址</span><br><span class="hljs-number">5.</span> 通信 <br>    <span class="hljs-number">1.</span> 接收数据:read/recv <br>    <span class="hljs-number">2.</span> 发送数据:write/send<br><span class="hljs-number">6.</span> 关闭连接 <br>    <span class="hljs-number">1.</span> close();<br><br><br><br><span class="hljs-comment">// 客户端的流程</span><br><span class="hljs-number">1.</span> 创建通信的套接字<br>    <span class="hljs-type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>); <br><span class="hljs-number">2.</span> 监听的套接字绑定本地的IP 端口<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br>    <span class="hljs-comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 bind(lfd, addr, len);</span><br><span class="hljs-number">3.</span> 连接服务器<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">serveraddr</span>;</span><br>    connect(fd, &amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br><span class="hljs-number">4.</span> 通信 <br>    <span class="hljs-number">1.</span> 接收数据:read/recv <br>    <span class="hljs-number">2.</span> 发送数据:write/send<br><span class="hljs-number">5.</span> 关闭连接 <br>    <span class="hljs-number">1.</span> close();<br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件: sys/un.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNIX_PATH_MAX 108 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> {</span><br><span class="hljs-type">sa_family_t</span> sun_family; <span class="hljs-comment">// 地址族协议 af_local</span><br><span class="hljs-type">char</span> sun_path[UNIX_PATH_MAX]; <span class="hljs-comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0 </span><br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsQHqv2ecPFGd83vlI01tiX"  --> <p>#历史记录::<br>2022-05-23🌵socket : 第一次创建</p><!-- basicblock-end --><p>socket</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IP地址转换</title>
      <link href="/posts/47652/"/>
      <url>/posts/47652/</url>
      
        <content type="html"><![CDATA[<p>IP地址转换函数</p><p>将点分十进制转换成网络字节序的整数(大端字节序)；将主机字节序转换为网络字节序<br>带点-&gt;不带点</p><p>ipv4是点分十进制，ipv6是用16进制表示<br>![[Pasted image 20220512155003.png|700]]<br>网络字节序的整数：点分十进制不带点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span>;<br>    af:地址族： AF_INET  AF_INET6<br>    src:需要转换的点分十进制的IP字符串<br>    dst:转换后的结果保存在这个里面<br><br><span class="hljs-comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span>;<br>    af:地址族： AF_INET  AF_INET6<br>    src: 要转换的ip的整数的地址<br>    dst: 转换成IP地址字符串保存的地方<br>    size：第三个参数的大小（数组的大小）<br>    返回值：返回转换后的数据的地址（字符串），和 dst 是一样的<br><br><br></code></pre></td></tr></tbody></table></figure><p>代码实例</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 创建一个ip字符串,点分十进制的IP地址字符串</span><br>    <span class="hljs-type">char</span> buf[] = <span class="hljs-string">"192.168.1.4"</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span><br>    inet_pton(AF_INET, buf, &amp;num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)&amp;num;<span class="hljs-comment">// 要一个字节一个字节来打印</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d %d\n"</span>, *p, *(p+<span class="hljs-number">1</span>), *(p+<span class="hljs-number">2</span>), *(p+<span class="hljs-number">3</span>));<br><br><br>    <span class="hljs-comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span><br>    <span class="hljs-type">char</span> ip[<span class="hljs-number">16</span>] = <span class="hljs-string">""</span>;<span class="hljs-comment">// 用一个数组来保存转换结果</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * str =  inet_ntop(AF_INET, &amp;num, ip, <span class="hljs-number">16</span>);<span class="hljs-comment">// 16也可用sizeof()</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"str : %s\n"</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ip : %s\n"</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ip == str);<span class="hljs-comment">// 比较了两个是否相同</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>![[Pasted image 20220512161659.png|700]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs3rUOL50tgWxUVcrEyyAUM" --> <p>#历史记录::<br>2022-05-23🌵IP地址转换 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP 状态转换</title>
      <link href="/posts/43055/"/>
      <url>/posts/43055/</url>
      
        <content type="html"><![CDATA[<p>为什么四次挥手中第 2. 3次ACK和FIN不一同发送<br><a href="marginnote3app://note/F69FB942-D510-4A4F-86A5-1092F7D95657">margin</a><br>![[fa69a4bbf2c1b3c47c7227367f60be6f 3.png|475]]<br>因为客户端想跟服务端断开连接，但是服务端不一定想和客户端断开连接<br>服务端也许还想继续给客户端发送数据呢，不一定非要发送FIN<br>这是单方向的意愿<br>而三次握手中为什么能一块发送ACK，SYN是因为，他们两个都想建立连接，就一块发送了</p><p>为什么要有2msl的等待时间</p><p><a href="marginnote3app://note/F69FB942-D510-4A4F-86A5-1092F7D95657">margin</a><br>![[fa69a4bbf2c1b3c47c7227367f60be6f 3.png|475]]<br>因为防止第四次挥手的时候，服务端没有收到客户端的ACK，如果有一个等待时间<br>服务端可以在这个期间，多次发送FIN信号来请求客户端的ACK，以便来完成最后挥手</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start --> <p>#历史记录::<br>2022-05-23🌵TCP 状态转换 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP通信并发</title>
      <link href="/posts/42719/"/>
      <url>/posts/42719/</url>
      
        <content type="html"><![CDATA[<blockquote><p>暂时没学</p></blockquote><p>并发：多个客户端连接服务器进行通信</p><p>要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。<br>思路：<br>1.一个父进程，多个子进程<br>2.父进程负责等待并接受客户端的连接<br>用父进程用for循环/while循环的调用accpet函数，来建立接受请求<br>![[Pasted image 20220523154757.png|800]]<br>3.子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信<br>![[Pasted image 20220523154846.png|800]]</p><p>只需要修改之前文件的服务端代码，客户端不用变，因为是服务器处理多个服务器的连接<br>第一版文件代码：[[TCP通信代码案例]]<br>server_process</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recyleChild</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> </span>{<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-comment">// 所有的子进程都回收了</span><br>            <span class="hljs-keyword">break</span>;<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 还有子进程活着</span><br>            <span class="hljs-keyword">break</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>){<br>            <span class="hljs-comment">// 被回收了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"子进程 %d 被回收了\n"</span>, ret);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;<br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>    act.sa_handler = recyleChild;<br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    <span class="hljs-built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br>    <br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>){<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> saddr;<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>);<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(lfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-built_in">sizeof</span>(saddr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"bind"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 监听</span><br>    ret = <span class="hljs-built_in">listen</span>(lfd, <span class="hljs-number">128</span>); <span class="hljs-comment">// 第二参数给8也足够</span><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"listen"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// exit(0)也可</span><br>    }<br><br>    <span class="hljs-comment">// 服务端不断循环等待客户端连接</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> cliaddr;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(cliaddr);<br>        <span class="hljs-comment">// 接受连接</span><br>        <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">accept</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);<br>        <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-keyword">if</span>(errno == EINTR) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">"accept"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        }<br><br>        <span class="hljs-comment">// 每一个连接进来，创建一个子进程跟客户端通信</span><br>        <span class="hljs-type">pid_t</span> pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 子进程</span><br>            <span class="hljs-comment">// 获取客户端的信息</span><br>            <span class="hljs-type">char</span> cliIp[<span class="hljs-number">16</span>];<br>            <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="hljs-built_in">sizeof</span>(cliIp));<span class="hljs-comment">// 转换为主机字节序</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cliPort = <span class="hljs-built_in">ntohs</span>(cliaddr.sin_port);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client ip is : %s, prot is %d\n"</span>, cliIp, cliPort);<br><br>            <span class="hljs-comment">// 接收客户端发来的数据</span><br>            <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(cfd, &amp;recvBuf, <span class="hljs-built_in">sizeof</span>(recvBuf));<br><br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">"read"</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv client : %s\n"</span>, recvBuf);<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client closed....\n"</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>                <span class="hljs-built_in">write</span>(cfd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf) + <span class="hljs-number">1</span>);<br>            }<br>            <span class="hljs-built_in">close</span>(cfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);    <span class="hljs-comment">// 退出当前子进程</span><br>        }<br><br>    }<br>    <span class="hljs-built_in">close</span>(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>client.c</p><h2 id="-code1-"><a class="markdownIt-Anchor" href="#-code1-"></a> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// TCP通信的客户端</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.创建套接字</span><br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 2.连接服务器端</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span><br>    serveraddr.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">"192.168.193.128"</span>, &amp;serveraddr.sin_addr.s_addr);<br>    serveraddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br>    <br>    <span class="hljs-comment">// 3. 通信</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <br>        <span class="hljs-built_in">sprintf</span>(recvBuf, <span class="hljs-string">"data : %d\n"</span>, i++);<br>        <br>        <span class="hljs-comment">// 给服务器端发送数据</span><br>        write(fd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf)+<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">int</span> len = read(fd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv server : %s\n"</span>, recvBuf);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 表示服务器端断开连接</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"server closed..."</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>        sleep(<span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></h2><p><strong>其他资料</strong></p><!-- basicblock-start --> <p>#历史记录::<br>2022/10/20🌵TCP通信并发 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP四次挥手</title>
      <link href="/posts/13901/"/>
      <url>/posts/13901/</url>
      
        <content type="html"><![CDATA[<p>三次握手是客户端请求的<br>四次挥手是两端都可以主动提出<br>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。<br>客户端和服务器端都可以主动发起断开连接，谁先调用close()谁就是发起。</p><p>四次挥手需要双向断开连接<br>因为在TCP连接的时候，采用三次握手建立的的连接是双向的，在断开的时候需要双向断开。</p><p><a href="marginnote3app://note/E6901E15-6494-4F39-AF33-A4A4ED51F96C">margin</a><br>![[8040067f3329cf2fbc08a2f62b656dae.png|1000]]</p><ol><li>客户端将FIN置为1，向服务端发送断开请求</li><li>服务端将标志位ACK置为1，同意客户端断开请求</li><li>服务端将FIN置为1，向客户端发送断开请求</li><li>客户端将标志位ACK置为1，同意服务端断开请求</li></ol><blockquote><p>至此客户端与服务端双向断开了，完成了四次挥手</p></blockquote><h2 id="01-四次挥手图解"><a class="markdownIt-Anchor" href="#01-四次挥手图解"></a> 0.1 四次挥手图解</h2><p><a href="marginnote3app://note/6BE6AC4F-C374-451D-B1C5-004754636D8C">margin</a></p><p>![[cc43ec85e80ff543de3790b517e6300f.png|1000]]</p><p>详见下面中：第13次到第18次</p><p>[[滑动窗口#^fyk6mo]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start --> <p>#历史记录::<br>2022/10/20🌵TCP四次挥手 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/posts/60656/"/>
      <url>/posts/60656/</url>
      
        <content type="html"><![CDATA[<p>服务器端根据设置一个接受数据的尺寸来控制客户端的发送<br>TCP 中采用滑动窗口来进行传输控制,滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时,发送方一般不能再发送数据报。<br>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。</p><p>窗口理解为缓冲区的大小<br>滑动窗口的大小会随着发送数据和接收数据而变化。<br>通信的双方都有发送缓冲区和接收数据的缓冲区<br>服务器：<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）<br>客户端：</p><p>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）</p><p>![[Pasted image 20220520164119.png]]</p><blockquote><p>这个可以不看，看下边的实例就行</p></blockquote><h1 id="1-滑动窗口实例"><a class="markdownIt-Anchor" href="#1-滑动窗口实例"></a> 1 滑动窗口实例</h1><blockquote><p>mss：maximum segment size (一条数据的最大数据量) 。eg：&lt;mss 1460&gt; 一次最多可发送1460字节的数量的数据<br>win：滑动窗口尺寸。eg：win 4096 (客户端/服务端 滑动窗口尺寸为4096)<br>0(0)：随机序号seq(发送的数据量)</p></blockquote><h2 id="11-滑动窗口图解"><a class="markdownIt-Anchor" href="#11-滑动窗口图解"></a> 1.1 滑动窗口图解</h2><p>![[b410e87074b018768803fa755cf0a49d.png]]<a href="marginnote3app://note/DC538902-F13D-465E-AE98-019FC531D786"></a></p><ol><li>客户端向服务器发起连接，客户端的滑动窗口是4096，一次发送的最大数据量是1460</li><li>服务器接收连接请求ack = seq + 数据量 + SYN(1个字节)，ack = 1(表示对SYN的确认，此时没有数据) ，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024</li><li>第三次握手</li><li>4-9 客户端连续给服务器发送了6k的数据，每次发送1k</li><li>第10次，服务器告诉客户端：发送的6k数据以及接收到，存储在缓冲区中，缓冲区数据己经处理了2k，窗口大小是2k</li><li>第11次，服务器告诉客户端：发送的6k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了4k，窗口大小是4k</li><li>第12次，客户端又给服务器发送了1k的数据</li><li>第13次，客户端主动请求和服务器断开连接，并且给服务器发送了1k的数据   ^fyk6mo</li><li>第14次，服务器回复ack 8194 ，win 2048<ol><li>同意断开连接的请求+告诉客户端己经接受到方才发的2k的数据<ol><li>ack = seq + 数据量 + FIN(1个字节)<ol><li>上次是7169(1024)，多一个字节是因为对FIN的确认</li></ol></li><li>客户端发送FIN也是可以携带数据的，因为此时还处于互相连接的状态</li></ol></li><li>滑动窗口2k</li></ol></li><li>第15、16次，通知客户端滑动窗口的大小</li><li>第17次，第三次挥手，服务器端给客户端发送 TN,请求断开连接</li><li>第18次，第四次回收，客户端同意了服务器端的断开请求</li></ol><hr><p><strong>其他资料</strong></p><!-- basicblock-start --> <p>#历史记录::<br>2022/10/20🌵滑动窗口 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.分割回文串</title>
      <link href="/posts/15279/"/>
      <url>/posts/15279/</url>
      
        <content type="html"><![CDATA[<h1 id="1-131分割回文串"><a class="markdownIt-Anchor" href="#1-131分割回文串"></a> 1 131.分割回文串</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目链接</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例: 输入:&nbsp;<span class="hljs-string">"aab"</span> 输出: [ [<span class="hljs-string">"aa"</span>,<span class="hljs-string">"b"</span>], [<span class="hljs-string">"a"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>] ]<br></code></pre></td></tr></tbody></table></figure><p><strong>"回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</strong><br>1. 顾名思义，“回文子串”的意思是一个字符串中的回文串，比如字符串“baba”中t就包含有“bab”和“aba”这两个回文子串<br>2. <strong>单个字母也是回文串</strong></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题这涉及到两个关键问题：</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p><strong>其实切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…。</li></ul><p>所以切割问题，也可以抽象为一棵树形结构，如图：<br>![[9.分割回文串 2022-05-20 11.47.01.excalidraw]]<br>切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><p>定义一些变量<br>path，result</p><h2 id="31-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#31-确定回溯函数参数返回值void"></a> 3.1 确定回溯函数参数返回值(void)</h2><p>startIndex：保证下一层for循环的起始位置，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。<br>这个startIndex就是切割线。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br>vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><p>![[Pasted image 20220520092428.png|1000]]</p><h2 id="32-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#32-终止条件-存放结果-return"></a> 3.2 终止条件, 存放结果, return</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。<br>如果起始位置已经大于s的大小，说明已经找到了一组分割方案了<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> startIndex)</span> {<br>    <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了，💡横向遍历完了</span><br>    <span class="hljs-keyword">if</span> (startIndex &gt;= s.size()) {<br>        result.push_back(path);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h2 id="33-单层搜索过程"><a class="markdownIt-Anchor" href="#33-单层搜索过程"></a> 3.3 单层搜索过程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">截取子串<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.size(); i++)`，我们定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。<br>判断子串是否为回文串： (用一个函数)<br>用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。这里是无所谓顺序的，只要满足条件就跳出函数，否则一直<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br>将回文串加入path<br><span class="hljs-built_in">string</span> str = s.substr(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.push_back(str);<br>递归下去<br>backtracking(s, i + <span class="hljs-number">1</span>); <br>注意切割过的位置，不能重复切割，所以，传入下一层的起始位置为i + <span class="hljs-number">1</span>。<br>弹出回溯<br>path.pop_back(); <span class="hljs-comment">// 回溯过程，弹出本次已经填在的子串</span><br><br></code></pre></td></tr></tbody></table></figure><h2 id="34-c整体代码"><a class="markdownIt-Anchor" href="#34-c整体代码"></a> 3.4 C++整体代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) {   <span class="hljs-comment">// 是回文子串</span><br>                <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>                string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            } <span class="hljs-keyword">else</span> {                                <span class="hljs-comment">// 不是回文，跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯过程，弹出本次已经填在的子串</span><br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[9.分割回文串.自写代码]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsLaWYYJ2RF5oMy6ebwp0wc"--> <p>#历史记录::<br>2022/9/30🌵9.分割回文串 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.组合总和II</title>
      <link href="/posts/21516/"/>
      <url>/posts/21516/</url>
      
        <content type="html"><![CDATA[<h1 id="1-40组合总和ii"><a class="markdownIt-Anchor" href="#1-40组合总和ii"></a> 1 40.组合总和II</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">力扣题目链接</a></p><p>给定一个数组&nbsp;candidates&nbsp;和一个目标数&nbsp;target&nbsp;，找出&nbsp;candidates&nbsp;中所有可以使数字和为&nbsp;target&nbsp;的组合。</p><p>candidates&nbsp;中的每个数字在每个组合中只能使用一次。</p><p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p><p>示例&nbsp;1: 输入: candidates =&nbsp;[10,1,2,7,6,1,5], target =&nbsp;8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p><p>示例&nbsp;2: 输入: candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5, 所求解集为: [ &nbsp; [1,2,2], &nbsp; [5] ]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="Obs8smtYwS0kltN4pmhaNvPe" --> <p>回溯算法去重问题::</p><p>与[[7.组合总和]]区别是：不能重复的使用元素<br>最后也要不能有重复的组合<br><strong>树层去重的话，需要对数组排序！</strong><br><strong>所谓去重，其实就是使用过的元素不能重复选取，使用过”在这个树形结构上是有两个维度的</strong><br>1.  同一树枝上使用过<br>2. 同一<strong>树层</strong>上使用过</p><p>我们要<strong>去重的是同一树层上的<font color="#F36208">使用过</font></strong>，同一树枝上的都是一个组合里的元素(path中的元素)，不用去重。<br>示例&nbsp;1: 输入: candidates =&nbsp;[10,1,2,7,6,1,5], target =&nbsp;8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]<br>![[8.组合总和II 2022-05-19 09.46.46.excalidraw]]</p><!-- basicblock-end --><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><p>定义一些变量<br>bool型数组used，用来记录同一树枝上的元素是否使用过。(去重的关键)<br>可直接放到backtracking中去</p><h2 id="31-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#31-确定回溯函数参数返回值void"></a> 3.1 确定回溯函数参数返回值(void)</h2><p>startIndex和sum都是局部变量</p><h2 id="32-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#32-终止条件-存放结果-return"></a> 3.2 终止条件, 存放结果, return</h2><p>终止条件：path路径和 = 目标和 (sum == target)</p><h2 id="33-单层搜索过程"><a class="markdownIt-Anchor" href="#33-单层搜索过程"></a> 3.3 单层搜索过程</h2><p>[[组合问题模板]]<br>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>处理节点;<br>把元素加进去：path.push_back(×);<br>backtracking(路径，选择列表); // 递归<br>i++：本身就控制了递归到下一层，[[startIndex]]是用来控制下一层开始的起始位置<br>回溯，撤销处理结果<br>path.pop();<br>}<br>去重：要去重的是“同一树层上的使用过”，要先判断同一树层上元素（相同的元素）是否使用过<br>![[8.组合总和II 2022-05-19 09.59.27.excalidraw]]<br>used用来记录数字在本层的位置<br>**如果<code>candidates[i] == candidates[i - 1]</code> <font color="#F36208">(现在的数=前一个数)</font>，<br>并且 <code>used[i - 1] == false</code><font color="#F36208">(在本层的位置不同)</font>，<br>就说明：在本层中两个数是相同的，但是位置不同的，就去重<br>used[i - 1] == false，说明同一树层candidates[i - 1]使用过<br><font color="#F36208">used[i - 1] ：表示的是前一个字符和现在的字符不一样</font><br>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</p><p>for循环里应该做continue的操作，等到破坏条件在退出</p><p>[[8.组合总和II.自写]]</p><h1 id="4-代码"><a class="markdownIt-Anchor" href="#4-代码"></a> 4 代码</h1><p>v1, 编译已通过，2022年05月19日</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>{<span class="hljs-comment">// used数组用vector&lt;bool&gt;</span><br>        <span class="hljs-keyword">if</span>(sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){    <br>        <span class="hljs-comment">// 必须要有i &gt; 0, 因为要从第二个下标才可以比较</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>){<span class="hljs-comment">// 剪枝放到for循环中去，注意是usd[i-1] 不可=false ，这里是赋值，要用==</span><br>                <span class="hljs-keyword">continue</span>;<br>            }   <br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i+<span class="hljs-number">1</span>, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            sum -= candidates[i];<br>            used[i] = <span class="hljs-literal">false</span>;<br><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// ❓必须有，不知道为什么放到上边为什么不行</span><br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//  首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  used);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过 只用 startIndex 来给树层去重:&nbsp;⏱1-0</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtacking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum +  candidates[i] &lt;= target; i++){<br>            <span class="hljs-comment">// 💡要对同一树层使用过的元素进行去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtacking</span>(candidates, target, sum+candidates[i], i+<span class="hljs-number">1</span>);<span class="hljs-comment">// ❗️和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br><br><br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtacking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obssn8rRIikeW5Mxy9vXZl1r" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::8.组合总和II.md" --> <p>#历史记录::<br>2022/9/29🌵8.组合总和II : v2通过 只用 startIndex 来给树层去重:&nbsp;⏱1-0</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手</title>
      <link href="/posts/7923/"/>
      <url>/posts/7923/</url>
      
        <content type="html"><![CDATA[<p>三次握手的目的是保证双方互相之间建立了连接<br>三次握手发生在客户端连接的时候，当调用connect()函数时，底层会通过TCP协议进行三次握手。</p><p>seq：序号<br>ACK：标志位<br>ack(AcK)：确认序号，只有当 ACK=1 时确认序号才有用<br>TCP是用字节流传输，会为每个字节分配一个序号</p><h1 id="1-三次握手"><a class="markdownIt-Anchor" href="#1-三次握手"></a> 1 三次握手</h1><p>时序图<br><img src="https://s1.vika.cn/space/2022/05/26/9e8848db48ec40d2a865d364ed1dfe16" alt=""></p><p>牛客总结<br>第一次握手：<br>1.客户端将SYN标志位置为1，向服务端请求建立连接，<br>2.生成一个随机(<font color="#F36208">其实是有固定算法的</font>)的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>1.服务端将<font color="#F36208">标志位</font><font color="#F36208">ACK</font>置为1，接收客户端的连接。<br>并且回发一个确认序号：ack=客户端的序号 +  数据长度+ SYN/FIN（按一个字节算）<br>2.服务器端会向客户端发起连接请求：SYN=1<br>3.服务器会生成一个随机序号(<font color="#F36208">其实是有固定算法的</font>)：seq = K<br>第三次握手：<br>1.客户单应答服务器的连接请求：ACK=1<br>2.客户端回复收到了服务器端的数据：ack=服务端的序号 +数据长度 + SYN/FIN（按一个字节算）<br>自己总结<br><font color="#F36208">第一次握手：客户端发起连接</font><br>1.客户端将标志位SYN置位1，表示向服务端请求连接。2.并且根据算法生成一个客户端序号cseq：J<br><font color="#F36208">第二次握手：服务端回复请求，发起连接</font><br>1.服务端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 客户端的序号(J) + 数据字节个数 + SYN/FIN(算一个字节)<br>3.服务端将标志位SYN置位1，表示向客户端请求连接。4.并且根据算法生成一个服务端序号sseq：K<br><font color="#F36208">第三次握手：客户端回复请求</font><br>1.客户端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 服务端的序号(K) + 数据字节个数 + SYN/FIN(算一个字节)</p><p>第一次握手(客户端→服务端)：客户端请求连接<br>客户端与服务端还没有建立连接，不能发数据<br>第二次握手(客户端←服务端)：服务端同意连接+请求与客户端连接<br>第三次握手(客户端→服务端)：客户端同意连接<br>此时客户端已经和服务端已经建立了连接，这次客户端的握手已经可以携带数据了<br>之后服务端与客户端都互相建立了连接，可以互相自由通信</p><h2 id="11-三次握手实例"><a class="markdownIt-Anchor" href="#11-三次握手实例"></a> 1.1 三次握手实例</h2><p><img src="https://s1.vika.cn/space/2022/05/26/e1cbc619a8b445c5a3cb9282c0d21c21" alt=""></p><h2 id="12-为什么不能两次握手"><a class="markdownIt-Anchor" href="#12-为什么不能两次握手"></a> 1.2 为什么不能两次握手</h2><p>因为要确保客户端能<font color="#C32E94">收发</font>消息，服务端能<font color="#C32E94">收发</font>消息，3次握手正好少一次都不行<br><img src="https://s1.vika.cn/space/2022/05/26/7f7c22713cf345368d2778005723b9b1" alt=""></p><p>四次握手也是可以的，服务端的ACK和SYN连在一起发了，拆开发就是四次握手<br>保证可靠连接的最小次数是三次握手</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsmWEKtCEW64t5rDlMr9yns" --> <p>#历史记录::<br>2022/10/20🌵TCP三次握手 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>startIndex</title>
      <link href="/posts/64148/"/>
      <url>/posts/64148/</url>
      
        <content type="html"><![CDATA[<p>来控制for循环的起始位置::<br>如果是用一个集合来求组合就用startIndex: [[2.组合问题|2.组合问题]]<br>如果是多个集合取组合，各个集合之间相互不影响就可以吧不用startIndex: [[5.电话号码的字母组合|5.电话号码的字母组合]]<br><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍</strong>。</p><!-- basicblock-end --><p>i++：本身就控制了递归到下一层，startIndex是用来控制下一层开始的起始位置</p><p>startIndex是可以自定义从第几个位置开始的，eg：startIndex = 1就是从下一层的[1]位置开始<br>for循环中 i 从下一个时，因为:i++, i 就天生比startIndex大1了</p><p>[[8.组合总和II]]<br>for循环汇总 i 从下一个时，i 就天生比startIndex大1了<br>可以用[[startIndex]]来去重，就不用used数组了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 此时的i比startIndex大1，因为for循环中i++了，此时startIndex还未加1，所以</span><br><span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>排列问题不用startIndex</p><p>![[11. 子集问题#^isql7c]]</p><p>在同一的树层上去重：<br>![[13.子集II#^3c5r8l]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsMfnz8IFr85iZgPSBe7Ro5"  --> <p>#历史记录::<br>2022/9/29🌵startIndex :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.组合总和</title>
      <link href="/posts/2470/"/>
      <url>/posts/2470/</url>
      
        <content type="html"><![CDATA[<h1 id="1-题目描述"><a class="markdownIt-Anchor" href="#1-题目描述"></a> 1 题目描述</h1><p>向一个集合中找出和为n的组合，所有的数字都可以被重复选取<br>示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</p><!-- basicblock-start oid="Obs9dRGMbbJuMyOi26UHtHvK" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>![[7.组合总和 2022-09-29 10.20.32.excalidraw]]<br>sum等于target的时候，需要收集结果，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum &gt; target) { <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) {<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 不用i+1了，表示可以重复读取当前的数</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>剪枝优化：<br>![[7.组合总和 2022-09-29 10.52.49.excalidraw]]<br>for循环剪枝代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)<br></code></pre></td></tr></tbody></table></figure><h2 id="21-回溯三部曲"><a class="markdownIt-Anchor" href="#21-回溯三部曲"></a> 2.1 回溯三部曲</h2><p>定义一些变量<br>path<br>result<br>[[startIndex]]::</p><h3 id="211-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#211-确定回溯函数参数返回值void"></a> 2.1.1 确定回溯函数参数返回值(void)</h3><p>candidates：目标和<br>sum：用来和target对比，等于目标和就可以终止<br>startIndex：来控制for循环的起始位置</p><h3 id="212-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#212-终止条件-存放结果-return"></a> 2.1.2 终止条件, 存放结果, return</h3><p>sum=目标和就可以终止</p><h3 id="213-单层搜索过程"><a class="markdownIt-Anchor" href="#213-单层搜索过程"></a> 2.1.3 单层搜索过程</h3><!-- basicblock-start oid="ObsHuryuOlHk6rmYpKeO4HHM" --> <p>如何重复选取元素呢，看代码，注释部分::<br>必须得有 startIndex, 不能没有, startIndex 控制着回溯的下一层的起始位置, 如果没有的话, 那都没法回溯了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) {<br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span><br>    sum -= candidates[i];   <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>从startIndex开始，搜索sum = 目标和的path集合<br><strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 2022年05月18日，编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span> (sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){ <span class="hljs-comment">// ❗️注意这里的剪枝，自己写错了不是单纯的sum &lt;= traget；数组长度也可以.szie()</span><br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            <span class="hljs-built_in">backtracking</span>(candidates,  target,  sum, i);<span class="hljs-comment">// startIndex是用来控制下一层的起始位置的</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br> <br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过: 看注释: ⏱0-54</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>: <br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtraking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 把一个符合结果的返回, return 之后, 就开始执行 pop_back 了, 所以又会找下一个递归的元素</span><br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtraking</span>(candidates, target, sum + candidates[i], i);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtraking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs0sw6w0p8tQRyHhfUIoTar"  --> <p>#历史记录::<br>2022/9/29🌵7.组合总和 : v2通过: 看注释: ⏱0-54</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.电话号码的字母组合</title>
      <link href="/posts/48297/"/>
      <url>/posts/48297/</url>
      
        <content type="html"><![CDATA[<h1 id="1-17电话号码的字母组合"><a class="markdownIt-Anchor" href="#1-17电话号码的字母组合"></a> 1 17.电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合"></p><p>示例: 输入：“23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObsEHJO9qGFMW9sUT95OY1GJ" --> <h2 id="21-数字和字母如何映射"><a class="markdownIt-Anchor" href="#21-数字和字母如何映射"></a> 2.1 数字和字母如何映射::</h2><p>可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = {<br>    <span class="hljs-string">""</span>, <span class="hljs-comment">// 0</span><br>    <span class="hljs-string">""</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-string">"abc"</span>, <span class="hljs-comment">// 2</span><br>    <span class="hljs-string">"def"</span>, <span class="hljs-comment">// 3</span><br>    <span class="hljs-string">"ghi"</span>, <span class="hljs-comment">// 4</span><br>    <span class="hljs-string">"jkl"</span>, <span class="hljs-comment">// 5</span><br>    <span class="hljs-string">"mno"</span>, <span class="hljs-comment">// 6</span><br>    <span class="hljs-string">"pqrs"</span>,<span class="hljs-comment">// 7</span><br>    <span class="hljs-string">"tuv"</span>, <span class="hljs-comment">// 8</span><br>    <span class="hljs-string">"wxyz"</span>,<span class="hljs-comment">// 9</span><br>};<span class="hljs-comment">// const 变量 后面要加；</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h2 id="22"><a class="markdownIt-Anchor" href="#22"></a> 2.2</h2><p>![[5.电话号码的字母组合 2022-09-28 22.02.52.excalidraw]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><p>存放结果的：s(类似path)，result<br>类型是string</p><h2 id="31-确定回溯函数参数"><a class="markdownIt-Anchor" href="#31-确定回溯函数参数"></a> 3.1 确定回溯函数参数</h2><p>string digits：题目给的 <code>vector&lt;string&gt; letterCombinations(string digits)</code><br>传入的数字，eg：”2,3“，这里不是int型的，而是数字字符串<br>digits：<br>int index： 用来遍历digits的，记录遍历到第几个数字了，在递归函数中起到深度的作用<br>不是[[2.组合问题]]中的startIndex(用来控制下一层递归的起始位置)</p><h2 id="32-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#32-终止条件-存放结果-return"></a> 3.2 终止条件, 存放结果, return</h2><p>如果index 等于 输入的数字个数（digits.size）了，然后收集结果，结束本层递归。</p><h2 id="33-单层搜索过程"><a class="markdownIt-Anchor" href="#33-单层搜索过程"></a> 3.3 单层搜索过程</h2><p>将index指向的数字转为int，用来找到字符集中对应的字母</p><p>用for循环处理这个字符集<br>目标：取出字母，根据字母个数开始遍历宽度，eg：“abc”，宽度为3(<font color="#F36208">letter.size()</font>)·<br>1. 取出string digits的数字，2. 然后对应letterMap中的字母<br>所有数字型的字符减去字符‘0’，将会得到该字符的绝对值，是一个整数。<br>eg：digits=”<mark>2</mark>3“；digits[0] - ‘0’ = <mark>2</mark>；digits[1] - ‘0’ = 3<br>第几个位置是数字几，最后得出的结果就是几</p><ul><li><p>[x] for循环不是出不去了吗 #疑问 ✅ 2022-05-18</p><ul><li>例如“ad”，到了if终止条件检测(index == digits.size()) 就return了</li></ul><p>下次记得提前监听一下设置全局变量(s，result)</p></li></ul><h1 id="4-代码"><a class="markdownIt-Anchor" href="#4-代码"></a> 4 代码</h1><p>v1, 复习了一遍之前的代码, 没自己写一遍⏱0-38</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    string s;<br>    vector&lt;string&gt; result;<br>    <span class="hljs-type">int</span> index;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = {<br>        <span class="hljs-string">""</span>, <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">""</span>, <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">"abc"</span>, <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">"def"</span>, <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">"ghi"</span>, <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">"jkl"</span>, <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">"mno"</span>, <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">"pqrs"</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">"tuv"</span>, <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">"wxyz"</span>, <span class="hljs-comment">// 9</span><br>    };<span class="hljs-comment">// const 变量 后面要加；</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(string digits, <span class="hljs-type">int</span> k)</span></span>{ <span class="hljs-comment">// 我觉得可以不用const string&amp;</span><br>        <span class="hljs-comment">// ❗️要把终止条件放到回溯函数中去,放到外边编译不通过</span><br>        <span class="hljs-keyword">if</span> ( digits.<span class="hljs-built_in">size</span>() == k){<br>        result.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>        <span class="hljs-type">int</span> digit = digits[k] - <span class="hljs-string">'0'</span>;<span class="hljs-comment">// 取digits的一个数字</span><br>        string letter = letterMap[digit];<span class="hljs-comment">// 取出字母</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letter.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// i不能等于1，这样漏了起始位置0</span><br>            s.<span class="hljs-built_in">push_back</span>(letter[i]);<span class="hljs-comment">// 不是i，要添加s里的是字母</span><br>            <span class="hljs-built_in">backtracking</span>(digits, k + <span class="hljs-number">1</span>);<span class="hljs-comment">// index + 1控制深度</span><br>            s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// pop_back中不需要参数i，自动弹出的是第一个字母</span><br>        }<br>    }<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>{<br>        s.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>){<br>            <span class="hljs-keyword">return</span> result;<span class="hljs-comment">// 不能单独return，return的结果应当和返回值类型一样</span><br>        }<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码随想录的代码</p><p>[[自写代码]]</p><h1 id="5-周末总结"><a class="markdownIt-Anchor" href="#5-周末总结"></a> 5 周末总结</h1><p><strong>本题每一个数字代表的是不同集合，也就是求不同集合之间的组合</strong><br>[[2.组合问题]]，[[4.组合总和III]]，是求同一集合中组合</p><ul><li>[ ] 输入1 * # 按键等等异常情况，现在还没有弄</li></ul><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsJDI4SNWRXaFoJ7rGKbf0b" --> <p>#历史记录::<br>2022/9/28🌵5.电话号码的字母组合 : v1, 复习了一遍之前的代码, 没自己写一遍⏱0-38</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法剪枝</title>
      <link href="/posts/3235/"/>
      <url>/posts/3235/</url>
      
        <content type="html"><![CDATA[<h1 id="1-对-for-循环的范围去重"><a class="markdownIt-Anchor" href="#1-对-for-循环的范围去重"></a> 1 对 for 循环的范围去重</h1><p>含起始位置和终止位置</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){ <br></code></pre></td></tr></tbody></table></figure><p>[[2.组合问题]]</p><p>[[8.组合总和II]]<br>[[4.组合总和III]]</p><h1 id="2-对树层去重"><a class="markdownIt-Anchor" href="#2-对树层去重"></a> 2 对树层去重</h1><h2 id="21-8组合总和ii"><a class="markdownIt-Anchor" href="#21-8组合总和ii"></a> 2.1 [[8.组合总和II]]</h2><p>💡要对同一树层使用过的元素进行去重</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum +  candidates[i] &lt;= target; i++){<br>    <span class="hljs-comment">// 💡要对同一树层使用过的元素进行去重</span><br>    <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) {<br>        <span class="hljs-keyword">continue</span>;<br>    }<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-built_in">backtacking</span>(candidates, target, sum+candidates[i], i+<span class="hljs-number">1</span>);<span class="hljs-comment">// ❗️和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>    path.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></tbody></table></figure><h1 id="3-对树枝去重"><a class="markdownIt-Anchor" href="#3-对树枝去重"></a> 3 对树枝去重</h1><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsboIJGZMEqUKtpvDngZCIL" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::剪枝.md" --> <p>#历史记录::<br>2022/9/28🌵剪枝 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.组合总和III</title>
      <link href="/posts/62353/"/>
      <url>/posts/62353/</url>
      
        <content type="html"><![CDATA[<h1 id="1-216组合总和iii"><a class="markdownIt-Anchor" href="#1-216组合总和iii"></a> 1 216.组合总和III</h1><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接</a></p><p>找出所有相加之和为&nbsp;n 的&nbsp;k&nbsp;个数的组合。组合中只允许含有 1 -&nbsp;9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>: 输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span> 输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]]<br><br>示例 <span class="hljs-number">2</span>: 输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">9</span> 输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>eg:<br>在[1,2,3,4,5,6,7,8,9]这个集合中找到<strong>和为n</strong>的<strong>k个数</strong>的组合。<br>输入: n = 4 ，k = 2输出: [ [1,3] ]</p><p>![[4.组合总和III 2022-09-28 16.56.44.excalidraw]]</p><h2 id="21-确定递归函数参数"><a class="markdownIt-Anchor" href="#21-确定递归函数参数"></a> 2.1 确定递归函数参数</h2><p>n：目标和<br>k：要的个数<br>startIndex：下一层for循环搜素的起始位置<br>sum：path中的和，用来和n来比较</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span><br></code></pre></td></tr></tbody></table></figure><p>其实这里sum这个参数也可以省略，每次targetSum减去选取的元素数值，然后判断如果targetSum为0了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个sum参数。</p><ul><li>$ 还要强调一下，回溯法中递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</li></ul><h2 id="22-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#22-终止条件-存放结果-return"></a> 2.2 终止条件, 存放结果, return</h2><p>k限制了深度，在往下就没有意义了：path.size() 和 k相等了，就终止。<br>如果path中的和与目标和相等就放入结果result中</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (path.size() == k) {<br>    <span class="hljs-keyword">if</span> (sum == targetSum) result.push_back(path);<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 就直接返回</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="23-单层搜索过程"><a class="markdownIt-Anchor" href="#23-单层搜索过程"></a> 2.3 单层搜索过程</h2><p><strong>别忘了处理节点 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong><br>集合固定的就是9个数[1,…,9]，所以for循环固定i&lt;=9<br>处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>; i++) {<br>    sum += i;<br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// i+1调整startIndex，让递归到下一层</span><br>    sum -= i; <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p><ul><li>path中的和大于4就没有意义了：sum &gt; 4</li><li>剪枝的代码，可以把for循环，加上 <code>i &lt;= 9 - (k - path.size()) + 1</code> 的限制！<ul><li>对for循环选择的起始范围的剪枝。</li></ul></li></ul><p>[[回溯算法剪枝]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 还行吧⏱0-28</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span></span>{<br>        <span class="hljs-keyword">if</span>(sum &gt; n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝 </span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k){<br>            <span class="hljs-keyword">if</span>(sum == n){<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++){ <span class="hljs-comment">// ❗️不要忘记=号</span><br>            <span class="hljs-comment">//sum += i;</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n, k , i+<span class="hljs-number">1</span>, sum + i); <span class="hljs-comment">// 💡sum + i 直接传进这里跟注释的效果一样</span><br>            <span class="hljs-comment">//sum -= i;</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br><br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) {<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k ){<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// ❗️n==0,不能联立放到第一个 if 判断语句中</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++){<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(k, n-i, i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) {<br>        <span class="hljs-built_in">backtracking</span>(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsxQ9tpdYBmzWTfp6cxBGdG" --> <p>#历史记录::<br>2022/9/28🌵4.组合总和III : v1, 还行吧⏱0-28</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法模板</title>
      <link href="/posts/13212/"/>
      <url>/posts/13212/</url>
      
        <content type="html"><![CDATA[<h1 id="1-回溯三部曲"><a class="markdownIt-Anchor" href="#1-回溯三部曲"></a> 1 回溯三部曲::</h1><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>startIndex：控制下一层的起始位置<br>去重(从下一层的第一个位置开始：<span class="hljs-built_in">backtracking</span>(...., i+<span class="hljs-number">1</span>))<br>排列问题不用startIndex<br>used[]：去重(从下一层的起始位置开始：<span class="hljs-built_in">backtracking</span>(...., <span class="hljs-number">0</span>))<br><span class="hljs-keyword">if</span> (终止条件) {<br>存放结果;<br><span class="hljs-keyword">return</span>;<br>要取树上所有节点时不要加<span class="hljs-keyword">return</span><br>}<br><br><br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>定义一些变量</p><h2 id="11-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#11-确定回溯函数参数返回值void"></a> 1.1 确定回溯函数参数返回值(void)</h2><h2 id="12-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#12-终止条件-存放结果-return"></a> 1.2 终止条件, 存放结果, return</h2><h2 id="13-单层搜索过程"><a class="markdownIt-Anchor" href="#13-单层搜索过程"></a> 1.3 单层搜索过程</h2><!-- basicblock-start oid="ObsaodmKESNMsc0sTNNBqc8G" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::回溯算法模板.md" --> <p>#历史记录::<br>2022/9/28🌵回溯算法模板.md</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.组合优化</title>
      <link href="/posts/50548/"/>
      <url>/posts/50548/</url>
      
        <content type="html"><![CDATA[<p>[[2.组合问题]]<br><a href="https://leetcode.cn/problems/combinations/submissions/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-start oid="ObsYz3UogGu35JEfq6xUEeLw" --> <h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1 思路::</h1><!-- basicblock-end --><p>![[3.组合优化 2022-09-28 16.11.10.excalidraw]]</p><!-- basicblock-start oid="ObsDbgREId29fWXbspKsmegB" --> <p><strong>剪枝精髓是::</strong></p><p>for循环时候要有一个范围，如果不满足这个范围, 就没有必要搜索了。<br>注意代码中i，就是for循环里选择的起始位置。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++)<br></code></pre></td></tr></tbody></table></figure><p>startIndex是起始位置, n是遍历的终止位置，<br><strong>范围就是[startIndex, n]</strong><br>控制 n 的值就是剪枝</p><!-- basicblock-end --><h2 id="11-举例"><a class="markdownIt-Anchor" href="#11-举例"></a> 1.1 举例</h2><p>n = 4, k = 4：要[1,2,3,4]这种</p><ol><li>已经添加到path(单一数组如[1,2])的个数为：path.size()</li><li>还需要的元素个数：k - path.size()</li><li>终止位置为：<strong>n -  (k - path.size()) + 1</strong> <mark>(总共的元素个数 - 还需要的元素个数 + 1)</mark><ul><li>? 为什么+1: ✅ 是因为要包括起始位置，总体是左闭的区间</li><li>&amp; eg：目前添加path中的元素个数为0，4 - (4 - 0) + 1 = 1 (跟图上一样，最多遍历1个就终止)</li></ul></li></ol><!-- basicblock-start oid="ObsfO9QzrwMZnvqABHlyNk8y" --> <h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码::</h1><!-- basicblock-end --><p>v1, 有点懵吧,还好 ⏱0-37</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 跳出 if 循环</span><br>         }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span> ; i++){ <span class="hljs-comment">// 💡在这里剪枝</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n, k, i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) {<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsGT1INYurrpkRdg7gy9Lhd" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::3.组合优化.md" --> <p>#历史记录::<br>2022/9/28🌵3.组合优化.md:  v1, 有点懵吧,还好 ⏱0-37</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0. 回溯算法集合</title>
      <link href="/posts/18033/"/>
      <url>/posts/18033/</url>
      
        <content type="html"><![CDATA[<p>[[1.回溯算法理论基础]]</p><p>[[2.组合问题]]</p><p>[[3.组合优化]]</p><p>[[4.组合总和III]]</p><p>[[5.电话号码的字母组合]]</p><p>[[6.回溯周末总结]]</p><p>[[7.组合总和]]</p><p>[[8.组合总和II]]</p><p>[[9.分割回文串]]</p><p>[[10.复制IP地址]]</p><p>[[11.子集问题]]</p><p>[[12.回溯周末总结]]</p><p>[[13.子集 II]]</p><p>[[14.递增子序列]]</p><p>[[15.全排列]]</p><p>[[16.全排列II]]</p><p>[[17.回溯算法总结]]</p><p>[[18.回溯算法去重问题的另一种写法]]</p><p>[[19.重新安排行程]]</p><p>[[20.N皇后]]</p><p>[[21.解数独]]</p><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsm4FhsEgOmu97u2rp8JMVZ" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::0. 回溯算法集合.md" --> <p>#历史记录::<br>2022/9/28🌵0. 回溯算法集合 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.组合问题</title>
      <link href="/posts/61446/"/>
      <url>/posts/61446/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第77题-组合"><a class="markdownIt-Anchor" href="#1-第77题-组合"></a> 1 第77题. 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例:  <br>输入:&nbsp;n = <span class="hljs-number">4</span>, k = <span class="hljs-number">2</span>  <br>输出:  <br><br>[  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],  <br>]<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>[[回溯法能解决n层for循环的问题]]</p><p>![[2.组合问题 2022-09-28 15.32.18.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过, 算是抄一遍⏱0-46</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++){<span class="hljs-comment">// ❗️ i 是 &lt;= n, ❗️startIndex这里不是下标的意思 </span><br>            path.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">// 加入本层的第一个数</span><br>            <span class="hljs-comment">// 到下一层， 随后又会加入本层的第一个数</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i+<span class="hljs-number">1</span>);<span class="hljs-comment">// k 控制着递归的层数, ❗️不是startindex+1, 而是 i+1, i 控制着 startIndex</span><br>            <span class="hljs-comment">// 弹出上一层加入的数</span><br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// ❗️vector 是 pop_back()</span><br><br>        }<br><br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) {<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[回溯算法模板]]</p><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsmV74o0U0NglfPn3zHTM24"  --> <p>#历史记录::<br>2022/9/28🌵 <a href="http://2.xn--8pr770hlso7nc.md">2.组合问题.md</a>: v1, 通过, 算是抄一遍⏱0-46</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.回溯算法理论基础</title>
      <link href="/posts/25363/"/>
      <url>/posts/25363/</url>
      
        <content type="html"><![CDATA[<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>：<mark>组合无序，排列有序</mark><br>{1, 2} 和 {2, 1}：组合是一样的，排列是不一样的</p><!-- basicblock-start oid="ObsrusxrXf0Y469dKCkR51pZ" --> <h1 id="1-回溯法能解决的问题"><a class="markdownIt-Anchor" href="#1-回溯法能解决的问题"></a> 1 回溯法能解决的问题::</h1><!-- basicblock-end --><ul><li>组合问题：N个数里面按一定规则找出k个数的集合<ul><li>[[2.组合问题]] [[4.组合总和III]] [[5.电话号码的字母组合]]</li></ul></li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li><li>$ [[回溯法能解决n层for循环的问题]]</li></ul><!-- basicblock-start oid="ObsZIjQjSB3eor68dkSy1eOI" --> <h1 id="2-如何理解回溯法"><a class="markdownIt-Anchor" href="#2-如何理解回溯法"></a> 2 如何理解回溯法::</h1><!-- basicblock-end --><ul><li>$ 回溯法解决的问题都可以抽象为树形结构（N叉树）<br><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</li></ul><p>如果把子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。<br>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><h2 id="31-回溯函数模板返回值以及参数"><a class="markdownIt-Anchor" href="#31-回溯函数模板返回值以及参数"></a> 3.1 回溯函数模板返回值以及参数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></tbody></table></figure><p>返回值一般为void。<br>参数:  因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><h2 id="32-回溯函数终止条件"><a class="markdownIt-Anchor" href="#32-回溯函数终止条件"></a> 3.2 回溯函数终止条件</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (终止条件) {<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 结束本轮递归开始回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>终止条件：一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><h2 id="33-回溯搜索的遍历过程"><a class="markdownIt-Anchor" href="#33-回溯搜索的遍历过程"></a> 3.3 回溯搜索的遍历过程</h2><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。<br>![[回溯算法过程.excalidraw|900]]</p><p>回溯函数遍历过程伪代码如下：<br><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>    处理节点;<br>    <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>回溯算法模板框架</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 结束本轮递归开始回溯</span><br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsY0FqZyXLZ0e7IoC61Et8q"  --> <p>#历史记录::<br>2022/9/28🌵1.回溯算法理论基础.md: 第一次创建: ⏱0-26</p><!-- basicblock-end --> ]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 回溯算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP通信代码案例</title>
      <link href="/posts/12103/"/>
      <url>/posts/12103/</url>
      
        <content type="html"><![CDATA[<h1 id="1-服务器端通信"><a class="markdownIt-Anchor" href="#1-服务器端通信"></a> 1 服务器端通信</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// TCP 通信的服务器端</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.创建socket(用于监听的套接字)</span><br>    <span class="hljs-type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 2.绑定</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><span class="hljs-comment">// 用sockaddr比较麻烦，sockaddrin是模块化成员的比较好用</span><br>    <span class="hljs-comment">//对成员赋值</span><br>    saddr.sin_family = AF_INET;<br>    <span class="hljs-comment">// inet_pton(AF_INET, "192.168.193.128", saddr.sin_addr.s_addr);// //将网络字节序的整数,转换成点分十进制的IP地址字符串</span><br>    serverad<br>    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="hljs-comment">//这个是可连接的IP地址， 0.0.0.0，定义的这个宏INADDR_ANY就是0，因为只有服务端可以这样写，表示谁的都可以连接</span><br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<span class="hljs-comment">// 主机会随机分配一个端口号，如果只写9999是不对的，因为这是主机字节序，要用网络字节序用到htons函数。</span><br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr)); <span class="hljs-comment">// 转换sockaddr类型指针</span><br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"bind"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 3.监听</span><br>    ret = listen(lfd, <span class="hljs-number">8</span>);<span class="hljs-comment">// 给个8足够了</span><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"listen"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<span class="hljs-comment">// exit(0)也可</span><br>    }<br><br>    <span class="hljs-comment">// 4.接收客户端连接</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientaddr</span>;</span><span class="hljs-comment">// 定义客户端的地址信息</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(clientaddr);<span class="hljs-comment">// sizeof的返回值是int 不能用socklen_t，但len的类型应该给是socklen_t的，为了编译通过这样改了，可以强转socklen_t</span><br>    <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;len); <span class="hljs-comment">// accpet函数如果没有客户端连接会阻塞在这里</span><br>    <br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"accept"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 输出客户端的信息</span><br>    <span class="hljs-type">char</span> clientIP[<span class="hljs-number">16</span>];<span class="hljs-comment">// 点分十进制，每个.前是3个字节也就是12个字节，又有三个”.“和最后的结束符，所以定义16</span><br>    inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="hljs-keyword">sizeof</span>(clientIP));<span class="hljs-comment">// 将网络字节序的整数,转换成点分十进制的IP地址字符串(因为接受的网络字节序)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> clientPort = ntohs(clientaddr.sin_port);<span class="hljs-comment">// 获取端口+转换主机字节序的short    </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client ip is %s, port is %d\n"</span>, clientIP, clientPort);<br><br>    <span class="hljs-comment">// 5.通信</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <br>        <span class="hljs-comment">// 获取客户端的数据</span><br>        <span class="hljs-type">int</span> num = read(cfd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<span class="hljs-comment">// read函数：如果客户端没有发来数据会阻塞在这里</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv client data : %s\n"</span>, recvBuf);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 表示客户端断开连接</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"clinet closed..."</span>);<br>            <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 断开连接就break</span><br>        }<br><br>        <span class="hljs-type">char</span> * data = <span class="hljs-string">"hello,i am server"</span>;<br>        <span class="hljs-comment">// 给客户端发送数据</span><br>        write(cfd, data, <span class="hljs-built_in">strlen</span>(data));<br>    }<br>   <br>    <span class="hljs-comment">// 关闭文件描述符：监听和接受描述符</span><br>    close(cfd);<br>    close(lfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-客户端通信"><a class="markdownIt-Anchor" href="#2-客户端通信"></a> 2 客户端通信</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// [[TCP通信]]的客户端</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.创建套接字</span><br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 2.连接服务器端</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span> <br>    serveraddr.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">"192.168.193.128"</span>, &amp;serveraddr.sin_addr.s_addr);<br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <br>    <span class="hljs-comment">// 3. 通信</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br><br>        <span class="hljs-type">char</span> * data = <span class="hljs-string">"hello,i am client"</span>;<br>        <span class="hljs-comment">// 给客户端发送数据</span><br>        write(fd, data , <span class="hljs-built_in">strlen</span>(data));<br><br>        sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">// 慢一点</span><br>        <br>        <span class="hljs-type">int</span> len = read(fd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv server data : %s\n"</span>, recvBuf);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 表示服务器端断开连接</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"server closed..."</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>    }<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs col">![[Pasted image 20220512220917.png]]<br>第一开始运行服务端会阻塞着(因为accpet函数)，等待的客户端的连接<br><br>![[Pasted image 20220512220948.png]]<br>只通信一次的结果，没有while(1)死循环<br></code></pre></td></tr></tbody></table></figure><p>作业：<br>客户端给服务器发送一个数据，服务器在把它发回客户端 (回射服务器)<br>客户端获取键盘录入的数据给服务器发过去，服务器在随便回个消息</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsTOSfR5ATuNWmO253x1hLS" --> <p>#历史记录::<br>2022-05-12🌵TCP通信代码案例 : 第一次创建</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/posts/61467/"/>
      <url>/posts/61467/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><ol><li>左子树比根节点小，右子树比根节点大，(左小右大)</li><li>左右子树也分别是二叉搜索树</li></ol><p><img src="https://img-blog.csdnimg.cn/20200806190304693.png" alt=""></p><ul><li>&amp; 左子树中最大的元素也比根节点小, 右子树中最小的元素也比根节点大<ul><li>$ 这是二叉搜索树的性质决定的</li></ul></li></ul><!-- basicblock-start oid="Obs65oCz6Nl7gX7dcHpKPINZ" --> <h2 id="11-平衡二叉搜索树"><a class="markdownIt-Anchor" href="#11-平衡二叉搜索树"></a> 1.1 平衡二叉搜索树::</h2><!-- basicblock-end --><ol><li><p>平衡二叉搜索数是不是二叉搜索树和平衡二叉树的结合？<br>是的，是二叉搜索树和平衡二叉树的结合。</p></li><li><p>平衡二叉树与完全二叉树的区别在于底层节点的位置？<br>是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。</p></li><li><p>堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？<br>是的, 堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 <strong>但<mark>完全二叉树一定是平衡二叉树</mark>，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树</strong>。</p></li></ol><!-- basicblock-start oid="Obs2EjX4XYMRZCX0rBMJtzm6" --><h1 id="2-性质"><a class="markdownIt-Anchor" href="#2-性质"></a> 2 性质::</h1><p>中序遍历变为顺序数组：<br><strong>左中右：递增数组(由小变大)</strong>&nbsp;<br>右中左：递减数组(由大变小)</p><p>中序遍历二叉搜树代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void不需要返回 NULL</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>    （处理节点）                  <span class="hljs-comment">// 中 💡result.push_back(cur-&gt;val) 转化成递增数组</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obstwgv0yLKU0BVSy4zCeGoI" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::二叉搜索树.md" --> <p>#历史记录::<br>2022/9/23🌵二叉搜索树 :</p><!-- basicblock-end -->]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 代码随想录 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/3/"/>
      <url>/posts/3/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h1><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h1><p>[[4.26 select  API介绍]]</p><p>[[4.27select代码编写]]</p><p>4.1 网络结构模式<br>4.2 MAC 地址、IP 地址、端口（1）<br>4.3 MAC地址、1P地址、端口（2）<br>4.4 网络模型<br>4.5 协议<br>4.6 网络通信的过程（1<br>4.7 网络通信的过程 (2)</p><ul><li><p>[[socket 综述]]</p><ul><li>4.8 socket 介绍，</li><li>4.11 socket 地址，</li><li>4.35 本地套接字通信</li><li>4.14 socket 函数</li></ul></li><li><p>[[字节序]]</p><ul><li>4.9 字节序</li><li>4.10 字节序转换函数</li></ul></li></ul><p>[[IP地址转换]]<br>4.12 IP 地址转换函数</p><ul><li>[[TCP 通信流程]]<ul><li>4.13 TCP 通信流程</li><li>4.15 TCP通信实现（服务器端）</li><li>4.16 TCP 通信实现（客户端）</li></ul></li></ul><p>[[TCP三次握手]]<br>4.17 TCP 三次握手</p><p>[[滑动窗口]]<br>4.18 滑动窗口</p><p>[[TCP四次挥手]]<br>4.19 TCP 四次挥手</p><p>[[TCP通信并发]]<br>4.20 多进程实现并发服务器 (1）<br>4.21 多进程实现并发服务器 (2）</p><p>4.22 多线程实现并发服务器</p><p>[[TCP 状态转换]]<br>4.23 TCP状态转换</p><p>[[端口复用]]<br>4.24 半关闭、端口复用</p><p>[[IO多路复用]]<br>4.25 IO 多路复用简介</p><p>4.26 select APl介绍<br>4.27 select代码编写<br>4.28 poll API介绍及代码编写<br>4.29 epoll API介绍<br>4.30 epoll 代码编写<br>4.31 epoll的两种工作模式<br>4.32 UDP通信实现<br>4.33广播|<br>4.34组播</p>]]></content>
      
      
      <categories>
          
          <category> 👨🏻‍💻code </category>
          
          <category> 项目 </category>
          
          <category> webserver </category>
          
          <category> 4 Linux网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
