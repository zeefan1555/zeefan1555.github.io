<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>map 的实现</title>
    <link href="/posts/52450/"/>
    <url>/posts/52450/</url>
    
    <content type="html"><![CDATA[<p>📝map 的实现::</p><!-- basicblock-end -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>constance iterators</title>
    <link href="/posts/38720/"/>
    <url>/posts/38720/</url>
    
    <content type="html"><![CDATA[<p>📝constance iterators::</p><!-- basicblock-end --><p>在 C++ 中，constance iterator 指的是一种迭代器，它指向的对象不能被修改。这种迭代器的定义方式为 <code>const_iterator</code>，可以用来遍历容器中的元素，但无法修改容器中的内容。</p><p>使用 constance iterator 的优点有：</p><ul><li>可以避免误操作，因为它不能被用于修改容器中的元素。</li><li>可以提高代码的可读性和可维护性。</li><li>可以带来一定的性能提升。</li></ul><p>在 C++ 中，<strong>对于每一个容器类型，都有一个与之对应的 constance iterator 类型</strong>。例如，对于 vector 类型，它的 constance iterator 类型为 <code>vector&lt;T&gt;::const_iterator</code>。如果需要遍历一个 vector 容器中的元素，并且不需要修改容器中的内容，则可以使用 constance iterator 来进行遍历。</p><blockquote><p>[!note]<br>使用 constance iterator 遍历 vector 容器时，不能使用 vector 的 <code>begin()</code> 和 <code>end()</code> 方法，而应该使用 <code>cbegin()</code></p></blockquote><p>例子</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br><br>    <span class="hljs-comment">// 使用 constance iterator 遍历 vector 中的元素</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it;<br>    <span class="hljs-comment">// constance iterator 遍历 vector 容器时，</span><br>    <span class="hljs-comment">// 不能使用 vector 的 `begin()` 和 `end()` 方法，而应该使用 `cbegin()`</span><br>    <span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">cbegin</span>(); it != v.<span class="hljs-built_in">cend</span>(); ++it) {<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">" "</span>;<br>    }<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>set的实现</title>
    <link href="/posts/232/"/>
    <url>/posts/232/</url>
    
    <content type="html"><![CDATA[<p>📝set的实现::</p><!-- basicblock-end --><p>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</p><p>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p><p>set不允许迭代器修改元素的值，其迭代器是一种[[constance iterators]]</p><p>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，[[红黑树]]</p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> ia[<span class="hljs-number">5</span>] = { <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> }; <span class="hljs-comment">// 定义一个数组，并初始化为1,2,3,4,5</span><br>    <span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(ia, ia + <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 利用该数组初始化一个set对象</span><br><br>    <span class="hljs-comment">// 输出集合中元素的个数</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 5</span><br><br>    <span class="hljs-comment">// 输出集合中是否存在元素3</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-comment">// 输出集合中是否存在元素10</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">count</span>(<span class="hljs-number">10</span>) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>    <span class="hljs-comment">// 向集合中插入元素3，由于集合中已经存在3，因此不会插入成功</span><br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 输出集合中元素的个数，由于上一步插入不成功，因此个数不变</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 5</span><br>    <span class="hljs-comment">// 输出集合中是否存在元素3，仍然存在</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    <span class="hljs-comment">// 删除集合中元素1</span><br>    s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 输出集合中元素的个数，因为删除了一个元素，因此个数减少</span><br>    cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 4</span><br><br>    <span class="hljs-comment">// 定义一个迭代器，指向集合的开头</span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator b = s.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">// 定义一个迭代器，指向集合的末尾 </span><br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator e = s.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-comment">// 遍历集合中的所有元素</span><br><span class="hljs-keyword">for</span> (; b != e; ++b)<br>    cout &lt;&lt; *b &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 2 3 4 5</span><br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用STL函数find查找集合中是否存在元素5</span><br>b = <span class="hljs-built_in">find</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 如果找到，则输出5 found</span><br><span class="hljs-keyword">if</span> (b != s.<span class="hljs-built_in">end</span>())<br>    cout &lt;&lt; <span class="hljs-string">"5 found"</span> &lt;&lt; endl; <span class="hljs-comment">// 5 found</span><br><br><span class="hljs-comment">// 使用集合的成员函数find查找集合中是否存在元素2</span><br>b = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 如果找到，则输出2 found</span><br><span class="hljs-keyword">if</span> (b != s.<span class="hljs-built_in">end</span>())<br>    cout &lt;&lt; <span class="hljs-string">"2 found"</span> &lt;&lt; endl; <span class="hljs-comment">// 2 found</span><br><br><span class="hljs-comment">// 使用集合的成员函数find查找集合中是否存在元素1</span><br>b = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 如果未找到，则输出1 not found</span><br><span class="hljs-keyword">if</span> (b == s.<span class="hljs-built_in">end</span>())<br>    cout &lt;&lt; <span class="hljs-string">"1 not found"</span> &lt;&lt; endl; <span class="hljs-comment">// 1 not found</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><br></code></pre></td></tr></tbody></table></figure><p>在上面的代码中，我们通过以下方式使用了 <code>set</code> 类型：</p><ul><li>创建了一个 <code>set&lt;int&gt;</code> 对象，并利用一个 <code>int</code> 数组初始化了该对象；</li><li>访问了集合中元素的个数，并统计了某个特定元素是否存在于集合中；</li><li>向集合中插入了新元素，并删除了某个元素；</li><li>遍历了集合中的所有元素。</li></ul><p>总而言之，这段代码演示了 <code>set</code> 类型的一些基本用法。</p><p>关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高，因为STL提供的find()函数是一种顺序搜索算法。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>priority_queue</title>
    <link href="/posts/230/"/>
    <url>/posts/230/</url>
    
    <content type="html"><![CDATA[<p>📝priority_queue::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口<br>在插入元素时，元素并非按照插入次序排列，它会自动根据<strong>权值</strong>（通常是元素的实值）排列，权值最高，排在最前面，</p><p>如下图所示。</p><p>![[priority_queue(优先级队列).excalidraw]]<br>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现。<br>priority_queue的这种实现机制导致其不被归为容器，而是一种容器适配器器。关键的源码如下：</p><h1 id="2-源码"><a class="markdownIt-Anchor" href="#2-源码"></a> 2: 源码</h1><blockquote><p>[!question] #📗    暂时没看</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Squence</span> = vector&lt;T&gt;, <br><span class="hljs-keyword">class</span> Compare = less&lt;<span class="hljs-keyword">typename</span> Sequence::value_tyoe&gt; &gt; <br><span class="hljs-keyword">class</span> priority_queue{<br><span class="hljs-comment">// 定义一个模板类 priority_queue，它接受三个参数： </span><br><span class="hljs-comment">// T：优先队列中元素的类型。 </span><br><span class="hljs-comment">// Sequence：底层容器的类型。用于存储优先队列中的元素。 </span><br><span class="hljs-comment">// Compare：元素大小比较标准的类型。用于比较优先队列中元素的大小。</span><br><br><span class="hljs-keyword">protected</span>: <br>Sequence c; <span class="hljs-comment">// 底层容器。用于存储优先队列中的数据。 </span><br>Compare comp; <span class="hljs-comment">// 元素大小比较标准。用于比较优先队列中元素的大小。</span><br><br><span class="hljs-keyword">public</span>: <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">empty</span>();} <br><span class="hljs-comment">// 判断优先队列是否为空。如果底层容器为空，则优先队列也为空。</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">size</span>();}<br><span class="hljs-comment">// 返回优先队列中元素的个数。</span><br><br><span class="hljs-function">const_reference <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">front</span>()}<br><span class="hljs-comment">// 返回优先队列中最高优先级的元素。</span><br><br><span class="hljs-type">void</span> <span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> value_type&amp; x)<br>{<br>    <span class="hljs-comment">// 向优先队列中添加一个元素。</span><br>    <span class="hljs-comment">// 将元素添加到底层容器中，并调用 std::push_heap 来维护优先队列的性质。</span><br>    c.<span class="hljs-built_in">push_heap</span>(x);<br>    <span class="hljs-built_in">push_heap</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(),comp);<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 从优先队列中移除最高优先级的元素。</span><br>    <span class="hljs-comment">// 调用 std::pop_heap 来维护优先队列的性质，然后从底层容器中移除元元素。 </span><br>    <span class="hljs-built_in">pop_heap</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), comp);<br>    c.<span class="hljs-built_in">pop_back</span>();<br>    } <br>};<br><br></code></pre></td></tr></tbody></table></figure><p>priority_queue的所有元素，进出都有一定的规则，<strong>只有queue顶端的元素（权值最高者），才有机会被外界取用</strong>，<br><strong>它没有遍历功能，也不提供迭代器</strong></p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> ia[<span class="hljs-number">9</span>] = {<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span> };<br><span class="hljs-function">priority_queue&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pq</span><span class="hljs-params">(ia, ia + <span class="hljs-number">9</span>)</span></span>;<br>cout &lt;&lt; pq.<span class="hljs-built_in">size</span>() &lt;&lt;endl;  <span class="hljs-comment">// 9</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pq.<span class="hljs-built_in">size</span>(); i++)<br>{<br>cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 8 8 8 8 8 8 8 8 8, 💡只能调取顶部元素</span><br>}<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>{<br>cout &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">' '</span>;<span class="hljs-comment">// 8 7 6 5 4 3 2 1 0</span><br>pq.<span class="hljs-built_in">pop</span>();<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>heap API</title>
    <link href="/posts/228/"/>
    <url>/posts/228/</url>
    
    <content type="html"><![CDATA[<p>📝heap API::</p><!-- basicblock-end --><p>那heap算法有哪些？常见有的插入、弹出、排序和构造算法，下面一一进行描述。</p><h1 id="1-push_heap插入算法"><a class="markdownIt-Anchor" href="#1-push_heap插入算法"></a> 1: push_heap插入算法</h1><p>[[完全二叉树.excalidraw]]</p><p>![[push_heap插入算法.excalidraw]]</p><h1 id="2-pop_heap弹出算法"><a class="markdownIt-Anchor" href="#2-pop_heap弹出算法"></a> 2: pop_heap弹出算法</h1><p>‌‌‌<br>![[pop_heap弹出算法.excalidraw]]<br>‌‌‌</p><h1 id="3-sort算法"><a class="markdownIt-Anchor" href="#3-sort算法"></a> 3: sort算法</h1><p>一言以蔽之，因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap范围减1，<br>那么不断的执行pop_heap直到树为空，即可得到一个递增序列。</p><h1 id="4-make_heap算法"><a class="markdownIt-Anchor" href="#4-make_heap算法"></a> 4: make_heap算法</h1><p>将一段数据转化为heap，一个一个数据插入，<strong>调用上面说的两种percolate算法即可</strong>。</p><blockquote><p>[!success] #✅ 最大堆不一定是按照递增的顺序排的? 只是顶部上是最大的?<br>您的理解是正确的。<br>最大堆不一定按照递增的顺序排列，因为它是一种特殊的数据结构，它的性质是每个父节点都大于（或等于）它的子节点。<br>最大堆的顶部元素（也称为根节点）是整个堆中最大的元素。<br>所以下面的输出结果是没错的</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 包含 make_heap, push_heap, pop_heap 和 sort_heap 等函数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> <span class="hljs-comment">// 包含 vector 容器</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>  vector&lt;<span class="hljs-type">int</span>&gt; v = { <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> }; <span class="hljs-comment">// 创建 vector 并插入元素</span><br><br>  <span class="hljs-built_in">make_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将 vector 转换为堆</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<br>  {<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 输出堆中的元素：6 4 5 3 1 0 2</span><br>  }<br>  cout &lt;&lt; endl;<br><br>  v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// 向 vector 中插入一个新元素</span><br>  <span class="hljs-built_in">push_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 重新排序堆</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<br>  {<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 输出堆中的元素：7 6 5 4 1 0 2 3</span><br>  }<br>  cout &lt;&lt; endl;<br><br>  <span class="hljs-built_in">pop_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 弹出堆顶元素</span><br>  cout &lt;&lt; v.<span class="hljs-built_in">back</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出 vector 末尾元素：7</span><br>  v.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 从 vector 中删除末尾元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<br>  {<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 输出堆中的元素：6 4 5 3 1 0 2</span><br>  }<br>  cout &lt;&lt; endl;<br><br>  <span class="hljs-built_in">sort_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 对堆进行排序</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : v)<br>  {<br>    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>; <span class="hljs-comment">// 输出堆中的元素：0 1 2 3 4 5 6</span><br>  }<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
    <tags>
      
      <tag>✅</tag>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>heap(STL)(🗃)</title>
    <link href="/posts/226/"/>
    <url>/posts/226/</url>
    
    <content type="html"><![CDATA[<p>📝heap::</p><!-- basicblock-end --><h1 id="1-堆与栈内存方面"><a class="markdownIt-Anchor" href="#1-堆与栈内存方面"></a> 1: [[堆与栈(内存方面(🗃))]]</h1><h1 id="2-简介"><a class="markdownIt-Anchor" href="#2-简介"></a> 2: 简介</h1><p>heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高。</p><p>![[heap(STL)(🗃) 2022-12-15 17.09.09.excalidraw]]</p><h1 id="3-小顶锥和大顶锥的原理"><a class="markdownIt-Anchor" href="#3-小顶锥和大顶锥的原理"></a> 3: [[小顶锥和大顶锥的原理]]</h1><h1 id="4-heap-api"><a class="markdownIt-Anchor" href="#4-heap-api"></a> 4: [[heap API]]</h1><h1 id="5-priority_queue"><a class="markdownIt-Anchor" href="#5-priority_queue"></a> 5: [[priority_queue]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
    <tags>
      
      <tag>🗃️</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>queue</title>
    <link href="/posts/218/"/>
    <url>/posts/218/</url>
    
    <content type="html"><![CDATA[<p>📝queue::</p><!-- basicblock-end --><p>queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021436.png" alt=""></p><p>类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，queue的源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> queue<br>{<br>...<br><span class="hljs-keyword">protected</span>:<br>    Sequence c;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">empty</span>();}<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">size</span>();}<br>    <span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">front</span>();}<br>    <span class="hljs-function">const_reference <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">front</span>();}<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; x)</span></span>{c.<span class="hljs-built_in">push_back</span>(x);}<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>{c.<span class="hljs-built_in">pop_front</span>();}<br>};<br></code></pre></td></tr></tbody></table></figure><p>从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成，Sequence默认也是deque数据结构。queue也是一类container adapter。</p><p>同样，queue也可以使用list作为底层容器，<strong>不具有遍历功能，没有迭代器</strong>。</p><p>queue 是一种先进先出 (FIFO) 的数据结构，它的元素会按照它们被插入的顺序进行存储。这种数据结构不支持迭代器，因为迭代器的目的是按照某种顺序对元素进行遍历，而 queue 没有特定的遍历顺序。</p><p>要遍历 queue 中的元素，您可以使用 queue 的其他操作，例如 front() 和 pop()。例如，您可以在 while 循环中使用 front() 和 pop() 操作来遍历 queue 中的元素。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我们使用的 stack 是属于哪个版本的 STL？</title>
    <link href="/posts/206/"/>
    <url>/posts/206/</url>
    
    <content type="html"><![CDATA[<p>📝我们使用的 stack 是属于哪个版本的 STL？::</p><!-- basicblock-end --><p>首先大家要知道栈和队列是 STL（C<ins>标准库）里面的两个数据结构。<br>C</ins>标准库是有多个版本的，要知道我们使用的 STL 是哪个版本，才能知道对应的栈和队列的实现原理。<br>那么来介绍一下，三个最为普遍的 STL 版本：</p><ol><li>HP STL 其他版本的 C++ STL，一般是以 HP STL 为蓝本实现出来的，HP STL 是 C++ STL 的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger 参照 HP STL 实现出来的，被 Visual C++编译器所采用，不是开源的。</li><li>SGI STL 由 Silicon Graphics Computer Systems 公司参照 HP STL 实现，被 Linux 的 C++编译器 GCC 所采用，SGI STL 是开源软件，源码可读性甚高。</li></ol><p>接下来介绍的栈和队列也是 SGI STL 里面的数据结构，知道了使用版本，才知道对应的底层实现。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/posts/204/"/>
    <url>/posts/204/</url>
    
    <content type="html"><![CDATA[<p>📝红黑树::</p><!-- basicblock-end --><p>红黑树是一种二叉查找树，它保证了任意一个节点到叶子节点的最长路径不超过最短路径的两倍，<br>因此在红黑树上的插入、删除和查找操作的时间复杂度都是对数级别的。</p><p>红黑树通常用来实现关联数组和其他抽象数据类型。</p><p>红黑树是一种自平衡二叉查找树，它在插入和删除节点时通过旋转树中的节点来保持平衡。这个平衡的过程有许多规则，其中一些规则涉及红黑树节点的颜色。</p><p>具体来说，红黑树遵循以下规则：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>如果一个节点是红色的，那么它的两个子节点必须都是黑色的。</li><li>从根节点到叶子节点的所有路径必须包含相同数量的黑色节点。</li></ol><p>这些规则确保了红黑树总是平衡的，并且保证了查找、插入和删除操作的时间复杂度都是对数级别的。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划核心套路详解</title>
    <link href="/posts/188/"/>
    <url>/posts/188/</url>
    
    <content type="html"><![CDATA[<p>📝动态规划核心套路详解::</p><!-- basicblock-end --><p>![[动态规划原理.excalidraw]]</p><blockquote><p>[!note] 如何判断是否有重叠子问题<br>一个状态是否有多个入口</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>labuladong</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>alloc</title>
    <link href="/posts/182/"/>
    <url>/posts/182/</url>
    
    <content type="html"><![CDATA[<p>📝alloc::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>在 C++ 中，alloc 是一个内存分配器。它主要用于动态<br>内存分配，可以在运行时为对象分配内存。<br>alloc 主要用在 C++ 标准库中，例如在 std::allocator 类模板中。它提供了一种通用的方法来分配内存，可以用于容器类型，例如 vector 和 list。</p><blockquote><p>[!success] #✅ 它可以自动释放内存吗<br>不，alloc 是一个内存分配器，它主要用于动态内存分配。它并不会自动释放内存，这需要用户手动调用相应的函数来释放内存。例如，在 C++ 中，可以使用 std::allocator 类模板的 deallocate() 函数来释放分配给对象的内存。</p></blockquote><blockquote><p>[!question] #📕    到底是常用不常用<br>使用alloc可以让你更方便地管理内存，并且可以提高程序的性能。它是一种非常常见的内存分配器，用来管理内存的大多数C++标准库容器都使用了alloc。</p></blockquote><h1 id="2-new-delete-的关系"><a class="markdownIt-Anchor" href="#2-new-delete-的关系"></a> 2: new delete 的关系</h1><p><code>alloc</code> 是一个C++ 库函数，它通常用于为内存分配所需的空间。这个函数的作用和 <code>new</code> 运算符类似，都是用来分配内存空间。但是，<code>alloc</code> 和 <code>new</code> 有一个重要的区别：<code>alloc</code> 只能用于内存分配，而 <code>new</code> 运算符不仅能分配内存空间，还能调用构造函数初始化对象。</p><p>解释一下 c++中的alloc</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
      <tag>✅</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>list</title>
    <link href="/posts/23529/"/>
    <url>/posts/23529/</url>
    
    <content type="html"><![CDATA[<p>📝list::</p><!-- basicblock-end --><p>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。</p><p>list<strong>不能保证节点在存储空间中连续存储</strong>，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</p><p>list节点的结构见如下源码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__list_node</span>{<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* void_pointer;<br>    void_pointer prev;<br>    void_pointer next;<br>    T data;<br>}<br></code></pre></td></tr></tbody></table></figure><p>从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。</p><p>此外list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“<strong>前闭后开</strong>”的区间结构</p><p>list的空间管理默认采用[[alloc]]作为空间配置器，为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间</p><p>由于list的双向特性，其支持在头部（front)和尾部（back)两个方向进行push和pop操作，当然还支持erase，splice，sort，merge，reverse，sort等操作，这里不再详细阐述。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>slist</title>
    <link href="/posts/39975/"/>
    <url>/posts/39975/</url>
    
    <content type="html"><![CDATA[<p>📝28、STL中slist的实现::</p><!-- basicblock-end --><p>slist（single linked list）是单向链表list是双向链表，</p><h1 id="1-它们的主要区别在于"><a class="markdownIt-Anchor" href="#1-它们的主要区别在于"></a> 1: 它们的主要区别在于：</h1><blockquote><p>[!note] 1</p><ul><li>slist的迭代器属于单向的Forward iterator<ul><li>slist迭代器是从头结点向尾结点移动</li></ul></li><li>list的迭代器是双向的Bidirectional iterator</li></ul></blockquote><blockquote><p>[!note] 2</p><ul><li>它和普通的链表还有一个显著的区别，就是它只允许在链表的头部插入元素。<ul><li>这意味着，当你调用slist的push_front()函数时，新插入的元素将会放在链表的最前面，并成为新的头结点。因此，如果你按照顺序输入一系列数字，那么它们在链表中的存储顺序将会和输入顺序相反。</li></ul></li></ul></blockquote><p>虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p><p>slist的单向迭代器如下图所示：</p><p>![[slist.excalidraw]]</p><h2 id="11-slist-的遍历"><a class="markdownIt-Anchor" href="#11-slist-的遍历"></a> 1.1: slist 的遍历</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义迭代器</span><br>slist_iterator it = slist.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-comment">// 遍历链表</span><br><span class="hljs-keyword">while</span> (it != slist.<span class="hljs-built_in">end</span>()) {<br>  cout &lt;&lt; *it &lt;&lt; endl; <span class="hljs-comment">// 输出当前结点的值</span><br>  ++it; <span class="hljs-comment">// 移动到下一个结点</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-还没看"><a class="markdownIt-Anchor" href="#2-还没看"></a> 2: 还没看</h1><p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Allco</span> = alloc&gt;<br><span class="hljs-keyword">class</span> slist<br>{<br>...<br><span class="hljs-keyword">private</span>:<br>    ...<br>    <span class="hljs-type">static</span> list_node* <span class="hljs-built_in">create_node</span>(<span class="hljs-type">const</span> value_type&amp; x){}<span class="hljs-comment">//配置空间、构造元素</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-built_in">destroy_node</span>(list_node* node){}<span class="hljs-comment">//析构函数、释放空间</span><br><span class="hljs-keyword">private</span>:<br>    list_node_base head; <span class="hljs-comment">//头部</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>{}<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>{}<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span></span>{}<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>{}<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(slist&amp; L)</span></span>{}<span class="hljs-comment">//交换两个slist，只需要换head即可</span><br>    <span class="hljs-function">reference <span class="hljs-title">front</span><span class="hljs-params">()</span></span>{} <span class="hljs-comment">//取头部元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">const</span> value&amp; x)</span></span>{}<span class="hljs-comment">//头部插入元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span>{}<span class="hljs-comment">//从头部取走元素</span><br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>forward_list&lt;<span class="hljs-type">int</span>&gt; fl;<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">3</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">6</span>);<br>fl.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">5</span>);<br><br>forward_list&lt;<span class="hljs-type">int</span>&gt;::iterator ite1 = fl.<span class="hljs-built_in">begin</span>();<br>forward_list&lt;<span class="hljs-type">int</span>&gt;::iterator ite2 = fl.<span class="hljs-built_in">end</span>();<br><span class="hljs-keyword">for</span>(;ite1 != ite2; ++ite1)<br>{<br>cout &lt;&lt; *ite1 &lt;&lt;<span class="hljs-string">" "</span>; <span class="hljs-comment">// 5 6 2 3 1</span><br>}<br>cout &lt;&lt; endl;<br><br>ite1 = <span class="hljs-built_in">find</span>(fl.<span class="hljs-built_in">begin</span>(), fl.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>); <span class="hljs-comment">//寻找2的位置</span><br><br><span class="hljs-keyword">if</span> (ite1 != ite2)<br>fl.<span class="hljs-built_in">insert_after</span>(ite1, <span class="hljs-number">99</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : fl)<br>{<br>cout &lt;&lt; it &lt;&lt; <span class="hljs-string">" "</span>;  <span class="hljs-comment">//5 6 2 99 3 1</span><br>}<br>cout &lt;&lt; endl;<br><br>ite1 = <span class="hljs-built_in">find</span>(fl.<span class="hljs-built_in">begin</span>(), fl.<span class="hljs-built_in">end</span>(), <span class="hljs-number">6</span>); <span class="hljs-comment">//寻找6的位置</span><br><span class="hljs-keyword">if</span> (ite1 != ite2)<br>fl.<span class="hljs-built_in">erase_after</span>(ite1);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : fl)<br>{<br>cout &lt;&lt; it &lt;&lt; <span class="hljs-string">" "</span>;  <span class="hljs-comment">//5 6 99 3 1</span><br>}<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>需要注意的是C<ins>标准委员会没有采用slist的名称，<br>forward_list在C</ins> 11中出现，它与slist的区别是没有size()方法。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26、STL中迭代器失效的情况有哪些？</title>
    <link href="/posts/51935/"/>
    <url>/posts/51935/</url>
    
    <content type="html"><![CDATA[<p>📝26、STL中迭代器失效的情况有哪些？::</p><!-- basicblock-end --><h1 id="1-以vector为例"><a class="markdownIt-Anchor" href="#1-以vector为例"></a> 1: 以vector为例：</h1><p><strong>插入元素：</strong></p><p>1、尾后插入：size &lt; capacity时，<br>首迭代器不失效尾迭代失效（未重新分配空间），<br>size == capacity时，所有迭代器均失效（需要重新分配空间）。</p><p>2、<strong>中间插入</strong>：中间插入：size &lt; capacity时，<br>首迭代器不失效但插入元素之后所有迭代器失效，<br>size == capacity时，所有迭代器均失效。</p><p>当向 vector 容器的中间插入元素时，容器可能会进行内存重新分配以容纳新的元素。这会导致容器中所有元素的位置发生改变，包括插入元素之前的元素。因此，插入元素之后所有迭代器都会失效。</p><p><strong>删除元素：</strong><br>尾后删除：只有尾迭代失效。</p><p><strong>中间删除</strong>：删除位置之后所有迭代器失效。</p><h1 id="2-其他"><a class="markdownIt-Anchor" href="#2-其他"></a> 2: 其他</h1><blockquote><p>[!question] #📙</p></blockquote><p>deque 和 vector 的情况类似,</p><p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p><p>map/set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器,<br>使用递增方法获取下一个迭代器 mmp.erase(iter++);</p><p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器的分类(🗃)3G</title>
    <link href="/posts/55110/"/>
    <url>/posts/55110/</url>
    
    <content type="html"><![CDATA[<p>📝25、说一下STL每种容器对应的迭代器::</p><!-- basicblock-end --><table><thead><tr><th>容器</th><th>迭代器</th></tr></thead><tbody><tr><td>vector、deque</td><td>随机访问迭代器</td></tr><tr><td>stack、queue、priority_queue</td><td>无</td></tr><tr><td>list、(multi)set/map</td><td>双向迭代器</td></tr><tr><td>unordered_(multi)set/map、forward_list, hash table</td><td>前向迭代器</td></tr></tbody></table><h1 id="1-constance-iterators"><a class="markdownIt-Anchor" href="#1-constance-iterators"></a> 1: [[constance iterators]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
    <tags>
      
      <tag>🗃️</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector 删除操作</title>
    <link href="/posts/37902/"/>
    <url>/posts/37902/</url>
    
    <content type="html"><![CDATA[<p>vector 删除操作::</p><!-- basicblock-end --><ul><li>向量容器vector的成员函数pop_back()可以删除最后一个元素.</li><li>而函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。</li><li>还可以采用通用算法remove()来删除vector容器中的元素.<ul><li>不同的是：采用remove一般情况下不会改变容器的大小，</li><li>而pop_back()与erase()等成员函数会改变容器的大小。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢</title>
    <link href="/posts/39979/"/>
    <url>/posts/39979/</url>
    
    <content type="html"><![CDATA[<p>📝为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢::</p><!-- basicblock-end --><h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1:</h1><p>考虑可能产生的堆空间浪费，所以增长倍数不能太大，一般是 1.5 或 2；<br>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。<br>C++并没有规定扩容因子 K, 这是由标准库的实现者决定的。<br>[[VS 与 GCC]]</p><p>k=2 每次扩展的新尺寸必然刚好大于之前分配的总和，之前分配的内存空间不可能被使用，这样对于缓存并不友好，所以最好倍增长因子设置为(1,2)之间<br><strong>采用 1.5 倍的增长方式可以更好的实现对内存的重复利用。</strong><br>采用1.5 倍也可能覆盖掉之前的内存, 跟下边的同理</p><blockquote><p>[!note] 为什么导致之前分配的内存不能再被使用<br>这是因为内存分配是有顺序的，每次分配都是在上一次分配的基础上进行的。如果以两倍的方式扩容，那么每次扩容后的内存容量都会大于之前分配内存的总和，这就导致之前分配的内存空间不能再被使用。</p><p>例如，假设原来分配了100MB的内存，然后以两倍的方式扩容，那么扩容后的内存容量就会是100MB x 2 = 200MB。在这种情况下，之前分配的100MB的内存空间就不能再被使用了，因为它已经被扩容后的内存空间占用了。如果再需要分配内存，那么就必须从200MB开始分配，而之前分配的100MB的内存空间就无法再被使用了。</p></blockquote><blockquote><p>[!note] 为什么对缓存并不友好<br>对于缓存来说，以两倍的方式扩容并不友好，因为每次扩容后的内存容量必然刚好大于之前分配的总和，导致之前分配的内存空间无法再被使用。<br>这会导致缓存的性能降低，因为缓存就是用来重复使用之前访问过的数据的，如果之前分配的内存空间无法再被使用，那么就会导致缓存失效，性能就会降低。<br>因此，对于缓存来说，以两倍的方式扩容并不友好。</p></blockquote><p>通常情况下，当您想要扩容内存时，您可以采用分配新内存并将数据复制到新内存空间的方式。这样做可以确保之前分配的内存空间依然可以被使用，因为它们没有被覆盖或修改。</p><h2 id="11-测试代码"><a class="markdownIt-Anchor" href="#11-测试代码"></a> 1.1: 测试代码</h2><p>Vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍</p><p>测试代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">//在Linux + GCC下</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; res.<span class="hljs-built_in">capacity</span>() &lt;&lt;endl; <span class="hljs-comment">//2</span><br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; res.<span class="hljs-built_in">capacity</span>() &lt;&lt;endl;<span class="hljs-comment">//4</span><br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; res.<span class="hljs-built_in">capacity</span>() &lt;&lt;endl;<span class="hljs-comment">//8</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//在 win 10 + VS2019下</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; res.<span class="hljs-built_in">capacity</span>() &lt;&lt;endl; <span class="hljs-comment">//2</span><br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; res.<span class="hljs-built_in">capacity</span>() &lt;&lt;endl;<span class="hljs-comment">//3</span><br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    cout &lt;&lt; res.<span class="hljs-built_in">capacity</span>() &lt;&lt;endl;<span class="hljs-comment">//6</span><br>   }<br></code></pre></td></tr></tbody></table></figure><p>运行上述代码，一开始配置了一块长度为2的空间，接下来插入一个数据，长度变为原来的两倍，为4，此时已占用的长度为3，再继续两个数据，此时长度变为8，可以清晰的看到空间的变化过程</p><p>需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响</p><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2:</h1><p>在扩容时，如果采用三倍、四倍或其他的方式，可能会导致<strong>扩容的次数更多</strong>，从而降低程序的效率。<br>例如，如果采用三倍的方式扩容，则当容量从 1 扩容到 3 时，需要进行一次扩容；当容量从 3 扩容到 6 时，需要进行第二次扩容，以此类推。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？</title>
    <link href="/posts/6170/"/>
    <url>/posts/6170/</url>
    
    <content type="html"><![CDATA[<p>📝为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？::</p><!-- basicblock-end --><blockquote><p>[!summary]<br>采用采用成倍方式扩容，可以有 O(1)时间复杂度，<br>增加指定大小的容量达到O(n)的时间复杂度，<br>因此，使用成倍的方式扩容。</p></blockquote><h1 id="1-解释一下为什么插入元素的时间复杂度是-o1"><a class="markdownIt-Anchor" href="#1-解释一下为什么插入元素的时间复杂度是-o1"></a> 1: 解释一下为什么插入元素的时间复杂度是 O(1)</h1><p>当向一个 vector 中插入元素时，如果容量足够，则只需要将新元素添加到容器的末尾，并更新 vector 的长度即可。这个过程的时间复杂度为 O(1)，因为它只需要常数次的操作。</p><p>如果 vector 的容量不够，那么需要进行扩容操作。如果采用成倍扩容的方式，则只需要分配一个新的容器，并将原来的容器指针指向新的容器即可。这个过程的时间复杂度也是 O(1) 的，因为它只需要常数次的操作<br>如果采用增加指定大小的容量来扩容，每次扩容的时间复杂度将为 O(n)，因为在扩容时需要将原来的元素拷贝到新的容器中</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VS 与 GCC</title>
    <link href="/posts/51222/"/>
    <url>/posts/51222/</url>
    
    <content type="html"><![CDATA[<p>📝VS 与 GCC::</p><!-- basicblock-end --><p>VS（Visual Studio）是一个由微软公司推出的集成开发环境（Integrated Development Environment，IDE）。<br>它提供了一组工具，用于编写、编译、调试以及发布应用程序。VS 主要用于开发 Windows 应用程序，但也可用于开发 Linux 和 MacOS 应用程序。</p><p>GCC（GNU Compiler Collection）是一个自由的、开源的编译器套件，包含了多种编程语言的编译器，如 C、C++、Objective-C、Fortran、Ada 和诸如此类的语言。<br>GCC 是由 GNU 项目开发，可在多种平台上运行，包括 Linux、Windows 和 MacOS。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>size()和 capacity()</title>
    <link href="/posts/39409/"/>
    <url>/posts/39409/</url>
    
    <content type="html"><![CDATA[<p>📝size()和 capacity()::</p><!-- basicblock-end --><h1 id="1-size-capacity"><a class="markdownIt-Anchor" href="#1-size-capacity"></a> 1: size &amp; capacity</h1><ul><li>vector的大小有两个维度一个是size一个是capicity，size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。<ul><li>size就是我们平时用来遍历vector时候用的，<strong>当前已经存储数据的个数</strong> 例如：<code>for (int i = 0; i &lt; vec.size(); i++)</code></li><li>capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size,<strong>底层真正可以保存的元素个数</strong></li></ul></li></ul><p>对于 vector 来说，capacity 是永远大于等于 size<br>capacity 和 size 相等时，vector 就会扩容，capacity: 变大（翻倍）<br>当 insert 数据的时候，如果已经大于 capicity，capicity 会成倍扩容，但对外暴露的 size 其实仅仅是+1 而已，剩下的位置还是空闲的</p><p>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。<br>因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。<br>只有当n&gt;capacity()时，调用reserve(n)才会改变vector容量。</p><h1 id="2-resize-reserve"><a class="markdownIt-Anchor" href="#2-resize-reserve"></a> 2: resize &amp; reserve</h1><p>resize()成员函数改变元素的数目，至于空间的的变化需要看具体情况去分析，如下：<br><strong>resize()函数只改变容器的元素数目，未改变容器大小</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type __new_size, <span class="hljs-type">const</span> _Tp&amp; __x)</span> </span>{<br>      <span class="hljs-keyword">if</span> (__new_size &lt; <span class="hljs-built_in">size</span>()) <br>            <span class="hljs-built_in">erase</span>(<span class="hljs-built_in">begin</span>() + __new_size, <span class="hljs-built_in">end</span>());<br>      <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">insert</span>(<span class="hljs-built_in">end</span>(), __new_size - <span class="hljs-built_in">size</span>(), __x);<br>      }<br></code></pre></td></tr></tbody></table></figure><p>当reserve()分配的空间比原空间小时，是不会引起重新分配的</p><p>用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23、常见容器性质总结？</title>
    <link href="/posts/29119/"/>
    <url>/posts/29119/</url>
    
    <content type="html"><![CDATA[<p>📝23、常见容器性质总结？::</p><!-- basicblock-end --><p>1.vector 底层数据结构为数组，支持快速随机访问</p><p>2.list 底层数据结构为双向链表，支持快速增删</p><p>3.deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p><p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p><p>[堆1] --&gt; [堆2] --&gt;[堆3] --&gt; …</p><p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p><p>4.stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p><p>5.queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p><p>6.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p><p>7.set 底层数据结构为红黑树，有序，不重复</p><p>8.multiset 底层数据结构为红黑树，有序，可重复</p><p>9.map 底层数据结构为红黑树，有序，不重复</p><p>10.multimap 底层数据结构为红黑树，有序，可重复</p><p>11.unordered_set 底层数据结构为hash表，无序，不重复</p><p>12.unordered_multiset 底层数据结构为hash表，无序，可重复</p><p>13.unordered_map 底层数据结构为hash表，无序，不重复</p><p>14.unordered_multimap 底层数据结构为hash表，无序，可重复</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hash table</title>
    <link href="/posts/21358/"/>
    <url>/posts/21358/</url>
    
    <content type="html"><![CDATA[<p>📝hash table::</p><!-- basicblock-end --><h1 id="1-hash-table-原理"><a class="markdownIt-Anchor" href="#1-hash-table-原理"></a> 1: [[hash table 原理]]</h1><h1 id="2-22-stl中hash-table扩容发生什么"><a class="markdownIt-Anchor" href="#2-22-stl中hash-table扩容发生什么"></a> 2: [[22、STL中hash table扩容发生什么？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22、STL中hash table扩容发生什么？</title>
    <link href="/posts/47511/"/>
    <url>/posts/47511/</url>
    
    <content type="html"><![CDATA[<p>📝22、STL中hash table扩容发生什么？::</p><!-- basicblock-end --><p>![[hash table 原理图.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21、STL中的allocator、deallocator</title>
    <link href="/posts/45319/"/>
    <url>/posts/45319/</url>
    
    <content type="html"><![CDATA[<p>‌‌‌📝21、STL中的allocator、deallocator::</p><!-- basicblock-end --><p>![[STL 第二级空间配置器.excalidraw]]</p><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：<br>当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；<br>当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL模板库-21-40 目录</title>
    <link href="/posts/5479/"/>
    <url>/posts/5479/</url>
    
    <content type="html"><![CDATA[<p>📝STL模板库-21-40 目录::</p><!-- basicblock-end --><h1 id="1-21-stl中的allocator-deallocator"><a class="markdownIt-Anchor" href="#1-21-stl中的allocator-deallocator"></a> 1: [[21、STL中的allocator、deallocator]]</h1><h1 id="2-22-stl中hash-table扩容发生什么"><a class="markdownIt-Anchor" href="#2-22-stl中hash-table扩容发生什么"></a> 2: [[22、STL中hash table扩容发生什么？]]</h1><h1 id="3-23-常见容器性质总结"><a class="markdownIt-Anchor" href="#3-23-常见容器性质总结"></a> 3: [[23、常见容器性质总结？]]</h1><h1 id="4-vector-原理-扩容过程-vector删除操作"><a class="markdownIt-Anchor" href="#4-vector-原理-扩容过程-vector删除操作"></a> 4: [[vector 原理 (扩容过程)]], [[vector删除操作]]</h1><h1 id="5-迭代器的分类"><a class="markdownIt-Anchor" href="#5-迭代器的分类"></a> 5: [[迭代器的分类(🗃)]]</h1><h1 id="6-26-stl中迭代器失效的情况有哪些"><a class="markdownIt-Anchor" href="#6-26-stl中迭代器失效的情况有哪些"></a> 6: [[26、STL中迭代器失效的情况有哪些？]]</h1><h1 id="7-vector-原理-扩容过程"><a class="markdownIt-Anchor" href="#7-vector-原理-扩容过程"></a> 7: [[vector 原理 (扩容过程)]]</h1><h1 id="8-slist"><a class="markdownIt-Anchor" href="#8-slist"></a> 8: [[slist]]</h1><h1 id="9-source_postscodec阿秀stl模板库-21-40list"><a class="markdownIt-Anchor" href="#9-source_postscodec阿秀stl模板库-21-40list"></a> 9: [[source/_posts/👨🏻‍💻code/C++/阿秀/STL模板库-21-40/list]]</h1><h1 id="10-deque"><a class="markdownIt-Anchor" href="#10-deque"></a> 10: [[deque(🗃)]]</h1><h1 id="11-stack-queue"><a class="markdownIt-Anchor" href="#11-stack-queue"></a> 11: [[stack &amp;&amp; queue(🗃)]]</h1><h1 id="12-heapstl"><a class="markdownIt-Anchor" href="#12-heapstl"></a> 12: [[heap(STL)(🗃)]]</h1><h1 id="13-priority_queue"><a class="markdownIt-Anchor" href="#13-priority_queue"></a> 13: [[priority_queue]]</h1><h1 id="14-set的实现"><a class="markdownIt-Anchor" href="#14-set的实现"></a> 14: [[set的实现]]</h1><p>[[map(🗃)]]</p><h1 id="15-map"><a class="markdownIt-Anchor" href="#15-map"></a> 15: [[map]]</h1><p>map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key</p><p>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constant iterator，也不是mutable iterator</p><p>标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map。map的架构如下图所示</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022980.png" alt=""></p><p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>map&lt;string, <span class="hljs-type">int</span>&gt; maps;<br>    <span class="hljs-comment">//插入若干元素</span><br>maps[<span class="hljs-string">"jack"</span>] = <span class="hljs-number">1</span>;<br>maps[<span class="hljs-string">"jane"</span>] = <span class="hljs-number">2</span>;<br>maps[<span class="hljs-string">"july"</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//以pair形式插入</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"david"</span>, <span class="hljs-number">4</span>)</span></span>;<br>maps.<span class="hljs-built_in">insert</span>(p);<br><span class="hljs-comment">//迭代输出元素</span><br>map&lt;string, <span class="hljs-type">int</span>&gt;::iterator iter = maps.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; iter != maps.<span class="hljs-built_in">end</span>(); ++iter)<br>{<br>cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string">" "</span>;<br>cout &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-string">"--"</span>; <span class="hljs-comment">//david 4--jack 1--jane 2--july 3--</span><br>}<br>cout &lt;&lt; endl;<br><span class="hljs-comment">//使用subscipt操作取实值</span><br><span class="hljs-type">int</span> num = maps[<span class="hljs-string">"july"</span>];<br>cout &lt;&lt; num &lt;&lt; endl; <span class="hljs-comment">// 3</span><br><span class="hljs-comment">//查找某key</span><br>iter = maps.<span class="hljs-built_in">find</span>(<span class="hljs-string">"jane"</span>);<br><span class="hljs-keyword">if</span>(iter != maps.<span class="hljs-built_in">end</span>())<br>cout &lt;&lt; iter-&gt;second &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">//修改实值</span><br>iter-&gt;second = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> num2 = maps[<span class="hljs-string">"jane"</span>]; <span class="hljs-comment">// 100</span><br>cout &lt;&lt; num2 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>需要注意的是subscript（下标）操作既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">maps[<span class="hljs-string">"abc"</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//左值运用int num = masp["abd"]; //右值运用</span><br></code></pre></td></tr></tbody></table></figure><p>无论如何，subscript操作符都会先根据键值找出实值，源码如下：</p><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">...T&amp; operator[](const key_type&amp; k){<br>    <span class="hljs-keyword">return</span> (*((<span class="hljs-built_in">insert</span>(value_type(k, T()))).<span class="hljs-built_in">first</span>)).<span class="hljs-built_in">second</span>;<br>}...<br></code></pre></td></tr></tbody></table></figure><p>代码运行过程是：首先根据键值和实值做出一个元素，这个元素的实值未知，因此产生一个与实值型别相同的临时对象替代：</p><p>再将这个对象插入到map中，并返回一个pair：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">pair&lt;iterator,<span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(value_type(k, T()))</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>pair第一个元素是迭代器，指向当前插入的新元素，如果插入成功返回true，此时对应左值运用，根据键值插入实值。插入失败（重复插入）返回false，此时返回的是已经存在的元素，则可以取到它的实值</p><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">(insert(value_<span class="hljs-keyword">type</span>(k, <span class="hljs-type">T</span>()))).first; //迭代器<br>*((insert(value_<span class="hljs-keyword">type</span>(k, <span class="hljs-type">T</span>()))).first); //解引用<br>(*((insert(value_<span class="hljs-keyword">type</span>(k, <span class="hljs-type">T</span>()))).first)).second; //取出实值<br></code></pre></td></tr></tbody></table></figure><p>由于这个实值是以引用方式传递，因此作为左值或者右值都可以</p><h1 id="16-36-set和map的区别multimap和multiset的区别"><a class="markdownIt-Anchor" href="#16-36-set和map的区别multimap和multiset的区别"></a> 16: 36、set和map的区别，multimap和multiset的区别</h1><p>set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是 identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素</p><p>map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。</p><p>他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入。</p><p>multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</p><p><strong>红黑树概念</strong></p><p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p><p>1、它是二叉排序树（继承二叉排序树特显）：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。<ul><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。<ul><li>左、右子树也分别为二叉排序树。<br>2、它满足如下几点要求：</li><li>树中所有节点非红即黑。<ul><li>根节点必为黑节点。</li><li>红节点的子节点必为黑（黑节点子节点可为黑）。</li><li>从根到NULL的任何路径上黑结点数相同。<br>3、查找时间一定可以控制在O(logn)。</li></ul></li></ul></li></ul></li></ul><h1 id="17-37-stl中unordered_map和map的区别和应用场景"><a class="markdownIt-Anchor" href="#17-37-stl中unordered_map和map的区别和应用场景"></a> 17: 37、STL中unordered_map和map的区别和应用场景</h1><p>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</p><p>unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大</p><p>从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</p><h1 id="18-38-hashtable中解决冲突有哪些方法"><a class="markdownIt-Anchor" href="#18-38-hashtable中解决冲突有哪些方法"></a> 18: 38、hashtable中解决冲突有哪些方法？</h1><p><strong>记住前三个：</strong></p><p>线性探测</p><p>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p><p><strong>开链</strong></p><p>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p><p><strong>再散列</strong></p><p>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p><p><strong>二次探测</strong></p><p>使用hash函数计算出的位置如果已经有元素占用了，按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p><p><strong>公共溢出区</strong></p><p>一旦hash函数计算的结果相同，就放入公共溢出区</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-21-40</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>deque(🗃)</title>
    <link href="/posts/25249/"/>
    <url>/posts/25249/</url>
    
    <content type="html"><![CDATA[<p>📝deque(🗃)::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，<br>虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</p><p>![[deque 原理图.excalidraw]]</p><p>deque和vector的区别<br>一个是deque运行<strong>在常数时间内</strong>对头端进行元素操作(最重要)<br>二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来</p><p>如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque</p><h1 id="2-底层结构"><a class="markdownIt-Anchor" href="#2-底层结构"></a> 2: 底层结构</h1><p>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性<br>deque的数据结构如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">deque</span><br>{<br>    ...<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">typedef</span> pointer* map_pointer;<span class="hljs-comment">//指向map指针的指针</span><br>    map_pointer map;<span class="hljs-comment">//指向map</span><br>    size_type map_size;<span class="hljs-comment">//map的大小</span><br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">itertator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!question] #📕<br><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021322.png" alt=""></p></blockquote><h1 id="3-迭代器还没看"><a class="markdownIt-Anchor" href="#3-迭代器还没看"></a> 3: 迭代器(还没看)</h1><p>deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。<br>deque的迭代器数据结构如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__deque_iterator</span><br>{<br>    ...<br>    T* cur;<span class="hljs-comment">//迭代器所指缓冲区当前的元素</span><br>    T* first;<span class="hljs-comment">//迭代器所指缓冲区第一个元素</span><br>    T* last;<span class="hljs-comment">//迭代器所指缓冲区最后一个元素</span><br>    map_pointer node;<span class="hljs-comment">//指向map中的node</span><br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220021453.png" alt=""></p><p>deque迭代器的“++”、“–”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL容器 (🗃)</title>
    <link href="/posts/354/"/>
    <url>/posts/354/</url>
    
    <content type="html"><![CDATA[<p>📝STL (🗃)::</p><!-- basicblock-end --><p>[[23、常见容器性质总结？]]</p><h1 id="1-vector"><a class="markdownIt-Anchor" href="#1-vector"></a> 1: [[vector (🗃)]]</h1><h2 id="11-heapstl"><a class="markdownIt-Anchor" href="#11-heapstl"></a> 1.1: [[heap(STL)(🗃)]]</h2><p>[[priority_queue]]</p><h2 id="12"><a class="markdownIt-Anchor" href="#12"></a> 1.2:</h2><h1 id="2-map-类容器"><a class="markdownIt-Anchor" href="#2-map-类容器"></a> 2: [[map 类容器(🗃)]]</h1><h1 id="3-list-类容器"><a class="markdownIt-Anchor" href="#3-list-类容器"></a> 3: [[list 类容器(🗃)]]</h1><h1 id="4-set"><a class="markdownIt-Anchor" href="#4-set"></a> 4: [[set(🗃)]]</h1><h1 id="5-deque"><a class="markdownIt-Anchor" href="#5-deque"></a> 5: [[deque(🗃)]]</h1><p>[[stack &amp;&amp; queue(🗃)]]</p><h1 id="6-hash"><a class="markdownIt-Anchor" href="#6-hash"></a> 6: hash</h1><h2 id="61-hash-table"><a class="markdownIt-Anchor" href="#61-hash-table"></a> 6.1: [[hash table]]</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>list 类容器(🗃)</title>
    <link href="/posts/176/"/>
    <url>/posts/176/</url>
    
    <content type="html"><![CDATA[<h1 id="1-slist"><a class="markdownIt-Anchor" href="#1-slist"></a> 1: [[slist]]</h1><h1 id="2-list"><a class="markdownIt-Anchor" href="#2-list"></a> 2: [list]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/121/"/>
    <url>/posts/121/</url>
    
    <content type="html"><![CDATA[<h1 id="1-list与queue之间的区别"><a class="markdownIt-Anchor" href="#1-list与queue之间的区别"></a> 1: list与queue之间的区别</h1><p>list和queue都是常见的数据结构。list是一种有序集合，支持随机访问和修改，并提供了方便的插入和删除元素的操作。<br>queue是一种先进先出（FIFO）的数据结构，新元素会被添加到队列的末尾，而队列中的元素会按照它们被添加的顺序被移除。</p><h1 id="2-vector"><a class="markdownIt-Anchor" href="#2-vector"></a> 2: vector</h1><ol><li>[[list 类容器(🗃)|list]] 不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</li><li>list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</li></ol><h1 id="3-vector-与-deque-的区别"><a class="markdownIt-Anchor" href="#3-vector-与-deque-的区别"></a> 3: vector 与 deque 的区别</h1><ol start="5"><li>deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；可以在头尾两端分别做元素的插入和删除操作；</li><li>deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作，二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19、map中与find的区别？</title>
    <link href="/posts/44792/"/>
    <url>/posts/44792/</url>
    
    <content type="html"><![CDATA[<p>📝19、map中与find的区别？::</p><!-- basicblock-end --><ol><li>map的下标运算符[]的作用是：<ol><li>将关键码作为下标去执行查找，并返回对应的值；</li><li>如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</li></ol></li><li>map的find函数：<ol><li>用关键码执行查找，找到了返回该位置的迭代器；</li><li>如果不存在这个关键码，就返回尾迭代器。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hash_map</title>
    <link href="/posts/16311/"/>
    <url>/posts/16311/</url>
    
    <content type="html"><![CDATA[<p>📝hash_map::</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>和map的区别，hash_map如何解决冲突以及扩容</title>
    <link href="/posts/53600/"/>
    <url>/posts/53600/</url>
    
    <content type="html"><![CDATA[<p>📝和map的区别，hash_map如何解决冲突以及扩容::</p><!-- basicblock-end --><blockquote><p>[!question] #📕</p></blockquote><ol start="3"><li>所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些，</li><li>那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</li><li>如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</li><li>unordered_map的底层实现是hash_table;</li><li>hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</li><li><strong>什么时候扩容</strong>：当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。</li><li><strong>扩容(resize)</strong>, 就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map 类容器(🗃)</title>
    <link href="/posts/22130/"/>
    <url>/posts/22130/</url>
    
    <content type="html"><![CDATA[<p>📝map 类容器(🗃)::</p><!-- basicblock-end --><p>![[map 类容器(🗃)表格. excalidraw]]</p><h1 id="1-map"><a class="markdownIt-Anchor" href="#1-map"></a> 1: [[map(🗃)]]</h1><p>map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</p><h1 id="2-unordered_map"><a class="markdownIt-Anchor" href="#2-unordered_map"></a> 2: [[unordered_map(🗃)]]</h1><p>存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的<br>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。<br>不同的是unordered_map不会根据key的大小进行排序，</p><h1 id="3-hash_map"><a class="markdownIt-Anchor" href="#3-hash_map"></a> 3: [[hash_map]]</h1><h1 id="4-容器去重"><a class="markdownIt-Anchor" href="#4-容器去重"></a> 4: [[容器去重]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16、map插入方式有哪几种？</title>
    <link href="/posts/40455/"/>
    <url>/posts/40455/</url>
    
    <content type="html"><![CDATA[<p>📝16、map插入方式有哪几种？::</p><!-- basicblock-end --><ol><li>用insert函数插入pair数据，💡这个就行了</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">mapStudent.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, string&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">"student_one"</span>)); <br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>用insert函数插入value_type数据</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">mapStudent.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, string&gt;::<span class="hljs-built_in">value_type</span> (<span class="hljs-number">1</span>, <span class="hljs-string">"student_one"</span>));<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>在insert函数中使用[[make_pair()]]函数</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">mapStudent.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"student_one"</span>)); <br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>用数组方式插入数据</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">mapStudent[<span class="hljs-number">1</span>] = <span class="hljs-string">"student_one"</span>; <br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>O(logn)</title>
    <link href="/posts/36970/"/>
    <url>/posts/36970/</url>
    
    <content type="html"><![CDATA[<p>📝O(logn)::</p><!-- basicblock-end --><blockquote><p>[!question] #📕</p></blockquote><p>时间复杂度是用来衡量算法执行时间的一种度量方法。对于一个算法，它的时间复杂度表示为 O(f(n))，其中 f(n) 是算法执行次数和输入数据量 n 的关系。</p><p>如果时间复杂度表示为 O(logn)，这意味着随着输入数据量 n 的增加，算法执行次数的增长率为 log(n)。也就是说，如果输入数据量增加一倍，算法执行次数只会增加一个对数量级。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15、如何在共享内存上使用STL标准库？</title>
    <link href="/posts/24866/"/>
    <url>/posts/24866/</url>
    
    <content type="html"><![CDATA[<p>📝15、如何在共享内存上使用STL标准库？::</p><!-- basicblock-end --><ol><li>想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。</li></ol><p>我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。</p><p>当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。</p><p>一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。</p><ol start="2"><li>假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？</li></ol><p>一个方法就是进程A把容器放在共享内存中的<strong>确定地址</strong>上（fixed offsets），则进程B可以从该已知地址上获取容器。</p><p>另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。</p><p>进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</title>
    <link href="/posts/24673/"/>
    <url>/posts/24673/</url>
    
    <content type="html"><![CDATA[<p>📝14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？::</p><!-- basicblock-end --><p>[[红黑树]]</p><blockquote><p>[!question] #📙</p></blockquote><ol><li>他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn)时间内完成，因此可以完成高效的插入删除；</li><li>在这里我们定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</li><li>因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</li></ol><h1 id="1-map-set是怎么实现的"><a class="markdownIt-Anchor" href="#1-map-set是怎么实现的"></a> 1: map、set是怎么实现的</h1><p>map 和 set 都是基于红黑树实现的。<br>红黑树是一种自平衡的二叉查找树，它在保证查找、插入和删除操作复杂度为 O(log n) 的同时，还能够保证树的高度尽可能地小。<br>这使得红黑树非常适合用来实现 map 和 set 这样的容器。</p><p>[[O(logn)]]</p><h1 id="2-红黑树是怎么能够同时实现这两种容器"><a class="markdownIt-Anchor" href="#2-红黑树是怎么能够同时实现这两种容器"></a> 2: 红黑树是怎么能够同时实现这两种容器？</h1><p>红黑树之所以能够实现 map 和 set 这两种容器，是因为它们都需要一个支持快速插入、查找和删除元素的数据结构。红黑树正好满足这些需求，因此它被用来实现这两种容器。</p><p>红黑树是一种平衡二叉搜索树，它能够保证在插入、删除和搜索操作的时候，所需的时间复杂度都是对数级别的。它的实现方式使得它能够同时满足 <code>map</code> 和 <code>set</code> 的要求。</p><p><code>map</code>是一种关联容器，它存储了一组键值对，并能够按照键快速查询值。红黑树可以用来实现<code>map</code>，因为它可以通过比较键值来排序元素，从而使得查询键值对变得快速。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符重载</title>
    <link href="/posts/22011/"/>
    <url>/posts/22011/</url>
    
    <content type="html"><![CDATA[<p>📝运算符重载::</p><!-- basicblock-end --><p>运算符重载是指在 C++ 中，允许用户重新定义现有运算符的含义。<br>这样，用户可以使用已经定义好的运算符来操作自定义的类型。<br>举个例子，假设你定义了一个名为 <code>Complex</code> 的类来表示复数，那么你可以重载 <code>+</code> 运算符来实现两个复数之间的加法。这样，以后你就可以像下面这样编写代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">Complex <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>Complex c = a + b;<br><br></code></pre></td></tr></tbody></table></figure><p>在上面的例子中，你重载了 <code>+</code> 运算符，让它能够用来计算两个复数之间的和。换句话说，运算符重载允许你为现有运算符定义新的含义。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12、容器内部删除一个元素</title>
    <link href="/posts/20185/"/>
    <url>/posts/20185/</url>
    
    <content type="html"><![CDATA[<p>📝12、容器内部删除一个元素::</p><!-- basicblock-end --><h1 id="1-顺序容器序列式容器比如vector-deque"><a class="markdownIt-Anchor" href="#1-顺序容器序列式容器比如vector-deque"></a> 1: 顺序容器（序列式容器，比如vector、deque）</h1><p>erase [[迭代器(🗃)]]不仅使所指向被删除的迭代器失效，而且<strong>使被删元素之后的所有迭代器失效</strong><br>因为破坏了后边的顺序, list除外</p><p>所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p><p>It = c.erase(it);</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};<br>vec.<span class="hljs-built_in">erase</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>); <span class="hljs-comment">// 删除 vec 中第 3 个元素</span><br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-关联容器关联式容器比如map-set-multimap-multiset等"><a class="markdownIt-Anchor" href="#2-关联容器关联式容器比如map-set-multimap-multiset等"></a> 2: 关联容器(关联式容器，比如map、set、multimap、multiset等)</h1><p>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；<br>c.erase(it++)</p><blockquote><p>[!success] #✅<br>当您使用erase()函数删除一个迭代器时，它实际上删除了该迭代器所指向的元素。由于erase()函数的返回值是void，因此删除元素后该迭代器就失效了。<br>为了保证迭代器的有效性，<strong>采用erase(it++)的方式来删除迭代器, 在删除该迭代器所指向的元素后，它就会自动指向下一个元素，从而保证迭代器的有效性</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
      <tag>✅</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器(🗃)</title>
    <link href="/posts/22579/"/>
    <url>/posts/22579/</url>
    
    <content type="html"><![CDATA[<p>📝迭代器::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>迭代器是一种对象，它允许你遍历序列中的每个元素。<br>例如，如果你有一个列表，你可以使用迭代器来遍历列表中的所有元素。<br>迭代器提供了一种简单的方法来遍历序列，并且可以在不需要了解底层实现细节的情况下遍历序列中的元素。<br>迭代器是一种抽象概念，它存在于许多不同的编程语言中，并且在许多情况下都是非常有用的。</p><h1 id="2-实现原理"><a class="markdownIt-Anchor" href="#2-实现原理"></a> 2: 实现原理</h1><p>1、迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p><p>2、迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的[[source/_posts/👨🏻‍💻code/C++/阿秀/STL模板库-01-20/运算符重载|运算符重载]]。<br>这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p><p>3、最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</p><h1 id="3-unordered_map-迭代器例子"><a class="markdownIt-Anchor" href="#3-unordered_map-迭代器例子"></a> 3: unordered_map 迭代器例子</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 创建一个 unordered_map</span><br>    std::unordered_map&lt;std::string, <span class="hljs-type">int</span>&gt; map;<br><br>    <span class="hljs-comment">// 插入一些键/值对</span><br>    map[<span class="hljs-string">"foo"</span>] = <span class="hljs-number">1</span>;<br>    map[<span class="hljs-string">"bar"</span>] = <span class="hljs-number">2</span>;<br>    map[<span class="hljs-string">"baz"</span>] = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 使用迭代器遍历 unordered_map 中的所有键/值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); ++it)<br>    {<br>        <span class="hljs-comment">// 获取当前迭代器指向的键/值对</span><br>        <span class="hljs-type">const</span> std::pair&lt;std::string, <span class="hljs-type">int</span>&gt;&amp; p = *it;<br><br>        <span class="hljs-comment">// 输出键/值对</span><br>        std::cout &lt;&lt; p.first &lt;&lt; <span class="hljs-string">": "</span> &lt;&lt; p.second &lt;&lt; std::endl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-26-stl中迭代器失效的情况有哪些"><a class="markdownIt-Anchor" href="#4-26-stl中迭代器失效的情况有哪些"></a> 4: [[26、STL中迭代器失效的情况有哪些？]]</h1><h1 id="5-迭代器的分类"><a class="markdownIt-Anchor" href="#5-迭代器的分类"></a> 5: [[迭代器的分类(🗃)]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>🗃️</tag>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>底层结构</title>
    <link href="/posts/56617/"/>
    <url>/posts/56617/</url>
    
    <content type="html"><![CDATA[<p>📝底层结构::</p><!-- basicblock-end --><p>动态数组vector，不用关心初始的大小，可以随意的添加数据</p><p><strong>vector的底层实现也是普通数组</strong>。</p><blockquote><p>vector的底层实现是array，严格来讲vector是容器，不是数组</p></blockquote><p>![[vector 容器实现与扩充 2022-10-21 17.00.06.excalidraw|700]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>容器去重</title>
    <link href="/posts/55122/"/>
    <url>/posts/55122/</url>
    
    <content type="html"><![CDATA[<p>📝容器去重::</p><!-- basicblock-end --><p><code>unordered_map</code>是一种关联容器，它维护着一组键值对。在插入键值对时，它会把键作为唯一的标识，如果发现已经有相同的键存在，就会覆盖掉原来的值。这样，就保证了在同一个<code>unordered_map</code>中每个键值对的键都是唯一的。</p><p>如果你想要一个可以为任意类型的键去重的容器，除了 <code>unordered_map</code>，你还可以使用 <code>unordered_set</code>。</p><p>但是，与<code>unordered_map</code>不同的是，<code>unordered_set</code>不保存值，<strong>只保存键</strong>，这意味着它只能用来存储唯一的键值，而不能像<code>unordered_map</code>那样存储键值对。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中 map如何通过 key 来返回 value</title>
    <link href="/posts/45143/"/>
    <url>/posts/45143/</url>
    
    <content type="html"><![CDATA[<p>📝C++中 map如何通过 key 来返回 value::</p><!-- basicblock-end --><h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1:</h1><p>map.first<br>map.second</p><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2:</h1><p>在 C++ 中，可以使用 map 的 <code>at</code> 成员函数来通过 key 来返回 value。比如，如果我们有一个 map <code>my_map</code>，其中包含了一些键值对，那么我们可以这样返回指定键对应的值：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> key = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> value = my_map.<span class="hljs-built_in">at</span>(key);<br></code></pre></td></tr></tbody></table></figure><p>请注意，如果指定的键不存在于 map 中，则会抛出一个 <code>std::out_of_range</code> 异常。因此，在使用 <code>at</code> 时，应该确保 map 中包含了指定的键。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>50.第一个只出现一次的字符</title>
    <link href="/posts/26780/"/>
    <url>/posts/26780/</url>
    
    <content type="html"><![CDATA[<p>📝50.第一个只出现一次的字符::<a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个只出现一次的字符 - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-数组"><a class="markdownIt-Anchor" href="#1-数组"></a> 1: 数组</h1><p>时间复杂度: O(n) : 遍历所有的元素<br>空间复杂度O(1): 只开辟了 26 个空间</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> arry[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : s){<br>            arry[i-<span class="hljs-string">'a'</span>]++;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i : s ){<br>            <span class="hljs-keyword">if</span>(arry[i-<span class="hljs-string">'a'</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>        }<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-哈希表"><a class="markdownIt-Anchor" href="#2-哈希表"></a> 2: 哈希表</h1><p>C++没有有序的哈希表</p><p>[[C++中 map如何通过 key 来返回 value]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>49. 丑数</title>
    <link href="/posts/15818/"/>
    <url>/posts/15818/</url>
    
    <content type="html"><![CDATA[<p>📝49. 丑数::<a href="https://leetcode.cn/problems/chou-shu-lcof/">剑指 Offer 49. 丑数 - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1: 思路</h1><ul><li>整体思路：<ul><li>除了第一个丑数外，所有的丑数都是某一个丑数的 2、3 或 5 倍的数字</li><li>因为要从小到大求第 n 个丑数，所以需要按照顺序每次获取下一个最小的丑数，最终获得第 n 个</li></ul></li><li>复杂度：<ul><li>时间复杂度：O(n)。只需要 n 次遍历即可求得第 n 个丑数</li><li>空间复杂度：O(n)。需要保存动态规划的整体状态数组</li></ul></li></ul><h1 id="2-算法流程"><a class="markdownIt-Anchor" href="#2-算法流程"></a> 2: 算法流程</h1><p>状态定义： dp[n] 表示第 n 个丑数，<br>a 表示 2 倍数字的索引用于 <code>dp[a]*2</code>,<br>b 表示 3 倍数字的索引用于 <code>dp[b]*3</code><br>c 表示 5 倍数字的索引用于 <code>dp[c]*5</code></p><p>初始状态： dp[0]=1，因为第一个丑数是 1</p><p>转移方程：<br>dp[n]=min(dp[a]∗2,dp[b]∗3,dp[c]∗5)<br>每次计算之后，<br>如果 2 倍的数字最小，则 a++，<br>如果 3 倍的数字最小，则 b++，<br>如果 5 倍的数字最小，则 c++</p><p>![[49. 丑数 2022-12-13 10.23.38.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> dp[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span> , b = <span class="hljs-number">0</span> , c = <span class="hljs-number">0</span>; <span class="hljs-comment">// 各自对应因子的dp下标值</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++){<br>            <span class="hljs-type">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(n2, n3), n5);<br>            <span class="hljs-keyword">if</span>(dp[i] == n2) a++; <span class="hljs-comment">// 下标值后移一位</span><br>            <span class="hljs-keyword">if</span>(dp[i] == n3) b++;<br>            <span class="hljs-keyword">if</span>(dp[i] == n5) c++;<br>        }<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>        <br><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48. 最长不含重复字符的子字符串</title>
    <link href="/posts/41912/"/>
    <url>/posts/41912/</url>
    
    <content type="html"><![CDATA[<p>📝48. 最长不含重复字符的子字符串::<a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>![[48. 最长不含重复字符的子字符串 2022-12-13 09.08.43.excalidraw]]</p><p>这个代码错了, 下次在看</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> mm[<span class="hljs-number">300</span>];<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>,  ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//双指针记录子字符串范围 哈希表记录字母出现的次数 避免重复</span><br>        <span class="hljs-keyword">while</span>(l &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>()){<br>            <span class="hljs-comment">//如果没有重复的字母出现在子字符串中 那么移动右指针扩大字符串范围</span><br>            <span class="hljs-keyword">while</span>(r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; mm[s[r] - <span class="hljs-number">0</span>] &lt; <span class="hljs-number">1</span>) {<br>                mm[s[r] - <span class="hljs-number">0</span>]++;<br>                r++;<br>            }<br>            ans = <span class="hljs-built_in">max</span>(ans, r-l);<br>            <span class="hljs-comment">//如果有重复的字母出现在子字符串中 那么移动左指针缩小字符串范围</span><br>            <span class="hljs-keyword">while</span>(l &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; mm[s[r] - <span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>){<br>                mm[s[l] - <span class="hljs-number">0</span>]--;<br>                l++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>同步消息队列</title>
    <link href="/posts/9343/"/>
    <url>/posts/9343/</url>
    
    <content type="html"><![CDATA[<p>📝同步消息队列::</p><!-- basicblock-end --><p>同步消息队列是指线程间通信时，线程发送消息和接收消息的过程是同步的。<br>这意味着，当线程发送消息后，它会被阻塞，直到另一个线程接收到该消息为止。<br>同步消息队列可以保证消息的顺序，<strong>但是会导致线程阻塞</strong>，影响程序的效率。</p><p>同步消息队列（synchronous message queue）是一种分布式消息系统，它可以让多个应用程序之间实现同步消息传递。这种系统通常包括一个中心服务器和多个客户端应用程序。</p><p>在同步消息队列中，客户端应用程序可以向中心服务器发送消息，也可以从中心服务器接收消息。每条消息都有一个唯一的 ID，可以用来标识这条消息。当客户端应用程序向中心服务器发送消息时，会等待中心服务器的响应。中心服务器收到消息后，会将消息加入消息队列，并向客户端应用程序发送响应。</p><h1 id="1-同步与异步消息队列的不同"><a class="markdownIt-Anchor" href="#1-同步与异步消息队列的不同"></a> 1: 同步与异步消息队列的不同</h1><blockquote><p>[!cite] 同步消息队列和异步消息队列都是分布式消息系统，它们可以让多个应用程序之间实现消息传递。但是，这两种消息队列在原理上有一些不同。</p></blockquote><h2 id="11-同步"><a class="markdownIt-Anchor" href="#11-同步"></a> 1.1: 同步</h2><p>同步消息队列是一种<strong>阻塞式的消息队列</strong>，它要求客户端应用程序在发送消息之后必须等待中心服务器的响应。<br>这意味着，发送消息的客户端应用程序会被挂起，直到中心服务器响应为止。<br>因此，如果中心服务器在响应时出现问题，比如说崩溃或网络中断，发送消息的客户端应用程序就会一直处于挂起状态，无法继续执行。</p><h2 id="12-异步"><a class="markdownIt-Anchor" href="#12-异步"></a> 1.2: 异步</h2><p>相比之下，异步消息队列是一种<strong>非阻塞式的消息队列</strong>，它不要求客户端应用程序等待中心服务器的响应。<br>当客户端应用程序向中心服务器发送消息时，可以立刻继续执行其他任务，而不用等待响应。中心服务器收到消息后，会将消息加入消息队列，并向客户端应用程序发送响应。</p><p>由于异步消息队列不要求客户端应用程序等待中心服务器的响应，它可以提高系统的吞吐量和可用性。但是，由于消息的响应是异步的，客户端应用程序可能需要更复杂的逻辑来处理消息的响应。此外，由于消息的响应是异步的，客户端应用程序可能需要额外的代码来管理消息的重试和失败。</p><p>总之，同步消息队列和异步消息队列都是有用的工具，但它们在实现原理上有一些不同。在选择消息队列时，需要根据实际应用场景来考虑这些不同。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/posts/5159/"/>
    <url>/posts/5159/</url>
    
    <content type="html"><![CDATA[<p>📝消息队列::</p><!-- basicblock-end --><h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1:</h1><h2 id="11-异步消息队列"><a class="markdownIt-Anchor" href="#11-异步消息队列"></a> 1.1: [[异步消息队列]]</h2><h2 id="12-同步消息队列"><a class="markdownIt-Anchor" href="#12-同步消息队列"></a> 1.2: [[同步消息队列]]</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>管道</title>
    <link href="/posts/14893/"/>
    <url>/posts/14893/</url>
    
    <content type="html"><![CDATA[<p>📝管道::</p><!-- basicblock-end --><p>管道是指在线程间通信中，用于在不同线程之间传输数据的一种通信机制。<br>通常，管道可以实现线程之间的单向通信，<strong>即一个线程只能向管道写入数据，而另一个线程只能从管道中读取数据</strong>。<br>管道提供了一种简单、高效的方式来在线程之间传递数据。</p><p>在不同的编程语言和操作系统中，管道的实现方式可能会有所不同。例如，在 Linux 操作系统中，管道是作为一种特殊的文件类型实现的，程序可以通过读写管道文件来实现线程间通信。<br>在 Java 中，管道通常由两个类实现：PipedInputStream 和 PipedOutputStream，程序可以通过这两个类来实现线程间通信。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>muduo线程间的通信是靠什么实现的？</title>
    <link href="/posts/12752/"/>
    <url>/posts/12752/</url>
    
    <content type="html"><![CDATA[<p>📝muduo线程间的通信是靠什么实现的？::</p><!-- basicblock-end --><p>muduo是一个多线程网络库，它提供了几种不同的方式来实现线程间通信。下面列举了一些常见的方式：</p><ol start="2"><li>消息队列：线程间通过发送消息到一个消息队列来进行通信。消息队列是一种异步的通信机制，在线程间通信时不会产生阻塞。</li><li>事件通知：<br>Muduo提供了一个EventLoop类来管理事件循环。通常一个线程只会有一个EventLoop对象，并且它会在该线程中运行。EventLoop提供了一些方法来添加或删除事件，并且会自动监听这些事件，并在事件发生时执行相应的回调函数。</li></ol><h1 id="1-异步消息队列"><a class="markdownIt-Anchor" href="#1-异步消息队列"></a> 1: [[异步消息队列]]</h1><p>异步消息队列（async message queue）是指一种可以在线程间或进程间传递消息的机制。它与 eventfd 的主要区别在于，异步消息队列是一个存储消息的容器，可以存储多条消息，而 eventfd 只能存储一个整数值。</p><p>异步消息队列通常用于传递比较复杂的消息，而 eventfd 更适合用于简单的通知类型的消息。</p><h1 id="2-eventfd"><a class="markdownIt-Anchor" href="#2-eventfd"></a> 2: [[eventfd]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>muduo 与 eventfd</title>
    <link href="/posts/58802/"/>
    <url>/posts/58802/</url>
    
    <content type="html"><![CDATA[<p>📝muduo 与 eventfd::</p><!-- basicblock-end --><p>eventfd 是 Linux 中一个用于实现进程间或线程间同步的工具。它通过一个计数器来记录写入操作的次数，并允许线程或进程通过读取 eventfd 来获取这个值。</p><p>muduo 可以通过使用 eventfd 来实现线程间的同步。例如，当一个线程处理完一个任务后，它可以向 eventfd 写入一个数据，从而通知另一个线程这个任务已经完成。另一个线程可以通过读取 eventfd 来获取通知，并继续处理下一个任务。</p><p>因此，muduo 可以通过使用 eventfd 来实现线程间的同步，从而提高服务器的性能。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>eventfd</title>
    <link href="/posts/57605/"/>
    <url>/posts/57605/</url>
    
    <content type="html"><![CDATA[<p>📝eventfd::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>eventfd 是 Linux 中一个用于同步的工具，它可以用于线程间或进程间的通信。<br>eventfd是Linux内核中的一个系统调用，它可以用于在线程间或进程间传递事件。<br>它的工作方式类似于<strong>异步消息队列</strong>，但提供了更快的性能。<br>eventfd支持两种模式：非阻塞模式和阻塞模式。</p><ul><li>在非阻塞模式下，当事件被传递到eventfd时，会立即返回，不会等待其它线程的处理。</li><li>而在阻塞模式下，如果没有线程正在处理事件，则当前线程会阻塞在eventfd上等待其它线程处理完事件，直到可以继续工作。</li></ul><h1 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2: 原理</h1><blockquote><p>[!example]<br>通过 eventfd，进程可以通过读写文件描述符来操作计数器。<br>例如，一个进程可以通过写入一个整数值来将该值加到计数器上，另一个进程可以通过读取该值来从计数器上减去该值。<br>此外，eventfd 还允许进程指定一个标志，来决定在写入和读取时如何处理计数器的值。</p></blockquote><p>它通过一个<strong>计数器</strong>来实现这一功能。</p><ul><li><p>当一个线程或进程向 eventfd <strong>写入数据</strong>时，它会将计数器的值<strong>增加</strong>相应的数量。这样，另一个线程或进程就可以通过读取 eventfd 来获取这个值，从而得知已经发生了多少次写入操作。</p><ul><li>summary eventfd里面维持了一个8字节的计数器，每次向一个eventfd执行写操作都可以向计数器中加值。</li></ul></li><li><p>这个计数器也可以被设置为自动重置，这样当一个线程或进程<strong>读取完</strong> eventfd 的值后，计数器会被自动重置为 0，以便于更新新的写入操作。</p><ul><li>summary 在读操作中会把这个值读取出来，并将计数器清0。</li></ul></li></ul><p>通过这种方式，eventfd 可以在多线程或多进程环境中实现简单而有效的同步。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异步消息队列</title>
    <link href="/posts/35119/"/>
    <url>/posts/35119/</url>
    
    <content type="html"><![CDATA[<p>📝异步消息队列::</p><!-- basicblock-end --><p>异步消息队列（asynchronous message queue）是一种用于在线程间传递消息的机制。<br>它通常由一个队列和一些线程同步机制组成。</p><p>当一个线程有消息要发送给另一个线程时，它会将消息放入队列中，而另一个线程会从队列中取出消息并处理。</p><p>这样就可以实现线程间的异步通信，避免线程之间的同步问题，提高程序的执行效率。</p><h1 id="1-应用场景"><a class="markdownIt-Anchor" href="#1-应用场景"></a> 1: 应用场景</h1><p>异步消息队列可以用于许多不同的应用场景，<br>比如操作系统中的消息传递机制、多线程应用程序中的线程间通信、网络库中的事件通知等。</p><h1 id="2-异步队列与管道的区别"><a class="markdownIt-Anchor" href="#2-异步队列与管道的区别"></a> 2: 异步队列与管道的区别</h1><p>管道与异步队列是两种不同的线程通信机制，<br>它们之间的区别主要在于<strong>通信的方向</strong>和<strong>实现方式</strong></p><p>管道通常实现<strong>单向通信</strong>，即一个线程向管道写入数据，另一个线程从管道中读取数据。<br>管道是通过一种特殊的文件类型实现的，程序可以通过读写管道文件来实现线程间通信。</p><p>而异步队列则实现了<strong>双向通信</strong>，即两个线程之间可以相互传递数据。异步队列是通过一种特殊的数据结构（如队列、栈等）来实现的，程序可以通过操作该数据结构来实现线程间通信。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>你的服务器和muduo的有什么区别？</title>
    <link href="/posts/13276/"/>
    <url>/posts/13276/</url>
    
    <content type="html"><![CDATA[<p>📝你的服务器和muduo的有什么区别？::</p><!-- basicblock-end --><p>答：</p><p>事件处理模式、ET和LT、线程间通信eventfd和sockpair。</p><ol><li><p>在我的项目中，使用的是同步IO来模拟proactor模型。在我的服务器中，首先会使用一个线程来进行事件的监听、连接、和数据的IO操作。如果有连接进来的话，那么就需要后序监听该连接的可读事件。如果监听到可读的话，首先会把所有的数据读取完毕，然后使用一个子线程来处理请求。当请求执行完毕之后，又会注册可写事件，让这个IO线程帮进行数据的写操作。也就是说，工作线程自己是不需要进行IO操作的。</p></li><li><p>而在muduo中，是使用主反应堆来监听连接请求。已经连接完毕后，就会把这个连接分发给子反应堆的其中一个。然后在子反应堆中进行事件的可读可写的监听，并处理请求。如果在子反应堆需要费时的IO操作的，子反应堆又会开出一个IO线程来进行读写。</p></li><li><p>另外一个就是在我的项目中，文件的描述符的是使用ET模式的，而muduo里面默认使用的是LT。ET的优点就是内核只会通知一次，而LT模式下，如果数据没有读取完毕，内核会一直通知。但是ET的缺点也是只通知一次，所以要把一次性把所有的数据全部读完，这样数据量大的时候，对其他的连接不公平。而LT模式每个文件描述符可以读取相等的数据，这样会比较公平。</p></li><li><p>eventfd</p></li><li><p>vector + 栈空间的设计。</p><p>我自己项目里面是？</p><p>首先是vector，这个vector可以自动扩容。也就是我们在程序一开始的时候不需要不需要分配很多的内存。在muduo网络库里面其实是分配了</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程间的通信方式(🗃)</title>
    <link href="/posts/32384/"/>
    <url>/posts/32384/</url>
    
    <content type="html"><![CDATA[<p>📝线程间的通信？::</p><!-- basicblock-end --><p>答：</p><h1 id="1-管道"><a class="markdownIt-Anchor" href="#1-管道"></a> 1: [[管道]]</h1><h1 id="2-消息队列"><a class="markdownIt-Anchor" href="#2-消息队列"></a> 2: [[消息队列]]</h1><h1 id="3-异步消息队列"><a class="markdownIt-Anchor" href="#3-异步消息队列"></a> 3: [[异步消息队列]]</h1><ol start="3"><li>共享内存。</li><li>信号量。</li><li>信号。</li><li>socket通信。</li></ol><p>线程间通信的方式有很多种，包括：</p><ol><li>共享内存：多个线程共享同一块内存，在这块内存中进行数据交换。</li><li>消息传递：多个线程通过发送和接收消息来实现通信。<ol><li>这个应该是普通的</li></ol></li><li>信号量：多个线程通过对一个信号量进行操作来协调工作。</li><li>同步对象：多个线程通过对一个同步对象进行操作来协调工作。</li><li>条件变量：多个线程通过监视一个条件变量来协调工作。</li></ol><p>上述方法只是一些常用的线程间通信方式，并不能涵盖所有可能的方法。具体应用时应根据实际情况选择适当的方法。</p><h1 id="4-tip"><a class="markdownIt-Anchor" href="#4-tip"></a> 4: tip</h1><p>如果您想了解更多关于线程间通信的内容，可以考虑以下几点：</p><ol><li>不同的线程间通信方式各有优缺点，在选择方法时应考虑多种因素，包括但不限于性能、安全性和可移植性。</li><li>线程间通信有时也需要进行同步，以避免线程间的数据竞争和错误。可以使用互斥锁、读写锁和信号量等同步工具来实现同步。</li><li>线程间通信的方式也可能会受到硬件和操作系统的限制，因此应注意运行环境的差异。</li><li>线程间通信的实现可能会比较复杂，应注意代码的可读性和可维护性。可以使用线程池、任务队列和消息队列等技术来简化实现。</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>muduo线程间的通信是靠什么实现的？</title>
    <link href="/posts/12744/"/>
    <url>/posts/12744/</url>
    
    <content type="html"><![CDATA[<p>📝muduo线程间的通信是靠什么实现的？::</p><!-- basicblock-end --><p>[[muduo线程间的通信是靠什么实现的？]]</p><p>[[muduo 与 eventfd]]</p><p>muduo是一个开源的C++网络库，它提供了一个高性能的网络通信框架。<br>在muduo中，线程间的通信通常是通过异步消息队列实现的。<br>当一个线程有消息要传递给另一个线程时，它会将消息放入[[异步消息队列]]中，另一个线程会从队列中取出消息并处理。这样就可以避免线程之间的同步问题，提高程序的执行效率。</p><p>靠eventfd实现的。</p><p>[[eventfd]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>端口等级权限</title>
    <link href="/posts/34521/"/>
    <url>/posts/34521/</url>
    
    <content type="html"><![CDATA[<p>📝端口等级权限::</p><!-- basicblock-end --><p>端口是网络通信中用来识别特定应用程序的一个编号。<br>它的等级权限指的是使用特定端口的应用程序需要的权限级别。</p><p>一般来说，端口可以分为三个等级：</p><ul><li><p>常规端口（0-1023）：这些端口由 Internet 协议（IP）协议族规定，用于运行常规服务，例如 HTTP（端口 80）和 SMTP（端口 25）。通常情况下，只有特权用户（例如系统管理员）才能使用这些端口。</p></li><li><p>注册端口（1024-49151）：这些端口由 IANA（Internet Assigned Numbers Authority）分配，用于运行特定的应用程序。这些端口并不属于特权端口，因此任何用户都可以使用它们。</p></li><li><p>动态/私有端口（49152-65535）：这些端口不属于 IANA 的端口范围，可由用户自行分配。这些端口主要用于临时传输数据，不用于正式服务。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>API</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>端口复用</title>
    <link href="/posts/55002/"/>
    <url>/posts/55002/</url>
    
    <content type="html"><![CDATA[<p>📝端口复用::</p><!-- basicblock-end --><p>端口复用是指在一个主机上，多个应用程序可以使用同一个端口。这样，当一个应用程序占用了一个端口后，其他应用程序就可以使用该端口。</p><p>在传统的网络编程中，一个应用程序只能占用一个端口。当该应用程序关闭后，内核会等待一段时间，再释放该端口。<br>如果在这段时间内，另一个应用程序要使用该端口，则会出现错误。<br>启用端口复用可以避免这种情况，提高应用程序的可用性。</p><p>例如，如果应用程序要使用80端口作为Web服务器的端口，则可以启用端口复用，让其他应用程序也可以使用80端口。</p><p>端口复用是指在一台主机上，同一个端口可以被多个应用程序使用。这样，多个应用程序就可以通过同一个端口与外界通信，而不用担心端口冲突问题。</p><p>在网络通信中，端口复用通常用于服务器应用程序，它可以让服务器程序更快速地重新启动，从而提高系统的可用性。</p><p>在 Linux 系统中，可以通过设置<code>SO_REUSEADDR</code>套接字选项来启用端口复用。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> on = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">setsockopt</span>(listenFd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-built_in">sizeof</span>(on)) &lt; <span class="hljs-number">0</span>) <br>{     <br><span class="hljs-comment">// 设置端口复用失败 </span><br>}<br></code></pre></td></tr></tbody></table></figure><p>这样，当应用程序关闭后，内核会立即释放该端口，而不用等待超时。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>API</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Epoll 的工作模式</title>
    <link href="/posts/11698/"/>
    <url>/posts/11698/</url>
    
    <content type="html"><![CDATA[<p>📝Epoll 的工作模式::</p><!-- basicblock-end --><blockquote><p>[!summary]<br><code>LT模式</code> 下，<code>epoll_wait</code> 检测到某个文件描述符有就绪事件，应用程序可以不立即处理，<br>在下次 <code>epoll_wait</code> 的时候还会继续提醒这个事件，直到这个事件被处理。</p><p><code>ET 模式</code>下，检测到某个文件描述符有就绪事件时，应用程序必须立即处理，否则下次 <code>epoll_wait</code> 不再提醒这次事件。</p></blockquote><p>![[水平触发与边沿触发 .excalidraw]]</p><h1 id="1-lt-模式-水平触发"><a class="markdownIt-Anchor" href="#1-lt-模式-水平触发"></a> 1: LT 模式 (水平触发)</h1><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br>读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>a.用户不读数据，数据一直在缓冲区，epoll 会一直通知<br>b.用户只读了一部分数据，epoll会通知<br>c.缓冲区的数据读完了，不通知</p><p>LT(level - triggered)是缺省(默认)的工作方式，并且同时支持 block 和 no-block socket(阻塞与非阻塞)。<br>在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操 作。<br>如果你不作任何操作，内核还是会继续通知你的。<br>- example 如果传出数组还有数据, 你没读完, 还会继续通知你</p><h1 id="2-et-模式边沿触发"><a class="markdownIt-Anchor" href="#2-et-模式边沿触发"></a> 2: ET 模式(边沿触发)</h1><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区<br>读缓冲区有数据 - &gt; epoll检测到了会给用户通知<br>a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了<br>b.用户只读了一部分数据，epoll不通知<br>c.缓冲区的数据读完了，不通知</p><blockquote><p>[!tip] 因为只通知一次, 所以用 while 循环一直把缓冲区的数据的读完</p></blockquote><p>ET(edge - triggered)是高速工作方式，只支持 no-block socket (非阻塞)。<br>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。<br>但是请注意，如果一直不对这个 fd 作 IO 操作(从而导致它再次变成 未就绪)，内核不会发送更多的通知(only once)。<br>- example 传出数组有数据, 但只通知你一次.<br>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。<br>epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄(文件描述符)的阻塞读/阻塞写 操作把处理多个文件描述符的任务饿死</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> {</span><br>    <span class="hljs-type">uint32_t</span>     events; <span class="hljs-comment">/* Epoll events */</span><br>    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">/* User data variable */</span><br>    <br>};<br>常见的Epoll检测事件: <br>- EPOLLIN<br>    - EPOLLOUT<br>    - EPOLLERR<br>    - EPOLLET <span class="hljs-comment">// 设置 ET 模式 : 要添加这个时间</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器的流程框架</title>
    <link href="/posts/42553/"/>
    <url>/posts/42553/</url>
    
    <content type="html"><![CDATA[<p>📝服务器的流程框架::</p><!-- basicblock-end --><p>![[TCP 通信流程.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> 先创建一个用于监听的文件描述符:<br>   <span class="hljs-type">int</span> listenFd = <span class="hljs-built_in">socket</span>(<span class="hljs-type">int</span> af, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol) <span class="hljs-comment">//af = AF_INET(表示IPV4), type = SOCK_STREAM</span><br><span class="hljs-number">2.</span> 再绑定本机的端口号和地址:<br>    <span class="hljs-built_in">bind</span>(listenFd, )<br><span class="hljs-number">3.</span> 再开始监听这个端口<br>    <span class="hljs-built_in">listen</span>(listenfd)<br>        <br><span class="hljs-number">4.</span> 注册一个内核事件表：<br>    <span class="hljs-type">int</span> epollFd = <span class="hljs-built_in">epoll_create</span>(...)<br><span class="hljs-number">5.</span> 将监听文件符注册到内核事件表中：<br>    <span class="hljs-built_in">epoll_ctl</span>(epollFd, listenFd, ...)<br><span class="hljs-number">6.</span> 等待一组文件描述符上的就绪信息：<br>    epoll_event events[MAX_SIZE];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">int</span> size = <span class="hljs-built_in">epoll_wait</span>(epollFd, epoll_event, ...)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) {<br>            <span class="hljs-type">int</span> fd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span>(fd == listenFd) { <span class="hljs-comment">// 新用户连接</span><br><span class="hljs-type">int</span> clientFd = <span class="hljs-built_in">accept</span>(listenFd, ...)<br>                <span class="hljs-built_in">epoll_ctl</span>(epollFd, clientFd, ...)<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].event &amp; EPOLLIN) { <span class="hljs-comment">// 监听到可读</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>                    <span class="hljs-built_in">recv</span>()<br>                }<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].event &amp; EPOLLOUT) { <span class="hljs-comment">// 监听到可写</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>                    <span class="hljs-built_in">send</span>()<br>                }<br>            }<br>        }   <br>    }<br></code></pre></td></tr></tbody></table></figure><p>这段代码实现了一个简单的服务器，它的主要功能是接收客户端的连接，并能够接收客户端发送的数据并进行响应。</p><p>首先，它创建一个用于监听的文件描述符，通过调用<code>socket</code>函数，并将其绑定到一个本地的端口和地址。</p><p>然后，它开始监听这个端口，通过调用<code>listen</code>函数。</p><p>接下来，它创建一个内核事件表，并将监听文件描述符注册到内核事件表中。</p><p>最后，它进入一个循环，等待一组文件描述符上的就绪信息。<br>当有新的客户端连接时，它会接受该连接，并将客户端的文件描述符注册到内核事件表中。<br>当接收到可读或可写的事件时，它会调用 <code>recv</code> 或 <code>send</code> 函数接收或发送数据。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>web 面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>47. 礼物的最大价值</title>
    <link href="/posts/38915/"/>
    <url>/posts/38915/</url>
    
    <content type="html"><![CDATA[<p>📝47. 礼物的最大价值::<a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>![[47. 礼物的最大价值 2022-12-12 11.03.26.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>{<br>        <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> column = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// dp[i][j] 表示从 grid[0][0] 到 grid[i-1][j-1] 时的最大价值</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(row + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(column + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= column; j++) {<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + grid[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[row][column];<br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><p>[[memset]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">210</span>][<span class="hljs-number">210</span>] = {<span class="hljs-number">0</span>} ;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>{ <br>        <span class="hljs-comment">// memset(dp, 0, sizeof(dp));</span><br>        <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> column = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; column; j++){<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span> &amp;&amp; j ==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>){<br>                    dp[i][j] = <span class="hljs-built_in">max</span>( dp[i][j], dp[i<span class="hljs-number">-1</span>][j] +grid[i][j]);<br>                }<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>){<br>                    dp[i][j] = <span class="hljs-built_in">max</span>( dp[i][j], dp[i][j<span class="hljs-number">-1</span>] +grid[i][j]);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[row<span class="hljs-number">-1</span>][column<span class="hljs-number">-1</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>46. 把数字翻译成字符串</title>
    <link href="/posts/57702/"/>
    <url>/posts/57702/</url>
    
    <content type="html"><![CDATA[<p>📝46. 把数字翻译成字符串::<a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>![[46. 把数字翻译成字符串 2022-12-12 09.55.24.excalidraw]]</p><p>[[1.动态规划理论基础]]</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<span class="hljs-comment">// ❓为什么非得是 1000</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>{<br>        string  s = <span class="hljs-built_in">to_string</span>(num); <span class="hljs-comment">// 为了获取"整数 num"的长度</span><br>        <br><br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] == <span class="hljs-string">'1'</span>) dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">'2'</span> &amp;&amp; s[<span class="hljs-number">1</span>] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[<span class="hljs-number">1</span>] &lt;= <span class="hljs-string">'5'</span>) dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br><br>        <span class="hljs-comment">// 考虑 dp 数组脑子里只考虑第一种递推就行, 不要直接想到最后边(五点七边)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> ;  i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">'1'</span>) dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<span class="hljs-comment">// 1 可以和任何数组合</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">'2'</span> &amp;&amp; s[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">'5'</span>) dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];<span class="hljs-comment">// 2 和特殊数组合</span><br>            <span class="hljs-keyword">else</span>  dp[i] = dp[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 不能组合</span><br>        }<br><br>        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 不能用 num.size, 因为 num 是一个数不是一个数组</span><br><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>45. 把数组排成最小的数</title>
    <link href="/posts/4617/"/>
    <url>/posts/4617/</url>
    
    <content type="html"><![CDATA[<p>📝45. 把数组排成最小的数::<a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">面试题45. 把数组排成最小的数 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>‌‌‌　　![[45. 把数组排成最小的数 2022-12-12 08.58.37.excalidraw]]</p><p>[[sort()函数]]</p><blockquote><p>[!question] #疑问  不明白sort 函数中自定义排序的原理</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; x, <span class="hljs-type">const</span> string&amp; y)</span></span>{ <span class="hljs-comment">// ❗️需要在主函数外</span><br>            <span class="hljs-keyword">return</span> x+y &lt; y+x;<br>        }<br>    <span class="hljs-function">string <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        vector&lt;string&gt; vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums){<br>            vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(i));<br>        }<br><br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp);<br><br>        string ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i :vec){<br>            ans+=i;<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>邹工期刊</title>
    <link href="/posts/62141/"/>
    <url>/posts/62141/</url>
    
    <content type="html"><![CDATA[<p>📝邹工期刊::</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
      <category>论文学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>邹工纯铜毕业论文</title>
    <link href="/posts/53686/"/>
    <url>/posts/53686/</url>
    
    <content type="html"><![CDATA[<p>📝邹工纯铜毕业论文::</p><!-- basicblock-end --><h1 id="1-绪论"><a class="markdownIt-Anchor" href="#1-绪论"></a> 1: 绪论</h1><h2 id="11"><a class="markdownIt-Anchor" href="#11"></a> 1.1:</h2><h2 id="12"><a class="markdownIt-Anchor" href="#12"></a> 1.2:</h2><h3 id="121"><a class="markdownIt-Anchor" href="#121"></a> 1.2.1:</h3><h3 id="122"><a class="markdownIt-Anchor" href="#122"></a> 1.2.2:</h3><h3 id="123"><a class="markdownIt-Anchor" href="#123"></a> 1.2.3:</h3><h3 id="124-塑性流动挤出切削工艺原理"><a class="markdownIt-Anchor" href="#124-塑性流动挤出切削工艺原理"></a> 1.2.4: 塑性流动挤出切削工艺原理</h3><p>![[图 1-3 PFM 工艺原理图(邹工)excalidraw]]</p><h3 id="125"><a class="markdownIt-Anchor" href="#125"></a> 1.2.5:</h3><h1 id="2-实验材料与实验过程"><a class="markdownIt-Anchor" href="#2-实验材料与实验过程"></a> 2: 实验材料与实验过程</h1><h1 id="3-塑性流动挤出切削工艺有限元模拟结果与分析"><a class="markdownIt-Anchor" href="#3-塑性流动挤出切削工艺有限元模拟结果与分析"></a> 3: 塑性流动挤出切削工艺有限元模拟结果与分析</h1><h2 id="31-引言"><a class="markdownIt-Anchor" href="#31-引言"></a> 3.1: 引言</h2><h2 id="32-有限元模型的建立"><a class="markdownIt-Anchor" href="#32-有限元模型的建立"></a> 3.2: 有限元模型的建立</h2><h3 id="321-几何结构与网格划分"><a class="markdownIt-Anchor" href="#321-几何结构与网格划分"></a> 3.2.1: 几何结构与网格划分</h3><p>在 PFM 有限元模拟中，将凸模与凹模定义为刚性体，材料选用 AISI-D2，而将工件定义为塑性体，材料选用 C10100。</p><p>将工件网格数量设置为 10000。由于侧面开口处工件材料的塑性流动状况为本研究的重点研究对象，故对此处的工件材料进行局部网格细化，细化比例为 0.01:1。</p><p>对于刚性体，虽然在模拟中不产生变形，但是本研究中需要考虑凸模与凹模的传热影响，因此也需要对凸模与凹模进行合适的网格划分。</p><p>在 PFM 有限元模拟中，随着凸模的下压，工件材料将会从侧面开口与侧面开口以下部分的通道流出，工件形状严重变化，工件网格严重扭曲，极有可能产生网格畸变。当网格畸变达到一定程度时，便会导致有限元模拟出现不收敛的状况，阻碍模拟过程的顺利进行。针对这一问题，DEFORM 软件提供了自适应网格重划分技术，而这一技术可由四种条件触发，它们分别为<strong>干涉深度、最大位移增量、最大时间增量与最大步数增量</strong>，本研究中选用<strong>干涉深度</strong>条件</p><p>对于干涉深度条件值的设置，<strong>如果其值小于或等于最小单元长度的十分之七</strong>，则可以避免出现网格扭曲变形程度过大的情况，所以通过测量本模型中工件的最小单元长度后，将干涉深度条件值设置为 0.04mm。<br>另外，实验与有限元模拟中，<strong>凸模的下压速度均为 20mm/s，下压位移均为 48mm</strong>。<br>由于有限元模拟中<strong>步长深度一般位于最小单元长度的十分之一到三分之一之间</strong>，所以通过测量本模型中工件的最小单元长度后，将步长深度设置为 0.025mm，模拟步数设置为 1920。</p><h3 id="322-本构模型"><a class="markdownIt-Anchor" href="#322-本构模型"></a> 3.2.2: 本构模型</h3><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202212051116286.png" alt="|600"></p><h3 id="323-摩擦模型与传热模型"><a class="markdownIt-Anchor" href="#323-摩擦模型与传热模型"></a> 3.2.3: 摩擦模型与传热模型</h3><p>DEFORM 软件拥有<strong>剪切摩擦</strong>、<strong>库伦摩擦</strong>与兼具两者的<strong>混合摩擦</strong>等形式的摩擦模型，</p><p>本研究中的有限元模拟可以将<strong>摩擦模型</strong>直接简化为<strong>剪切摩擦模型</strong>，</p><blockquote><p>[!summary]</p><ul><li>并将凸模与凹模之间、凸模与工件之间以及凹模与工件之间的摩擦系数均设置为 0.2</li><li>环境温度及凸模、凹模与工件的初始温度均设置为 20℃，</li><li>并将凸模与凹模之间、凸模与工件之间以及凹模与工件之间的传热系数均设置为 40N/sec/mm/℃</li><li>而将凸模、凹模、工件分别与环境之间的传热系数设置为 0.02N/sec/mm/℃</li></ul></blockquote><h3 id="324-模拟参数选定"><a class="markdownIt-Anchor" href="#324-模拟参数选定"></a> 3.2.4: 模拟参数选定</h3><h2 id="33-塑性流动挤出切削工艺过程分析"><a class="markdownIt-Anchor" href="#33-塑性流动挤出切削工艺过程分析"></a> 3.3: 塑性流动挤出切削工艺过程分析</h2><h2 id="34-塑性流动区域划分"><a class="markdownIt-Anchor" href="#34-塑性流动区域划分"></a> 3.4: 塑性流动区域划分</h2><h2 id="35-挤出厚度对塑性流动挤出切削有限元模拟的影"><a class="markdownIt-Anchor" href="#35-挤出厚度对塑性流动挤出切削有限元模拟的影"></a> 3.5: 挤出厚度对塑性流动挤出切削有限元模拟的影</h2><h2 id="36-挤压角度对塑性流动挤出切削有限元模拟的影响"><a class="markdownIt-Anchor" href="#36-挤压角度对塑性流动挤出切削有限元模拟的影响"></a> 3.6: 挤压角度对塑性流动挤出切削有限元模拟的影响</h2><h2 id="37-本章小结"><a class="markdownIt-Anchor" href="#37-本章小结"></a> 3.7: 本章小结</h2><p>时间复杂度 O(N)O(N) ： 其中 N 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N)O(N) 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1)O(1) ，因此使用 O(N)O(N) 时间。<br>空间复杂度 O(N)O(N) ： HashMap 使用 O(N)O(N) 额外空间；最差情况下（输入二叉树为链表时），递归深度达到 N ，占用 O(N)O(N) 的栈帧空间；因此总共使用 O(N)O(N) 空间。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
      <category>论文学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>俞宁纯铜毕业论文</title>
    <link href="/posts/34291/"/>
    <url>/posts/34291/</url>
    
    <content type="html"><![CDATA[<p>📝纯铜毕业论文::</p><!-- basicblock-end --><h1 id="1-绪论"><a class="markdownIt-Anchor" href="#1-绪论"></a> 1: 绪论</h1><h1 id="2-实验过程及分析方法"><a class="markdownIt-Anchor" href="#2-实验过程及分析方法"></a> 2: 实验过程及分析方法</h1><h2 id="21-塑性流动挤出切削实验"><a class="markdownIt-Anchor" href="#21-塑性流动挤出切削实验"></a> 2.1: 塑性流动挤出切削实验</h2><h3 id="211-实验材料"><a class="markdownIt-Anchor" href="#211-实验材料"></a> 2.1.1: 实验材料</h3><h3 id="212-工艺原理"><a class="markdownIt-Anchor" href="#212-工艺原理"></a> 2.1.2: 工艺原理</h3><h1 id="3-塑性流动挤出切削有限元建模及结果分析"><a class="markdownIt-Anchor" href="#3-塑性流动挤出切削有限元建模及结果分析"></a> 3: 塑性流动挤出切削有限元建模及结果分析</h1><h2 id="31-引言"><a class="markdownIt-Anchor" href="#31-引言"></a> 3.1: 引言</h2><h2 id="32-三维有限元模型建立"><a class="markdownIt-Anchor" href="#32-三维有限元模型建立"></a> 3.2: 三维有限元模型建立</h2><h3 id="321-挤压角度的变化"><a class="markdownIt-Anchor" href="#321-挤压角度的变化"></a> 3.2.1: 挤压角度的变化</h3><p>![[俞宁有限元仿真总结(目录).excalidraw#^area=6RzV3y9_y9vW6OK21WXvU|挤压角度的变化]]</p><h2 id="33-等效应变分布"><a class="markdownIt-Anchor" href="#33-等效应变分布"></a> 3.3: 等效应变分布</h2><h2 id="34-本章小结"><a class="markdownIt-Anchor" href="#34-本章小结"></a> 3.4: 本章小结</h2><p>![[俞宁有限元仿真总结(目录).excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
      <category>论文学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>42. 连续子数组的最大和</title>
    <link href="/posts/21426/"/>
    <url>/posts/21426/</url>
    
    <content type="html"><![CDATA[<p>📝42. 连续子数组的最大和::</p><!-- basicblock-end --><p>动态规划是本题的最优解法，以下按照标准流程解题。</p><h1 id="1-动态规划解析"><a class="markdownIt-Anchor" href="#1-动态规划解析"></a> 1: 动态规划解析：</h1><ul><li><p><strong>状态定义：</strong> 设动态规划列表 dp ，dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和。</p><ul><li>为何定义最大和 dp[i] 中必须包含元素 nums[i] ：保证 dp[i] 递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的 <strong>连续子数组</strong> 要求。</li></ul></li><li><p><strong>转移方程：</strong> 若 dp[i−1]≤0 ，说明 dp[i−1] 对 dp[i] 产生负贡献，即 dp[i−1]+nums[i] 还不如 nums[i] 本身大。</p></li><li><p>当 dp[i−1]&gt;0 时：执行 dp[i]=dp[i−1]+nums[i] ；</p></li><li><p>当 dp[i−1]≤0 时：执行 dp[i]=nums[i] ；</p></li><li><p><strong>初始状态：</strong> dp[0]=nums[0]，即以 nums[0] 结尾的连续子数组最大和为 nums[0] 。</p></li><li><p><strong>返回值：</strong> 返回 dp 列表中的最大值，代表全局最大值。<br>[[1.动态规划理论基础]]</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>40. 最小的k个数</title>
    <link href="/posts/23385/"/>
    <url>/posts/23385/</url>
    
    <content type="html"><![CDATA[<p>📝40. 最小的k个数::<a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>下次学习一下快排的原理</p><p>sort 的时间复杂度是多少?: O(nlogn)</p><p>[[sort()函数]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++){<br>            ans.<span class="hljs-built_in">push_back</span>(arr[i]);<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unordered_map</title>
    <link href="/posts/50283/"/>
    <url>/posts/50283/</url>
    
    <content type="html"><![CDATA[<p>📝unordered_map::</p><!-- basicblock-end --><h1 id="1-key排序"><a class="markdownIt-Anchor" href="#1-key排序"></a> 1: key排序</h1><p>不需要 key 有序的时候效率最高<br>std::map或者std::multimap可以对key排序，但不能对value排序。<br>error: type ‘multimap&lt;char, int&gt;’ does not provide a subscript operator<br><code>map[i]++;</code></p><h1 id="2-操作"><a class="markdownIt-Anchor" href="#2-操作"></a> 2: 操作</h1><ul><li><p>创建元素: unordered_map&lt;key, value&gt; map;</p></li><li><p>插入元素:</p><ul><li>map.insert(<strong>pair&lt;int, int&gt;</strong>(a, b));</li><li>tip  <code>map[key]++</code>  //  存在key则 value 值++, 没有 key 则自动创造 key 在 value 值++<br>map的下标运算符[]的作用是：<br>将key作为下标去执行查找，并返回相应的值；<br>如果不存在这个key，就将一个具有该key和value的某人值插入这个map。</li></ul></li><li><p>获取元素:</p><ul><li><code>auto iter = map.find(x);</code>, <code>return iter-&gt;second</code>  lhs.second//  获取第二个元素</li><li><code>map[key]</code> = value // 获取第二个元素</li></ul></li><li><p>查找元素</p><ul><li><code>if(map.find(x) != map.end())</code> :&nbsp;相当于找到 x 时进入 if 语句</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取key 与 value 的值</span><br>key = map.first<br>value = map.second<br><br></code></pre></td></tr></tbody></table></figure><p>for 循环中映射 , it 是指针, 指向 map 的一个完整的元素包括key 和 value ,不是单一个元素<br><code>for(unordered_map&lt;int, int&gt; :: iterator it = map.begin(); it != map.end(); it++){}</code><br>^drp7wt</p><h1 id="3-遍历-key-值"><a class="markdownIt-Anchor" href="#3-遍历-key-值"></a> 3: 遍历 key 值</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_map&lt;string, <span class="hljs-type">int</span>&gt; myMap;<br><br><span class="hljs-comment">// 省略代码，假设已经向 myMap 中插入了一些键值对</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;kv : myMap) {<br>    string key = kv.first;<br>    <span class="hljs-type">int</span> value = kv.second;<br><br>    <span class="hljs-comment">// 操作 key 和 value</span><br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>map定义</title>
    <link href="/posts/34152/"/>
    <url>/posts/34152/</url>
    
    <content type="html"><![CDATA[<p>📝map定义::</p><!-- basicblock-end --><p>有 key 和 value 对应的: 用 map<br>map 能在最快的时间内, 去查找这个 key 是否在 map<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208121703566.png" alt="|600"></p><p>红黑树可以自动排序<br>std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解</p><p>![[8. 三数之和#^l8megb]]</p><p>![[1. 二叉树理论基础#^bew6dm]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>39. 数组中出现次数超过一半的数字</title>
    <link href="/posts/60161/"/>
    <url>/posts/60161/</url>
    
    <content type="html"><![CDATA[<p>📝39. 数组中出现次数超过一半的数字::<a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>解题思路：</p><blockquote><p>本文将 “数组中出现次数超过一半的数字” 简称为 <strong>“众数”</strong> 。<br>需要注意的是，数学中众数的定义为 “数组中出现次数最多的数字” ，与本文定义不同。</p></blockquote><p>本题常见的三种解法：</p><ol><li><strong>哈希表统计法：</strong> 遍历数组 <code>nums</code> ，用 HashMap 统计各数字的数量，即可找出 众数 。此方法时间和空间复杂度均为 O(N) 。</li><li><strong>数组排序法：</strong> 将数组 <code>nums</code> 排序，<strong>数组中点的元素</strong> 一定为众数。</li><li><strong>摩尔投票法：</strong> 核心理念为 <strong>票数正负抵消</strong> 。此方法时间和空间复杂度分别为 O(N) 和 O(1) ，为本题的最佳解法。</li></ol><h1 id="1-哈希表"><a class="markdownIt-Anchor" href="#1-哈希表"></a> 1: 哈希表</h1><p>[[map(🗃)]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n : nums){<br>            map[n]++;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m : map){<br>            <span class="hljs-keyword">if</span>(m.second &gt; nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> m.first;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-数学法"><a class="markdownIt-Anchor" href="#2-数学法"></a> 2: 数学法</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="3-投票法"><a class="markdownIt-Anchor" href="#3-投票法"></a> 3: 投票法</h1><p>不是很好理解, 还是哈希法吧<br><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/">剑指 Offer 39. 数组中出现次数超过一半的数字（摩尔投票法，清晰图解） - 数组中出现次数超过一半的数字 - 力扣（LeetCode）</a><br><strong>拓展：</strong> 由于题目说明 <code>给定的数组总是存在多数元素</code> ，因此本题不用考虑 <strong>数组不存在众数</strong> 的情况。若考虑，需要加入一个 “验证环节” ，遍历数组 <code>nums</code> 统计 <code>x</code> 的数量。</p><ul><li>若 <code>x</code> 的数量超过数组长度一半，则返回 <code>x</code> ；</li><li>否则，返回未找到众数；<br>时间和空间复杂度不变，仍为 O(N) 和 O(1)。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums){<br>            <span class="hljs-keyword">if</span>(votes == <span class="hljs-number">0</span>) x = num;<br>            votes += num == x ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>        }<br>        <span class="hljs-keyword">return</span> x;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vector 原理 (扩容过程)</title>
    <link href="/posts/49630/"/>
    <url>/posts/49630/</url>
    
    <content type="html"><![CDATA[<p>📝vector 原理 (扩容过程)::</p><!-- basicblock-end --><h1 id="1-为什么要要扩容"><a class="markdownIt-Anchor" href="#1-为什么要要扩容"></a> 1: 为什么要要扩容</h1><h1 id="2-size和-capacity-resize-和-reserve"><a class="markdownIt-Anchor" href="#2-size和-capacity-resize-和-reserve"></a> 2: [[size()和 capacity() &amp;&amp; resize 和 reserve]]</h1><h1 id="3-扩容方式"><a class="markdownIt-Anchor" href="#3-扩容方式"></a> 3: 扩容方式</h1><p>C++中 vector（可以理解是一个动态数组，底层是普通数组实现的）<br>如果插入元素大于预先普通数组大小，vector 底部会有一个扩容的操作，</p><ol><li>先申请两倍于原先普通数组的大小，</li><li>然后把数据拷贝到新数组上，</li><li>最后: <strong>析构掉旧内存中的对象</strong>, 在<strong>释放原数组内存</strong>。</li></ol><p>vector则使用灵活的动态空间配置，维护一块<strong>连续的线性空间</strong>，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。<br>这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数），源码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> size_type len  = old_size + <span class="hljs-built_in">max</span>(old_size, n);<br></code></pre></td></tr></tbody></table></figure><p>string 同理</p><blockquote><p>[!example]-<br>原vector中的size和capicity相同都是3，初始化为1 2 3，此时要push_back一个元素4。<br>那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存，<br><strong>注意图中底层数组的内存起始地址已经变了</strong>。<br><img src="https://img-blog.csdnimg.cn/20201218185902217.png" alt="vector原理|800"></p></blockquote><h2 id="31-固定扩容"><a class="markdownIt-Anchor" href="#31-固定扩容"></a> 3.1: 固定扩容</h2><p>机制： 每次扩容的时候在原 capacity 的基础上加上固定的容量，</p><ul><li>example 比如初始 capacity 为 100，扩容一次为 capacity+20, 再扩容仍然为 capacity+20;</li></ul><p>缺点：<br>考虑一种极端的情况，vector 每次添加的元素数量刚好等于每次扩容固定增加的容量+1，就会造成一种情况，每添加一次元素就需要扩容一次，而扩容的时间花费十分高昂。<strong>所以固定扩容可能会面临多次扩容的情况</strong>，时间复杂度较高：</p><p>优点： 固定扩容方式空间利用率比较高。</p><h2 id="32-加倍扩容机制-每次扩容的时候原-capacity-翻倍"><a class="markdownIt-Anchor" href="#32-加倍扩容机制-每次扩容的时候原-capacity-翻倍"></a> 3.2: 加倍扩容机制： 每次扩容的时候原 capacity 翻倍，</h2><ul><li>example 比如初始 capcity=100, 扩容一次变为 200，再扩容变为 400；</li></ul><p>优点： 一次扩容 capacity 翻倍的方式使得正常情况下添加元素需要<strong>扩容的次数大大减少（预留空间较多）</strong>，时间复杂度较低：</p><p>缺点： 因为每次扩容空间翻倍，而很多空间没有利用上，空间利用率不如固定扩容。</p><p><strong>在实际应用中，一般采用空间换时间的策略</strong>。</p><h2 id="33-问题"><a class="markdownIt-Anchor" href="#33-问题"></a> 3.3: 问题</h2><blockquote><p>[!success] #✅</p></blockquote><p>1、[[为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？]]</p><p>2、[[为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢]]</p><h1 id="4-影响"><a class="markdownIt-Anchor" href="#4-影响"></a> 4: 影响</h1><h2 id="41"><a class="markdownIt-Anchor" href="#41"></a> 4.1:</h2><p>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了；<br>增大内存的操作会使迭代器引用指针失效</p><p>可能影响的操作就是: 插入操作 push 类 insert 类等</p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n<sup>2)了，甚至可能拷贝好几次，就不止O(n</sup>2)了。</p><p>解决办法：可以采用链表来进行插入操作<br>eg：<code>vector&lt;vector&lt;int&gt;&gt; que：[[7,0],[7,1]]</code> →<code>list&lt;vector&lt;int&gt;&gt; que：[7,0]→[7,1]</code></p><h2 id="42"><a class="markdownIt-Anchor" href="#42"></a> 4.2:</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
      <tag>✅</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</title>
    <link href="/posts/4234/"/>
    <url>/posts/4234/</url>
    
    <content type="html"><![CDATA[<p>📝9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素::</p><!-- basicblock-end --><h1 id="1-vector"><a class="markdownIt-Anchor" href="#1-vector"></a> 1: vector</h1><p>vector数据结构 vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，<strong>所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)</strong>。</p><p>另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。<br>连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，<strong>在中间和头部删除和插入相对不易，需要挪动大量的数据</strong>。</p><p>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</p><h1 id="2-list"><a class="markdownIt-Anchor" href="#2-list"></a> 2: list</h1><p>list数据结构 list是由双向链表实现的，因此<strong>内存空间是不连续的</strong>。</p><p>只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。</p><p>非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。<br>每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。</p><p>区别：</p><ul><li>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。</li><li>list的访问要遍历整个链表，<strong>它的随机访问效率低</strong>。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</li><li>从遍历上来说，list是单向的，vector是双向的。</li><li>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。</li></ul><p>int mySize = vec.size();<a href="http://vec.at">vec.at</a>(mySize -2);</p><p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要<strong>访问list里的元素只能遍历</strong>，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历：</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8、STL的两级空间配置器</title>
    <link href="/posts/5925/"/>
    <url>/posts/5925/</url>
    
    <content type="html"><![CDATA[<p>📝8、STL的两级空间配置器::</p><!-- basicblock-end --><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1: 概念</h1><blockquote><p>[!note] 原因<br>我们知道动态开辟内存时，要在堆上申请，<br>但若是我们需要频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；</p><p>每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；<br>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</p></blockquote><blockquote><p>[!note] 方法<br>于是就设置了二级空间配置器，<strong>当开辟内存&lt;=128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong><br>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。如果<strong>大于128字节再转去一级配置器器</strong>。</p></blockquote><h2 id="11-一级配置器"><a class="markdownIt-Anchor" href="#11-一级配置器"></a> 1.1: 一级配置器</h2><p><strong>一级空间配置器</strong>中重要的函数就是 <code>allocate</code>、<code>deallocate</code>、<code>reallocate</code> 。<br>一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置。<br>大致过程是：<br>1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数<br>2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常<br>3、如果自定义了处理函数就进行处理，完事再继续分配试试</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220035143.png" alt=""></p><h2 id="12-二级配置器"><a class="markdownIt-Anchor" href="#12-二级配置器"></a> 1.2: 二级配置器</h2><p>![[STL 第二级空间配置器.excalidraw]]</p><p>1、维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</p><p>2、对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：<br>（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。<br>（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。<br>（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。</p><p>3、内存池为空，申请内存此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。</p><p>4、malloc没有成功在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。</p><p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p><h3 id="121-缺点"><a class="markdownIt-Anchor" href="#121-缺点"></a> 1.2.1: 缺点</h3><p>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：</p><p>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；</p><p>2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p><h2 id="13-一级分配器"><a class="markdownIt-Anchor" href="#13-一级分配器"></a> 1.3: 一级分配器</h2><p>GC4.9之后就没有第一级了，只有第二级</p><h2 id="14-二级分配器"><a class="markdownIt-Anchor" href="#14-二级分配器"></a> 1.4: 二级分配器</h2><p>——default_alloc_template 剖析</p><p>有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（0-15号链表，最小8字节最大128字节）</p><p>allocate函数：如果要分配的内存大于128字节，就转用第一级分配器，否则也就是小于128字节。<br>那么首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，<strong>默认一次申请20个区块</strong>，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc 2 * 20个块）去内存池去拿或者重新分配。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7、简单说一下traits技法</title>
    <link href="/posts/6791/"/>
    <url>/posts/6791/</url>
    
    <content type="html"><![CDATA[<p>📝7、简单说一下traits技法::</p><!-- basicblock-end --><p>traits技法利用“内嵌型别“的编程技巧与<strong>编译器的template参数推导功能</strong>，增强C++未能提供的关于型别认证方面的能力。<br>常用的有iterator_traits和type_traits。</p><h1 id="1-iterator_traits"><a class="markdownIt-Anchor" href="#1-iterator_traits"></a> 1: iterator_traits</h1><p>被称为<strong>特性萃取机</strong>，能够方便的让外界获取以下5种型别：</p><ul><li>value_type：迭代器所指对象的型别</li><li>difference_type：两个迭代器之间的距离</li><li>pointer：迭代器所指向的型别</li><li>reference：迭代器所引用的型别</li><li>iterator_category：三两句说不清楚，建议看书</li></ul><h1 id="2-type_traits"><a class="markdownIt-Anchor" href="#2-type_traits"></a> 2: type_traits</h1><p>关注的是型别的<strong>特性</strong>，例如这个型别是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符） 和non-trivial dtor（析构函数），如果答案是否定的，可以采取直接操作内存的方式提高效率，一般来说，type_traits支持以下5中类型的判断：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">__type_traits&lt;T&gt;::has_trivial_default_constructor<br>__type_traits&lt;T&gt;::has_trivial_copy_constructor<br>__type_traits&lt;T&gt;::has_trivial_assignment_operator<br>__type_traits&lt;T&gt;::has_trivial_destructor<br>__type_traits&lt;T&gt;::is_POD_type<br></code></pre></td></tr></tbody></table></figure><p>由于编译器只针对class object形式的参数进行参数推到，因此上式的返回结果不应该是个bool值，实际上使用的是一种空的结构体：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__true_type</span>{};<span class="hljs-keyword">struct</span> <span class="hljs-title class_">__false_type</span>{};<br></code></pre></td></tr></tbody></table></figure><p>这两个结构体没有任何成员，不会带来其他的负担，又能满足需求，可谓一举两得</p><p>当然，如果我们自行定义了一个Shape类型，也可以针对这个Shape设计type_traits的特化版本</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__type_traits</span>&lt;Shape&gt;{<br><span class="hljs-keyword">typedef</span> __true_type has_trivial_default_constructor;<br><span class="hljs-keyword">typedef</span> __false_type has_trivial_copy_constructor;<br><span class="hljs-keyword">typedef</span> __false_type has_trivial_assignment_operator;<br><span class="hljs-keyword">typedef</span> __false_type has_trivial_destructor;<br><span class="hljs-keyword">typedef</span> __false_type is_POD_type;<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hash table 原理</title>
    <link href="/posts/52381/"/>
    <url>/posts/52381/</url>
    
    <content type="html"><![CDATA[<p>📝hash table 原理::</p><!-- basicblock-end --><p>STL中的hashtable使用的是<strong>开链法</strong>解决hash冲突问题，如下图所示。<br>![[hash table 原理图.excalidraw]]</p><p>hash table中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hash table_node数据结构组成的linked-list，而。</p><p>在hash table设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hash table时，会根据存入的元素个数选择大于等于元素个数的质数作为hash table的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。<br>如果插入hash table的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hash table的位置。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>weak_ptr</title>
    <link href="/posts/38635/"/>
    <url>/posts/38635/</url>
    
    <content type="html"><![CDATA[<p>📝weak_ptr::</p><!-- basicblock-end --><p>1、weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况，<br>但 weak_ptr 没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>2、和 shared_ptr 指向相同内存 shared_ptr 析构之后内存释放，<br>在使用之前使用函数 Iock () 检查 weak_ptr 是否为空指针。</p><blockquote><p>[!question]<br>那个视频里没听懂::   #疑问<br>![[weak_ptr.excalidraw]]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3、使用智能指针管理内存资源，RAII是怎么回事？</title>
    <link href="/posts/11810/"/>
    <url>/posts/11810/</url>
    
    <content type="html"><![CDATA[<p>📝3、使用智能指针管理内存资源，RAII是怎么回事？::</p><!-- basicblock-end --><ol><li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</li></ol><p>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。<br>2.  智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。</p><p>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2、解释一下什么是trivial destructor</title>
    <link href="/posts/32250/"/>
    <url>/posts/32250/</url>
    
    <content type="html"><![CDATA[<p>📝2、解释一下什么是trivial destructor::</p><!-- basicblock-end --><p>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</p><p>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数<strong>如果申请了新的空间一定要显式的释放，否则会造成内存泄露</strong></p><p>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？</p><p>《STL源码解析》中给出的说明是:</p><p>首先利用value_type()获取所指对象的型别，再利用<code>__type_traits&lt;T&gt;</code>判断该型别的析构函数是否trivial，若是(__true_type)，则什么也不做，若为(__false_type)，则去调用destory()函数。</p><p>也就是说，在实际的应用当中，STL库提供了相关的判断方法__type_traits，感兴趣的读者可以自行查阅使用方式。<br>除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1、什么是STL？</title>
    <link href="/posts/2248/"/>
    <url>/posts/2248/</url>
    
    <content type="html"><![CDATA[<p>📝1、什么是STL？::</p><!-- basicblock-end --><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p><ul><li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li><li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li><li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL模板库-01-20 目录</title>
    <link href="/posts/29365/"/>
    <url>/posts/29365/</url>
    
    <content type="html"><![CDATA[<p>📝STL模板库-01-20 目录::</p><!-- basicblock-end --><h1 id="1-1-什么是stl"><a class="markdownIt-Anchor" href="#1-1-什么是stl"></a> 1: [[1、什么是STL？]]</h1><h1 id="2-2-解释一下什么是trivial-destructor"><a class="markdownIt-Anchor" href="#2-2-解释一下什么是trivial-destructor"></a> 2: [[2、解释一下什么是trivial destructor]]</h1><h1 id="3-3-使用智能指针管理内存资源raii是怎么回事"><a class="markdownIt-Anchor" href="#3-3-使用智能指针管理内存资源raii是怎么回事"></a> 3: [[3、使用智能指针管理内存资源，RAII是怎么回事？]]</h1><h1 id="4-前置与后置"><a class="markdownIt-Anchor" href="#4-前置与后置"></a> 4: [[前置<ins>与后置</ins>]]</h1><h1 id="5-左右值引用目录"><a class="markdownIt-Anchor" href="#5-左右值引用目录"></a> 5: [[左右值引用(目录)]]</h1><h1 id="6-hash-table-原理"><a class="markdownIt-Anchor" href="#6-hash-table-原理"></a> 6: [[hash table 原理]]</h1><h1 id="7-7-简单说一下traits技法"><a class="markdownIt-Anchor" href="#7-7-简单说一下traits技法"></a> 7: [[7、简单说一下traits技法]]</h1><h1 id="8-8-stl的两级空间配置器"><a class="markdownIt-Anchor" href="#8-8-stl的两级空间配置器"></a> 8: [[8、STL的两级空间配置器]]</h1><h1 id="9-9-vector与list的区别与应用怎么找某vector或者list的倒数第二个元素"><a class="markdownIt-Anchor" href="#9-9-vector与list的区别与应用怎么找某vector或者list的倒数第二个元素"></a> 9: [[9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素]]</h1><h1 id="10-size和-capacity-resize-和-reserve"><a class="markdownIt-Anchor" href="#10-size和-capacity-resize-和-reserve"></a> 10: [[size()和 capacity() &amp;&amp; resize 和 reserve]]</h1><h1 id="11-11-vector如何释放空间"><a class="markdownIt-Anchor" href="#11-11-vector如何释放空间"></a> 11: [[11、Vector如何释放空间]]</h1><h1 id="12-12-容器内部删除一个元素"><a class="markdownIt-Anchor" href="#12-12-容器内部删除一个元素"></a> 12: [[12、容器内部删除一个元素]]</h1><h1 id="13-迭代器"><a class="markdownIt-Anchor" href="#13-迭代器"></a> 13: [[迭代器(🗃)]]</h1><h1 id="14-14-map-set是怎么实现的红黑树是怎么能够同时实现这两种容器-为什么使用红黑树"><a class="markdownIt-Anchor" href="#14-14-map-set是怎么实现的红黑树是怎么能够同时实现这两种容器-为什么使用红黑树"></a> 14: [[14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？]]</h1><h1 id="15-15-如何在共享内存上使用stl标准库"><a class="markdownIt-Anchor" href="#15-15-如何在共享内存上使用stl标准库"></a> 15: [[15、如何在共享内存上使用STL标准库？]]</h1><h1 id="16-16-map插入方式有哪几种"><a class="markdownIt-Anchor" href="#16-16-map插入方式有哪几种"></a> 16: [[16、map插入方式有哪几种？]]</h1><h1 id="17-和map的区别hash_map如何解决冲突以及扩容"><a class="markdownIt-Anchor" href="#17-和map的区别hash_map如何解决冲突以及扩容"></a> 17: [[和map的区别，hash_map如何解决冲突以及扩容]]</h1><h1 id="18-18-vector越界访问下标map越界访问下标vector删除元素时会不会释放空间"><a class="markdownIt-Anchor" href="#18-18-vector越界访问下标map越界访问下标vector删除元素时会不会释放空间"></a> 18: [[18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？]]</h1><h1 id="19-19-map下标运算符中与find的区别"><a class="markdownIt-Anchor" href="#19-19-map下标运算符中与find的区别"></a> 19: [[19、map下标运算符中与find的区别？]]</h1><h1 id="20-20-list-与其他容器的区别"><a class="markdownIt-Anchor" href="#20-20-list-与其他容器的区别"></a> 20: [[20、 list 与其他容器的区别]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>STL模板库-01-20</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>38. 字符串的排列</title>
    <link href="/posts/14994/"/>
    <url>/posts/14994/</url>
    
    <content type="html"><![CDATA[<p>📝38. 字符串的排列::<a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>![[38. 字符串的排列 2022-11-29 17.27.46.excalidraw]]</p><h1 id="1-递归解析"><a class="markdownIt-Anchor" href="#1-递归解析"></a> 1: 递归解析：</h1><ol><li><strong>终止条件：</strong> 当 <code>x = len(c) - 1</code> 时，代表所有位已固定（最后一位只有 11 种情况），则将当前组合 <code>c</code> 转化为字符串并加入 <code>res</code> ，并返回；</li><li><strong>递推参数：</strong> 当前固定位 <code>x</code> ；</li><li><strong>递推工作：</strong> 初始化一个 Set ，用于排除重复的字符；将第 <code>x</code> 位字符与 <code>i</code> ∈ <code>[x, len(c)]</code> 字符分别交换，并进入下层递归；<ol><li><strong>剪枝：</strong> 若 <code>c[i]</code> 在 Set 中，代表其是重复字符，因此 “剪枝” ；</li><li>将 <code>c[i]</code> 加入 Set，以便之后遇到重复字符时剪枝；</li><li><strong>固定字符：</strong> 将字符 <code>c[i]</code> 和 <code>c[x]</code> 交换，即固定 <code>c[i]</code> 为当前位字符；</li><li><strong>开启下层递归：</strong> 调用 <code>dfs(x + 1)</code> ，即开始固定第 <code>x + 1</code> 个字符；</li><li><strong>还原交换：</strong> 将字符 <code>c[i]</code> 和 <code>c[x]</code> 交换（还原之前的交换）；</li></ol></li></ol><ul><li><strong>时间复杂度 O(N!N) ：</strong> N 为字符串 <code>s</code> 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 N×(N−1)×(N−2)…×2×1 ，即复杂度为 O(N!) ；字符串拼接操作 <code>join()</code> 使用 O(N) ；因此总体时间复杂度为 O(N!N) 。</li><li><strong>空间复杂度 O(N^2) ：</strong> 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N) ；递归中辅助 Set 累计存储的字符数量最多为 N+(N−1)+…+2+1=(N+1)N/2 ，即占用 O(N^2) 的额外空间。</li></ul><p>抄了一遍, 还是不懂</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    }<br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> x)</span> </span>{<br>        <span class="hljs-keyword">if</span>(x == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {<br>            res.<span class="hljs-built_in">push_back</span>(s);                       <span class="hljs-comment">// 添加排列方案</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">find</span>(s[i]) != st.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 重复，因此剪枝</span><br>            st.<span class="hljs-built_in">insert</span>(s[i]);<br>            <span class="hljs-built_in">swap</span>(s[i], s[x]);                       <span class="hljs-comment">// 交换，将 s[i] 固定在第 x 位</span><br>            <span class="hljs-built_in">dfs</span>(s, x + <span class="hljs-number">1</span>);                          <span class="hljs-comment">// 开启固定第 x + 1 位字符</span><br>            <span class="hljs-built_in">swap</span>(s[i], s[x]);                       <span class="hljs-comment">// 恢复交换</span><br>        }<br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>37. 序列化二叉树</title>
    <link href="/posts/7844/"/>
    <url>/posts/7844/</url>
    
    <content type="html"><![CDATA[<p>📝<a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/">37. 序列化二叉树</a>::</p><!-- basicblock-end --><p>序列化的字符串实际上是二叉树的 “层序遍历”（BFS）结果</p><p>通过 BFS 可以记录二叉树的值, 以及节点相应的位置信息</p><h1 id="1-序列化-serialize"><a class="markdownIt-Anchor" href="#1-序列化-serialize"></a> 1: 序列化 Serialize ：</h1><p>借助队列，对二叉树做层序遍历，并将越过叶节点的 <code>null</code> 也打印出来。</p><h2 id="11-算法流程"><a class="markdownIt-Anchor" href="#11-算法流程"></a> 1.1: 算法流程</h2><ol><li><strong>特例处理：</strong> 若 <code>root</code> 为空，则直接返回空列表 <code>"[]"</code> ；</li><li><strong>初始化：</strong> 队列 <code>que</code> （包含根节点 <code>root</code> ）；序列化列表 <code>res</code> ；</li><li><strong>层序遍历：</strong> 当 <code>que</code> 为空时跳出；</li><li>节点出队，记为 <code>node</code> ；</li><li>若 <code>node</code> 不为空：① 打印字符串 <code>node.val</code> ，② 将左、右子节点加入 <code>que</code> ；</li><li>否则（若 <code>node</code> 为空）：打印字符串 <code>"null"</code> ；</li><li><strong>返回值：</strong> 拼接列表，用 <code>','</code> 隔开，首尾添加中括号；</li></ol><h2 id="12-复杂度分析"><a class="markdownIt-Anchor" href="#12-复杂度分析"></a> 1.2: 复杂度分析：</h2><ul><li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N+1 个 <code>null</code> ，总体复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2N+1)=O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li><li><strong>空间复杂度 O(N) ：</strong> 最差情况下，队列 <code>que</code> 同时存储 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(N+1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个节点（或 N+1 个 <code>null</code> ），使用 O(N) ；列表 <code>res</code> 使用 O(N) 。j</li></ul><p>[[5. 二叉树的层序遍历]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> {<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-comment">// bfs</span><br>        string res;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root); <br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* front = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (front) {<br>                res += <span class="hljs-built_in">to_string</span>(front-&gt;val) + <span class="hljs-string">","</span>;<br>                q.<span class="hljs-built_in">push</span>(front-&gt;left);<br>                q.<span class="hljs-built_in">push</span>(front-&gt;right);<br>            }<br>            <span class="hljs-keyword">else</span> res += <span class="hljs-string">"null,"</span>;<br>        }<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>{<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        vector&lt;string&gt; s = <span class="hljs-built_in">split</span>(data);<br>        <br>        queue&lt;TreeNode*&gt; q;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(s[<span class="hljs-number">0</span>]));<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* front = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">"null"</span>) {<br>                front-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(s[i]));<br>                q.<span class="hljs-built_in">push</span>(front-&gt;left);<br>            }<br>            ++i;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">"null"</span>) {<br>                front-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(s[i]));<br>                q.<span class="hljs-built_in">push</span>(front-&gt;right);<br>            }<br>            ++i;<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">split</span><span class="hljs-params">(string&amp; s)</span> </span>{<br>        vector&lt;string&gt; res;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &lt; n) {<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; s[j] != <span class="hljs-string">','</span>) ++j;<br>            res.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(i, j - i));<br>            i = j + <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>先写一个序列化</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> {<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">" "</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        string res;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node){<br>                res += <span class="hljs-built_in">to_string</span>(node-&gt;val) + <span class="hljs-string">","</span>;<br>                que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            <span class="hljs-keyword">else</span> res += <span class="hljs-string">"null,"</span>;<br><br>        }<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br><br><br>        <br>    }<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>{<br>        <br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>36. 二叉搜索树与双向链表</title>
    <link href="/posts/33802/"/>
    <url>/posts/33802/</url>
    
    <content type="html"><![CDATA[<p>📝36. 二叉搜索树与双向链表::<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">502 Bad Gateway</a></p><!-- basicblock-end --><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt=""><br>小的右值针指向大的, 大的左指针指向小的: <code>小&lt;-&gt;大</code></p><p>算法流程：</p><p><strong><code>dfs(cur):</code></strong> 递归法中序遍历；</p><ol><li><strong>终止条件：</strong> 当节点 <code>cur</code> 为空，代表越过叶节点，直接返回；</li><li>递归左子树，即 <code>dfs(cur.left)</code> ；</li><li><strong>构建链表：</strong><ol><li><strong>当 <code>pre</code> 为空时：</strong> 代表正在访问链表头节点，记为 <code>head</code> ；</li><li><strong>当 <code>pre</code> 不为空时：</strong> 修改双向节点引用，即 <code>pre.right = cur</code> ， <code>cur.left = pre</code> ；</li><li><strong>保存 <code>cur</code> ：</strong> 更新 <code>pre = cur</code> ，即节点 <code>cur</code> 是后继节点的 <code>pre</code> ；</li></ol></li><li>递归右子树，即 <code>dfs(cur.right)</code> ；</li></ol><p><strong><code>treeToDoublyList(root)：</code></strong></p><ol><li><strong>特例处理：</strong> 若节点 <code>root</code> 为空，则直接返回；</li><li><strong>初始化：</strong> 空节点 <code>pre</code> ；</li><li><strong>转化为双向链表：</strong> 调用 <code>dfs(root)</code> ；</li><li><strong>构建循环链表：</strong> 中序遍历完成后，<code>head</code> 指向头节点， <code>pre</code> 指向尾节点，因此修改 <code>head</code> 和 <code>pre</code> 的双向节点引用即可；</li><li><strong>返回值：</strong> 返回链表的头节点 <code>head</code> 即可；</li></ol><p>复杂度分析：</p><ul><li><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数，中序遍历需要访问所有节点。</li><li><strong>空间复杂度 O(N) ：</strong> 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    Node* pre, *head; <span class="hljs-comment">// 当前节点的上一个节点, 头结点</span><br>    <span class="hljs-comment">// dfs 处理完, 只剩头尾节点没有连接上, 在主函数中单独处理一下</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(cur-&gt;left);<br><br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">//还没有上一个节点,说明现在这个节点是第一个处理的</span><br>            head = cur;   <span class="hljs-comment">//第一个处理的当然是最小的那个,设为头</span><br><br>            pre = cur;    <span class="hljs-comment">//将其赋值给pre 然后继续往下走</span><br>        }<br>        <span class="hljs-keyword">else</span>{<br>            <span class="hljs-comment">// 连接为 pre &lt;-&gt; cur</span><br>            pre-&gt;right = cur;<br>            cur-&gt;left = pre;<br><br>            pre = cur; <span class="hljs-comment">// //将其赋值给pre 然后继续往下走</span><br>        }<br><br>        <span class="hljs-built_in">dfs</span>(cur-&gt;right);<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-comment">//把除去头尾节点的都链接上 当它运行完,preNode 指向尾节点. headNode 指向头</span><br>        head-&gt;left = pre;<br>        pre-&gt;right = head;<br>        <span class="hljs-keyword">return</span> head;<br>        <br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>35. 复杂链表的复制</title>
    <link href="/posts/44008/"/>
    <url>/posts/44008/</url>
    
    <content type="html"><![CDATA[<p>📝35. 复杂链表的复制::<a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/submissions/">剑指 Offer 35. 复杂链表的复制 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>算法流程</p><ol><li>若头节点 <code>head</code> 为空节点，直接返回 null ；</li><li><strong>初始化：</strong> 哈希表 <code>dic</code> ， 节点 <code>cur</code> 指向头节点；</li><li><strong>复制链表：</strong></li><li>建立新节点，并向 <code>dic</code> 添加键值对 <code>(原 cur 节点, 新 cur 节点）</code> ；</li><li><code>cur</code> 遍历至原链表下一节点；</li><li><strong>构建新链表的引用指向：</strong></li><li>构建新节点的 <code>next</code> 和 <code>random</code> 引用指向；</li><li><code>cur</code> 遍历至原链表下一节点；</li><li><strong>返回值：</strong> 新链表的头节点 <code>dic[cur]</code> ；<br>复杂度分析：</li></ol><ul><li><strong>时间复杂度 O(N) ：</strong> 两轮遍历链表，使用 O(N) 时间。</li><li><strong>空间复杂度 O(N) ：</strong> 哈希表 <code>dic</code> 使用线性大小的额外空间。</li></ul><p>[[map(🗃)]]</p><p>K 神</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>{<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        Node* cur = head;<br>        unordered_map&lt;Node*, Node*&gt; map;<br>        <span class="hljs-comment">// 复制链表</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) {<br>            map[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>        }<br>        cur = head;<br>        <span class="hljs-comment">// 构建新链表的引用指向：</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>){<br>            map[cur]-&gt;next = map[cur-&gt;next];<br>            map[cur]-&gt;random = map[cur-&gt;random];<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> map[head];<br>        <br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>66、C++函数调用的压栈过程</title>
    <link href="/posts/61653/"/>
    <url>/posts/61653/</url>
    
    <content type="html"><![CDATA[<p>📝66、C++函数调用的压栈过程::<br>知道了压栈出栈的过程, 但是这个怎么感觉看不懂啊</p><!-- basicblock-end --><blockquote><p>[!example]<br>![[C++函数调用的压栈过程.excalidraw]]</p></blockquote><p>函数的调用过程：</p><ul><li>1）从栈空间分配存储空间</li><li>2）从实参的存储空间复制值到形参栈空间</li><li>3）进行运算</li></ul><p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p><p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p><p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>61-80 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>65、C++的四种强制转换reinterpret_castconst_caststatic_cast dynamic_cast</title>
    <link href="/posts/13189/"/>
    <url>/posts/13189/</url>
    
    <content type="html"><![CDATA[<p>📝65、C++的四种强制转换reinterpret_castconst_caststatic_cast dynamic_cast::</p><!-- basicblock-end --><h1 id="1-reinterpret_cast"><a class="markdownIt-Anchor" href="#1-reinterpret_cast"></a> 1: <strong>reinterpret_cast</strong></h1><p><code>reinterpret\_cast&lt;type-id&gt; (expression)</code></p><p>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</p><h1 id="2-const_cast"><a class="markdownIt-Anchor" href="#2-const_cast"></a> 2: <strong>const_cast</strong></h1><p>const_cast&lt;type_id&gt; (expression)</p><p>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：</p><ul><li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li><li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li><li>const_cast一般用于修改底指针。如const char *p形式</li></ul><h1 id="3-static_cast"><a class="markdownIt-Anchor" href="#3-static_cast"></a> 3: <strong>static_cast</strong></h1><p>static_cast &lt; type-id &gt; (expression)</p><p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p><ul><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的<ul><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li></ul></li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li></ul></li><li>把空指针转换成目标类型的空指针</li><li>把任何类型的表达式转换成void类型</li></ul><p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p><h1 id="4-dynamic_cast"><a class="markdownIt-Anchor" href="#4-dynamic_cast"></a> 4: <strong>dynamic_cast</strong></h1><p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p><p><code>dynamic\_cast &lt;type-id&gt; (expression)</code></p><p>该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</p><p>如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用</p><p>dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）</p><p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>() :<span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>) {}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>{};<br><span class="hljs-type">int</span> b;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>() :<span class="hljs-built_in">d</span>(<span class="hljs-number">2</span>) {}<br><span class="hljs-type">int</span> d;<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> n = <span class="hljs-number">97</span>;<br><br><span class="hljs-comment">//reinterpret_cast</span><br><span class="hljs-type">int</span> *p = &amp;n;<br><span class="hljs-comment">//以下两者效果相同</span><br><span class="hljs-type">char</span> *c = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt; (p); <br><span class="hljs-type">char</span> *c2 =  (<span class="hljs-type">char</span>*)(p);<br>cout &lt;&lt; <span class="hljs-string">"reinterpret_cast输出："</span>&lt;&lt; *c2 &lt;&lt; endl;<br><span class="hljs-comment">//const_cast</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;n;<br><span class="hljs-type">int</span> *p3 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(p2);<br>*p3 = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">"const_cast输出："</span> &lt;&lt; *p3 &lt;&lt; endl;<br><br>Base* b1 = <span class="hljs-keyword">new</span> Son;<br>Base* b2 = <span class="hljs-keyword">new</span> Base;<br><br><span class="hljs-comment">//static_cast</span><br>Son* s1 = <span class="hljs-built_in">static_cast</span>&lt;Son*&gt;(b1); <span class="hljs-comment">//同类型转换</span><br>Son* s2 = <span class="hljs-built_in">static_cast</span>&lt;Son*&gt;(b2); <span class="hljs-comment">//下行转换，不安全</span><br>cout &lt;&lt; <span class="hljs-string">"static_cast输出："</span>&lt;&lt; endl;<br>cout &lt;&lt; s1-&gt;d &lt;&lt; endl;<br>cout &lt;&lt; s2-&gt;d &lt;&lt; endl; <span class="hljs-comment">//下行转换，原先父对象没有d成员，输出垃圾值</span><br><br><span class="hljs-comment">//dynamic_cast</span><br>Son* s3 = <span class="hljs-built_in">dynamic_cast</span>&lt;Son*&gt;(b1); <span class="hljs-comment">//同类型转换</span><br>Son* s4 = <span class="hljs-built_in">dynamic_cast</span>&lt;Son*&gt;(b2); <span class="hljs-comment">//下行转换，安全</span><br>cout &lt;&lt; <span class="hljs-string">"dynamic_cast输出："</span> &lt;&lt; endl;<br>cout &lt;&lt; s3-&gt;d &lt;&lt; endl;<br><span class="hljs-keyword">if</span>(s4 == <span class="hljs-literal">nullptr</span>)<br>cout &lt;&lt; <span class="hljs-string">"s4指针为nullptr"</span> &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; s4-&gt;d &lt;&lt; endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//输出结果</span><br><span class="hljs-comment">//reinterpret_cast输出：a</span><br><span class="hljs-comment">//const_cast输出：100</span><br><span class="hljs-comment">//static_cast输出：</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//-33686019</span><br><span class="hljs-comment">//dynamic_cast输出：</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//s4指针为nullptr</span><br></code></pre></td></tr></tbody></table></figure><p>从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>61-80 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>64、成员初始化列表的概念，为什么用它会快一些？</title>
    <link href="/posts/33951/"/>
    <url>/posts/33951/</url>
    
    <content type="html"><![CDATA[<p>📝64、成员初始化列表的概念，为什么用它会快一些？::</p><!-- basicblock-end --><h1 id="1-成员初始化列表的概念"><a class="markdownIt-Anchor" href="#1-成员初始化列表的概念"></a> 1: 成员初始化列表的概念</h1><p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值<br>[[函数特化.excalidraw]]</p><h1 id="2-为什么用它会快一些"><a class="markdownIt-Anchor" href="#2-为什么用它会快一些"></a> 2: 为什么用它会快一些</h1><p>用初始化列表会快一些的原因是，对于类型，它少了一次<strong>调用构造函数</strong>的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。</p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>()<br>    {<br>        cout &lt;&lt; <span class="hljs-string">"默认构造函数A()"</span> &lt;&lt; endl;<br>    }<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a)<br>    {<br>        value = a;<br>        cout &lt;&lt; <span class="hljs-string">"A(int "</span>&lt;&lt;value&lt;&lt;<span class="hljs-string">")"</span> &lt;&lt; endl;<br>    }<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)<br>    {<br>        value = a.value;<br>        cout &lt;&lt; <span class="hljs-string">"拷贝构造函数A(A&amp; a):  "</span>&lt;&lt;value &lt;&lt; endl;<br>    }<br>    <span class="hljs-type">int</span> value;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">// ❓列表初始化</span><br>    {<br>        b = <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>);<br>    }<br>    A a;<br>    A b;<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    B b;<br>}<br><br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//A(int 1)</span><br><span class="hljs-comment">//默认构造函数A()</span><br><span class="hljs-comment">//A(int 2)</span><br></code></pre></td></tr></tbody></table></figure><p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。<br>由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，<br>但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，<br>所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。</strong></p><h1 id="3-59-有哪些情况必须用到成员列表初始化"><a class="markdownIt-Anchor" href="#3-59-有哪些情况必须用到成员列表初始化"></a> 3: [[59、有哪些情况必须用到成员列表初始化？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>61-80 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>封装</title>
    <link href="/posts/46151/"/>
    <url>/posts/46151/</url>
    
    <content type="html"><![CDATA[<p>📝封装::</p><!-- basicblock-end --><p><strong>定义</strong>： 数据和代码捆绑在一起，避免外界干扰和不确定性访问；</p><p><strong>功能</strong>：<br>把客观事物封装成抽象的类，<br>并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，</p><p>例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/posts/28440/"/>
    <url>/posts/28440/</url>
    
    <content type="html"><![CDATA[<p>📝继承::</p><!-- basicblock-end --><p><strong>定义</strong>： <strong>让某种类型对象获得另一个类型对象的属性和方法</strong></p><p><strong>功能</strong>： 它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展<br>常见的继承有三种方式：</p><ul><li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li><li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力<ul><li>question 是子类也得有函数吗</li></ul></li><li>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力<ul><li>question 可拓展功能吗</li></ul></li></ul><blockquote><p>[!example] <strong>例如</strong>：<br>将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉等公共方法，<br>在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法。</p></blockquote><p><a href="https://www.bilibili.com/video/BV1wZ4y1B7A7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">8分钟搞懂面向对象编程 | 面向过程vs面向对象 | OOP | 封装 继承 多态_哔哩哔哩_bilibili</a><br>![[C++ 三大特性 2022-09-27 20.22.16.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>62、对象复用的了解，零拷贝的了解</title>
    <link href="/posts/22559/"/>
    <url>/posts/22559/</url>
    
    <content type="html"><![CDATA[<p>📝62、对象复用的了解，零拷贝的了解::代码看不太懂啊</p><!-- basicblock-end --><h1 id="1-对象复用"><a class="markdownIt-Anchor" href="#1-对象复用"></a> 1: 对象复用</h1><p>对象复用其本质是一种设计模式：Flyweight享元模式。</p><p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p><h1 id="2-零拷贝"><a class="markdownIt-Anchor" href="#2-零拷贝"></a> 2: 零拷贝</h1><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p><p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p><p>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部</p><p>区别在于：</p><ul><li>使用push_back()函数需要调用<strong>拷贝构造函数</strong>和<strong>转移构造函数</strong>，</li><li>而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，<strong>效率更高</strong>。</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span><br>{<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//初始构造函数</span><br>    <span class="hljs-built_in">Person</span>(string p_name, <span class="hljs-type">int</span> p_age): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(p_name)), <span class="hljs-built_in">age</span>(p_age)<br>    {<br>         cout &lt;&lt; <span class="hljs-string">"I have been constructed"</span> &lt;&lt;endl;<br>    }<br>     <span class="hljs-comment">//拷贝构造函数</span><br>     <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    {<br>         cout &lt;&lt; <span class="hljs-string">"I have been copy constructed"</span> &lt;&lt;endl;<br>    }<br>     <span class="hljs-comment">//转移构造函数</span><br>     <span class="hljs-built_in">Person</span>(Person&amp;&amp; other): <span class="hljs-built_in">name</span>(std::<span class="hljs-built_in">move</span>(other.name)), <span class="hljs-built_in">age</span>(other.age)<br>    {<br>         cout &lt;&lt; <span class="hljs-string">"I have been moved"</span>&lt;&lt;endl;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    vector&lt;Person&gt; e;<br>    cout &lt;&lt; <span class="hljs-string">"emplace_back:"</span> &lt;&lt;endl;<br>    e.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">"Jane"</span>, <span class="hljs-number">23</span>); <span class="hljs-comment">//不用构造类对象</span><br><br>    vector&lt;Person&gt; p;<br>    cout &lt;&lt; <span class="hljs-string">"push_back:"</span>&lt;&lt;endl;<br>    p.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Person</span>(<span class="hljs-string">"Mike"</span>,<span class="hljs-number">36</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//emplace_back:</span><br><span class="hljs-comment">//I have been constructed</span><br><span class="hljs-comment">//push_back:</span><br><span class="hljs-comment">//I have been constructed</span><br><span class="hljs-comment">//I am being moved.</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>61-80 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>61、什么是内存泄露，如何检测与避免</title>
    <link href="/posts/33630/"/>
    <url>/posts/33630/</url>
    
    <content type="html"><![CDATA[<p>📝61、什么是内存泄露，如何检测与避免::</p><!-- basicblock-end --><p>![[进程的地址空间分布.excalidraw]]</p><h1 id="1-内存泄露"><a class="markdownIt-Anchor" href="#1-内存泄露"></a> 1: 内存泄露</h1><p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。<br>堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。<br>应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p><p><strong>避免内存泄露的几种方式</strong></p><ul><li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li><li>一定要将基类的析构函数声明为<strong>虚函数</strong></li><li>对象数组的释放一定要用<strong>delete []</strong></li><li>有new就有delete，有malloc就有free，保证它们一定成对出现</li></ul><p><strong>检测工具</strong></p><ul><li>Linux下可以使用<strong>Valgrind工具</strong></li><li>Windows下可以使用<strong>CRT库</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>61-80 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>61-80 基础语法目录</title>
    <link href="/posts/46949/"/>
    <url>/posts/46949/</url>
    
    <content type="html"><![CDATA[<p>📝61-80 基础语法目录::</p><!-- basicblock-end --><h1 id="1-61-什么是内存泄露如何检测与避免"><a class="markdownIt-Anchor" href="#1-61-什么是内存泄露如何检测与避免"></a> 1: [[61、什么是内存泄露，如何检测与避免]]</h1><h1 id="2-62-对象复用的了解零拷贝的了解"><a class="markdownIt-Anchor" href="#2-62-对象复用的了解零拷贝的了解"></a> 2: [[62、对象复用的了解，零拷贝的了解]]</h1><h1 id="3-c-三大特性"><a class="markdownIt-Anchor" href="#3-c-三大特性"></a> 3: [[C++ 三大特性]]</h1><h1 id="4-成员列表初始化"><a class="markdownIt-Anchor" href="#4-成员列表初始化"></a> 4: [[成员列表初始化]]</h1><h1 id="5-65-c的四种强制转换reinterpret_castconst_caststatic_cast-dynamic_cast"><a class="markdownIt-Anchor" href="#5-65-c的四种强制转换reinterpret_castconst_caststatic_cast-dynamic_cast"></a> 5: [[65、C++的四种强制转换reinterpret_castconst_caststatic_cast dynamic_cast]]</h1><h1 id="6-66-c函数调用的压栈过程"><a class="markdownIt-Anchor" href="#6-66-c函数调用的压栈过程"></a> 6: [[66、C++函数调用的压栈过程]]</h1><h1 id="7-67-写c代码时有一类错误是-coredump-很常见你遇到过吗怎么调试这个错误"><a class="markdownIt-Anchor" href="#7-67-写c代码时有一类错误是-coredump-很常见你遇到过吗怎么调试这个错误"></a> 7: 67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h1><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><ul><li>使用gdb命令对core文件进行调试</li></ul><p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">mkdir coredumpTest<br>vim coredumpTest.cpp<br></code></pre></td></tr></tbody></table></figure><p>在编辑器内键入</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,i);<span class="hljs-comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">g++ coredumpTest.cpp -g -o coredumpTest<br></code></pre></td></tr></tbody></table></figure><p>运行</p><p>使用gdb调试coredump</p><h1 id="8-68-说说移动构造函数"><a class="markdownIt-Anchor" href="#8-68-说说移动构造函数"></a> 8: 68、说说移动构造函数</h1><ol><li>我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li><li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</li></ol><p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p><ol start="3"><li>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</li></ol><h1 id="9-69-c中将临时变量作为返回值时的处理过程"><a class="markdownIt-Anchor" href="#9-69-c中将临时变量作为返回值时的处理过程"></a> 9: 69、C++中将临时变量作为返回值时的处理过程</h1><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p><p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p><p>如果我们需要返回值，一般使用赋值语句就可以了。</p><h1 id="10-70-如何获得结构成员相对于结构开头的字节偏移量"><a class="markdownIt-Anchor" href="#10-70-如何获得结构成员相对于结构开头的字节偏移量"></a> 10: 70、如何获得结构成员相对于结构开头的字节偏移量</h1><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">S</span><br>{<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">char</span> y;<br><span class="hljs-type">int</span> z;<br><span class="hljs-type">double</span> a;<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>在Visual Studio 2019 + Win10 下的输出情况如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，</span><br></code></pre></td></tr></tbody></table></figure><p>当然了，如果加上 #pragma pack(4) 指定4字节对齐方式就可以了。</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#pragma</span> <span class="hljs-built_in">pack</span>(<span class="hljs-number">4</span>)<br>struct  S<br>{<br>int x;<br>char y;<br>int z;<br>double <span class="hljs-selector-tag">a</span>;<br>};<br>void <span class="hljs-built_in">test02</span>()<br>{<br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="hljs-comment">// 4</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="hljs-comment">// 8</span><br>cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="hljs-comment">// 12</span><br>｝<br>```C++<br><br><br>S结构体中各个数据成员的内存空间划分如下所示，需要注意内存对齐<br><br>!<span class="hljs-selector-attr">[]</span>(https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/<span class="hljs-number">202205220035079</span>.png)<br><br># <span class="hljs-number">12</span>: <span class="hljs-number">71</span>、静态类型和动态类型，静态绑定和动态绑定的介绍<br><br>-   静态类型：对象在声明时采用的类型，在编译期既已确定；<br>-   动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；<br>-   静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；<br>-   动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；<br><br>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。举个例子：<br><br></code></pre></td></tr></tbody></table></figure><p>#include <iostream><br>using namespace std;</iostream></p><p>class A<br>{<br>public:<br>/<em>virtual</em>/ void func() { std::cout &lt;&lt; “A::func()\n”; }<br>};<br>class B : public A<br>{<br>public:<br>void func() { std::cout &lt;&lt; “B::func()\n”; }<br>};<br>class C : public A<br>{<br>public:<br>void func() { std::cout &lt;&lt; “C::func()\n”; }<br>};<br>int main()<br>{<br>C* pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*；<br>B* pb = new B(); //pb的静态类型和动态类型也都是B*；<br>A* pa = pc;      //pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；<br>pa = pb;         //pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；<br>C <em>pnull = NULL; //pnull的静态类型是它声明的类型C</em>,没有动态类型，因为它指向了NULL；<br>pa-&gt;func();      //A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；<br>pc-&gt;func();      //C::func() pc的动、静态类型都是C*，因此调用C::func()；<br>pnull-&gt;func();   //C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；<br>return 0;<br>}</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><br>如果将A类中的virtual注释去掉，则运行结果是：<br><br>```C++<br>pa-&gt;<span class="hljs-keyword">func</span>();      <span class="hljs-regexp">//</span>B::<span class="hljs-keyword">func</span>() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；<br>pc-&gt;<span class="hljs-keyword">func</span>();      <span class="hljs-regexp">//</span>C::<span class="hljs-keyword">func</span>() pc的动、静态类型都是C*，因此也是先在C中查找；<br>pnull-&gt;<span class="hljs-keyword">func</span>();   <span class="hljs-regexp">//</span>空指针异常，因为是<span class="hljs-keyword">func</span>是virtual函数，因此对<span class="hljs-keyword">func</span>的调用只能等到运行期才能确定，然后才发现pnull是空指针；<br></code></pre></td></tr></tbody></table></figure><p>在上面的例子中，</p><ul><li>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</li><li>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</li><li>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</li></ul><p><strong>本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。</strong></p><p>至此总结一下静态绑定和动态绑定的区别：</p><ul><li>静态绑定发生在编译期，动态绑定发生在运行期；</li><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>要想实现动态，必须使用动态绑定；</li><li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li></ul><p><strong>建议：</strong></p><p>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查。看下面的代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span><br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>{<br>std::cout &lt;&lt; <span class="hljs-string">"E::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> : <span class="hljs-keyword">public</span> E<br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span>{<br>std::cout &lt;&lt; <span class="hljs-string">"F::func()\t"</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>;<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>F* pf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">F</span>();<br>E* pe = pf;<br>pf-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//F::func() 1  正常，就该如此；</span><br>pe-&gt;<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span><br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-built_in">test2</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="11-72-引用是否能实现动态绑定为什么可以实现"><a class="markdownIt-Anchor" href="#11-72-引用是否能实现动态绑定为什么可以实现"></a> 11: 72、引用是否能实现动态绑定，为什么可以实现？</h1><p>可以。</p><p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p><p>举个例子：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> <br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">fun</span>()</span><br>{<br>cout &lt;&lt; <span class="hljs-string">"base :: fun()"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> : <span class="hljs-title">public</span> <span class="hljs-title">Base</span><br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">fun</span>()</span><br>{<br>cout &lt;&lt; <span class="hljs-string">"son :: fun()"</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span>()</span><br>{<br>cout &lt;&lt; <span class="hljs-string">"son :: not virtual function"</span> &lt;&lt;endl;<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>{<br>Son s;<br>Base&amp; b = s; <span class="hljs-comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span><br>s.fun(); <span class="hljs-comment">//son::fun()</span><br>b.fun(); <span class="hljs-comment">//son :: fun()</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>需要说明的是虚函数才具有动态绑定</strong>，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p><h1 id="12-73-全局变量和局部变量有什么区别"><a class="markdownIt-Anchor" href="#12-73-全局变量和局部变量有什么区别"></a> 12: 73、全局变量和局部变量有什么区别？</h1><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p><p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p><p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面。</p><h1 id="13-74-指针加减计算要注意什么"><a class="markdownIt-Anchor" href="#13-74-指针加减计算要注意什么"></a> 13: 74、指针加减计算要注意什么？</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p><p>举个例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> *a, *b, c;<br>a = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x500</span>;<br>b = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x520</span>;<br>c = b - a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, c); <span class="hljs-comment">// 8</span><br>a += <span class="hljs-number">0x020</span>;<br>c = b - a;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, c); <span class="hljs-comment">// -24</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5*16<sup>2=1280）和1312（5*16</sup>2+2*16=1312)，那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8</p><p>a自增16进制0x20之后，其实际地址变为1280 + 2*16*4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24</p><p>遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</strong></p><h1 id="14-75-怎样判断两个浮点数是否相等"><a class="markdownIt-Anchor" href="#14-75-怎样判断两个浮点数是否相等"></a> 14: 75、怎样判断两个浮点数是否相等？</h1><p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p><h1 id="15-76-方法调用的原理栈汇编"><a class="markdownIt-Anchor" href="#15-76-方法调用的原理栈汇编"></a> 15: 76、方法调用的原理（栈，汇编）</h1><ol><li>机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</li><li>由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</li><li>过程实现</li></ol><p>① 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</p><p>② 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</p><p>③ 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p><p>④ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</p><p>⑤ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。</p><p>⑥ 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</p><p>⑦ 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</p><p>⑧ 弹出返回地址，跳出当前过程，继续执行调用者的代码。</p><ol start="4"><li>过程调用和返回指令</li></ol><p>① call指令</p><p>② leave指令</p><p>③ ret指令</p><h1 id="16-77-c中的指针参数传递和引用参数传递有什么区别底层原理你知道吗"><a class="markdownIt-Anchor" href="#16-77-c中的指针参数传递和引用参数传递有什么区别底层原理你知道吗"></a> 16: 77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h1><p><strong>1)</strong> 指针参数传递本质上是值传递，它所传递的是一个地址值。</p><p>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</p><p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p><p><strong>2)</strong> 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</p><p>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。</p><p>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p><p><strong>3)</strong> 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</p><p>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p><p><strong>4)</strong> 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</p><p>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p><p>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p><h1 id="17-78-类如何实现只能静态分配和只能动态分配"><a class="markdownIt-Anchor" href="#17-78-类如何实现只能静态分配和只能动态分配"></a> 17: 78、类如何实现只能静态分配和只能动态分配</h1><ol><li>前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</li><li>建立类的对象有两种方式：</li></ol><p>① 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</p><p>② 动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</p><ol start="3"><li>只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</li></ol><h1 id="18-79-如果想将某个类用作基类为什么该类必须定义而非声明"><a class="markdownIt-Anchor" href="#18-79-如果想将某个类用作基类为什么该类必须定义而非声明"></a> 18: 79、如果想将某个类用作基类，为什么该类必须定义而非声明？</h1><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p><p>所以必须定义而非声明。</p><h1 id="19-80-继承机制中对象之间如何转换指针和引用之间如何转换"><a class="markdownIt-Anchor" href="#19-80-继承机制中对象之间如何转换指针和引用之间如何转换"></a> 19: 80、继承机制中对象之间如何转换？指针和引用之间如何转换？</h1><p>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</p><p>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>61-80 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pragma</tag>
      
      <tag>include</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>59、有哪些情况必须用到成员列表初始化？</title>
    <link href="/posts/61052/"/>
    <url>/posts/61052/</url>
    
    <content type="html"><![CDATA[<p>📝59、有哪些情况必须用到成员列表初始化？作用是什么？::</p><!-- basicblock-end --><ol><li>必须使用成员初始化的四种情况</li></ol><p>① 当初始化一个引用成员时；</p><p>② 当初始化一个常量成员时；</p><p>③ 当调用一个基类的构造函数，而它拥有一组参数时；</p><p>④ 当调用一个成员类的构造函数，而它拥有一组参数时；</p><ol start="2"><li>成员初始化列表做了什么</li></ol><p>① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p><p>② list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>60、C++中新增了string，它与C语言中的 char 有什么区别吗？它是如何实现的？</title>
    <link href="/posts/49936/"/>
    <url>/posts/49936/</url>
    
    <content type="html"><![CDATA[<p>📝60、C++中新增了string，它与C语言中的 char 有什么区别吗？它是如何实现的？::</p><!-- basicblock-end --><p>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</p><p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>58、类成员初始化方式？</title>
    <link href="/posts/1390/"/>
    <url>/posts/1390/</url>
    
    <content type="html"><![CDATA[<p>📝58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？::</p><!-- basicblock-end --><p>构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</p><ol><li>赋值初始化，通过在函数体内进行赋值初始化；</li><li>列表初始化，在冒号后使用初始化列表进行初始化。</li></ol><p>这两种方式的主要区别在于：</p><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p><ol start="2"><li>一个派生类构造函数的执行顺序如下：</li></ol><ul><li>① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</li><li>② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</li><li>③ 类类型的成员对象的构造函数（按照初始化顺序）</li><li>④ 派生类自己的构造函数。</li></ul><ol start="3"><li>方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，<strong>C++的赋值操作是会产生临时对象的</strong>。临时对象的出现会降低程序的效率。</li></ol><h1 id="1-成员列表初始化"><a class="markdownIt-Anchor" href="#1-成员列表初始化"></a> 1: [[成员列表初始化]]</h1><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2:</h1><p>![[函数特化.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>57、malloc、realloc、calloc的区别</title>
    <link href="/posts/37086/"/>
    <url>/posts/37086/</url>
    
    <content type="html"><![CDATA[<p>📝57、malloc、realloc、calloc的区别::</p><!-- basicblock-end --><ol><li>malloc函数</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num_size)</span></span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">// 申请20个int类型的空间；</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>calloc函数</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n,<span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">20</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></tbody></table></figure><p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p><ol start="3"><li>realloc函数</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *p, <span class="hljs-type">size_t</span> new_size)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>给动态分配的空间分配额外的空间，用于扩充容量。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>55、malloc申请的存储空间能用delete释放吗</title>
    <link href="/posts/38977/"/>
    <url>/posts/38977/</url>
    
    <content type="html"><![CDATA[<p>📝55、malloc申请的存储空间能用delete释放吗::</p><!-- basicblock-end --><p>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。</p><p>malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。</p><p>new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。</p><p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>36、创建索引时需要注意什么？</title>
    <link href="/posts/63281/"/>
    <url>/posts/63281/</url>
    
    <content type="html"><![CDATA[<p>📝36、创建索引时需要注意什么？::</p><!-- basicblock-end --><ol><li>索引不是越多越好，虽然索引会提高 select 效率，但是也降低了insert以及update<br>的效率</li><li>数据量小的表不需要建立索引，会增加额外的索引开销</li><li>不经常使用的列不要建立索引</li><li>频繁更新的列不要建立索引，会影响更新的效率</li></ol><ul><li><p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。</p><ul><li>在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li></ul></li><li><p>question 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p></li><li><p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p><ul><li>唯一、不为空、经常被查询的字段的字段适合建索引</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非聚合索引</title>
    <link href="/posts/21337/"/>
    <url>/posts/21337/</url>
    
    <content type="html"><![CDATA[<p>📝非聚合索引::</p><!-- basicblock-end --><p>如果您认识某个字，如果您认识某个字，您可以快速地从自动中查到这个字。<br>但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据"偏旁部首"查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。</p><p>但您结合"部首目录"和"检字表"而查到的字的排序并不是真正的正文的排序方法，<br>比如您查"张"字，我们可以看到在查部首之后的检字表中"张"的页码是672页，检字表中"张"的上面是"驰"字，但页码却是63 页，"张"的下面是"弩"字，页面是390页。很显然，这些字并不是真正的分别位于"张"字的上下方，</p><p>现在您看到的连续的"驰、张、弩"三字实际上就是他 们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后 再翻到您所需要的页码。</p><p>我们把<strong>这种目录纯粹是目录，正文纯粹是正文的排序方式称为"非聚集索引"。</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聚集索引</title>
    <link href="/posts/60612/"/>
    <url>/posts/60612/</url>
    
    <content type="html"><![CDATA[<p>📝聚集索引::</p><!-- basicblock-end --><h1 id="1-聚集索引"><a class="markdownIt-Anchor" href="#1-聚集索引"></a> 1: 聚集索引</h1><p><strong>聚集索引</strong>就是按照拼音查询，<strong>非聚集索引</strong>就是按照偏旁等来进行查询。</p><p>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查"安"字，就会很自然地翻开字典的前几页，因为"安"的拼音是"an"，而按照拼音排序 汉字的字典是以英文字母"a"开头并以"z"结尾的，那么"安"字就自然地排在字典的前部。</p><p>如果您翻完了所有以"a"开头的部分仍然找不到这个字，那么就 说明您的字典中没有这个字；</p><p>同样的，如果查"张"字，那您也会将您的字典翻到最后部分，因为"张"的拼音是"zhang"。</p><p>也就是说，字典的正文部分本身 就是一个目录，您不需要再去查其他目录来找到您需要找的内容。</p><p>我们把这种<strong>正文内容本身就是一种按照一定规则排列的目录称为"聚集索引"</strong></p><h1 id="2-非聚集合索引"><a class="markdownIt-Anchor" href="#2-非聚集合索引"></a> 2: [[非聚集(合)索引]]</h1><h1 id="3-聚集索引与非聚集索引的区别是什么"><a class="markdownIt-Anchor" href="#3-聚集索引与非聚集索引的区别是什么"></a> 3: 聚集索引与非聚集索引的区别是什么?</h1><p>聚集索引和非聚集索引的区别在于，<br>通过聚集索引可以查到需要查找的数据，<br>而通过非聚集索引可以查到记录对应的主键值，再使用主键的值通过聚集索引查找到需要的数据。</p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p><p>聚集索引（Innodb）的叶节点就是数据节点，<br>而非聚集索引(MyisAM)的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。<br>类似与 B+树咯</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>32、SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？</title>
    <link href="/posts/3122/"/>
    <url>/posts/3122/</url>
    
    <content type="html"><![CDATA[<p>📝32、SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？::</p><!-- basicblock-end --><p>NOW（）命令用于显示当前年份，月份，日期，<strong>小时，分钟和秒</strong>。<br>CURRENT_DATE（）仅显示当前年份，月份, 和日期</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一致性 (Consistency)</title>
    <link href="/posts/32431/"/>
    <url>/posts/32431/</url>
    
    <content type="html"><![CDATA[<p>📝一致性 (Consistency)::</p><!-- basicblock-end --><p>事务完成时, 必须使所有的数据都保持一致状态。</p><p><strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>这表示写入的资料必须完全符合所有的<strong>预设规则</strong>，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p>比如A向B转账，不可能A扣了钱，B却没收到。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隔离性 (Isolation)</title>
    <link href="/posts/44615/"/>
    <url>/posts/44615/</url>
    
    <content type="html"><![CDATA[<p>📝隔离性 (Isolation)::</p><!-- basicblock-end --><p><strong>隔离性</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力<br>数据库系统提供的隔离机制,保证事务在<strong>不受外部并发操作影响</strong>的独立环境下运行。</p><p><strong>作用</strong>: 允许多个并发事务同时对数据进⾏修改和读写的能⼒，它可以防⽌由于多个事务并发执⾏时由于交叉执⾏⽽导致的数据不⼀致</p><p>事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p><p>redis 的隔离性<br>redis 的事务中的隔离性并没有保证原⼦性，已经做过的操作是不会 rollback 的。<br>它的隔离性是指其他事务不会⼲扰到它⾃⼰的事务。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28、数据库三大范式精讲</title>
    <link href="/posts/48872/"/>
    <url>/posts/48872/</url>
    
    <content type="html"><![CDATA[<p>📝28、数据库三大范式精讲::</p><!-- basicblock-end --><h1 id="1-第一范式"><a class="markdownIt-Anchor" href="#1-第一范式"></a> 1: 第一范式</h1><blockquote><p>[!summary] 简而言之，<strong>第一范式就是无重复的列</strong>。</p></blockquote><p>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。</p><p>如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p><h1 id="2-第二范式"><a class="markdownIt-Anchor" href="#2-第二范式"></a> 2: 第二范式</h1><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。<br>第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。</p><p>为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。第二范式（2NF）要求实体的属性完全依赖于主关键字。</p><p>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。</p><blockquote><p>[!summary] 简而言之，<strong>第二范式就是非主属性非部分依赖于主关键字</strong>。</p></blockquote><h1 id="3-第三范式"><a class="markdownIt-Anchor" href="#3-第三范式"></a> 3: 第三范式</h1><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p><p>例如，<br>存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。<br>那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。<br>如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p><blockquote><p>[!summary] 简而言之，第三范式就是属性不依赖于其它非主属性。</p></blockquote><h1 id="4-数据库三大范式精要总结"><a class="markdownIt-Anchor" href="#4-数据库三大范式精要总结"></a> 4: 数据库三大范式精要总结</h1><h2 id="41-1简单归纳"><a class="markdownIt-Anchor" href="#41-1简单归纳"></a> 4.1: （1）简单归纳：</h2><p>第一范式（1NF）：字段不可分；<br>第二范式（2NF）：有主键，非主键字段依赖主键；<br>第三范式（3NF）：非主键字段不能相互依赖。</p><h2 id="42-2解释"><a class="markdownIt-Anchor" href="#42-2解释"></a> 4.2: （2）解释：</h2><p>1NF：原子性。字段不可再分,否则就不是关系数据库;； 　　<br>2NF：唯一性。一个表只说明一个事物； 　　<br>3NF：每列都与主键有直接关系，不存在传递依赖。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27、数据库中的主键、超键、候选键、外键是什么？（很棒）</title>
    <link href="/posts/58704/"/>
    <url>/posts/58704/</url>
    
    <content type="html"><![CDATA[<p>📝27、数据库中的主键、超键、候选键、外键是什么？（很棒）::</p><!-- basicblock-end --><ul><li><strong>超键</strong>：在关系中能唯一标识<strong>元组的属性集</strong>称为关系模式的超键</li><li><strong>候选键</strong>：不含有<strong>多余属性的超键</strong>称为候选键。也就是在候选键中，若再删除属性，就不是键了！</li><li><strong>主键</strong>：<strong>用户选作元组标识的一个候选键程序主键</strong></li><li><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</li></ul><p><strong>举例</strong>：</p><table><thead><tr><th>学号</th><th>姓名</th><th>性别</th><th>年龄</th><th>系别</th><th>专业</th></tr></thead><tbody><tr><td>20020612</td><td>李辉</td><td>男</td><td>20</td><td>计算机</td><td>软件开发</td></tr><tr><td>20060613</td><td>张明</td><td>男</td><td>18</td><td>计算机</td><td>软件开发</td></tr><tr><td>20060614</td><td>王小玉</td><td>女</td><td>19</td><td>物理</td><td>力学</td></tr><tr><td>20060615</td><td>李淑华</td><td>女</td><td>17</td><td>生物</td><td>动物学</td></tr><tr><td>20060616</td><td>赵静</td><td>男</td><td>21</td><td>化学</td><td>食品化学</td></tr><tr><td>20060617</td><td>赵静</td><td>女</td><td>20</td><td>生物</td><td>植物学</td></tr></tbody></table><ol><li>超键：我们从例子中可以发现学号是标识学生实体的唯一标识。那么该元组的超键就为学号。除此之外我们还可以把它跟其他属性组合起来，比如：(<code>学号</code>，<code>性别</code>)，(<code>学号</code>，<code>年龄</code>)</li><li>候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。</li><li>主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。</li><li>外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。</li></ol><p><strong>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>覆盖索引</title>
    <link href="/posts/21485/"/>
    <url>/posts/21485/</url>
    
    <content type="html"><![CDATA[<p>📝覆盖索引::</p><!-- basicblock-end --><p>们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。<br>最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。<br>覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p>在普通索引树中，就可以直接查到待查结果，而不需要回表<br>由于覆盖素引可以减少树的搜素次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><blockquote><p>[!question]<br>当执行如下语句时，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表::   #疑问</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select ID from T where k between 3 and 5<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引的优缺点</title>
    <link href="/posts/53356/"/>
    <url>/posts/53356/</url>
    
    <content type="html"><![CDATA[<p>📝索引的优缺点::</p><!-- basicblock-end --><h1 id="1-优点"><a class="markdownIt-Anchor" href="#1-优点"></a> 1: 优点</h1><p>用索引引可以大大加快数据的检索速度（大大减少检索的数据量），这也是创建素引的最主要的原因。</p><p>但是注意使用素引不一定能够提高查询性能，因为如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。其余大多数情况下，索引查询比全表扫描要快。</p><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><h1 id="2-缺点"><a class="markdownIt-Anchor" href="#2-缺点"></a> 2: 缺点</h1><p>空间消耗，一个素引对应的就是一棵 b+树，每一个节点都是一个 16KB大小的页。占用的空间较大。<br>创建索引和维护素引需要耗费许多时间，当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</p><blockquote><p>[!example]<br>举例子：向数据库中增加一条记录，如果记录应该存储的页恰好满了，此时就要进行对应的 [[索引维护|页分裂]] 操作。<br>![[MySQL B+Tree .excalidraw]]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>25、什么时候需要建立数据库索引呢？</title>
    <link href="/posts/34574/"/>
    <url>/posts/34574/</url>
    
    <content type="html"><![CDATA[<p>📝25、什么时候需要建立数据库索引呢？::</p><!-- basicblock-end --><p>在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。<br>不宜建立索引：<br>1）对于查询中很少涉及的列或者重复值比较多的列<br>2）对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24、一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</title>
    <link href="/posts/28912/"/>
    <url>/posts/28912/</url>
    
    <content type="html"><![CDATA[<p>📝24、一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？::</p><!-- basicblock-end --><ul><li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li><li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li><li>MySQL库主从读写分离。</li><li>找规律分表，减少单表中的数据量提高查询速度。</li><li>添加缓存机制，比如Memcached，Apc等。</li><li>不经常改动的页面，生成静态页面。</li><li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>22、视图的作用是什么？可以更改吗？</title>
    <link href="/posts/18077/"/>
    <url>/posts/18077/</url>
    
    <content type="html"><![CDATA[<p>📝22、视图的作用是什么？可以更改吗？::</p><!-- basicblock-end --><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的 sql 操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。</p><p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。</p><p>创建视图：create view xxx as xxxx</p><p>对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21、MySQL中有四种索引类型，可以简单说说吗？</title>
    <link href="/posts/53964/"/>
    <url>/posts/53964/</url>
    
    <content type="html"><![CDATA[<p>📝21、MySQL中有四种索引类型，可以简单说说吗？::</p><!-- basicblock-end --><ul><li><strong>FULLTEXT</strong> ：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引，需要注意的是MySQL5.6以后支持全文索引了，5.6之前是不支持的。</li><li><strong>HASH</strong> ：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</li><li><strong>BTREE</strong> ：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。</li><li><strong>RTREE</strong> ：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-40 MySQL目录</title>
    <link href="/posts/51352/"/>
    <url>/posts/51352/</url>
    
    <content type="html"><![CDATA[<p>📝21-40 MySQL目录::</p><!-- basicblock-end --><h1 id="1-21-mysql中有四种索引类型可以简单说说吗"><a class="markdownIt-Anchor" href="#1-21-mysql中有四种索引类型可以简单说说吗"></a> 1: [[21、MySQL中有四种索引类型，可以简单说说吗？]]</h1><h1 id="2-22-视图的作用是什么可以更改吗"><a class="markdownIt-Anchor" href="#2-22-视图的作用是什么可以更改吗"></a> 2: [[22、视图的作用是什么？可以更改吗？]]</h1><h1 id="3-文件索引和数据库索引为什么使用b树而不使用-b-树"><a class="markdownIt-Anchor" href="#3-文件索引和数据库索引为什么使用b树而不使用-b-树"></a> 3: [[文件索引和数据库索引为什么使用B+树而不使用 B 树]]</h1><h1 id="4-24-一道场景题假如你所在的公司选择mysql数据库作数据存储一天五万条以上的增量预计运维三年你有哪些优化手段"><a class="markdownIt-Anchor" href="#4-24-一道场景题假如你所在的公司选择mysql数据库作数据存储一天五万条以上的增量预计运维三年你有哪些优化手段"></a> 4: [[24、一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？]]</h1><h1 id="5-25-什么时候需要建立数据库索引呢"><a class="markdownIt-Anchor" href="#5-25-什么时候需要建立数据库索引呢"></a> 5: [[25、什么时候需要建立数据库索引呢？]]</h1><h1 id="6-覆盖索引"><a class="markdownIt-Anchor" href="#6-覆盖索引"></a> 6: [[覆盖索引]]</h1><h1 id="7-27-数据库中的主键-超键-候选键-外键目录"><a class="markdownIt-Anchor" href="#7-27-数据库中的主键-超键-候选键-外键目录"></a> 7: [[27、数据库中的主键, 超键, 候选键, 外键(目录)]]</h1><h1 id="8-28-数据库三大范式精讲"><a class="markdownIt-Anchor" href="#8-28-数据库三大范式精讲"></a> 8: [[28、数据库三大范式精讲]]</h1><h1 id="9-28-数据库三大范式精讲4-数据库三大范式精要总结"><a class="markdownIt-Anchor" href="#9-28-数据库三大范式精讲4-数据库三大范式精要总结"></a> 9: [[28、数据库三大范式精讲#4 数据库三大范式精要总结]]</h1><h1 id="10-数据库引擎innodb与myisam的区别"><a class="markdownIt-Anchor" href="#10-数据库引擎innodb与myisam的区别"></a> 10: [[数据库引擎InnoDB与MyISAM的区别]]</h1><h1 id="11-事务的四大特性-acid目录"><a class="markdownIt-Anchor" href="#11-事务的四大特性-acid目录"></a> 11: [[事务的四大特性  ACID(目录)]]</h1><h1 id="12-32-sql中的now和current_date两个函数有什么区别"><a class="markdownIt-Anchor" href="#12-32-sql中的now和current_date两个函数有什么区别"></a> 12: [[32、SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？]]</h1><h1 id="13-33-35-聚集索引目录"><a class="markdownIt-Anchor" href="#13-33-35-聚集索引目录"></a> 13: 33-35: [[聚集索引(目录)]]</h1><h1 id="14-建立索引注意事项"><a class="markdownIt-Anchor" href="#14-建立索引注意事项"></a> 14: [[建立索引注意事项]]</h1><h1 id="15-char-和-varchar-的区别"><a class="markdownIt-Anchor" href="#15-char-和-varchar-的区别"></a> 15: [[char 和 varchar 的区别？]]</h1><h1 id="16-38-mysql-索引使用的注意事项"><a class="markdownIt-Anchor" href="#16-38-mysql-索引使用的注意事项"></a> 16: 38、MySQL 索引使用的注意事项</h1><p>MySQL 索引通常是被用于提高 WHERE 条件的数据行匹配时的搜索速度，在索引的使用过程中，存在一些使用细节和注意事项。</p><p>函数，运算，否定操作符，连接条件，多个单列索引，最左前缀原则，范围查询，不会包含有NULL值的列，like 语句不要在列上使用函数和进行运算</p><h2 id="161-1不要在列上使用函数这将导致索引失效而进行全表扫描"><a class="markdownIt-Anchor" href="#161-1不要在列上使用函数这将导致索引失效而进行全表扫描"></a> 16.1: <strong>1）不要在列上使用函数，这将导致索引失效而进行全表扫描。</strong></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where year(publish_time) &lt; 2017<br></code></pre></td></tr></tbody></table></figure><p>为了使用索引，防止执行全表扫描，可以进行改造。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where publish_time &lt; '2017-01-01'<br></code></pre></td></tr></tbody></table></figure><p>还有一个建议，不要在列上进行运算，这也将导致索引失效而进行全表扫描。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where id / 100 = 1<br></code></pre></td></tr></tbody></table></figure><p>为了使用索引，防止执行全表扫描，可以进行改造。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where id = 1 * 100<br></code></pre></td></tr></tbody></table></figure><h2 id="162-2尽量避免使用-或-not-in或-等否定操作符"><a class="markdownIt-Anchor" href="#162-2尽量避免使用-或-not-in或-等否定操作符"></a> 16.2: <strong>2）尽量避免使用 != 或 not in或 &lt;&gt; 等否定操作符</strong></h2><p>应该尽量避免在 where 子句中使用 != 或 not in 或 &lt;&gt; 操作符，因为这几个操作符都会导致索引失效而进行全表扫描。尽量避免使用 or 来连接条件应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where id = 1 or id = 2<br></code></pre></td></tr></tbody></table></figure><h2 id="163-3多个单列索引并不是最佳选择"><a class="markdownIt-Anchor" href="#163-3多个单列索引并不是最佳选择"></a> 16.3: <strong>3）多个单列索引并不是最佳选择</strong></h2><p>MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where news_year = 2017 and news_month = 1<br></code></pre></td></tr></tbody></table></figure><p>事实上，MySQL 只能使用一个单列索引。为了提高性能，可以使用复合索引 news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖。</p><h2 id="164-4复合索引的最左前缀原则"><a class="markdownIt-Anchor" href="#164-4复合索引的最左前缀原则"></a> 16.4: <strong>4）复合索引的最左前缀原则</strong></h2><p>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。假设，有一个场景只需要针对资讯的月份进行查询，那么，SQL 语句可以写成：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where news_month = 1<br></code></pre></td></tr></tbody></table></figure><p>此时，无法使用 news_year_month_idx(news_year, news_month) 索引，因为遵守“最左前缀”原则，在查询条件中没有使用复合索引的第一个字段，索引是不会被使用的。</p><h2 id="165-5覆盖索引的好处"><a class="markdownIt-Anchor" href="#165-5覆盖索引的好处"></a> 16.5: <strong>5）覆盖索引的好处</strong></h2><p>如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。</p><h2 id="166-6范围查询对多列查询的影响"><a class="markdownIt-Anchor" href="#166-6范围查询对多列查询的影响"></a> 16.6: <strong>6）范围查询对多列查询的影响</strong></h2><p>查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL 语句可以写成：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where publish_time &gt;= '2017-01-02' and publish_time &lt;= '2017-01-08' and enable = 1<br></code></pre></td></tr></tbody></table></figure><p>这种情况下，因为范围查询对多列查询的影响，将导致 news_publish_idx(publish_time, enable) 索引中 publish_time 右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time, enable) 索引等价于 news_publish_idx(publish_time) 。对于这种情况，我的建议：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth 字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL 可以改写成：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where news_weekth = 1 and enable = 1<br><br></code></pre></td></tr></tbody></table></figure><p>然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，我的建议：不必试图用 SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的 SortedSet 有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。</p><h2 id="167-7索引不会包含有null值的列"><a class="markdownIt-Anchor" href="#167-7索引不会包含有null值的列"></a> 16.7: <strong>7）索引不会包含有NULL值的列</strong></h2><p>只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。</p><h2 id="168-8隐式转换的影响"><a class="markdownIt-Anchor" href="#168-8隐式转换的影响"></a> 16.8: <strong>8）隐式转换的影响</strong></h2><p>当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。下面的案例中，date_str 是字符串，然而匹配的是整数类型，从而发生隐式转换。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from news where date_str = 201701<br><br></code></pre></td></tr></tbody></table></figure><p>因此，要谨记隐式转换的危害，时刻注意通过同类型进行比较。</p><h2 id="169-9like-语句的索引失效问题"><a class="markdownIt-Anchor" href="#169-9like-语句的索引失效问题"></a> 16.9: <strong>9）like 语句的索引失效问题</strong></h2><p>like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。</p><h1 id="17-39-mysql中有哪些索引有什么特点"><a class="markdownIt-Anchor" href="#17-39-mysql中有哪些索引有什么特点"></a> 17: 39、MySQL中有哪些索引？有什么特点？</h1><ul><li><p><strong>普通索引</strong>：仅加速查询</p></li><li><p><strong>唯一索引</strong>：加速查询 + 列值唯一（可以有null）</p></li><li><p><strong>主键索引</strong>：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</p></li><li><p><strong>组合索引</strong>：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p></li><li><p><strong>全文索引</strong>：对文本的内容进行分词，进行搜索</p></li><li><p><strong>索引合并</strong>：使用多个单列索引组合搜索</p></li><li><p><strong>覆盖索引</strong>：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p></li><li><p><strong>聚簇索引</strong>：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</p></li><li><p>当对表中的数据进行增加、删除和修改的时候，<strong>索引也要动态的维护</strong>，这样就降低了数据的维护速度。</p></li><li><p><strong>索引需要占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。</p></li><li><p><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>21-40 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3、你知道DNS是什么？</title>
    <link href="/posts/35781/"/>
    <url>/posts/35781/</url>
    
    <content type="html"><![CDATA[<p>📝3、你知道DNS是什么？::</p><!-- basicblock-end --><p><strong>官方解释</strong>：DNS（Domain Name System，域名系统），因特网上作为<strong>域名和IP地址相互映射</strong>的一个<strong>分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><p><strong>通俗的讲</strong>，我们更习惯于记住一个网站的名字，<a href="http://xn--www-eo8er22f.baidu.com">比如www.baidu.com</a>,而不是记住它的ip地址，比如：167.23.10.2。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>计算机网络</category>
      
      <category>阿秀</category>
      
      <category>01-20 计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2、说一下一次完整的HTTP请求过程包括哪些内容？</title>
    <link href="/posts/53374/"/>
    <url>/posts/53374/</url>
    
    <content type="html"><![CDATA[<p>📝2、说一下一次完整的HTTP请求过程包括哪些内容？::</p><!-- basicblock-end --><h1 id="1-第一种回答"><a class="markdownIt-Anchor" href="#1-第一种回答"></a> 1: 第一种回答</h1><ul><li>建立起客户机和服务器连接。</li><li>建立连接后，客户机发送一个请求给服务器。</li><li>服务器收到请求给予响应信息。</li><li>客户端浏览器将返回的内容解析并呈现，断开连接。</li></ul><h1 id="2-第二种回答"><a class="markdownIt-Anchor" href="#2-第二种回答"></a> 2: 第二种回答</h1><ul><li>域名解析 --&gt;</li><li>发起TCP的3次握手 --&gt;</li><li>建立TCP连接后发起http请求 --&gt;</li><li>服务器响应http请求，浏览器得到html代码 --&gt;</li><li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --&gt;</li><li>浏览器对页面进行渲染呈现给用户。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>计算机网络</category>
      
      <category>阿秀</category>
      
      <category>01-20 计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OSI</title>
    <link href="/posts/53709/"/>
    <url>/posts/53709/</url>
    
    <content type="html"><![CDATA[<p>📝OSI::</p><!-- basicblock-end --><h1 id="1-简要概括"><a class="markdownIt-Anchor" href="#1-简要概括"></a> 1: 简要概括</h1><ul><li><p>物理层：底层数据传输，如网线；网卡标准。</p></li><li><p>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</p></li><li><p>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</p></li><li><p>传输层：端到端传输数据的基本功能；如 TCP、UDP。</p></li><li><p>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</p></li><li><p>表示层：数据格式标识，基本压缩加密功能。</p></li><li><p>应用层：各种应用软件，包括 Web 应用。</p></li></ul><h1 id="2-说明"><a class="markdownIt-Anchor" href="#2-说明"></a> 2: 说明</h1><ul><li>在四层，既传输层数据被称作<strong>段</strong>（Segments）；</li><li>三层网络层数据被称做<strong>包</strong>（Packages）；</li><li>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</li><li>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</li></ul><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3: 总结</h1><ul><li>网络七层模型是一个标准，而非实现。</li><li>网络四层模型是一个实现的应用模型。</li><li>网络四层模型由七层模型简化合并而来。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>计算机网络</category>
      
      <category>阿秀</category>
      
      <category>01-20 计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-20 计算机网络目录</title>
    <link href="/posts/48738/"/>
    <url>/posts/48738/</url>
    
    <content type="html"><![CDATA[<p>📝01-20 计算机网络目录::</p><!-- basicblock-end --><h1 id="1-osi"><a class="markdownIt-Anchor" href="#1-osi"></a> 1: [[OSI]]</h1><h1 id="2-2-说一下一次完整的http请求过程包括哪些内容"><a class="markdownIt-Anchor" href="#2-2-说一下一次完整的http请求过程包括哪些内容"></a> 2: [[2、说一下一次完整的HTTP请求过程包括哪些内容？]]</h1><h1 id="3-3-你知道dns是什么"><a class="markdownIt-Anchor" href="#3-3-你知道dns是什么"></a> 3: [[3、你知道DNS是什么？]]</h1><h1 id="4-4-dns的工作原理"><a class="markdownIt-Anchor" href="#4-4-dns的工作原理"></a> 4: 4、DNS的工作原理？</h1><p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036790.png" alt=""> 过程： 总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。一、主机向本地域名服务器的查询一般都是采用递归查询。二、本地域名服务器向根域名服务器的查询的迭代查询。</p><ol><li>当用户输入域名时，浏览器先检查自己的缓存中是否包含这个域名映射的ip地址，有解析结束。 2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 3）若无命中，则请求本地域名服务器解析（LDNS）。 4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个主域名服务器地址。 5）此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域），接受请求的gTLD查找并返回这个域名对应的Name Server的地址 6）Name Server根据映射关系表找到目标ip，返回给LDNS</li><li>LDNS缓存这个域名和对应的ip，把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束</li></ol><h1 id="5-5-为什么域名解析用udp协议"><a class="markdownIt-Anchor" href="#5-5-为什么域名解析用udp协议"></a> 5: 5、为什么域名解析用UDP协议？</h1><p>因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。</p><p>而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。</p><p>不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。</p><h1 id="6-6-为什么区域传送用tcp协议"><a class="markdownIt-Anchor" href="#6-6-为什么区域传送用tcp协议"></a> 6: 6、为什么区域传送用TCP协议？</h1><p>因为TCP协议可靠性好啊！</p><p>你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？所以用TCP协议比较好！</p><h1 id="7-7-http长连接和短连接的区别"><a class="markdownIt-Anchor" href="#7-7-http长连接和短连接的区别"></a> 7: 7、HTTP长连接和短连接的区别</h1><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。</p><h1 id="8-8-什么是tcp粘包拆包发生的原因"><a class="markdownIt-Anchor" href="#8-8-什么是tcp粘包拆包发生的原因"></a> 8: 8、什么是TCP粘包/拆包？发生的原因？</h1><p>一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。</p><h3 id="811-原因"><a class="markdownIt-Anchor" href="#811-原因"></a> 8.1.1: 原因</h3><p>1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.</p><p>2、进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)</p><p>3、以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）</p><h3 id="812-解决方案"><a class="markdownIt-Anchor" href="#812-解决方案"></a> 8.1.2: 解决方案</h3><p>1、消息定长。</p><p>2、在包尾部增加回车或者空格符等特殊字符进行分割</p><p>3、将消息分为消息头和消息尾</p><p>4、使用其它复杂的协议，如RTMP协议等。</p><h1 id="9-9-为什么服务器会缓存这一项功能如何实现的"><a class="markdownIt-Anchor" href="#9-9-为什么服务器会缓存这一项功能如何实现的"></a> 9: 9、为什么服务器会缓存这一项功能?如何实现的？</h1><p><strong>原因</strong></p><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><p><strong>实现方法</strong></p><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h1 id="10-10-http请求方法你知道多少"><a class="markdownIt-Anchor" href="#10-10-http请求方法你知道多少"></a> 10: 10、HTTP请求方法你知道多少？</h1><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p><p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p><p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>2</td><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td></tr><tr><td>4</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>5</td><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>6</td><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>7</td><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>9</td><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table><h1 id="11-11-get-和-post-的区别你知道哪些"><a class="markdownIt-Anchor" href="#11-11-get-和-post-的区别你知道哪些"></a> 11: 11、GET 和 POST 的区别，你知道哪些？</h1><ol><li><p>get是获取数据，post是修改数据</p></li><li><p>get把请求的数据放在url上，以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）</p></li><li><p>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</p></li><li><p>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p></li><li><p>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</p></li><li><p>本质区别：GET是幂等的，而POST不是幂等的</p></li></ol><p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p><p>正因为它们有这样的区别，所以不应该且<strong>不能用get请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</p><h1 id="12-12-一个tcp连接可以对应几个http请求"><a class="markdownIt-Anchor" href="#12-12-一个tcp连接可以对应几个http请求"></a> 12: 12、一个TCP连接可以对应几个HTTP请求？</h1><p>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。</p><h1 id="13-13-一个-tcp-连接中-http-请求发送可以一起发送么比如一起发三个请求再三个响应一起接收"><a class="markdownIt-Anchor" href="#13-13-一个-tcp-连接中-http-请求发送可以一起发送么比如一起发三个请求再三个响应一起接收"></a> 13: 13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</h1><p>HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。</p><p>在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</p><p>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：</p><ul><li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li><li>和服务器建立多个 TCP 连接。</li></ul><h1 id="14-14-浏览器对同一-host-建立-tcp-连接到的数量有没有限制"><a class="markdownIt-Anchor" href="#14-14-浏览器对同一-host-建立-tcp-连接到的数量有没有限制"></a> 14: 14、浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？</h1><p>假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p><p><strong>有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</strong></p><p>如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。</p><p>如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p><blockquote><p>update1：微信好友“卷轴”提出勘误“连接到”-》“连接到的”</p></blockquote><h1 id="15-15-在浏览器中输入url地址后显示主页的过程"><a class="markdownIt-Anchor" href="#15-15-在浏览器中输入url地址后显示主页的过程"></a> 15: 15、在浏览器中输入url地址后显示主页的过程?</h1><blockquote><ul><li>根据域名，进行DNS域名解析；</li><li>拿到解析的IP地址，建立TCP连接；</li><li>向IP地址，发送HTTP请求；</li><li>服务器处理请求；</li><li>返回响应结果；</li><li>关闭TCP连接；</li><li>浏览器解析HTML；</li><li>浏览器布局渲染；</li></ul></blockquote><h1 id="16-16-在浏览器地址栏输入一个url后回车背后会进行哪些技术步骤"><a class="markdownIt-Anchor" href="#16-16-在浏览器地址栏输入一个url后回车背后会进行哪些技术步骤"></a> 16: 16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</h1><h2 id="161-第一种回答"><a class="markdownIt-Anchor" href="#161-第一种回答"></a> 16.1: 第一种回答</h2><p>1、查浏览器缓存，看看有没有已经缓存好的，如果没有</p><p>2 、检查本机host文件，</p><p>3、调用API，Linux下Socket函数 gethostbyname</p><p>4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议</p><p>5、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）</p><p>6、这个时候我们就有了服务器的IP地址以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，</p><p>7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，</p><p>8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，</p><p>9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，</p><p>10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。</p><p>11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页</p><blockquote><p>update1:为微信好友”卷轴“提出勘误”缺少5“-》现已加上</p></blockquote><h2 id="162-第二种回答"><a class="markdownIt-Anchor" href="#162-第二种回答"></a> 16.2: 第二种回答</h2><p>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存，打开 chrome://net-internals/#dns）。</p><p>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询。</p><p>如果 <code>gethostbyname</code> 没有这个域名的缓存记录，也没有在 <code>hosts</code> 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</p><p>查询本地 DNS 服务器</p><p>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</p><p>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</p><h1 id="17-17-谈谈dns解析过程具体一点"><a class="markdownIt-Anchor" href="#17-17-谈谈dns解析过程具体一点"></a> 17: 17、谈谈DNS解析过程，具体一点</h1><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036692.png" alt=""></p><ul><li>请求一旦发起，若是chrome浏览器，先在浏览器找之前<strong>有没有缓存过的域名所对应的ip地址</strong>，有的话，直接跳过dns解析了，若是没有，就会<strong>找硬盘的hosts文件</strong>，看看有没有，有的话，直接找到hosts文件里面的ip</li><li>如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个<strong>dns请求到本地dns服务器</strong>，<strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</li><li>查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中有此条记录，就可以直接返回结果，此过程是<strong>递归的方式进行查询</strong>。如果没有，本地DNS服务器还要向<strong>DNS根服务器</strong>进行查询。</li><li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li><li>最后，本地DNS服务器向<strong>域名的解析服务器</strong>发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li></ul><h1 id="18-18-dns负载均衡是什么策略"><a class="markdownIt-Anchor" href="#18-18-dns负载均衡是什么策略"></a> 18: 18、DNS负载均衡是什么策略？</h1><p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在<strong>DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器</strong>,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p><h1 id="19-19-https和http的区别"><a class="markdownIt-Anchor" href="#19-19-https和http的区别"></a> 19: 19、HTTPS和HTTP的区别</h1><p>1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><h1 id="20-20-什么是ssltls"><a class="markdownIt-Anchor" href="#20-20-什么是ssltls"></a> 20: 20、什么是SSL/TLS ？</h1><p>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。身份验证，加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p><p>SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的</p><p>对称加密：优点在于加密、解密效率通常比较高，HTTPS 是基于非对称加密的，公钥是公开的，</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>计算机网络</category>
      
      <category>阿秀</category>
      
      <category>01-20 计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</title>
    <link href="/posts/9852/"/>
    <url>/posts/9852/</url>
    
    <content type="html"><![CDATA[<p>📝数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？::</p><!-- basicblock-end --><p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</p><p><strong>通过分表</strong>，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题。分表策略可以归纳为垂直拆分和水平拆分： <strong>水平分表</strong>：取模分表就属于随机分表，而时间维度分表则属于连续分表。如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</p><p><strong>库内分表</strong>，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU内存磁盘 IO网络带宽等。</p><p><strong>分库与分表带来的分布式困境与应对之策</strong> 数据迁移与扩容问题----一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。分页与排序问题----需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p><p><strong>不可重复读的重点是修改，幻读的重点在于新增或者删除。</strong></p><ul><li><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。</p></li><li><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>01-20 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引主要使用的两种数据结构是什么？</title>
    <link href="/posts/31526/"/>
    <url>/posts/31526/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL索引主要使用的两种数据结构是什么？::</p><!-- basicblock-end --><ul><li><p><strong>哈希索引</strong>，对于哈希索引来说，底层的数据结构肯定是哈希表，因此<strong>在绝大多数需求为单条记录查询</strong>的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引</p></li><li><p><strong>BTree索引</strong>，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。</p></li></ul><p>但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</p><h1 id="1-hash-索引"><a class="markdownIt-Anchor" href="#1-hash-索引"></a> 1: [[Hash 索引]]</h1><h1 id="2-btree-索引"><a class="markdownIt-Anchor" href="#2-btree-索引"></a> 2: [[B+Tree 索引]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>乐观锁&amp;悲观锁(程序员角度)</title>
    <link href="/posts/52253/"/>
    <url>/posts/52253/</url>
    
    <content type="html"><![CDATA[<p>📝乐观锁&amp;悲观锁(程序员角度)::</p><!-- basicblock-end --><h1 id="1-乐观锁optimistic-locking"><a class="markdownIt-Anchor" href="#1-乐观锁optimistic-locking"></a> 1: 乐观锁（Optimistic Locking）</h1><p>认为对同⼀数据的并发操作不会总发⽣，属于⼩概率事件，不⽤每次都对数据上锁，也就是不采⽤数据库⾃⾝的锁机制，⽽是通过程序来实现。</p><p>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。</p><p>Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p><p>在程序上，我们可以采⽤版本号机制或者时间戳机制实现。</p><h1 id="2-悲观锁pessimistic-locking"><a class="markdownIt-Anchor" href="#2-悲观锁pessimistic-locking"></a> 2: 悲观锁（Pessimistic Locking）</h1><p>悲观锁，先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。<br>也是⼀种思想，对数据被其他事务的修改持保守态度，会通过数据库⾃⾝的锁机制来实现，从⽽保证数据操作的排它性。</p><p>当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><h1 id="3-乐观锁和悲观锁的适用场景"><a class="markdownIt-Anchor" href="#3-乐观锁和悲观锁的适用场景"></a> 3: 乐观锁和悲观锁的适⽤场景</h1><p>（1）乐观锁<br>适合读操作多的场景，相对来说写的操作⽐较少。它的优点在于程序实现，不存在死锁问题，不过适⽤场景也会相对乐观，因为它阻⽌不了除了程序以外的数据库操作。</p><p>（2）悲观锁</p><p>适合写操作多的场景，因为写的操作具有排它性。采⽤悲观锁的⽅式，可以在数据库层⾯阻 ⽌其他事务对该数据的操作权限，防⽌读 - 写和写 - 写的冲突。<br>但是加锁的时间会⽐较长，可能会长时间限制其他⽤户的访问，也就是说他的并发访问性不好。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 表连接 与 锁</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>53、delete p、delete  p、allocator都有什么作用？</title>
    <link href="/posts/63999/"/>
    <url>/posts/63999/</url>
    
    <content type="html"><![CDATA[<p>📝53、delete p、delete  p、allocator都有什么作用？::</p><!-- basicblock-end --><p>1、动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</p><p>2、 new动态数组返回的并不是数组类型，而是一个元素类型的指针；</p><p>3、 delete[]时，数组中的元素按逆序的顺序进行销毁；</p><p>4、 new在内存分配上面有一些局限性，new的机制是将<strong>内存分配</strong>和<strong>对象构造</strong>组合在一起，同样的，delete也是将<strong>对象析构</strong>和<strong>内存释放</strong>组合在一起的。<br>allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>malloc和new的区别？</title>
    <link href="/posts/44391/"/>
    <url>/posts/44391/</url>
    
    <content type="html"><![CDATA[<p>📝malloc和new的区别？::</p><!-- basicblock-end --><ul><li><p>malloc和free是标准库函数，支持覆盖；</p></li><li><p>new和delete是运算符，支持重载。</p></li><li><p>new/delete是C++关键字，需要编译器支持。</p></li><li><p>malloc/free是库函数，需要头文件支持；</p></li><li><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。</p></li><li><p>而malloc则需要显式地指出所需内存的尺寸。</p></li><li><p>new操作符内存分配成功时，返回的是<strong>对象类型的指针</strong>，</p><ul><li>类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。</li></ul></li><li><p>malloc内存分配成功则是返回void * ，必须需要通过<strong>强制类型转</strong>换将void*指针转换成我们需要的类型。</p></li><li><p>new内存分配失败时，会抛出bad_alloc异常。</p></li><li><p>malloc分配内存失败时返回NULL。</p></li><li><p>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；</p></li><li><p>new和delete除了分配回收功能外，还会调用构造函数和析构函数。</p></li></ul><blockquote><p>[!example]-<br>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。<br>delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。<br>malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>50、从汇编层去解释一下引用</title>
    <link href="/posts/53675/"/>
    <url>/posts/53675/</url>
    
    <content type="html"><![CDATA[<p>📝50、从汇编层去解释一下引用::</p><!-- basicblock-end --><p>![[进程的地址空间分布.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">9</span>:      <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-number">00401048</span>  mov     dword ptr [ebp<span class="hljs-number">-4</span>],<span class="hljs-number">1</span><br><br><span class="hljs-number">10</span>:     <span class="hljs-type">int</span> &amp;b = x;<br><br><span class="hljs-number">0040104F</span>   lea     eax,[ebp<span class="hljs-number">-4</span>]<br><br><span class="hljs-number">00401052</span>  mov     dword ptr [ebp<span class="hljs-number">-8</span>],eax<br></code></pre></td></tr></tbody></table></figure><p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存<strong>是从高往低进行分配</strong>的，所以b的地址比x的低。</p><p>lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器</p><p>mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址</p><p>ebp-8中上面两条汇编的作用即：<br>将x的地址存入变量b中，<br>这不和将某个变量的地址存入指针变量是一样的吗？<br>所以从汇编层次来看，的确引用是通过指针来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类(目录)</title>
    <link href="/posts/5253/"/>
    <url>/posts/5253/</url>
    
    <content type="html"><![CDATA[<p>📝类::</p><!-- basicblock-end --><h1 id="1-49-什么是类的继承"><a class="markdownIt-Anchor" href="#1-49-什么是类的继承"></a> 1: [[49、什么是类的继承？]]</h1><h1 id="2-58-类成员初始化方式"><a class="markdownIt-Anchor" href="#2-58-类成员初始化方式"></a> 2: [[58、类成员初始化方式？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>49、什么是类的继承？</title>
    <link href="/posts/51919/"/>
    <url>/posts/51919/</url>
    
    <content type="html"><![CDATA[<p>📝49、什么是类的继承？::</p><!-- basicblock-end --><h1 id="1-类与类之间的关系"><a class="markdownIt-Anchor" href="#1-类与类之间的关系"></a> 1: 类与类之间的关系</h1><p>has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；</p><p>use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；</p><p>is-A，继承关系，关系具有传递性；</p><h1 id="2-继承的相关概念"><a class="markdownIt-Anchor" href="#2-继承的相关概念"></a> 2: 继承的相关概念</h1><p>所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；</p><h1 id="3-继承的特点"><a class="markdownIt-Anchor" href="#3-继承的特点"></a> 3: 继承的特点</h1><p>子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；</p><h1 id="4-继承中的访问控制"><a class="markdownIt-Anchor" href="#4-继承中的访问控制"></a> 4: 继承中的访问控制</h1><p>public、protected、private</p><ol start="5"><li>继承中的构造和析构函数</li><li>继承中的兼容性原则</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>48、const关键字的作用有哪些</title>
    <link href="/posts/28252/"/>
    <url>/posts/28252/</url>
    
    <content type="html"><![CDATA[<p>📝48、const关键字的作用有哪些::</p><!-- basicblock-end --><ol><li>阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</li><li>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</li><li>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li><li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；</li><li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li><li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li><li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li><li>一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此<strong>const对象只能调用const成员函数</strong>。</li><li>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</li><li>const类型变量<strong>必须定义的时候进行初始化</strong>，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；</li></ol><p>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。<br>则这个时候无论加不加const对实参不会产生任何影响。<br>但是在引用或指针传递函数调用中，因为传进去的是一个<strong>引用或指针</strong>，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。<br>因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。<br>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>47、静态变量什么时候初始化</title>
    <link href="/posts/35281/"/>
    <url>/posts/35281/</url>
    
    <content type="html"><![CDATA[<p>📝47、静态变量什么时候初始化::</p><!-- basicblock-end --><p>![[进程的地址空间分布.excalidraw]]</p><p>初始化只有一次，<strong>但是可以多次赋值</strong>，在主程序之前，编译器已经为其分配好了内存。</p><p>静态局部变量和全局变量一样，数据都存放在<strong>全局区</strong>域，<br>所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。</p><p>在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p><p>而在C<ins>中，初始化时在执行相关代码时才会进行初始化，<br>主要是由于C</ins>引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。<br>所以C<ins>标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。<br>所以在C</ins>中是可以使用变量对静态局部变量进行初始化的。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46、值传递、指针传递、引用传递的区别和效率</title>
    <link href="/posts/32088/"/>
    <url>/posts/32088/</url>
    
    <content type="html"><![CDATA[<p>📝46、值传递、指针传递、引用传递的区别和效率::</p><!-- basicblock-end --><ol><li><strong>值传递</strong>：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。（传值）</li><li><strong>指针传递</strong>：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传递的是地址值）</li><li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li></ol><blockquote><p>[!summary]<br>效率上讲，指针传递和引用传递比值传递效率高。<br>一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>45、形参与实参的区别？</title>
    <link href="/posts/51772/"/>
    <url>/posts/51772/</url>
    
    <content type="html"><![CDATA[<p>📝45、形参与实参的区别？::</p><!-- basicblock-end --><ol><li>形参变量只有在被调用时才分配内存单元，在调用结束时，<strong>即刻释放所分配的内存单元</strong>。<ol><li>因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。</li></ol></li><li>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，<strong>在进行函数调用时，它们都必须具有确定的值</strong>，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</li><li>实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”的错误。</li><li>函数调用中发生的数据传送是单向的。<ol><li>即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。</li><li>因此在函数调用过程中，<strong>形参的值发生改变，而实参中的值不会变化</strong>。</li></ol></li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>顶层 const 和底层 const 的用法</title>
    <link href="/posts/11332/"/>
    <url>/posts/11332/</url>
    
    <content type="html"><![CDATA[<p>📝顶层 const 和底层 const 的用法::</p><!-- basicblock-end --><blockquote><p>[!tip]<br>左定向 (无法改变指向对象), 右定值 (无法改变指向对象的值)，<br>左右: 指的是 const 在 <code>*</code> 的左还是右边<br>顶层和底层也很好理解: 顶层说的是指针, 底层说的是数据</p></blockquote><ul><li><p>常量指针是一个不能给改变指向的指针。顶层const</p></li><li><p>指针是个常量，必须初始化.</p><ul><li>一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int <code>*const p</code>。<br>eg:<br><code>const int* d=new int(2);</code>, const 在 <code>*</code> 的左边,</li></ul></li><li><p>指针常量是一个指针，底层const</p></li><li><p>读成常量的指针，指向一个只读变量，即底层数据无法通过指针改变</p><ul><li>也就是后面所指明的int const 和 const int，都是一个常量，可以写作 <code>int const *p</code> 或 <code>const int *p</code>。</li></ul></li><li><p>用于声明引用变量，都是底层const</p></li></ul><p>eg:<br><code>int *const e=new int(2);</code>, const 在 <code>*</code> 的右边</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> b1 = &amp;a;        <span class="hljs-comment">//顶层const，b1本身是一个常量, 但可以通过给a赋值不同的地址改变这个指针指向。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* b2 = &amp;a;       <span class="hljs-comment">//底层const，b2本身可变，所指的对象是常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b3 = <span class="hljs-number">20</span>;    <span class="hljs-comment">//顶层const，b3是常量不可变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> b4 = &amp;a;  <span class="hljs-comment">//❓前一个const为底层，后一个为顶层，b4不可变</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b5 = a;   <span class="hljs-comment">//💡 用于声明引用变量，都是底层const</span><br></code></pre></td></tr></tbody></table></figure><h2 id="01-指针常量-顶层const-指针指向的对象无法改变"><a class="markdownIt-Anchor" href="#01-指针常量-顶层const-指针指向的对象无法改变"></a> 0.1: 指针常量 (顶层const): 指针指向的对象无法改变</h2><p>指针常量： 指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。<br>指针常量强调的是==<strong>指针==的不可改变性</strong>。💡不可以指向新的对象<br>特点： 靠近变量类型。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">形式： 数据类型* <span class="hljs-type">const</span> 指针变量 = &amp;变量名<br><br><span class="hljs-comment">//2.指针常量, 💡指针在前边</span><br><span class="hljs-type">int</span> tmp3 = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> tmp4 = <span class="hljs-number">13</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;tmp3；<span class="hljs-comment">// 常量指针</span><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">//正确：可以更改指向对象的值</span><br> p = &amp;tmp4；<span class="hljs-comment">//错误：不可以指向新的对象, 💡指针不可以修改</span><br></code></pre></td></tr></tbody></table></figure><h2 id="02-常量指针底层const-底层数据无法通过指针改变"><a class="markdownIt-Anchor" href="#02-常量指针底层const-底层数据无法通过指针改变"></a> 0.2: 常量指针（底层const) : 底层数据无法通过指针改变</h2><p><mark>常量指针</mark>： 是指定义了一个指针，这个指针指向一个只读的对象，<strong>不能通过常量指针来改变这个对象的值。</strong><br>常量指针强调的是<strong>指针对<mark>其所指对象</mark>的不可改变性</strong>。💡不可以通过指针来改变对象<br>特点： 靠近变量名。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1 常量指针, 💡指针在后边</span><br><span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;temp;<span class="hljs-comment">// (1) const 数据类型 *指针变量 = &amp;变量名</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p = &amp;temp;<span class="hljs-comment">// (2)数据类型 const *指针变量 = &amp;变量名</span><br><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 错误,不能通过常量指针来改变这个对象的值。</span><br>temp = <span class="hljs-number">9</span>; <span class="hljs-comment">// 💡正确, 直接改变原来对象可以</span><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>43、static的用法和作用？</title>
    <link href="/posts/17960/"/>
    <url>/posts/17960/</url>
    
    <content type="html"><![CDATA[<p>📝43、static的用法和作用？::</p><!-- basicblock-end --><h1 id="1-先来介绍它的第一条也是最重要的一条隐藏"><a class="markdownIt-Anchor" href="#1-先来介绍它的第一条也是最重要的一条隐藏"></a> 1: 先来介绍它的第一条也是最重要的一条：隐藏。</h1><p>（static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有<strong>全局可见性</strong>。</p><h1 id="2-static的第二个作用是保持变量内容的持久"><a class="markdownIt-Anchor" href="#2-static的第二个作用是保持变量内容的持久"></a> 2: static的第二个作用是保持变量内容的持久。</h1><p>（static变量中的记忆功能和全局生存期）<br>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</p><p>共有两种变量存储在静态存储区：全局变量和static变量，<br>只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来<strong>隐藏</strong>的。</p><h1 id="3-static的第三个作用是默认初始化为0static变量"><a class="markdownIt-Anchor" href="#3-static的第三个作用是默认初始化为0static变量"></a> 3: static的第三个作用是默认初始化为0（static变量）</h1><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。<br>在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p><h1 id="4-static的第四个作用c中的类成员声明static"><a class="markdownIt-Anchor" href="#4-static的第四个作用c中的类成员声明static"></a> 4: static的第四个作用：C++中的类成员声明static</h1><blockquote><p>[!question]</p></blockquote><ol><li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此<strong>其值在下次调用时仍维持上次的值</strong>；</li><li>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；</li><li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</li><li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</li><li>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</li></ol><p>类内：<br>6.  static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；<br>7.  由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；<br>8.  static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++标准异常类 exception</title>
    <link href="/posts/48781/"/>
    <url>/posts/48781/</url>
    
    <content type="html"><![CDATA[<p>📝C++标准异常类 exception::</p><!-- basicblock-end --><p>![[C++标准异常类 exception.excalidraw]]<br>bad_typeid例子:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>();<br>};<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>A* a = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">try</span> {<br>  cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*a).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">// Error condition</span><br>  }<br><span class="hljs-built_in">catch</span> (bad_typeid){<br>  cout &lt;&lt; <span class="hljs-string">"Object is NULL"</span> &lt;&lt; endl;<br>  }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//运行结果：bject is NULL</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>try、throw和catch关键字</title>
    <link href="/posts/33664/"/>
    <url>/posts/33664/</url>
    
    <content type="html"><![CDATA[<p>📝try、throw和catch关键字::</p><!-- basicblock-end --><p>C++中的异常处理机制主要使用<strong>try</strong>、<strong>throw</strong>和<strong>catch</strong>三个关键字，</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// 代码中，对两个数进行除法计算，其中除数为0。</span><br>    <span class="hljs-type">double</span> m = <span class="hljs-number">1</span>, n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> {<br>        cout &lt;&lt; <span class="hljs-string">"before dividing."</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">//抛出int型异常</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> - <span class="hljs-number">1.0</span>;  <span class="hljs-comment">//拋出 double 型异常</span><br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; m / n &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">"after dividing."</span> &lt;&lt; endl;<br>    }<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">double</span> d) {<br>        cout &lt;&lt; <span class="hljs-string">"catch (double)"</span> &lt;&lt; d &lt;&lt; endl;<br>    }<br>    <span class="hljs-built_in">catch</span> (...) {<span class="hljs-comment">// 捕获任何异常, 在这里也就是捕获到了 int 型异常</span><br>        cout &lt;&lt; <span class="hljs-string">"catch (...)"</span> &lt;&lt; endl;<br>    }<br>    cout &lt;&lt; <span class="hljs-string">"finished"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-comment">//before dividing.</span><br><span class="hljs-comment">//catch (...)</span><br><span class="hljs-comment">//finished</span><br></code></pre></td></tr></tbody></table></figure><p>程序的执行流程是先执行try包裹的语句块，</p><ul><li>如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，</li><li>如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。</li><li>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。<ul><li>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>42、C++的异常处理的方法</title>
    <link href="/posts/584/"/>
    <url>/posts/584/</url>
    
    <content type="html"><![CDATA[<p>📝42、C++的异常处理的方法::</p><!-- basicblock-end --><ul><li>数组下标越界</li><li>除法计算时除数为0</li><li>动态分配空间时空间不足</li><li>…</li></ul><p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p><h1 id="1-try-throw和catch关键字"><a class="markdownIt-Anchor" href="#1-try-throw和catch关键字"></a> 1: [[try、throw和catch关键字]]</h1><p>C++中的异常处理机制主要使用<strong>try</strong>、<strong>throw</strong>和<strong>catch</strong>三个关键字，</p><h1 id="2-函数的异常声明列表"><a class="markdownIt-Anchor" href="#2-函数的异常声明列表"></a> 2: 函数的异常声明列表</h1><p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-title">throw</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">double</span>,A,B,C)</span></span>{...};<br></code></pre></td></tr></tbody></table></figure><p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p><h1 id="3-c标准异常类-exception"><a class="markdownIt-Anchor" href="#3-c标准异常类-exception"></a> 3: [[C++标准异常类 exception]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>41、C++中有几种类型的new</title>
    <link href="/posts/30038/"/>
    <url>/posts/30038/</url>
    
    <content type="html"><![CDATA[<p>📝41、C++中有几种类型的new::</p><!-- basicblock-end --><h1 id="1-plain-new"><a class="markdownIt-Anchor" href="#1-plain-new"></a> 1: plain new</h1><p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>因此<strong>plain new</strong>在空间分配失败的情况下，抛出异常<strong>std::bad_alloc</strong>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">try</span><br>{<br><span class="hljs-type">char</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">10e11</span>];<br><span class="hljs-keyword">delete</span> p;<br>}<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc &amp;ex) <span class="hljs-comment">// 应该是捕捉 bad alloc 信号</span><br>{<br>cout &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//执行结果：bad allocation</span><br></code></pre></td></tr></tbody></table></figure><h1 id="2-nothrow-new"><a class="markdownIt-Anchor" href="#2-nothrow-new"></a> 2: nothrow new</h1><p>nothrow new在空间分配失败的情况下是不抛出异常，而是<strong>返回NULL</strong>，定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">new</span>(nothrow) <span class="hljs-type">char</span>[<span class="hljs-number">10e11</span>];<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <br>{<br>cout &lt;&lt; <span class="hljs-string">"alloc failed"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//运行结果：alloc failed</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-placement-new"><a class="markdownIt-Anchor" href="#3-placement-new"></a> 3: placement new</h1><p>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。<br>placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的<strong>构造函数</strong>。<br>定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>*,<span class="hljs-type">void</span>*)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>使用placement new需要注意两点：</p><ul><li>palcement new的主要用途就是<strong>反复使用一块较大的动态分配的内存</strong>来构造不同类型的对象或者他们的数组<ul><li>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），<ul><li>千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</li></ul></li></ul></li></ul><p>举个例子</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ADT</span>{<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ADT</span>(){<br>i = <span class="hljs-number">10</span>;<br>j = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">"ADT construct i="</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"j="</span>&lt;&lt;j &lt;&lt;endl;<br>}<br>~<span class="hljs-built_in">ADT</span>(){<br>cout &lt;&lt; <span class="hljs-string">"ADT destruct"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">char</span> *p = <span class="hljs-built_in">new</span>(nothrow) <span class="hljs-type">char</span>[<span class="hljs-keyword">sizeof</span> ADT + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) {<br>cout &lt;&lt; <span class="hljs-string">"alloc failed"</span> &lt;&lt; endl;<br>}<br>ADT *q = <span class="hljs-built_in">new</span>(p) ADT;  <span class="hljs-comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span><br><span class="hljs-comment">//delete q;//错误!不能在此处调用delete q;</span><br>q-&gt;ADT::~<span class="hljs-built_in">ADT</span>();<span class="hljs-comment">//显示调用析构函数</span><br><span class="hljs-keyword">delete</span>[] p;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//输出结果：</span><br><span class="hljs-comment">//ADT construct i=10j=100</span><br><span class="hljs-comment">//ADT destruct</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>41-60 基础语法</title>
    <link href="/posts/50522/"/>
    <url>/posts/50522/</url>
    
    <content type="html"><![CDATA[<p>📝41-60 基础语法::</p><!-- basicblock-end --><h1 id="1-41-new-的种类目录"><a class="markdownIt-Anchor" href="#1-41-new-的种类目录"></a> 1: [[41、new 的种类(目录)]]</h1><h1 id="2-42-c的异常处理的方法"><a class="markdownIt-Anchor" href="#2-42-c的异常处理的方法"></a> 2: [[42、C++的异常处理的方法]]</h1><h1 id="3-43-static的用法和作用"><a class="markdownIt-Anchor" href="#3-43-static的用法和作用"></a> 3: [[43、static的用法和作用？]]</h1><h1 id="4-顶层-const-和底层-const-的用法"><a class="markdownIt-Anchor" href="#4-顶层-const-和底层-const-的用法"></a> 4: [[顶层 const 和底层 const 的用法]]</h1><h1 id="5-45-形参与实参的区别"><a class="markdownIt-Anchor" href="#5-45-形参与实参的区别"></a> 5: [[45、形参与实参的区别？]]</h1><h1 id="6-46-值传递-指针传递-引用传递的区别和效率"><a class="markdownIt-Anchor" href="#6-46-值传递-指针传递-引用传递的区别和效率"></a> 6: [[46、值传递、指针传递、引用传递的区别和效率]]</h1><h1 id="7-747-静态变量什么时候初始化"><a class="markdownIt-Anchor" href="#7-747-静态变量什么时候初始化"></a> 7: 7:[[47、静态变量什么时候初始化]]</h1><h1 id="8-48-const关键字的作用有哪些"><a class="markdownIt-Anchor" href="#8-48-const关键字的作用有哪些"></a> 8: [[48、const关键字的作用有哪些]]</h1><h1 id="9-49-什么是类的继承"><a class="markdownIt-Anchor" href="#9-49-什么是类的继承"></a> 9: [[49、什么是类的继承？]]</h1><h1 id="10-50-从汇编层去解释一下引用"><a class="markdownIt-Anchor" href="#10-50-从汇编层去解释一下引用"></a> 10: [[50、从汇编层去解释一下引用]]</h1><h1 id="11-35-浅拷贝和深拷贝的区别"><a class="markdownIt-Anchor" href="#11-35-浅拷贝和深拷贝的区别"></a> 11: [[35、浅拷贝和深拷贝的区别]]</h1><h1 id="12-malloc和new的区别"><a class="markdownIt-Anchor" href="#12-malloc和new的区别"></a> 12: [[malloc和new的区别？]]</h1><h1 id="13-53-delete-p-delete-中括号p-allocator都有什么作用"><a class="markdownIt-Anchor" href="#13-53-delete-p-delete-中括号p-allocator都有什么作用"></a> 13: [[53、delete p、delete 中括号p、allocator都有什么作用？]]</h1><h1 id="14-new-delete-原理"><a class="markdownIt-Anchor" href="#14-new-delete-原理"></a> 14: [[new delete 原理]]</h1><h1 id="15-55-malloc申请的存储空间能用delete释放吗"><a class="markdownIt-Anchor" href="#15-55-malloc申请的存储空间能用delete释放吗"></a> 15: [[55、malloc申请的存储空间能用delete释放吗]]</h1><h1 id="16-malloc-free-原理"><a class="markdownIt-Anchor" href="#16-malloc-free-原理"></a> 16: [[malloc free 原理]]</h1><h1 id="17-57-malloc-realloc-calloc的区别"><a class="markdownIt-Anchor" href="#17-57-malloc-realloc-calloc的区别"></a> 17: [[57、malloc、realloc、calloc的区别]]</h1><h1 id="18-58-类成员初始化方式"><a class="markdownIt-Anchor" href="#18-58-类成员初始化方式"></a> 18: [[58、类成员初始化方式？]]</h1><h1 id="19-59-有哪些情况必须用到成员列表初始化"><a class="markdownIt-Anchor" href="#19-59-有哪些情况必须用到成员列表初始化"></a> 19: [[59、有哪些情况必须用到成员列表初始化？]]</h1><blockquote><p>update1:感谢网友“lcf163”提出修改意见，已采纳。<a href="https://github.com/forthespada/InterviewGuide/issues/4">https://github.com/forthespada/InterviewGuide/issues/4</a></p></blockquote><h1 id="20-60-c中新增了string它与c语言中的-char-有什么区别吗它是如何实现的"><a class="markdownIt-Anchor" href="#20-60-c中新增了string它与c语言中的-char-有什么区别吗它是如何实现的"></a> 20: [[60、C++中新增了string，它与C语言中的 char 有什么区别吗？它是如何实现的？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>41-60 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>36、内联函数和宏定义的区别</title>
    <link href="/posts/45617/"/>
    <url>/posts/45617/</url>
    
    <content type="html"><![CDATA[<p>📝36、内联函数和宏定义的区别::</p><!-- basicblock-end --><p>内联函数:  [[inline(内联函数)]]</p><ul><li>在使用时，宏只做简单字符串替换（编译前）。</li><li>而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li></li><li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li><li></li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li><li>内联函数有类型检测、语法判断等功能，而宏没有</li></ul><p><strong>内联函数适用场景:</strong></p><ul><li>使用宏定义的地方都可以使用 inline 函数。</li><li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。</li></ul><blockquote><p>感谢网友“bygaoyuan ”重新整理， <a href="https://github.com/forthespada/InterviewGuide/issues/3">https://github.com/forthespada/InterviewGuide/issues/3</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>40、什么情况下会调用拷贝构造函数</title>
    <link href="/posts/27067/"/>
    <url>/posts/27067/</url>
    
    <content type="html"><![CDATA[<p>📝40、什么情况下会调用拷贝构造函数::</p><!-- basicblock-end --><p>![[拷贝构造 &amp; 拷贝赋值.excalidraw]]</p><p>用类的一个实例化对象去初始化另一个对象的时候</p><ul><li>函数的参数是类的对象时（非引用传递）</li><li>函数的返回值是函数体内局部对象的类的对象时 ,<ul><li>此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li></ul></li></ul><p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p><p><strong>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p><p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p><p><strong>在VS2019下进行下述实验：</strong></p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() {};<br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a)<br>{<br>cout &lt;&lt; <span class="hljs-string">"copy constructor is called"</span> &lt;&lt; endl;<br>};<br>~<span class="hljs-built_in">A</span>() {};<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useClassA</span><span class="hljs-params">(A a)</span> </span>{}<br><br><span class="hljs-function">A <span class="hljs-title">getClassA</span><span class="hljs-params">()</span><span class="hljs-comment">//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span></span><br><span class="hljs-function"></span>{<br>A a;<br><span class="hljs-keyword">return</span> a;<br>}<span class="hljs-comment">//A&amp; getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span><br><span class="hljs-comment">//{</span><br><span class="hljs-comment">//A a;</span><br><span class="hljs-comment">//return a;</span><br><span class="hljs-comment">//}int main()</span><br>{<br>A a1,a3,a4;<br>A a2 = a1;  <span class="hljs-comment">//调用拷贝构造函数,对应情况1</span><br><span class="hljs-built_in">useClassA</span>(a1);<span class="hljs-comment">//调用拷贝构造函数，对应情况2</span><br>a3 = <span class="hljs-built_in">getClassA</span>();<span class="hljs-comment">//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span><br>a4 = <span class="hljs-built_in">getClassA2</span>(a1);<span class="hljs-comment">//发生NRV优化，且引用返回自身，不会调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>情况1比较好理解</p><p>情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象</p><p>情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象，依然会调用拷贝构造函数</p><blockquote><p>update1:<a href="https://github.com/forthespada/InterviewGuide/issues/2">https://github.com/forthespada/InterviewGuide/issues/2</a> 提出，感谢！- 2021.03.22</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>explicit 关键字</title>
    <link href="/posts/3006/"/>
    <url>/posts/3006/</url>
    
    <content type="html"><![CDATA[<p>📝explicit 关键字::</p><!-- basicblock-end --><p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显示的方式进行类型转换</strong>，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>explicit 关键字作用于单个参数的构造函数</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mutable 关键字</title>
    <link href="/posts/27682/"/>
    <url>/posts/27682/</url>
    
    <content type="html"><![CDATA[<p>📝mutable 关键字::</p><!-- basicblock-end --><p>mutable的中文意思是“可变的，易变的”，跟constant（既C<ins>中的const）是反义词。在C</ins>中，mutable也是为了突破const的限制而设置的。<br>被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。<br>我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。<br>但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p><p>样例</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>{<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//特殊变量 在常函数里值也可以被修改</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-type">const</span><span class="hljs-comment">//在函数里不可修改this指针指向的值 常量指针</span></span><br><span class="hljs-function">     </span>{<br>        m_A=<span class="hljs-number">10</span>;<span class="hljs-comment">//❓错误  不可修改值，this已经被修饰为常量指针</span><br>        m_B=<span class="hljs-number">20</span>;<span class="hljs-comment">//正确</span><br>     }<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>{<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<span class="hljs-comment">//特殊变量 在常函数里值也可以被修改</span><br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">const</span> person p;<span class="hljs-comment">//修饰常对象 不可修改类成员的值</span><br>p.m_A=<span class="hljs-number">10</span>;<span class="hljs-comment">//错误，被修饰了指针常量</span><br>p.m_B=<span class="hljs-number">200</span>;<span class="hljs-comment">//正确，特殊变量，修饰了mutable</span><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关键字</title>
    <link href="/posts/1432/"/>
    <url>/posts/1432/</url>
    
    <content type="html"><![CDATA[<p>📝关键字::</p><!-- basicblock-end --><h1 id="1-39-volatile-mutable和explicit关键字的用法"><a class="markdownIt-Anchor" href="#1-39-volatile-mutable和explicit关键字的用法"></a> 1: [[39、volatile、mutable和explicit关键字的用法]]</h1><h1 id="2-final和override关键字"><a class="markdownIt-Anchor" href="#2-final和override关键字"></a> 2: [[final和override关键字]]</h1><h1 id="3-const-关键字"><a class="markdownIt-Anchor" href="#3-const-关键字"></a> 3: [[const 关键字]]</h1><h1 id="4-try-throw和catch关键字"><a class="markdownIt-Anchor" href="#4-try-throw和catch关键字"></a> 4: [[try、throw和catch关键字]]</h1><h1 id="static-关键字"><a class="markdownIt-Anchor" href="#static-关键字"></a> [[static 关键字]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile 关键字</title>
    <link href="/posts/38251/"/>
    <url>/posts/38251/</url>
    
    <content type="html"><![CDATA[<p>📝volatile 关键字::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。<br>遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的<strong>稳定访问</strong>。</p><p>当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p><p><strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p><h1 id="2-volatile-指针"><a class="markdownIt-Anchor" href="#2-volatile-指针"></a> 2: volatile 指针</h1><p>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</p><p>修饰由指针指向的对象、数据是 const 或 volatile 的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cpch;<br><span class="hljs-keyword">volatile</span> <span class="hljs-type">char</span>* vpch;<br></code></pre></td></tr></tbody></table></figure><p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span>* <span class="hljs-type">const</span> pchc;<br><span class="hljs-type">char</span>* <span class="hljs-keyword">volatile</span> pchv;<br></code></pre></td></tr></tbody></table></figure><p>注意：</p><ul><li>question 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li><li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li><li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li></ul><h1 id="3-多线程下的volatile"><a class="markdownIt-Anchor" href="#3-多线程下的volatile"></a> 3: 多线程下的volatile</h1><p>有些变量是用volatile关键字声明的。<br>当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，<br><strong>该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中</strong>。<br>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。<br>volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39、volatile、mutable和explicit关键字的用法</title>
    <link href="/posts/43842/"/>
    <url>/posts/43842/</url>
    
    <content type="html"><![CDATA[<p>📝39、volatile、mutable和explicit关键字的用法::</p><!-- basicblock-end --><h1 id="1-volatile-关键字"><a class="markdownIt-Anchor" href="#1-volatile-关键字"></a> 1: [[volatile 关键字]]</h1><h1 id="2-mutable-关键字"><a class="markdownIt-Anchor" href="#2-mutable-关键字"></a> 2: [[mutable 关键字]]</h1><h1 id="3-explicit-关键字"><a class="markdownIt-Anchor" href="#3-explicit-关键字"></a> 3: [[explicit 关键字]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>38、如何用代码判断大小端存储？</title>
    <link href="/posts/42846/"/>
    <url>/posts/42846/</url>
    
    <content type="html"><![CDATA[<p>📝38、如何用代码判断大小端存储？::</p><!-- basicblock-end --><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1: 概念</h1><p>![[大端和小端.excalidraw]]</p><p><strong>在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</strong></p><h1 id="2-判断方式"><a class="markdownIt-Anchor" href="#2-判断方式"></a> 2: 判断方式</h1><p><strong>方式一：使用强制类型转换</strong>-这种法子不错</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span><br>    <span class="hljs-type">char</span> c = (<span class="hljs-type">char</span>)(a);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0x12</span>)<br>        cout &lt;&lt; <span class="hljs-string">"big endian"</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0x34</span>)<br>        cout &lt;&lt; <span class="hljs-string">"little endian"</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>方式二：巧用union联合体</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">endian</span><br>{<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> ch;<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    endian value;<br>    value.a = <span class="hljs-number">0x1234</span>;<br>    <span class="hljs-comment">//a和ch共用4字节的内存空间</span><br>    <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x12</span>)<br>        cout &lt;&lt; <span class="hljs-string">"big endian"</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.ch == <span class="hljs-number">0x34</span>)<br>        cout &lt;&lt; <span class="hljs-string">"little endian"</span>&lt;&lt;endl;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-转换方式"><a class="markdownIt-Anchor" href="#3-转换方式"></a> 3: 转换方式</h1><p>[[字节序]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>访问权限, 继承权限</title>
    <link href="/posts/33018/"/>
    <url>/posts/33018/</url>
    
    <content type="html"><![CDATA[<p>📝37、public，protected和private:: 直接看总结吧</p><!-- basicblock-end --><ul><li>public的变量和函数在类的内部外部都可以访问。</li><li>protected的变量和函数只能在类的内部和其派生类中访问。</li><li>private修饰的元素只能在类内访问。</li></ul><h1 id="1-访问权限"><a class="markdownIt-Anchor" href="#1-访问权限"></a> 1: 访问权限</h1><p>C++通过 public、protected、private 三个关键字来控制成员变量和<strong>成员函数的访问权限</strong>，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p><p>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private, 都是可以互相访问的，没有访问权限的限制。<br>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。</p><p>派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，</p><p>三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341241.png" alt=""></p><p>派生类对基类成员的访问形象有如下两种：</p><ul><li>内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问</li><li><strong>外部访问</strong>：在派生类外部，通过派生类的对象对从基类继承来的成员的访问</li></ul><blockquote><p>[!question]<br>无论共有继承、私有和保护继承，私有成员不能被“派生类”访问，基类中的共有和保护成员能被“派生类"访问。<br>对于共有继承，只有基类中的共有成员能被“派生类对象”访问，保护和私有成员不能被“派生类对象"”访问。<br>对于私有和保护继承，基类中的所有成员不能被“派生类对象"访问。::   #疑问</p></blockquote><h1 id="2-继承权限"><a class="markdownIt-Anchor" href="#2-继承权限"></a> 2: 继承权限</h1><h2 id="21-public继承"><a class="markdownIt-Anchor" href="#21-public继承"></a> 2.1: public继承</h2><p>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，<br>而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p><h2 id="22-protected继承"><a class="markdownIt-Anchor" href="#22-protected继承"></a> 2.2: protected继承</h2><p>保护继承的特点是<strong>基类</strong>的所有公有成员和保护成员都成为派生类的保护成员，<br>并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的，访问规则如下表</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341074.png" alt=""></p><h2 id="23-private继承"><a class="markdownIt-Anchor" href="#23-private继承"></a> 2.3: private继承</h2><p>私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341430.png" alt=""></p><blockquote><p>update1：感谢微信好友“李宇杰”指出方式二中代码错误，感谢。</p></blockquote><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3: 总结</h1><h2 id="31-一-访问权限"><a class="markdownIt-Anchor" href="#31-一-访问权限"></a> 3.1: 一、访问权限</h2><table><thead><tr><th>访问权限</th><th>外部</th><th>派生类</th><th>内部</th></tr></thead><tbody><tr><td>public</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>protected</td><td>❌</td><td>✔</td><td>✔</td></tr><tr><td>private</td><td>❌</td><td>❌</td><td>✔</td></tr></tbody></table><p>public、protected、private 的访问权限范围关系：</p><p>public &gt; protected &gt; private</p><h2 id="32-二-继承权限"><a class="markdownIt-Anchor" href="#32-二-继承权限"></a> 3.2: 二、继承权限</h2><ol><li>派生类继承自基类的成员权限有四种状态：public、protected、private、不可见</li><li>派生类对基类成员的访问权限取决于两点：<ol><li>一、继承方式；</li><li>二、基类成员在基类中的访问权限</li></ol></li><li>派生类对基类成员的访问权限是取以上两点中的更小的访问范围（除了 private 的继承方式遇到 private 成员是不可见外）。例如：</li></ol><ul><li>public 继承 + private 成员 =&gt; private</li><li>private 继承 + protected 成员 =&gt; private</li><li>private 继承 + private 成员 =&gt; 不可见</li></ul><blockquote><p>感谢网友做出归纳总结https://github.com/forthespada/InterviewGuide/issues/35， - 2022.02.22</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35、浅拷贝和深拷贝的区别</title>
    <link href="/posts/26869/"/>
    <url>/posts/26869/</url>
    
    <content type="html"><![CDATA[<p>📝35、浅拷贝和深拷贝的区别::</p><!-- basicblock-end --><p>![[浅拷贝和深拷贝.excalidraw]]</p><h1 id="1-浅拷贝"><a class="markdownIt-Anchor" href="#1-浅拷贝"></a> 1: <strong>浅拷贝</strong></h1><p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，<br>浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。<br>如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针(成了野指针)的资源就会出现错误。</p><h1 id="2-深拷贝"><a class="markdownIt-Anchor" href="#2-深拷贝"></a> 2: <strong>深拷贝</strong></h1><p>在计算机中1️⃣开辟了一块新的内存地址2️⃣用于存放复制的对象。</p><p>即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。<br>在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>{<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> num;<br><span class="hljs-type">char</span> *name;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(){<br>        name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>(<span class="hljs-number">20</span>);<br>cout &lt;&lt; <span class="hljs-string">"Student"</span> &lt;&lt; endl;<br>    };<br>~<span class="hljs-built_in">Student</span>(){<br>        cout &lt;&lt; <span class="hljs-string">"~Student "</span> &lt;&lt; &amp;name &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> name;<br>        name = <span class="hljs-literal">NULL</span>;<br>    };<br><span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> Student &amp;s){<span class="hljs-comment">//拷贝构造函数</span><br>        <span class="hljs-comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span><br>        name = s.name;<br>        <span class="hljs-comment">//深拷贝</span><br>        <span class="hljs-comment">//name = new char(20);</span><br>        <span class="hljs-comment">//memcpy(name, s.name, strlen(s.name));</span><br>        cout &lt;&lt; <span class="hljs-string">"copy Student"</span> &lt;&lt; endl;<br>    };<br>};<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>{<span class="hljs-comment">// 花括号让s1和s2变成局部对象，方便测试</span><br>Student s1;<br><span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<span class="hljs-comment">// 复制对象</span><br>}<br><span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//浅拷贝执行结果：</span><br><span class="hljs-comment">//Student</span><br><span class="hljs-comment">//copy Student</span><br><span class="hljs-comment">//~Student 0x7fffed0c3ec0</span><br><span class="hljs-comment">//~Student 0x7fffed0c3ed0</span><br><span class="hljs-comment">//*** Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 ***</span><br><br><span class="hljs-comment">//深拷贝执行结果：</span><br><span class="hljs-comment">//Student</span><br><span class="hljs-comment">//copy Student</span><br><span class="hljs-comment">//~Student 0x7fffebca9fb0</span><br><span class="hljs-comment">//~Student 0x7fffebca9fc0</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!summary]</p><ul><li>从执行结果可以看出，</li><li>浅拷贝在对象的拷贝创建时存在风险，<ul><li>即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，</li></ul></li><li>深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vim support</title>
    <link href="/posts/24980/"/>
    <url>/posts/24980/</url>
    
    <content type="html"><![CDATA[<p>📝vim support::</p><!-- basicblock-end --><p>unmap <space></space></p><p>" Have j and k navigate visual lines rather than logical ones</p><p>exmap lineStart cmcommand goLineLeftSmart</p><p>exmap lineEnd cmcommand goLineRight</p><p>nmap H lineStart</p><p>nmap L lineEnd</p><p>vmap gh ^</p><p>vmap gl $</p><p>nmap gh ^</p><p>nmap gl $</p><p>" this map not work</p><p>imap jk <esc><esc></esc></esc></p><p>nmap j gj</p><p>nmap k gk</p><p>" Quickly remove search highlights</p><p>nmap <a-n> :nohl</a-n></p><p>" Yank to system clipboard</p><p>set clipboard=unnamed</p><p>" Go back and forward with Ctrl+O and Ctrl+I</p><p>" (make sure to remove default Obsidian shortcuts for these to work)</p><p>exmap back obcommand app:go-back</p><p>nmap <a-a> :back</a-a></p><p>exmap forward obcommand app:go-forward</p><p>nmap <a-d> :forward</a-d></p><p>" Create links"</p><p>exmap insertLink obcommand editor:insert-link</p><p>map <a-y> :pasteinto</a-y></p><p>" Surround text with [[ ]] to make a wikilink</p><p>" NOTE: must use ‘map’ and not ‘nmap’</p><p>exmap wiki surround [[ ]]</p><p>map <a-m> :wiki</a-m></p><p>exmap openLink obcommand editor:follow-link</p><p>map <a-q> :openLink</a-q></p><p>" Reload Obsidian</p><p>exmap reload obcommand app:reload</p><p>map <a-r> :reload</a-r></p><p>"exmap commandPalette&nbsp;obcommand command-palette:open</p><p>""map <a-f> :commandPalette</a-f></p><p>" Reload Obsidian</p><p>exmap goParent obcommand breadcrumbs:jump-to-first-up</p><p>map gu :goParent</p><p>exmap nextTab obcommand workspace:next-tab</p><p>exmap prevTab obcommand workspace:previous-tab</p><p>map gt :nextTab</p><p>map gT :prevTab</p><p>exmap easymotion obcommand mrj-jump-to-link:activate-jump-to-anywhere</p><p>map gw :easymotion</p><p>exmap close obcommand workspace:close</p><p>map <space>c :close</space></p><p>map gc :close</p><p>exmap vs obcommand workspace:split-vertical</p><p>map gp :vs</p><p>" close other tabs</p><p>exmap to obcommand workspace:close-others</p><p>map to :to</p><p>exmap x obcommand workspace:close</p><p>exmap df obcommand app:delete-file</p><p>exmap nextHeading jsfile mdHelpers.js {jumpHeading(true)}</p><p>exmap prevHeading jsfile mdHelpers.js {jumpHeading(false)}</p><p>nmap ]] :nextHeading</p><p>nmap [[ :prevHeading</p><p>exmap logCursor jscommand { console.log(editor.getCursor()); }</p><p>nmap <c-q> :logCursor</c-q></p><p>" exmap togglefold obcommand editor:toggle-fold</p><p>" nmap zf :togglefold</p><p>" nmap zu :togglefold</p><p>exmap unfoldall obcommand editor:unfold-all</p><p>nmap zU :unfoldall</p><p>exmap foldall obcommand editor:fold-all</p><p>nmap zF :foldall</p><p>exmap it obcommand templater-obsidian:insert-templater</p><p>nmap <space>i :it</space></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>34、C++有哪几种的构造函数</title>
    <link href="/posts/33851/"/>
    <url>/posts/33851/</url>
    
    <content type="html"><![CDATA[<p>📝34、C++有哪几种的构造函数::</p><!-- basicblock-end --><p>红灯塞<br>张公案红灯</p><p>C++中的构造函数可以分为4类：</p><ul><li>默认构造函数<ul><li>初始化构造函数（有参数）</li></ul></li><li>[[拷贝构造 &amp; 拷贝赋值.excalidraw|拷贝构造函数]]</li><li>移动构造函（move和右值引用）</li><li>委托构造函数</li><li>转换构造函数</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(){<span class="hljs-comment">//默认构造函数，没有参数</span><br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">20</span>;<br>        <span class="hljs-keyword">this</span>-&gt;num = <span class="hljs-number">1000</span>;<br>    };    <br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> n):<span class="hljs-built_in">age</span>(a), <span class="hljs-built_in">num</span>(n){}; <span class="hljs-comment">//初始化构造函数，有参数和参数列表</span><br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> Student&amp; s){<span class="hljs-comment">//拷贝构造函数，这里与编译器生成的一致</span><br>        <span class="hljs-keyword">this</span>-&gt;age = s.age;<br>        <span class="hljs-keyword">this</span>-&gt;num = s.num;<br>    }; <br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> r){   <span class="hljs-comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span><br>        <span class="hljs-keyword">this</span>-&gt;age = r;<br>        <span class="hljs-keyword">this</span>-&gt;num = <span class="hljs-number">1002</span>;<br>    };<br>    ~<span class="hljs-built_in">Student</span>(){}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">int</span> num;<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    Student s1;<span class="hljs-comment">//默认构造函数: s1 age:20, num:1000</span><br>    <span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">18</span>,<span class="hljs-number">1001</span>)</span></span>;<span class="hljs-comment">//初始化构造函数: s2 age:18, num:1001</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">(a)</span></span>;<span class="hljs-comment">//拷贝构成函数: s3 age:10, num:1002</span><br>    <span class="hljs-function">Student <span class="hljs-title">s4</span><span class="hljs-params">(s3)</span></span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"s1 age:%d, num:%d\n"</span>, s1.age, s1.num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"s2 age:%d, num:%d\n"</span>, s2.age, s2.num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"s3 age:%d, num:%d\n"</span>, s3.age, s3.num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"s2 age:%d, num:%d\n"</span>, s4.age, s4.num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//运行结果</span><br><br><br><br><span class="hljs-comment">//s2 age:10, num:1002</span><br></code></pre></td></tr></tbody></table></figure><ul><li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li><li>复制构造函数用于复制本类的对象</li><li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>隐藏（hide）</title>
    <link href="/posts/40858/"/>
    <url>/posts/40858/</url>
    
    <content type="html"><![CDATA[<p>📝隐藏（hide）::</p><!-- basicblock-end --><p>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><h1 id="1-两个函数参数相同但是基类函数不是虚函数"><a class="markdownIt-Anchor" href="#1-两个函数参数相同但是基类函数不是虚函数"></a> 1: 两个函数参数相同，但是基类函数不是虚函数。</h1><p><strong>和重写的区别在于基类函数是否是虚函数</strong></p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>{ <span class="hljs-comment">// 💡父类中的函数不是虚函数</span><br>cout &lt;&lt; <span class="hljs-string">"A中的fun函数"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//隐藏父类的fun函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>{<br>cout &lt;&lt; <span class="hljs-string">"B中的fun函数"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    B b;<br>    b.<span class="hljs-built_in">fun</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//调用的是B中的fun函数</span><br>    b.A::<span class="hljs-built_in">fun</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//调用A中fun函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-两个函数参数不同无论基类函数是不是虚函数都会被隐藏"><a class="markdownIt-Anchor" href="#2-两个函数参数不同无论基类函数是不是虚函数都会被隐藏"></a> 2: 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。</h1><blockquote><p>[!question] 隐藏的意思应该是把优先忽略父类中的同名函数</p></blockquote><p><strong>和重载的区别在于两个函数不在同一个类中</strong>。</p><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>{<br>cout &lt;&lt; <span class="hljs-string">"A中的fun函数"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//隐藏父类的fun函数</span><br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span>* a)</span></span>{ <span class="hljs-comment">// 💡跟基类中的参数列表不一样</span><br>   cout &lt;&lt; <span class="hljs-string">"A中的fun函数"</span> &lt;&lt; endl;<br>   }<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    B b;<br>    b.<span class="hljs-built_in">fun</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//报错，调用的是B中的fun函数，参数类型不对</span><br>    b.A::<span class="hljs-built_in">fun</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//调用A中fun函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!question] 补充：</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{ <span class="hljs-comment">// 虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">"This is A fun "</span> &lt;&lt; a &lt;&lt; endl;<br>    }    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>        cout &lt;&lt; <span class="hljs-string">"This is A add "</span> &lt;&lt; a + b &lt;&lt; endl;<br>    }<br>};<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">override</span> </span>{  <span class="hljs-comment">// 覆盖 💡相当与重写</span><br>        cout &lt;&lt; <span class="hljs-string">"this is B fun "</span> &lt;&lt; a &lt;&lt; endl;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{   <span class="hljs-comment">// 隐藏, 参数列表不一样</span><br>        cout &lt;&lt; <span class="hljs-string">"This is B add "</span> &lt;&lt; a + a &lt;&lt; endl;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 基类指针指向派生类对象时，</span><br>        <span class="hljs-comment">// - 基类指针可以直接调用到派生类的覆盖函数，</span><br>        <span class="hljs-comment">// - 也可以通过 :: 调用到基类被覆盖的虚函数；</span><br>    <span class="hljs-comment">// 而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。</span><br><br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    p-&gt;<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>);      <span class="hljs-comment">// 调用子类 fun 覆盖函数</span><br>    p-&gt;A::<span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 调用父类 fun</span><br>    p-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);   <span class="hljs-comment">// 💡只能调用基类的函数</span><br>    <span class="hljs-comment">// p-&gt;add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配</span><br>    <span class="hljs-comment">// p-&gt;B::add(1);   // 错误，无法识别子类 add 函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重载与重写的区别：</title>
    <link href="/posts/22064/"/>
    <url>/posts/22064/</url>
    
    <content type="html"><![CDATA[<p>📝重载与重写的区别::</p><!-- basicblock-end --><p>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</p><ul><li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li><li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li></ul><p>![[overload.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>final</title>
    <link href="/posts/62558/"/>
    <url>/posts/62558/</url>
    
    <content type="html"><![CDATA[<p>📝final 关键字::</p><!-- basicblock-end --><p><strong>当不希望某个类被继承，或不希望某个虚函数被重写</strong>，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。<br>例子如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>};<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">public</span> Base<br>{<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span><br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">final</span> : A <span class="hljs-comment">// 指明B是不可以被继承的</span><br>{<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// Error: 在A中已经被final了</span><br>};<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : B <span class="hljs-comment">// Error: B is final</span><br>{<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>override关键字</title>
    <link href="/posts/34344/"/>
    <url>/posts/34344/</url>
    
    <content type="html"><![CDATA[<p>📝override关键字::</p><!-- basicblock-end --><p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>}<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>{<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//OK</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// OK</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">//OK, 它指定了子类的这个虚函数就是重写的父类的</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>override关键字父类中被<strong>virtual修饰的方法，在子类中可以重写。</strong><br>这样宽松的策略会有两个问题无法直观的判断，</p><ol><li>子类中的方法是否是重写的方法</li><li>不小心写错了子类中的需要重写的函数，包括函数名和参数等。<br>被override修饰的子类中的方法，可以避免这两个问题</li></ol><p>重写与重载的本质区别是，加入了override的修饰符的方法，此方法始终只有一个被你使用的方法。</p><p>如果不使用override，当你手一抖，将**foo()<strong>写成了</strong>f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。<br>所以，override的作用就出来了，<strong>它指定了子类的这个虚函数就是重写的父类的</strong>，如果你名字不小心打错了的话，编译器是不会编译通过的：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>{<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>{<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f00</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//OK，这个函数是B新增的，不是继承的</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0o</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span><br>};<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>![[关键字与运算符 2022-09-18 21.40.29.excalidraw]]</p></blockquote><blockquote><p>[!参考资料]<br><a href="https://www.bilibili.com/video/BV1Sm4y1X71z?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++11中新增的override关键字_哔哩哔哩_bilibili</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重写（覆盖）（override）</title>
    <link href="/posts/31186/"/>
    <url>/posts/31186/</url>
    
    <content type="html"><![CDATA[<p>📝重写（覆盖）（override）::</p><!-- basicblock-end --><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1: 定义</h1><p>重写指的是在派生类中覆盖了基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：<br>override是重写（覆盖）了一个方法以实现不同的功能，发生在父子类中</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>{} <span class="hljs-comment">// 💡必须是虚函数</span><br>}<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//重写,一般加override 关键字可以确保是重写父类的函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">override</span></span>{}<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="11-override关键字"><a class="markdownIt-Anchor" href="#11-override关键字"></a> 1.1: [[override关键字]]</h2><h1 id="2-规则"><a class="markdownIt-Anchor" href="#2-规则"></a> 2: 规则</h1><p>1.与原函数的区别(儿子都要比父亲的权限小)<br>1. 方法名、参数列表必须相同，<br>2. 返回值范围小于等于父类，<br>3. 抛出的异常范围小于等于父类，<br>4. 访问修饰符范围<strong>大于</strong>等于父类；<br>5. 如果父类方法访问修饰符为private 则子类就不能重写该方法。(💡爸爸的隐私你不能看)</p><p>2.被重写的方法不能为orivate<br>3.静态方法不能被重写为非静态的方法<br>4.重写方法的访问修饰符一定要大于被重写方法的访问修饰符(public&gt;:protected&gt;default&gt;private)<br>不能比爸爸的权限还高</p><h1 id="3-重载与重写的区别"><a class="markdownIt-Anchor" href="#3-重载与重写的区别"></a> 3: [[重载与重写的区别]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重载（overload）</title>
    <link href="/posts/43128/"/>
    <url>/posts/43128/</url>
    
    <content type="html"><![CDATA[<p>📝重载（overload）::</p><!-- basicblock-end --><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1: 定义</h1><p>重载是指在<strong>同一范围定义</strong>中的<strong>同名成员函数</strong>才存在重载关系。</p><ul><li>主要特点是函数名相同，参数类型和数目有所不同，</li></ul><p>重载和函数成员是否是虚函数无关。</p><h1 id="2-规则"><a class="markdownIt-Anchor" href="#2-规则"></a> 2: 规则</h1><ol><li>函数处在相同的范围（<strong>即在同一个类中</strong>）</li><li>与原函数的区别<ol><li>函数名字必须相同，参数列表（函数特征：参数类型、个数、顺序）必须不同,<ol><li>不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</li></ol></li><li>返回值类型可同可不同</li><li>访问修饰符可以不同.</li></ol></li><li>virtual 关键字可有可无</li></ol><blockquote><p>[!question]<br>1.不能通过访问权限、返回类型、抛出的异常进行重载<br>3.方法的异常类型和数目不会对重载造成影响使用多态, 是为了避免在父类里大量重载引起代码臃肿且难于维护。</p></blockquote><p>举个例子：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 虚函数也可以重载</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>    ...<br>}<br></code></pre></td></tr></tbody></table></figure><p>![[overload.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33、C++中的重载、重写（覆盖）和隐藏的区别</title>
    <link href="/posts/63480/"/>
    <url>/posts/63480/</url>
    
    <content type="html"><![CDATA[<p>📝33、C++中的重载、重写（覆盖）和隐藏的区别::</p><!-- basicblock-end --><h1 id="1-重载overload"><a class="markdownIt-Anchor" href="#1-重载overload"></a> 1: [[重载(overload)]]</h1><h1 id="2-重写覆盖override"><a class="markdownIt-Anchor" href="#2-重写覆盖override"></a> 2: [[重写(覆盖override)]]</h1><h1 id="3-重载与重写的区别"><a class="markdownIt-Anchor" href="#3-重载与重写的区别"></a> 3: [[重载与重写的区别]]</h1><h1 id="4-隐藏hide"><a class="markdownIt-Anchor" href="#4-隐藏hide"></a> 4: [[隐藏(hide)]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>32、C和C++的类型安全</title>
    <link href="/posts/18306/"/>
    <url>/posts/18306/</url>
    
    <content type="html"><![CDATA[<p>📝32、C和C++的类型安全::</p><!-- basicblock-end --><h1 id="1-什么是类型安全"><a class="markdownIt-Anchor" href="#1-什么是类型安全"></a> 1: 什么是类型安全？</h1><p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。<br>“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；<br>有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。</p><p>类型安全的编程语言与类型安全的程序之间，没有必然联系。<br>好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，<br>相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。<br>绝对类型安全的编程语言暂时还没有。</p><h1 id="2-c的类型安全"><a class="markdownIt-Anchor" href="#2-c的类型安全"></a> 2: C的类型安全</h1><p>C只在局部上下文中表现出类型安全，<br>比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：</p><h2 id="21-printf格式输出"><a class="markdownIt-Anchor" href="#21-printf格式输出"></a> 2.1: printf格式输出</h2><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341869.png" alt=""></p><p>上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误</p><h2 id="22-malloc函数的返回值"><a class="markdownIt-Anchor" href="#22-malloc函数的返回值"></a> 2.2: malloc函数的返回值</h2><p>malloc是C中进行内存分配的函数，它的返回类型是void*即空类型指针，<br>常常有这样的用法char* pStr=(char*)malloc(100*sizeof(char))，这里明显做了显式的类型转换。</p><p>类型匹配尚且没有问题，但是一旦出现int* pInt=(int*)malloc(100*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。</p><h1 id="3-c的类型安全"><a class="markdownIt-Anchor" href="#3-c的类型安全"></a> 3: C++的类型安全</h1><p>如果C<ins>使用得当，它将远比C更有类型安全性。相比于C语言，C</ins>提供了一些新的机制保障类型安全：</p><ul><li>操作符new返回的指针类型严格与对象匹配，而不是void*</li><li>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</li><li>引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换</li><li>一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</li><li>C++提供了<strong>dynamic_cast</strong>关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</li></ul><blockquote><p>[!note] 下面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。</p><ul><li>第一个例子用到了空类型指针void*，</li><li>第二个例子则是在两个类型指针之间进行强制转换。</li><li>因此，想保证程序的类型安全性，<ul><li>应尽量避免使用空类型指针void*，</li><li>尽量不对两种类型指针做强制转换</li></ul></li></ul></blockquote><h2 id="31-例1使用void进行类型转换"><a class="markdownIt-Anchor" href="#31-例1使用void进行类型转换"></a> 3.1: 例1：使用void*进行类型转换</h2><p>输出错误<br><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212341679.png" alt=""></p><h2 id="32-例2不同类型指针之间转换"><a class="markdownIt-Anchor" href="#32-例2不同类型指针之间转换"></a> 3.2: 例2：不同类型指针之间转换</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>{};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child1</span> : <span class="hljs-keyword">public</span> Parent<br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-built_in">Child1</span>(<span class="hljs-type">int</span> e):<span class="hljs-built_in">i</span>(e){}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child2</span> : <span class="hljs-keyword">public</span> Parent<br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">double</span> d;<br><span class="hljs-built_in">Child2</span>(<span class="hljs-type">double</span> e):<span class="hljs-built_in">d</span>(e){}<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-function">Child1 <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">Child2 <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">4.1</span>)</span></span>;<br>Parent* pp;<br>Child1* pc1;pp=&amp;c1; <br>pc1=(Child1*)pp;  <span class="hljs-comment">// 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span><br>cout&lt;&lt;pc1-&gt;i&lt;&lt;endl; <span class="hljs-comment">//❓输出：pp=&amp;c2; 💡应该是&amp;c1 吧</span><br>pc1=(Child1*)pp;  <span class="hljs-comment">//强制转换，且类型发生变化，将造成错误</span><br>cout&lt;&lt;pc1-&gt;i&lt;&lt;endl;<span class="hljs-comment">// 输出：1717986918</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31、野指针和悬空指针</title>
    <link href="/posts/19800/"/>
    <url>/posts/19800/</url>
    
    <content type="html"><![CDATA[<p>📝31、野指针和悬空指针::</p><!-- basicblock-end --><p>都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，<br>访问行为将会导致未定义行为。</p><h1 id="1-野指针"><a class="markdownIt-Anchor" href="#1-野指针"></a> 1: 野指针</h1><ul><li>野指针，指的是没有被初始化过的指针</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{ <br>          <span class="hljs-type">int</span>* p;     <span class="hljs-comment">// 未初始化</span><br>    std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="hljs-comment">// 未初始化就被使用</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>因此，为了防止出错，对于指针初始化时都是赋值为 <code>nullptr</code>，这样在使用时编译器就会直接报错，产生非法内存访问。</p><h1 id="2-悬空指针"><a class="markdownIt-Anchor" href="#2-悬空指针"></a> 2: 悬空指针</h1><ul><li>悬空指针，指针最初指向的内存已经被释放了的一种指针。</li></ul><blockquote><p>[!question] 代码不太懂</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{ <br>  <span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 这两个应该都没有分配内存</span><br>  <span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>      p = p2; <span class="hljs-comment">// 继续使用这两个指针</span><br>    <span class="hljs-keyword">delete</span> p2;<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。<br>需要设置为 <code>p=p2=nullptr</code>。此时再使用，编译器会直接保错。<br>避免野指针比较简单，但悬空指针比较麻烦。<br>c<ins>引入了智能指针，C</ins>智能指针的本质就是避免悬空指针的产生。</p><h1 id="3-产生原因及解决办法"><a class="markdownIt-Anchor" href="#3-产生原因及解决办法"></a> 3: <strong>产生原因及解决办法：</strong></h1><p>野指针：指针变量未及时初始化 =&gt; 定义指针变量及时初始化，要么置空。</p><p>悬空指针：指针free或delete之后没有及时置空 =&gt; 释放操作后立即置空。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30、externC的用法</title>
    <link href="/posts/6580/"/>
    <url>/posts/6580/</url>
    
    <content type="html"><![CDATA[<p>📝30、externC的用法::</p><!-- basicblock-end --><p>为了能够<strong>正确的在C++代码中调用C语言</strong>的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；</p><p>哪些情况下使用extern “C”：</p><p>（1）C++代码中调用C语言代码；</p><p>（2）在C++中的头文件中使用；</p><p>（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；</p><p>举个例子，C++中调用C代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MY_HANDLE_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MY_HANDLE_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>{<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">result_t</span>;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* <span class="hljs-type">my_handle_t</span>;<br>      <span class="hljs-function"><span class="hljs-type">my_handle_t</span> <span class="hljs-title">create_handle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">result_t</span> <span class="hljs-title">operate_on_handle</span><span class="hljs-params">(<span class="hljs-type">my_handle_t</span> handle)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close_handle</span><span class="hljs-params">(<span class="hljs-type">my_handle_t</span> handle)</span></span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>综上，总结出使用方法，<strong>在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误</strong>。所以使用extern "C"全部都放在于cpp程序相关文件或其头文件中。</p><p>总结出如下形式：</p><p>（1）C++调用C函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//xx.h</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//xx.c</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>{<br>  }<br><br><span class="hljs-comment">//xx.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {<br>    <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"xx.h"</span></span><br>}<br></code></pre></td></tr></tbody></table></figure><p>（2）C调用C++函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//xx.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span>{<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>}<br><span class="hljs-comment">//xx.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>{  }<br><span class="hljs-comment">//xx.c</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 💡不能用extern "C", 直接加 extern</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>29、初始化和赋值的区别</title>
    <link href="/posts/39102/"/>
    <url>/posts/39102/</url>
    
    <content type="html"><![CDATA[<p>📝29、初始化和赋值的区别::</p><!-- basicblock-end --><p>对于简单类型来说，初始化和赋值没什么区别</p><ul><li>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：<br>[[拷贝构造 &amp; 拷贝赋值.excalidraw]]<br>#📙</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">int</span> num2;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">num1</span>(a),<span class="hljs-built_in">num2</span>(b){};<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a){};<br>    <span class="hljs-comment">//重载 = 号操作符函数</span><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a){<br>        num1 = a.num1 + <span class="hljs-number">1</span>;<br>        num2 = a.num2 + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    };<br>};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span></span>;<br>    A a1 = a; <span class="hljs-comment">//拷贝初始化操作，调用拷贝构造函数</span><br>    A b;<br>    <span class="hljs-comment">// 拷贝赋值: b 先清空, 再创建 a 空间的大小, 在复制 a 的数据 </span><br>    b = a;<span class="hljs-comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28、拷贝初始化和直接初始化</title>
    <link href="/posts/31416/"/>
    <url>/posts/31416/</url>
    
    <content type="html"><![CDATA[<p>📝28、拷贝初始化和直接初始化::</p><!-- basicblock-end --><p>[[拷贝构造 &amp; 拷贝赋值.excalidraw]]<br>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：</p><ul><li>直接初始化: 直接调用与实参匹配的构造函数，</li><li>拷贝初始化: 首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。<ul><li>拷贝初始化总是调用拷贝构造函数。</li></ul></li></ul><p>举例如下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">"I am a string"</span>)</span></span>;<span class="hljs-comment">//语句1 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(str1)</span></span>;<span class="hljs-comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span><br>string str3 = <span class="hljs-string">"I am a string"</span>;<span class="hljs-comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span><br>string str4 = str1;<span class="hljs-comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span><br></code></pre></td></tr></tbody></table></figure><ul><li><strong>为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象</strong>，<ul><li>这样就完全等价于直接初始化了（语句1和语句3等价），但是需要辨别两种情况。</li></ul></li><li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li><li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li></ul><blockquote><p>感谢网友勘误：”string str2(str1); // 使用的是拷贝构造函数初始化而且直接初始化“，已修正，2021.10.12 -<a href="https://github.com/forthespada/InterviewGuide/issues/14">https://github.com/forthespada/InterviewGuide/issues/14</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>final和override关键字</title>
    <link href="/posts/56929/"/>
    <url>/posts/56929/</url>
    
    <content type="html"><![CDATA[<p>📝final和override关键字::</p><!-- basicblock-end --><h1 id="1-override关键字"><a class="markdownIt-Anchor" href="#1-override关键字"></a> 1: [[override关键字]]</h1><h1 id="2-final-关键字"><a class="markdownIt-Anchor" href="#2-final-关键字"></a> 2: [[final 关键字]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组名和指针（这里为指向数组首元素的指针）区别？</title>
    <link href="/posts/23464/"/>
    <url>/posts/23464/</url>
    
    <content type="html"><![CDATA[<p>📝数组名和指针（这里为指向数组首元素的指针）区别？::</p><!-- basicblock-end --><p>[[指针(目录)]]<br>二者均可通过增减偏移量来访问数组中的元素。</p><ul><li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li><li>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，<ul><li>多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24、C++中const和static的作用</title>
    <link href="/posts/28520/"/>
    <url>/posts/28520/</url>
    
    <content type="html"><![CDATA[<p>📝24、C++中const和static的作用::</p><!-- basicblock-end --><h1 id="1-static"><a class="markdownIt-Anchor" href="#1-static"></a> 1: <strong>static</strong></h1><h2 id="11-不考虑类的情况"><a class="markdownIt-Anchor" href="#11-不考虑类的情况"></a> 1.1: 不考虑类的情况</h2><ul><li>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</li><li>默认初始化为0，包括未初始化的<strong>全局静态变量与局部静态变量</strong>，都存在未初始化全局区<ul><li>[[进程的地址空间分布.excalidraw]]</li></ul></li><li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li></ul><h2 id="12-考虑类的情况"><a class="markdownIt-Anchor" href="#12-考虑类的情况"></a> 1.2: 考虑类的情况</h2><ul><li>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</li><li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li></ul><h1 id="2-const"><a class="markdownIt-Anchor" href="#2-const"></a> 2: <strong>const</strong></h1><h2 id="21-不考虑类的情况"><a class="markdownIt-Anchor" href="#21-不考虑类的情况"></a> 2.1: 不考虑类的情况</h2><ul><li>const常量在定义时必须初始化，之后无法更改</li><li>const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int&amp; i){ //…}<ul><li>[[左右值引用(目录)#^8baw7f]]</li></ul></li></ul><h2 id="22-考虑类的情况"><a class="markdownIt-Anchor" href="#22-考虑类的情况"></a> 2.2: 考虑类的情况</h2><ul><li>const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；<br>- 不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li><li>const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li></ul><p>补充一点const相关：<br>const修饰变量是也与static有一样的隐藏作用。<br>只能在该文件中使用，其他文件不可以引用声明使用。<br>因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23、define宏定义和const的区别</title>
    <link href="/posts/56642/"/>
    <url>/posts/56642/</url>
    
    <content type="html"><![CDATA[<p>📝23、define宏定义和const的区别::</p><!-- basicblock-end --><h1 id="1-编译阶段"><a class="markdownIt-Anchor" href="#1-编译阶段"></a> 1: <strong>编译阶段</strong></h1><ul><li>define是在编译的<strong>预处理</strong>阶段起作用，</li><li>而const是在编译、运行的时候起作用</li></ul><h1 id="2-安全性"><a class="markdownIt-Anchor" href="#2-安全性"></a> 2: <strong>安全性</strong></h1><ul><li>define只做替换，<strong>不做类型检查和计算</strong>，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</li><li>const常量有数据类型，编译器可以对其<strong>进行类型安全检查</strong></li></ul><h1 id="3-内存占用"><a class="markdownIt-Anchor" href="#3-内存占用"></a> 3: <strong>内存占用</strong></h1><ul><li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li><li>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</li><li>宏不检查类型；const会检查数据类型。</li><li>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-40 目录</title>
    <link href="/posts/55155/"/>
    <url>/posts/55155/</url>
    
    <content type="html"><![CDATA[<p>📝21-40 目录::</p><!-- basicblock-end --><h1 id="1-21-c与java的区别"><a class="markdownIt-Anchor" href="#1-21-c与java的区别"></a> 1: [[21、C++与Java的区别]]</h1><h1 id="2-22-c中struct和class的区别"><a class="markdownIt-Anchor" href="#2-22-c中struct和class的区别"></a> 2: [[22. C++中struct和class的区别]]</h1><h1 id="3-23-define宏定义和const的区别"><a class="markdownIt-Anchor" href="#3-23-define宏定义和const的区别"></a> 3: [[23、define宏定义和const的区别]]</h1><h1 id="4-24-c中const和static的作用"><a class="markdownIt-Anchor" href="#4-24-c中const和static的作用"></a> 4: [[24、C++中const和static的作用]]</h1><h1 id="5-const-关键字"><a class="markdownIt-Anchor" href="#5-const-关键字"></a> 5: [[const 关键字]]</h1><h1 id="6-数组名和指针这里为指向数组首元素的指针区别"><a class="markdownIt-Anchor" href="#6-数组名和指针这里为指向数组首元素的指针区别"></a> 6: [[数组名和指针（这里为指向数组首元素的指针）区别？]]</h1><h1 id="7-27-final和override关键字"><a class="markdownIt-Anchor" href="#7-27-final和override关键字"></a> 7: 27、[[final和override关键字]]</h1><h1 id="8-28-拷贝初始化和直接初始化"><a class="markdownIt-Anchor" href="#8-28-拷贝初始化和直接初始化"></a> 8: [[28、拷贝初始化和直接初始化]]</h1><h1 id="9-29-初始化和赋值的区别"><a class="markdownIt-Anchor" href="#9-29-初始化和赋值的区别"></a> 9: [[29、初始化和赋值的区别]]</h1><h1 id="10-30-externc的用法"><a class="markdownIt-Anchor" href="#10-30-externc的用法"></a> 10: [[30、externC的用法]]</h1><h1 id="11-31-野指针和悬空指针"><a class="markdownIt-Anchor" href="#11-31-野指针和悬空指针"></a> 11: [[31、野指针和悬空指针]]</h1><h1 id="12-32-c和c的类型安全"><a class="markdownIt-Anchor" href="#12-32-c和c的类型安全"></a> 12: [[32、C和C++的类型安全]]。</h1><h1 id="13-33-c中的重载-重写覆盖和隐藏的区别"><a class="markdownIt-Anchor" href="#13-33-c中的重载-重写覆盖和隐藏的区别"></a> 13: [[33、C++中的重载、重写（覆盖）和隐藏的区别]]</h1><h1 id="14-34-c有哪几种的构造函数"><a class="markdownIt-Anchor" href="#14-34-c有哪几种的构造函数"></a> 14: [[34、C++有哪几种的构造函数]]</h1><h1 id="15-35-浅拷贝和深拷贝的区别"><a class="markdownIt-Anchor" href="#15-35-浅拷贝和深拷贝的区别"></a> 15: [[35、浅拷贝和深拷贝的区别]]</h1><h1 id="16-36-内联函数和宏定义的区别"><a class="markdownIt-Anchor" href="#16-36-内联函数和宏定义的区别"></a> 16: [[36、内联函数和宏定义的区别]]</h1><h1 id="17-访问权限-继承权限"><a class="markdownIt-Anchor" href="#17-访问权限-继承权限"></a> 17: [[访问权限, 继承权限]]</h1><h1 id="18-38-如何用代码判断大小端存储"><a class="markdownIt-Anchor" href="#18-38-如何用代码判断大小端存储"></a> 18: [[38、如何用代码判断大小端存储？]]</h1><h1 id="19-39-volatile-mutable和explicit关键字的用法"><a class="markdownIt-Anchor" href="#19-39-volatile-mutable和explicit关键字的用法"></a> 19: [[39、volatile、mutable和explicit关键字的用法]]</h1><h1 id="20-40-什么情况下会调用拷贝构造函数"><a class="markdownIt-Anchor" href="#20-40-什么情况下会调用拷贝构造函数"></a> 20: [[40、什么情况下会调用拷贝构造函数]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库引擎InnoDB与MyISAM的区别</title>
    <link href="/posts/24704/"/>
    <url>/posts/24704/</url>
    
    <content type="html"><![CDATA[<p>📝数据库引擎InnoDB与MyISAM的区别:: 下边的具体特性不想总结了</p><!-- basicblock-end --><blockquote><p>[!summary] 面试题： InnoDB 引擎与 MyISAM 引擎的区别 ？<br>①.InnoDB引擎，支持事务，而MyISAM不支持。<br>②. InnoDB引擎，支持行锁和表锁，而MyISAM仅支持表锁，不支持行锁。<br>③. InnoDB引擎，支持外键，而MyISAM是不支持的。</p></blockquote><p>1）事务：MyISAM不支持，InnoDB支持<br>2）锁级别： MyISAM 表级锁，InnoDB 行级锁及外键约束<br>3）MyISAM存储表的总行数；InnoDB不存储总行数；<br>4）MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。<br>InnoDB主键索引采用聚集索引，B+树叶子存储数据</p><h1 id="1-使用场景"><a class="markdownIt-Anchor" href="#1-使用场景"></a> 1: 使用场景</h1><p>MyISAM适合： 插入不频繁，查询非常频繁，<br>如果执行大量的SELECT，MyISAM是更好的选择，没有事务。</p><p>InnoDB适合： 可靠性要求比较高，或者要求事务；<br>表更新和查询都相当的频繁，大量的INSERT或UPDATE</p><h1 id="2-innodb"><a class="markdownIt-Anchor" href="#2-innodb"></a> 2: <strong>InnoDB</strong></h1><ul><li>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</li><li>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。</li><li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</li><li>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读能够加快读操作并且自动创建的自适应哈希索引能够加速插入操作的插入缓冲区等。</li><li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li></ul><h1 id="3-myisam"><a class="markdownIt-Anchor" href="#3-myisam"></a> 3: <strong>MyISAM</strong></h1><ul><li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小可以容忍修复操作，则依然可以使用它。</li><li>提供了大量的特性，包括压缩表空间数据索引等。</li><li>不支持事务。</li><li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</li></ul><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4: <strong>总结</strong></h1><ul><li>事务: InnoDB 是事务型的，可以使用 <code>Commit</code> 和 <code>Rollback</code> 语句。</li><li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键: InnoDB 支持外键。</li><li>备份: InnoDB 支持在线热备份。</li><li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性: MyISAM 支持压缩表和空间数据索引。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中为什么要有事务回滚机制？</title>
    <link href="/posts/55791/"/>
    <url>/posts/55791/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL中为什么要有事务回滚机制？::</p><!-- basicblock-end --><blockquote><p>[!summary] 回滚日志，用于记录数据被修改前的信息 ,<br>作用包含两个 : 提供回滚 (保证事务的原子性) 和 MVCC (多版本并发控制) 。</p></blockquote><p>回滚日志作用：</p><ol><li>能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息</li><li>在整个系统发生崩溃数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，<ol><li>这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>听说过视图吗？那游标呢？</title>
    <link href="/posts/28536/"/>
    <url>/posts/28536/</url>
    
    <content type="html"><![CDATA[<p>📝听说过视图吗？那游标呢？::</p><!-- basicblock-end --><p>视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能.</p><p>游标是对查询出来的结果集作为一个单元来有效的处理。<br>一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>01-20 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件索引和数据库索引为什么使用B+树</title>
    <link href="/posts/43461/"/>
    <url>/posts/43461/</url>
    
    <content type="html"><![CDATA[<p>📝文件索引和数据库索引为什么使用B+树::</p><!-- basicblock-end --><p>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。<br>而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。</p><p>数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。</p><p><strong>B+树的特点</strong></p><ul><li>所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;</li><li>不可能在非叶子结点命中;</li><li>非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;</li></ul><h1 id="1-b树-方便扫库"><a class="markdownIt-Anchor" href="#1-b树-方便扫库"></a> 1: B+树 方便扫库</h1><blockquote><p>[!summary] B+tree的磁盘读写代价更低，B+tree的查询效率更加稳定</p><ul><li><strong>最重要</strong>的是，B+树还有一个最大的好处：方便扫库。<ul><li>B+树只要遍历叶子节点就可以实现整棵树的遍历</li><li>B树必须用中序遍历的方法按序扫库，</li></ul></li><li>数据库选用B+树的<strong>最主要原因</strong><ul><li>B+树支持<strong>range-query</strong>非常方便，</li><li>而B树不支持，</li><li>而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低</li></ul></li></ul></blockquote><p>![[B Tree &amp; B+Tree.excalidraw]]</p><h1 id="2-btree的磁盘读写代价更低"><a class="markdownIt-Anchor" href="#2-btree的磁盘读写代价更低"></a> 2: B+tree的磁盘读写代价更低：</h1><p>B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。<br>如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；</p><h1 id="3-btree的查询效率更加稳定"><a class="markdownIt-Anchor" href="#3-btree的查询效率更加稳定"></a> 3: B+tree的查询效率更加稳定：</h1><p>B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。<br>由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，<br>所以，任何关键字的查找必须走一条从根结点到叶子结点的路。<br>所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</p><blockquote><p>[!todo]<br>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</p><ul><li>相对于二叉树，<strong>层级更少</strong>，搜索效率高 (因为 B 树孩子多)</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发事务问题</title>
    <link href="/posts/55629/"/>
    <url>/posts/55629/</url>
    
    <content type="html"><![CDATA[<p>📝并发事务问题::</p><!-- basicblock-end --><p>数据库并发会带来脏读幻读丢弃更改不可重复读这四个常见问题，</p><blockquote><p>[!summary]</p><ol><li>脏读： ⼀个事务读取另⼀个事务还没有提交的数据</li><li>不可重复读： 同⼀个事务内，两个相同的查询返回了不同的结果</li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了"幻影"。</li></ol></blockquote><blockquote><p>[!example]<br>![[脏读, 不可重复读, 幻读(并发事务问题).excalidraw]]</p></blockquote><h1 id="1-脏读"><a class="markdownIt-Anchor" href="#1-脏读"></a> 1: 脏读</h1><p><strong>脏读</strong>：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。<br><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024781.png" alt="脏读"></p><p>第一个事务首先读取var变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取var为100，此时第一个事务做了回滚。最终第二个事务读取的var和数据库的var不一样。</p><h1 id="2-不可重复读"><a class="markdownIt-Anchor" href="#2-不可重复读"></a> 2: 不可重复读</h1><p><strong>不可重复读</strong>：T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024930.png" alt="不可重复读|400"></p><h1 id="3-幻读幻影读幻读"><a class="markdownIt-Anchor" href="#3-幻读幻影读幻读"></a> 3: <strong>幻读（幻影读）</strong>[[幻读]]</h1><p><strong>幻读</strong>：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了，强调范围。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024132.png" alt="幻读"></p><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><h1 id="4-丢弃修改"><a class="markdownIt-Anchor" href="#4-丢弃修改"></a> 4: <strong>丢弃修改</strong></h1><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。<br>例如：事务1读取某表中的数据A=50，事务2也读取A=50，事务1修改A=A+50，事务2也修改A=A+50，最终结果A=100，事务1的修改被丢失。</p><p><img src="https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024561.png" alt="丢弃修改|500"></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事务隔离级别 (解决事务并发问题)</title>
    <link href="/posts/24936/"/>
    <url>/posts/24936/</url>
    
    <content type="html"><![CDATA[<p>📝事务隔离级别 (解决事务并发问题)::</p><!-- basicblock-end --><p>为了解决并发事务所引发的问题,在数据库中引入了事务隔离级别。主要有以下几种:</p><h1 id="1-四种隔离级别"><a class="markdownIt-Anchor" href="#1-四种隔离级别"></a> 1: 四种隔离级别</h1><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read-uncommitted 未提交读</td><td>√</td><td>√</td><td>√</td></tr><tr><td>read-committed 提交读</td><td>×</td><td>√</td><td>√</td></tr><tr><td>repeatable-read 可重复读(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>serializable 可串行化读</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>Oracle 默认： 读已提交<br>MySQL 默认: 可重复读</p><blockquote><p>[!summary] 总结：<br>读未提交：别⼈改数据的事务尚未提交，我在我的事务中也能读到。<br>读已提交：别⼈改数据的事务已经提交，我在我的事务中才能读到。<br>可重复读：别⼈改数据的事务已经提交，我在我的事务中也<strong>不去</strong>读。<br>串⾏：我的事务尚未提交，别⼈就别想改数据。</p><ul><li>这 4 种隔离级别，并⾏性能依次降低，安全性依次提⾼。</li><li><strong>隔离级别越低，事务请求的锁越少</strong><ul><li>Read uncommitted 性能最高，数据安全性最差</li><li>Serializable 性能最低, 数据安全性最高</li></ul></li><li>一般不会修改事务的隔离级别, 直接采取默认的</li></ul></blockquote><h2 id="11-ru-未提交读read-uncommited"><a class="markdownIt-Anchor" href="#11-ru-未提交读read-uncommited"></a> 1.1: RU 未提交读（Read Uncommited）</h2><ul><li><strong>未提交读</strong>: 事务还没提交时，他做的变更能被其他事务看到</li></ul><p>在该隔离级别下，<strong>1️⃣事务之间完全不隔离</strong>，2️⃣<strong>可能会导致脏读幻读或不可重复读</strong>，⼀般情况不会使⽤</p><blockquote><p>[!example]-<br>比如对于一个数A原来50修改为100，但是我还没有提交修改，<br>另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，<br>但是另一个事务看到的A是100.</p></blockquote><h2 id="12-rc-提交读read-commited"><a class="markdownIt-Anchor" href="#12-rc-提交读read-commited"></a> 1.2: RC 提交读（Read Commited）</h2><p><strong>提交读</strong>，对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，<br>⼀个事务提交之后，他做的变更才能被其他事务看到</p><p>本事务读取到的是其它事务提交的最新数据，但有⼀个问题在同⼀个事务中，前后两相同的 select 可能会读到不同的结果</p><p><strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></p><blockquote><p>[!example]-<br>举例就是对于一个数A原来是50，然后提交修改成100，<br>这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，<br>这个时候另一个事务再进行读取发现A就突然变成100了；</p></blockquote><h2 id="13-rr-可重复读repeatable-read"><a class="markdownIt-Anchor" href="#13-rr-可重复读repeatable-read"></a> 1.3: RR 可重复读（Repeatable Read）</h2><ul><li><strong>重复读</strong>，就是对一个记录读取多次的记录是相同的，<br>开启事务后第一个select语句才是快照读的地方 : [[快照读 &amp; 当前读.excalidraw]]<br>每次查询的都是第一次的 select 语句<br>因此，同⼀个事务同样的 select 操作可以读到⼀致的结果, 为可重复读</li></ul><p><strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></p><blockquote><p>[!done]<br>别⼈改数据的事务已经提交，我在我的事务中<strong>也不去读</strong><br>因为每次 select 用的都是第一次的视图</p></blockquote><blockquote><p>[!example] 可重复读的场景: 数据校对逻辑的案例<br>校对上个⽉的余额和这个⽉余额的差值，<br>你希望<strong>在校对过程中</strong>，即使有⽤户发⽣了新的交易，也不影响校对结果。</p></blockquote><h2 id="14-serializable-可串行化读"><a class="markdownIt-Anchor" href="#14-serializable-可串行化读"></a> 1.4: serializable 可串行化读</h2><ul><li><strong>可串行化读</strong>，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，<ul><li>对同⼀⾏记录，写时加“写锁”，读时加“读锁”，出现冲突时按顺序完成。</li><li>读操作会隐式获取共享锁，保证不同事务之间的互斥<br>（我的事务尚未提交，别⼈别想改数据）</li></ul></li></ul><p>比如不会发生脏读和幻读；<strong>该级别可以防止脏读不可重复读以及幻读</strong></p><h1 id="2-其他"><a class="markdownIt-Anchor" href="#2-其他"></a> 2: 其他</h1><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ</strong>（可重复读）</p><p><strong>这里需要注意的是</strong>：<br>与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是<strong>Next-Key Lock 锁</strong>算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。[[间隙锁&amp;临键锁]]</p><p>所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。</p><p>因为<strong>隔离级别越低，事务请求的锁越少</strong>，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，<br>但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）并不会有任何性能损失</strong>。</p><p>InnoDB 存储引擎在分布式事务的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</p><h1 id="3-操作"><a class="markdownIt-Anchor" href="#3-操作"></a> 3: 操作</h1><p>MySQL 中的设置：transaction-isolation 设置为 read-committed，⽤show variables 来查看可重复读的场景</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查看事务隔离级别：<br>select @@transaction_isolation;<br>设置事务隔离级别：<br>set [ session | global ] transaction isolation level {read uncommitted | read committed | repeatable read | serializable };<br></code></pre></td></tr></tbody></table></figure><p>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><blockquote><p>[!example]<br>![[脏读, 幻读, 不可重复读.excalidraw|1800]]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 优化(目录)</title>
    <link href="/posts/24636/"/>
    <url>/posts/24636/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 优化(目录)::</p><!-- basicblock-end --><h1 id="1-说一下从哪些方面可以做到性能优化"><a class="markdownIt-Anchor" href="#1-说一下从哪些方面可以做到性能优化"></a> 1: 说一下从哪些方面可以做到性能优化？</h1><ul><li>为搜索字段创建索引</li><li>避免使用 Select *，列出需要查询的字段</li><li>垂直分割分表</li><li>选择正确的存储引擎</li></ul><h1 id="2-mysql查询优化"><a class="markdownIt-Anchor" href="#2-mysql查询优化"></a> 2: [[MySQL查询优化]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说一说DropDelete与Truncate的共同点和区别</title>
    <link href="/posts/57520/"/>
    <url>/posts/57520/</url>
    
    <content type="html"><![CDATA[<p>📝说一说Drop, Delete与Truncate的共同点和区别::</p><!-- basicblock-end --><h1 id="1-第一种回答"><a class="markdownIt-Anchor" href="#1-第一种回答"></a> 1: <strong>第一种回答</strong></h1><p>Drop, Delete, Truncate都表示删除，但是三者有一些差别：</p><ul><li><strong>Delete</strong>用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。</li><li><strong>Truncate</strong>删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比delete更快，占用的空间更小。</li><li><strong>Drop</strong>命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。</li></ul><blockquote><p>[!summary] 因此，<br>在不再需要一张表的时候，用Drop；<br>在想删除部分数据行时候，用Delete；<br>在保留表而删除所有数据的时候用Truncate。</p></blockquote><h1 id="2-第二种回答"><a class="markdownIt-Anchor" href="#2-第二种回答"></a> 2: <strong>第二种回答</strong></h1><ul><li>Drop直接删掉表;</li><li>Truncate删除表中数据，再插入时自增长id又从1开始 ;</li><li>Delete删除表中数据，可以加where字句。</li></ul><h1 id="3-具体解析暂时先不看了"><a class="markdownIt-Anchor" href="#3-具体解析暂时先不看了"></a> 3: <strong>具体解析</strong>(暂时先不看了)</h1><ol><li>DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</li><li>表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</li><li>一般而言，drop &gt; truncate &gt; delete</li><li>应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</li><li>TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</li><li>truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</li><li>delete语句为DML（Data Manipulation Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</li><li>truncatedrop是DDL（Data Define Language),操作立即生效，原数据不放到 rollback segment中，不能回滚</li><li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果与事务无关，用truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。</li><li>Truncate table 表名速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</li><li>TRUNCATE TABLE 删除表中的所有行，但表结构及其列约束索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</li><li>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>01-20 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 体系结构</title>
    <link href="/posts/8381/"/>
    <url>/posts/8381/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 体系结构::</p><!-- basicblock-end --><p>![[MySQL 整体架构图.excalidraw]]</p><h1 id="1-你了解mysql的内部构造吗一般可以分为哪两个部分"><a class="markdownIt-Anchor" href="#1-你了解mysql的内部构造吗一般可以分为哪两个部分"></a> 1: 你了解MySQL的内部构造吗？一般可以分为哪两个部分？</h1><p>可以分为服务层和存储引擎层两部分，其中：</p><p><strong>服务层包括连接器查询缓存分析器优化器执行器等</strong>，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期时间数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程触发器视图等。[[01.服务层：一条SQL查询语句是如何执行的？]]</p><p><strong>存储引擎层负责数据的存储和提取</strong>。其架构模式是插件式的，支持InnoDBMyISAMMemory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。</p><h1 id="2-存储引擎层"><a class="markdownIt-Anchor" href="#2-存储引擎层"></a> 2: [[存储引擎层]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyISAM和InnoDB实现B树索引方式的区别是什么？</title>
    <link href="/posts/38640/"/>
    <url>/posts/38640/</url>
    
    <content type="html"><![CDATA[<p>📝MyISAM和InnoDB实现B树索引方式的区别是什么？::</p><!-- basicblock-end --><h1 id="1-myisam"><a class="markdownIt-Anchor" href="#1-myisam"></a> 1: MyISAM</h1><ul><li><p>MyISAM: B+Tree叶节点的data域存放的是<strong>数据记录的地址</strong>，</p></li><li><p>在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，</p></li><li><p>然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”</p></li></ul><h1 id="2-innodb"><a class="markdownIt-Anchor" href="#2-innodb"></a> 2: InnoDB</h1><ul><li>InnoDB，其数据文件本身就是索引文件，<ul><li>相比MyISAM，索引文件和数据文件是分离的，</li><li>其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录</li></ul></li><li>这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，</li><li>而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。</li></ul><p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；<br>在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。<br>因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>01-20 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Innodb为什么要用自增id作为主键？</title>
    <link href="/posts/15328/"/>
    <url>/posts/15328/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!question]<br>📝Innodb为什么要用自增id作为主键？::   #疑问</p></blockquote><!-- basicblock-end --><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，频繁的移动分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>01-20 MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关系型和非关系型数据库</title>
    <link href="/posts/4466/"/>
    <url>/posts/4466/</url>
    
    <content type="html"><![CDATA[<p>📝关系型和非关系型数据库::</p><!-- basicblock-end --><h1 id="1-什么是非关系型数据库"><a class="markdownIt-Anchor" href="#1-什么是非关系型数据库"></a> 1: 什么是非关系型数据库？</h1><p>非关系型数据库也叫NOSQL，采用键值对的形式进行存储。</p><p>它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，<br>比如 Redis，Mongodb，HBase等等。</p><p>适合使用非关系型数据库的场景：</p><ul><li>日志系统</li><li>地理位置存储</li><li>数据量巨大</li><li>高可用</li></ul><h1 id="2-关系型和非关系型数据库的区别你了解多少"><a class="markdownIt-Anchor" href="#2-关系型和非关系型数据库的区别你了解多少"></a> 2: 关系型和非关系型数据库的区别你了解多少？</h1><ul><li>关系型数据库的优点<ul><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ul></li><li>非关系型数据库的优点<ul><li>不需要经过SQL层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>01-20 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-20目录</title>
    <link href="/posts/65183/"/>
    <url>/posts/65183/</url>
    
    <content type="html"><![CDATA[<p>📝关系型和非关系型数据库的区别你了解多少？::</p><!-- basicblock-end --><h1 id="1-关系型和非关系型数据库"><a class="markdownIt-Anchor" href="#1-关系型和非关系型数据库"></a> 1: [[关系型和非关系型数据库]]</h1><h1 id="2-innodb为什么要用自增id作为主键"><a class="markdownIt-Anchor" href="#2-innodb为什么要用自增id作为主键"></a> 2: [[Innodb为什么要用自增id作为主键？]]</h1><h1 id="3-索引目录2-为什么使用索引为什么使用索引"><a class="markdownIt-Anchor" href="#3-索引目录2-为什么使用索引为什么使用索引"></a> 3: [[索引(目录)#2 为什么使用索引？|为什么使用索引]]</h1><h1 id="4-myisam和innodb实现b树索引方式的区别是什么"><a class="markdownIt-Anchor" href="#4-myisam和innodb实现b树索引方式的区别是什么"></a> 4: [[MyISAM和InnoDB实现B树索引方式的区别是什么？]]</h1><h1 id="5-01服务层一条sql查询语句是如何执行的"><a class="markdownIt-Anchor" href="#5-01服务层一条sql查询语句是如何执行的"></a> 5: [[01.服务层：一条SQL查询语句是如何执行的？]]</h1><h1 id="6-mysql-体系结构"><a class="markdownIt-Anchor" href="#6-mysql-体系结构"></a> 6: [[MySQL 体系结构]]</h1><h1 id="7-说一说drop-delete与truncate的共同点和区别"><a class="markdownIt-Anchor" href="#7-说一说drop-delete与truncate的共同点和区别"></a> 7: [[说一说Drop, Delete与Truncate的共同点和区别]]</h1><h1 id="8-mysql-优化目录"><a class="markdownIt-Anchor" href="#8-mysql-优化目录"></a> 8: [[MySQL 优化(目录)]]</h1><h1 id="9-事务隔离级别-解决事务并发问题"><a class="markdownIt-Anchor" href="#9-事务隔离级别-解决事务并发问题"></a> 9: [[事务隔离级别 (解决事务并发问题)]]</h1><h1 id="10-btree-索引"><a class="markdownIt-Anchor" href="#10-btree-索引"></a> 10: [[B+Tree 索引]]</h1><h1 id="11-文件索引和数据库索引为什么使用b树而不使用-b-树"><a class="markdownIt-Anchor" href="#11-文件索引和数据库索引为什么使用b树而不使用-b-树"></a> 11: [[文件索引和数据库索引为什么使用B+树而不使用 B 树]]</h1><h1 id="12-听说过视图吗那游标呢"><a class="markdownIt-Anchor" href="#12-听说过视图吗那游标呢"></a> 12: [[听说过视图吗？那游标呢？]]</h1><h1 id="13-mysql中为什么要有事务回滚机制"><a class="markdownIt-Anchor" href="#13-mysql中为什么要有事务回滚机制"></a> 13: [[MySQL中为什么要有事务回滚机制？]]</h1><h1 id="14-数据库引擎innodb与myisam的区别"><a class="markdownIt-Anchor" href="#14-数据库引擎innodb与myisam的区别"></a> 14: [[数据库引擎InnoDB与MyISAM的区别]]</h1><h1 id="15-事务并发问题数据库并发事务会带来哪些问题"><a class="markdownIt-Anchor" href="#15-事务并发问题数据库并发事务会带来哪些问题"></a> 15: [[事务并发问题|数据库并发事务会带来哪些问题？]]</h1><h1 id="16-乐观锁悲观锁"><a class="markdownIt-Anchor" href="#16-乐观锁悲观锁"></a> 16: [[乐观锁&amp;悲观锁]]</h1><h1 id="17-mysql索引主要使用的两种数据结构是什么"><a class="markdownIt-Anchor" href="#17-mysql索引主要使用的两种数据结构是什么"></a> 17: [[MySQL索引主要使用的两种数据结构是什么？]]</h1><h1 id="18-数据库为什么要进行分库和分表呢"><a class="markdownIt-Anchor" href="#18-数据库为什么要进行分库和分表呢"></a> 18: [[数据库为什么要进行分库和分表呢？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>阿秀</category>
      
      <category>01-20 MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>B+Tree 索引</title>
    <link href="/posts/40064/"/>
    <url>/posts/40064/</url>
    
    <content type="html"><![CDATA[<p>📝B+Tree 索引::</p><!-- basicblock-end --><h1 id="1-概念-b-tree"><a class="markdownIt-Anchor" href="#1-概念-b-tree"></a> 1: 概念 [[B-Tree]]</h1><h1 id="2-myisam和innodb实现b树索引方式的区别是什么"><a class="markdownIt-Anchor" href="#2-myisam和innodb实现b树索引方式的区别是什么"></a> 2: [[MyISAM和InnoDB实现B树索引方式的区别是什么？]]</h1><h1 id="3-文件索引和数据库索引为什么使用b树而不使用-b-树"><a class="markdownIt-Anchor" href="#3-文件索引和数据库索引为什么使用b树而不使用-b-树"></a> 3: [[文件索引和数据库索引为什么使用B+树而不使用 B 树]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引常见面试题</title>
    <link href="/posts/44919/"/>
    <url>/posts/44919/</url>
    
    <content type="html"><![CDATA[<p>📝索引常见面试题::</p><!-- basicblock-end --><p>[[索引(目录)]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>小林 coding</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中struct和class的区别</title>
    <link href="/posts/63230/"/>
    <url>/posts/63230/</url>
    
    <content type="html"><![CDATA[<p>📝C++中struct和class的区别::</p><!-- basicblock-end --><h1 id="1-相同点"><a class="markdownIt-Anchor" href="#1-相同点"></a> 1: <strong>相同点</strong></h1><ul><li>两者都拥有成员函数、公有和私有部分</li><li>任何可以使用class完成的工作，同样可以使用struct完成</li></ul><h1 id="2-不同点"><a class="markdownIt-Anchor" href="#2-不同点"></a> 2: <strong>不同点</strong></h1><ul><li><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p></li><li><p>class默认是private继承， 而struct默认是public继承</p></li></ul><h1 id="3-引申c和c的struct区别"><a class="markdownIt-Anchor" href="#3-引申c和c的struct区别"></a> 3: <strong>引申</strong>：C++和C的struct区别</h1><ul><li><p>C语言中：struct是用户自定义数据类型（UDT）；</p></li><li><p>C<ins>中struct是抽象数据类型（ADT），支持成员函数的定义，（C</ins>中的struct能继承，能实现多态）</p></li><li><p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员<strong>不可以是函数</strong></p></li><li><p>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p></li><li><p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;</p></li><li><p>C<ins>中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C</ins>中被当作类的一种特例</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++的内存管理</title>
    <link href="/posts/34964/"/>
    <url>/posts/34964/</url>
    
    <content type="html"><![CDATA[<p>📝C++的内存管理::</p><!-- basicblock-end --><p>以C++为例来介绍一下编程语言的内存管理。</p><p>如果我们写C++的程序，就要知道栈和堆的概念，程序运行时所需的内存空间分为 固定部分，和可变部分，如下：</p><p><img src="https://img-blog.csdnimg.cn/20210309165950660.png" alt="C++内存空间|600"></p><blockquote><p>[!example]<br>![[进程的地址空间分布.excalidraw]]</p></blockquote><p>固定部分的内存消耗 是不会随着代码运行产生变化的， 可变部分则是会产生变化的</p><p>更具体一些，一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ul><li>栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。</li><li>堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回</li><li>未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量</li><li>初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量</li><li>程序代码区(Text)：存放函数体的二进制代码</li></ul><p>代码区和数据区所占空间都是固定的，而且占用的空间非常小，那么看运行时消耗的内存主要看可变部分。</p><p>在可变部分中，栈区间的数据在代码块执行结束之后，系统会自动回收，<strong>而堆区间数据是需要程序员自己回收，所以也就是造成内存泄漏的发源地。</strong><br>[[堆与栈(内存方面(🗃))]]<br>‌‌‌</p><p><strong>而Java、Python的话则不需要程序员去考虑内存泄漏的问题，虚拟机都做了这些事情</strong>。 ^674919</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21、C++与Java的区别</title>
    <link href="/posts/20392/"/>
    <url>/posts/20392/</url>
    
    <content type="html"><![CDATA[<p>📝21、C++与Java的区别::</p><!-- basicblock-end --><h1 id="1-语言特性"><a class="markdownIt-Anchor" href="#1-语言特性"></a> 1: 语言特性</h1><ul><li><p>Java语言给开发人员提供了更为简洁的语法；<strong>完全面向对象</strong>，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强</p></li><li><p>Java语言中没有指针的概念，引入了真正的数组。不同于C<ins>中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C</ins>程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题</p></li><li><p>C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），</p><ul><li>例如对一个数字，在windows下是大端存储，在unix中则为小端存储。</li><li>Java程序一般都是生成字节码，在JVM里面运行得到结果</li></ul></li><li><p>Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性</p></li></ul><h1 id="2-垃圾回收"><a class="markdownIt-Anchor" href="#2-垃圾回收"></a> 2: 垃圾回收</h1><ul><li>C<ins>用析构函数回收垃圾，写C和C</ins>程序时一定要注意内存的申请和释放</li><li>Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题<br>[[C++的内存管理]]</li></ul><h1 id="3-应用场景"><a class="markdownIt-Anchor" href="#3-应用场景"></a> 3: 应用场景</h1><ul><li>Java在桌面程序上不如C<ins>实用，C</ins>可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性。<ul><li>（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）</li></ul></li><li>Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架</li><li>对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在</li></ul><blockquote><p>[!cite] <strong>句柄与描述符:</strong> [[网络编程]]<br>文件描述符: 方便称呼操作系统创建的文件或套接字而赋予的数。<br>有时也被成为文件句柄 (句柄-- Windows 中的术语)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>21-40 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20、C++和C语言的区别</title>
    <link href="/posts/3243/"/>
    <url>/posts/3243/</url>
    
    <content type="html"><![CDATA[<p>📝20、C++和C语言的区别::</p><!-- basicblock-end --><ul><li><p>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</p><ul><li>[[new delete &amp; malloc free 目录]]</li></ul></li><li></li><li><p>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</p></li><li></li><li><p>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</p></li><li></li><li><p>question C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</p></li><li></li><li><p>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。</p><ul><li>也就是C++可以重载，C语言不允许。</li></ul></li><li><p>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；</p></li><li><p>而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的</p></li><li></li><li><p>在C++中，除了值和指针之外，新增了引用。</p><ul><li>引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li><li></li></ul></li><li><p>C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19、C++和Python的区别</title>
    <link href="/posts/8769/"/>
    <url>/posts/8769/</url>
    
    <content type="html"><![CDATA[<p>📝19、C++和Python的区别::</p><!-- basicblock-end --><p>包括但不限于：</p><ul><li>Python是一种脚本语言，是解释执行的，而C<ins>是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C</ins>高。</li><li>Python使用缩进来区分不同的代码块，C++使用花括号来区分</li><li>C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li><li>Python的库函数比C++的多，调用起来很方便</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指针(目录)</title>
    <link href="/posts/38225/"/>
    <url>/posts/38225/</url>
    
    <content type="html"><![CDATA[<p>📝指针(目录)::</p><!-- basicblock-end --><h1 id="1-智能指针"><a class="markdownIt-Anchor" href="#1-智能指针"></a> 1: [[智能指针]]</h1><h1 id="2-指针类型"><a class="markdownIt-Anchor" href="#2-指针类型"></a> 2: [[指针类型]]</h1><h1 id="3-数组名和指针这里为指向数组首元素的指针区别"><a class="markdownIt-Anchor" href="#3-数组名和指针这里为指向数组首元素的指针区别"></a> 3: [[数组名和指针（这里为指向数组首元素的指针）区别？]]</h1><h1 id="31-野指针和悬空指针"><a class="markdownIt-Anchor" href="#31-野指针和悬空指针"></a> [[31、野指针和悬空指针]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引用(目录)</title>
    <link href="/posts/26746/"/>
    <url>/posts/26746/</url>
    
    <content type="html"><![CDATA[<p>📝引用(目录)::</p><!-- basicblock-end --><p>引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</p><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1: 概念</h1><p>[[指针类型]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br>假设数组<span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]; <span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>] = &amp;a;其中：<br><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个<span class="hljs-type">int</span>类型的数组，这个数组大小是<span class="hljs-number">10</span>。<br><br>-   a是数组名，是数组首元素地址，+<span class="hljs-number">1</span>表示地址值加上一个<span class="hljs-type">int</span>类型的大小，<br>    - 如果a的值是<span class="hljs-number">0x00000001</span>，加<span class="hljs-number">1</span>操作后变为<span class="hljs-number">0x00000005</span>。*(a + <span class="hljs-number">1</span>) = a[<span class="hljs-number">1</span>]。<br>-   &amp;a是数组的指针，其类型为<span class="hljs-built_in">int</span> (*)[<span class="hljs-number">10</span>]（就是前面提到的数组指针），<br>    - 其加<span class="hljs-number">1</span>时，系统会认为是数组首地址加上整个数组的偏移（<span class="hljs-number">10</span>个<span class="hljs-type">int</span>型变量），值为数组a尾元素后一个元素的地址。<br><br>-   解引用: 若(<span class="hljs-type">int</span> *)p ，此时输出 *p时，其值为a[<span class="hljs-number">0</span>]的值，因为被转为<span class="hljs-type">int</span> *类型，解引用时按照<span class="hljs-type">int</span>类型大小来读取。<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-左右值引用目录"><a class="markdownIt-Anchor" href="#2-左右值引用目录"></a> 2: [[左右值引用(目录)]]</h1><h1 id="3-50-从汇编层去解释一下引用"><a class="markdownIt-Anchor" href="#3-50-从汇编层去解释一下引用"></a> 3: [[50、从汇编层去解释一下引用]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16、strlen和sizeof区别？</title>
    <link href="/posts/63970/"/>
    <url>/posts/63970/</url>
    
    <content type="html"><![CDATA[<p>📝16、strlen和sizeof区别？::</p><!-- basicblock-end --><ul><li><p>sizeof是运算符，并不是函数，结果在<strong>编译</strong>时得到而非运行中获得</p><ul><li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小</li></ul></li><li><p>strlen是字符处理的库函数。</p></li><li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；</p></li><li><p>strlen的参数只能是字符指针且结尾是’ <code>\0</code> '的<strong>字符串</strong>。</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span>{<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">"name"</span>;<br><br>    <span class="hljs-built_in">sizeof</span>(str); <span class="hljs-comment">// ❓ 取的是指针str的长度，是8</span><br>    <span class="hljs-built_in">strlen</span>(str); <span class="hljs-comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!tip] <strong>一个指针占多少字节？</strong><br>在上述中有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；<br>而在32位环境下，指针占用大小为4字节。<br>一个指针占内存的大小跟<strong>编译环境</strong>有关，而与机器的位数无关。<br>还有疑问的，可以自行打开Visual Studio编译器自己实验一番。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>define inline typedef</title>
    <link href="/posts/34551/"/>
    <url>/posts/34551/</url>
    
    <content type="html"><![CDATA[<p>📝define inline typedef::</p><!-- basicblock-end --><h1 id="1-define"><a class="markdownIt-Anchor" href="#1-define"></a> 1: [[define]]</h1><h1 id="2-define和inline的区别"><a class="markdownIt-Anchor" href="#2-define和inline的区别"></a> 2: [[define和inline的区别]]</h1><h1 id="3-define和typedef的区别"><a class="markdownIt-Anchor" href="#3-define和typedef的区别"></a> 3: [[define和typedef的区别]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13、宏定义和函数有何区别？</title>
    <link href="/posts/51828/"/>
    <url>/posts/51828/</url>
    
    <content type="html"><![CDATA[<p>📝13、宏定义和函数有何区别？::</p><!-- basicblock-end --><h1 id="1-define"><a class="markdownIt-Anchor" href="#1-define"></a> 1: [[define]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>malloc free 原理</title>
    <link href="/posts/29820/"/>
    <url>/posts/29820/</url>
    
    <content type="html"><![CDATA[<p>📝malloc free 原理::</p><!-- basicblock-end --><p>[[进程的地址空间分布.excalidraw]]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211290913640.svg" alt="|900"></p><p>1、<br>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由<strong>brk</strong>、<strong>mmap</strong>、<strong>munmap</strong>这些系统调用实现的;</p><p>2、<br>brk是将数据段(.data)的最高地址指针_edata往高地址推,<br>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。<br>这两种方式分配的都是虚拟内存，没有分配物理内存。<br>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p><p>3、<br>malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；<br>malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；<br>brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。<br>当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。<br>在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p><p>4、<br>malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。<br>操作系统中有一个记录空闲内存地址的链表。<br>当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p><h1 id="1-malloc"><a class="markdownIt-Anchor" href="#1-malloc"></a> 1: malloc</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>; <span class="hljs-comment">// 返回的是空指针</span><br><span class="hljs-comment">// 下面举个例子</span><br><span class="hljs-comment">//Student 一个学员的信息</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> //取别名</span><br><span class="hljs-class">{</span><br><span class="hljs-type">int</span> num:<br><span class="hljs-type">char</span> name [<span class="hljs-number">10</span>]；<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> *<span class="hljs-title">pnext</span>;</span><span class="hljs-comment">//指针</span><br>}STU; <br>STU* <span class="hljs-title function_">CreateList</span><span class="hljs-params">()</span>{<br>STU *P =(STU*) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(STU))：<span class="hljs-comment">//(STU*):强转, mallc 计算 STU 的长度给它 *P 分配一个空间</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1ee4y1D727?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">malloc函数，两分钟理解它，小白也能懂_哔哩哔哩_bilibili</a><br>delete 与 free的区别也就比较明显：<br>delete 不但释放内存,而且在释放内存之前会调用类的析构函数（当然必须要类的析构函数数存在）。<br>free不会报错，但是这只是释放内存，而不会析构对象</p><h1 id="2-free"><a class="markdownIt-Anchor" href="#2-free"></a> 2: free</h1><p>被free回收的内存不会立即返还给操作系统吗<br>被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。<br>这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p><h1 id="3-57-malloc-realloc-calloc的区别"><a class="markdownIt-Anchor" href="#3-57-malloc-realloc-calloc的区别"></a> 3: [[57、malloc、realloc、calloc的区别]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>new delete 原理</title>
    <link href="/posts/22343/"/>
    <url>/posts/22343/</url>
    
    <content type="html"><![CDATA[<p>new delete 原理::</p><!-- basicblock-end --><p>总结：<br>1.new做的事情，先申请一块地 再修房子<br>申请土地由<strong>malloc</strong>完成 修房子由<strong>构造函数</strong>完成</p><p>2.delete做的事情，先把房子销毁 再回收地<br>销段房子由<strong>析构函数</strong>完成回收地用<strong>free</strong>完成</p><blockquote><p>[!example]- new做的主要的3件事情</p></blockquote><p>1.先调用operator new() <code>里面有malloc函数</code><br>2.再调用构造函数<br>3.同时增加一个析构函数<br>![[new &amp; delete 概念.excalidraw]]</p><h1 id="1-new-原理"><a class="markdownIt-Anchor" href="#1-new-原理"></a> 1: new 原理</h1><p>简单类型直接调用operator new分配内存；<br>对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</p><p>对于简单类型，new[]计算好大小后调用operator new；</p><p>对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；</p><ul><li>new的实现过程是：<ul><li>首先调用一个名为<strong>operator new</strong>(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；</li><li>编译器运行相应的构造函数以构造这些对象，并为其传入初始值</li><li>最后返回指向新分配并构造后的的对象的<strong>具体类型指针</strong></li></ul></li></ul><h1 id="2-delete-原理"><a class="markdownIt-Anchor" href="#2-delete-原理"></a> 2: delete 原理</h1><ul><li><p>简单数据类型默认只是调用free函数；</p><ul><li>针对简单类型，delete和delete[]等同。</li></ul></li><li><p>复杂数据类型先调用析构函数再调用operator delete；</p></li><li><p>实现过程：</p><ul><li>对指针指向的对象运行适当的析构函数；</li><li>然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存</li></ul></li></ul><p>假设指针p指向new[]分配的内存。<br>因为要4字节存储数组大小，实际分配的内存地址为[p-4]，<strong>系统记录的也是这个地址</strong>。<code>delete[]</code>实际释放的就是[p-4]指向的内存。<br>而<code>delete</code>会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</p><h2 id="21-delete是如何知道释放内存的大小的"><a class="markdownIt-Anchor" href="#21-delete是如何知道释放内存的大小的"></a> 2.1: delete是如何知道释放内存的大小的？</h2><p>需要在 new [] 一个对象数组时，需要保存数组的维度，<br>C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，<br>在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p><h1 id="3-例子"><a class="markdownIt-Anchor" href="#3-例子"></a> 3: 例子</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span> (<span class="hljs-number">0</span>);<br>---<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span>{ <span class="hljs-comment">// 构造函数</span><br>age = <span class="hljs-number">10</span><br>}<br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>(){<br><span class="hljs-comment">// 💡new 构造函数</span><br>ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span> (<span class="hljs-number">0</span>); <span class="hljs-comment">// dummyHead 初始化为 0</span><br>A* pa = <span class="hljs-keyword">new</span> A; <span class="hljs-comment">// 会调用构造函数 A ; 初始值 pa = 10</span><br>A* pa2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(); <span class="hljs-comment">// 会调用构造函数 A ; 初始值 pa = 10</span><br><br><br><span class="hljs-comment">// new int</span><br><span class="hljs-type">int</span>* p1 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;      <span class="hljs-comment">//  1.直接new int,给随机值</span><br><span class="hljs-type">int</span>* p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> <span class="hljs-number">0</span>；   <span class="hljs-comment">//  2.new int()给初始值0</span><br><span class="hljs-type">int</span>* p3 =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (<span class="hljs-number">100</span>);<span class="hljs-comment">//  3.new int(100)给初始值100</span><br><br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8、new  delete 与 malloc  free的异同</title>
    <link href="/posts/21493/"/>
    <url>/posts/21493/</url>
    
    <content type="html"><![CDATA[<p>📝8、new  delete 与 malloc  free的异同::</p><!-- basicblock-end --><blockquote><p>[!参考资料]<br>[[new delete &amp; malloc free 目录]]<br><a href="https://www.bilibili.com/video/BV1vg41197B8?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++ new和malloc区别_哔哩哔哩_bilibili</a></p></blockquote><h1 id="1-四者的异同"><a class="markdownIt-Anchor" href="#1-四者的异同"></a> 1: 四者的异同</h1><p><strong>相同点</strong></p><ul><li>都可用于内存的动态申请和释放</li></ul><p><strong>不同点</strong></p><ul><li><p>New /delete是C<ins>运算符，Malloc/free是C/C</ins>语言标准库函数</p></li><li><p>new自动计算要分配的空间大小，malloc需要手工计算</p></li><li><p>new是类型安全的，malloc不是。例如：</p><ul><li>(malloc 类型转换成 int, 分配double 数据类型大小的内存空间不会报错）</li><li>(new一个 int 类型指针指向 float 会报错）</li></ul></li><li><p>new调用名为<strong>operator new</strong>的标准库函数分配足够空间并<code>调用</code>相关对象的<strong>构造函数</strong>，</p><ul><li>new是封装了malloc</li></ul></li><li><p>malloc 与 free均没有相关 <code>调用</code></p></li><li><p>malloc 与 free需要库文件支持，new delete不用</p></li><li></li><li><p>opeartor new/operator delete可以被重载，而malloc/free并不允许重载。</p></li><li><p>使用new操作符申请内存分配时无须指定内存块的大小，而malloc则需要显式地指出所需内存的尺寸eg : <code>malloc(sizeof(int))</code>。</p></li><li><p>new操作符<strong>从自由存储区</strong>上为对象动态分配内存空间，而malloc函数从<strong>堆上</strong>动态分配内存。</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[<span class="hljs-number">2</span>]; <span class="hljs-comment">//编译错误</span><br><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>));<span class="hljs-comment">//编译无错误</span><br></code></pre></td></tr></tbody></table></figure><p>![[New 与 Malloc的区别.excalidraw]]</p><h1 id="2-两者的异同"><a class="markdownIt-Anchor" href="#2-两者的异同"></a> 2: 两者的异同</h1><h2 id="21-malloc和new的区别"><a class="markdownIt-Anchor" href="#21-malloc和new的区别"></a> 2.1: [[malloc和new的区别？]]</h2><h2 id="22"><a class="markdownIt-Anchor" href="#22"></a> 2.2:</h2><ul><li>delete对指针所指对象运行适当的<strong>1️⃣析构函数</strong>；然后通过 <code>调用</code> 名为<strong>2️⃣operator delete</strong>的标准库函数释放该对象所用内存。<ul><li>cite delete 不但释放内存,而且在释放内存之前会调用类的析构函数（当然必须要类的析构函数数存在</li><li>free只是释放内存，而不会析构对象</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指针类型</title>
    <link href="/posts/19066/"/>
    <url>/posts/19066/</url>
    
    <content type="html"><![CDATA[<p>📝7、区别以下指针类型？::</p><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>]<br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>]<br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-params">(*p)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">-   <span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>]表示指针数组，强调数组概念，是一个数组变量，数组大小为<span class="hljs-number">10</span>，数组内每个元素都是指向<span class="hljs-type">int</span>类型的指针变量。<br>    <br>-   <span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个<span class="hljs-type">int</span>类型的数组，这个数组大小是<span class="hljs-number">10</span>。<br>    <br>-   <span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>是函数声明，函数名是p，参数是<span class="hljs-type">int</span>类型的，返回值是<span class="hljs-type">int</span> *类型的。</span><br><span class="hljs-function">    </span><br><span class="hljs-function">-   <span class="hljs-title">int</span> <span class="hljs-params">(*p)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>是函数指针，强调是指针，该指针指向的函数具有<span class="hljs-type">int</span>类型参数，并且返回值是<span class="hljs-type">int</span>类型的。</span><br><span class="hljs-function">    </span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>路径总和ii</title>
    <link href="/posts/47844/"/>
    <url>/posts/47844/</url>
    
    <content type="html"><![CDATA[<p>📝路径总和ii::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/path-sum-ii/">力扣题目链接</a></p><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明:&nbsp;叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和&nbsp;sum = 22，</p><p><img src="https://img-blog.csdnimg.cn/20210203160854654.png" alt="113.路径总和ii1.png"></p><h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1: 思路</h1><p>113.路径总和ii要遍历整个树，找到所有路径，<strong>所以递归函数不要返回值！</strong></p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210203160922745.png" alt="113.路径总和ii"></p><p>为了尽可能的把细节体现出来，我写出如下代码（<strong>这份代码并不简洁，但是逻辑非常清晰</strong>）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">// 递归函数不需要返回值，因为我们要遍历整个树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 遇到了叶子节点且找到了和为sum的路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br><span class="hljs-comment">// 💡回溯的操作有两个: path 路径的 pop, count 值的加回来</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;left-&gt;val);<br>            count -= cur-&gt;left-&gt;val;        <span class="hljs-comment">// 💡递归操作多了一个</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, count);    <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;left-&gt;val;        <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯, 💡就多了这个</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;right-&gt;val);<br>            count -= cur-&gt;right-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, count);   <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;right-&gt;val;       <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathsum</span>(treenode* root, <span class="hljs-type">int</span> sum) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> result;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 把根节点放进路径</span><br>        <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>至于113. 路径总和ii 的迭代法我并没有写，用迭代方式记录所有路径比较麻烦，也没有必要，如果大家感兴趣的话，可以再深入研究研究。<br>[[15. 二叉树中递归带着回溯]]</p><p>v2: 未通过, 错误在❗️处, 不懂怎么解决</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* node, <span class="hljs-type">int</span> count,  vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// ❗️不懂, 调试显示操作空指针了, 但是下面明明让空指针不进入循环了</span><br>        <span class="hljs-keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; count == node-&gt;val){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>        }<br><br>        <span class="hljs-keyword">if</span>(node-&gt;left){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;left, count - node-&gt;val, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>        <span class="hljs-keyword">if</span>(node-&gt;right){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;right, count - node-&gt;val, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br><br>    }<br><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> targetSum) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">getPath</span>(root, targetSum, path, result);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>34. 二叉树中和为某一值的路径</title>
    <link href="/posts/50133/"/>
    <url>/posts/50133/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!question]<br>📝34. 二叉树中和为某一值的路径:: <a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">Loading Question… - 力扣（LeetCode）</a> ::   #疑问</p></blockquote><!-- basicblock-end --><p>[[路径总和ii]]</p><p>没有写, 下次再写吧</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-built_in">recur</span>(root, target);<br>        <span class="hljs-keyword">return</span> res;<br>    }<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> tar)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        tar -= root-&gt;val;<span class="hljs-comment">// 每次相当于不同的 tar 不需要再进行tar += root-&gt;val;</span><br>        <span class="hljs-keyword">if</span> (tar == <span class="hljs-number">0</span> &amp;&amp; root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) {<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        }<br>        <br>        <span class="hljs-built_in">recur</span>(root-&gt;left, tar);<br>        <span class="hljs-built_in">recur</span>(root-&gt;right, tar);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        tar += root-&gt;val; <span class="hljs-comment">// 为什么有或者没有这一行都可以通过</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[递归解题方法]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐概念</title>
    <link href="/posts/1367/"/>
    <url>/posts/1367/</url>
    
    <content type="html"><![CDATA[<p>📝内存对齐概念::</p><!-- basicblock-end --><p>![[内存对齐.excalidraw]]</p><ul><li>内存对齐:  <strong>一次寻址</strong><br>一字节的char占用了四个字节，空了三个字节的内存地址，int数据从地址4开始。<br>此时，直接将地址4，5，6，7处的四个字节数据读取到即可<br>^9987ae</li><li>非内存对齐 : <strong>两次寻址，一次合并</strong><br>char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：<ol><li>因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据</li><li>CPU读取4，5，6，7处的四个字节数据</li></ol></li></ul><p><strong>总结:</strong><br>虽然浪费内存,但是内存资源一般都是充足的,我们更希望提升运行速度<br><strong>编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响</strong>。</p><p>例子</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// char 一字节, int 四字节</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>{</span><br>   <span class="hljs-type">int</span> num;<br>   <span class="hljs-type">char</span> cha;<br>}st;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span> b[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 4</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 400</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(b) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 100</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(st) &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 因为内存对齐,整个类的内存占用为 8 字节</span><br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6、你觉得堆快一点还是栈快一点？</title>
    <link href="/posts/55857/"/>
    <url>/posts/55857/</url>
    
    <content type="html"><![CDATA[<p>📝6、你觉得堆快一点还是栈快一点？::</p><!-- basicblock-end --><p>毫无疑问是栈快一点。<br>因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p><p>而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。<br>并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆与栈(内存方面(🗃))</title>
    <link href="/posts/23817/"/>
    <url>/posts/23817/</url>
    
    <content type="html"><![CDATA[<p>#🗃️<br>📝堆与栈目录::</p><!-- basicblock-end --><h1 id="1-5-堆和栈的区别"><a class="markdownIt-Anchor" href="#1-5-堆和栈的区别"></a> 1: [[5、堆和栈的区别]]</h1><h1 id="2-6-你觉得堆快一点还是栈快一点"><a class="markdownIt-Anchor" href="#2-6-你觉得堆快一点还是栈快一点"></a> 2: [[6、你觉得堆快一点还是栈快一点？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>🗃️</tag>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5、堆和栈的区别</title>
    <link href="/posts/9526/"/>
    <url>/posts/9526/</url>
    
    <content type="html"><![CDATA[<p>📝5、堆和栈的区别::</p><!-- basicblock-end --><p>[[堆与栈(内存方面(🗃))]]</p><blockquote><p>[!tip] <strong>形象的比喻</strong></p><ul><li>栈就像我们去饭馆里吃饭，只管点菜（发出申请）<ul><li>付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，</li><li>他的好处是快捷，但是自由度小。</li></ul></li><li>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</li></ul></blockquote><p>栈空间默认是4M, 堆区一般是 1G - 4G</p><ul><li><p>申请方式不同。</p><ul><li>栈由系统自动分配。</li><li>堆是自己申请和释放的。</li></ul></li><li><p>申请大小限制不同。</p><ul><li>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li><li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li></ul></li><li><p>申请效率不同。</p><ul><li>栈由系统分配，速度快，不会有碎片。</li><li>堆由程序员分配，速度慢，且会有碎片。</li></ul></li></ul><p>![[堆和栈的区别.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</title>
    <link href="/posts/28252/"/>
    <url>/posts/28252/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!question]<br>📝4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？::   #疑问</p></blockquote><!-- basicblock-end --><ul><li><p>需要返回函数内<strong>局部变量的内存</strong>的时候用指针。</p><ul><li>使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。</li><li>而返回局部变量的引用是没有意义的</li></ul></li><li><p>对栈空间大小比较敏感（比如递归）的时候使用引用,</p><ul><li>eg: <code>dfs(.., ..., vector&lt;int&gt; &amp; vec)</code><ul><li>使用引用传递不需要创建临时变量，开销要更小, 💡避免了参数的复制, 运行速度更快</li></ul></li></ul></li><li><p>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3、指针和引用的区别</title>
    <link href="/posts/51757/"/>
    <url>/posts/51757/</url>
    
    <content type="html"><![CDATA[<p>📝3、指针和引用的区别::</p><!-- basicblock-end --><ul><li><p>指针是一个变量，存储的是某个对象的一个地址;</p></li><li><p>引用跟原来的变量实质上是同一个东西，是原变量的别名</p></li><li></li><li><p>指针可以有多级，引用只有一级</p><ul><li>指针本身就有地址，所以可以有指向指针的指针</li></ul></li><li></li><li><p>指针可以为空，引用不能为NULL且在定义时必须初始化</p><ul><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul></li><li><p>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</p></li><li><p>✅当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</p></li><li><p>tip  引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。</p><ul><li>✅其本身就是变量（命了名的对象</li></ul></li><li><p>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</p></li><li></li><li><p><strong>引用一旦初始化之后就不可以再改变</strong>（变量可以被引用为多次，但引用只能作为一个变量引用）；</p></li><li><p>指针变量可以重新指向别的变量。</p><ul><li>指针在初始化后所<strong>指向的地址</strong>和其指向的<strong>地址中所存放的数据</strong>, 都可以改变，而引用在初始化之后不可再改变</li></ul></li></ul><p>[[const 关键字]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span><br><span class="hljs-function"></span>{<br>　　<span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>　　p=&amp;a;<br>　　cout&lt;&lt;p&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;*p&lt;&lt;endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> *p=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">test</span>(p); <br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>    cout&lt;&lt;<span class="hljs-string">"指针p为NULL"</span>&lt;&lt;endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><span class="hljs-comment">//main运行结果为：</span><br><span class="hljs-comment">//0x22ff44 1 : 进入了 test</span><br><span class="hljs-comment">//指针p为NULL, 因为变量 a 被析构了, 所以 p 又为 NULL 了</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testPTR</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>{<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br>p = &amp;a;<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testREFF</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; p)</span> </span>{<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br>p = a;<br><br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* b = &amp;a;<br><span class="hljs-built_in">testPTR</span>(b);<span class="hljs-comment">//❓改变指针指向，但是没改变指针的所指的内容</span><br>cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">// 10</span><br>cout &lt;&lt; *b &lt;&lt; endl;<span class="hljs-comment">// 10</span><br><br>a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">testREFF</span>(a);<br>cout &lt;&lt; a &lt;&lt; endl;<span class="hljs-comment">//12</span><br>}<br>在编译器看来, <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-type">int</span> &amp;b = a; 等价于 <span class="hljs-type">int</span> * <span class="hljs-type">const</span> b = &amp;a; <br>而 b = <span class="hljs-number">20</span>; 等价于 * b = <span class="hljs-number">20</span>; 自动转换为指针和自动解引用.<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存对齐</title>
    <link href="/posts/17743/"/>
    <url>/posts/17743/</url>
    
    <content type="html"><![CDATA[<p>📝内存对齐::</p><!-- basicblock-end --><h1 id="1-内存对齐概念"><a class="markdownIt-Anchor" href="#1-内存对齐概念"></a> 1: [[内存对齐概念]]</h1><h1 id="2-2-结构体内存对齐问题"><a class="markdownIt-Anchor" href="#2-2-结构体内存对齐问题"></a> 2: [[2、结构体内存对齐问题？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2、结构体内存对齐问题？</title>
    <link href="/posts/49540/"/>
    <url>/posts/49540/</url>
    
    <content type="html"><![CDATA[<p>📝2、结构体内存对齐问题？::</p><!-- basicblock-end --><h1 id="1-总结"><a class="markdownIt-Anchor" href="#1-总结"></a> 1: 总结</h1><blockquote><p>[!summary]</p><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li></ul></blockquote><h1 id="2-两个关键字"><a class="markdownIt-Anchor" href="#2-两个关键字"></a> 2: 两个关键字</h1><p>c++11以后引入两个关键字 <a href="https://zh.cppreference.com/w/cpp/language/alignas">alignas</a> 与 <a href="https://zh.cppreference.com/w/cpp/language/alignof">alignof</a>。<br><code>alignof</code> 可以<strong>计算</strong>出类型的对齐方式，<br><code>alignas</code>可以<strong>指定</strong>结构体的对齐方式。</p><p>但是<code>alignas</code>在某些情况下是不能使用的，具体见下面的例子:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// alignas 生效的情况, `alignas`可以指定结构体的对齐方式</span><br><br><span class="hljs-comment">// before</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> {<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint16_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>};<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 6  2 + 2 + 2, </span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 2,💡 `alignof` 可以计算出类型的对齐方式</span><br><br><br><span class="hljs-comment">// after</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">4</span>) Info2 {<span class="hljs-comment">// `alignas`可以指定结构体的对齐方式</span><br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint16_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>};<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 8  4 + 4, 💡`alignas`将内存对齐调整为4个字节。所以`sizeof(Info2)`的值变为了8。</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 4, 💡`alignof` 可以计算出类型的对齐方式</span><br></code></pre></td></tr></tbody></table></figure><p>若 <code>alignas</code> 小于自然对齐的最小单位，则被忽略。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// alignas 失效的情况</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> {<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>};<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 12  4 + 4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 4</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">2</span>) Info2 { <span class="hljs-comment">// 被忽略</span><br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>### };<br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="hljs-comment">// 12  4 + 4 + 4</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="hljs-comment">// 4 💡因为最小的字节是4, 而指定的是 2 所以被忽略了</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-其他question"><a class="markdownIt-Anchor" href="#3-其他question"></a> 3: 其他question</h1><ul><li>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code>。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> {<br>  <span class="hljs-type">uint8_t</span> a;<br>  <span class="hljs-type">uint32_t</span> b;<br>  <span class="hljs-type">uint8_t</span> c;<br>} ONEBYTE_ALIGN;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 6 1 + 4 + 1</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 6</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!question] 确定结构体中每个元素大小可以通过下面这种方法 #疑问</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> ONEBYTE_ALIGN</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(push,1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 0 1   3     6   8 9            15</span><br><span class="hljs-comment">* +-+---+-----+---+-+-------------+</span><br><span class="hljs-comment">* | |   |     |   | |             |</span><br><span class="hljs-comment">* |a| b |  c  | d |e|     pad     |</span><br><span class="hljs-comment">* | |   |     |   | |             |</span><br><span class="hljs-comment">* +-+---+-----+---+-+-------------+</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> {<br>  <span class="hljs-type">uint16_t</span> a : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">uint16_t</span> b : <span class="hljs-number">2</span>;<br>  <span class="hljs-type">uint16_t</span> c : <span class="hljs-number">3</span>;<br>  <span class="hljs-type">uint16_t</span> d : <span class="hljs-number">2</span>;<br>  <span class="hljs-type">uint16_t</span> e : <span class="hljs-number">1</span>;<br>  <span class="hljs-type">uint16_t</span> pad : <span class="hljs-number">7</span>;<br>} ONEBYTE_ALIGN;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_MSC_VER)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(pop)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ONEBYTE_ALIGN</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="hljs-comment">// 2</span><br>std::cout &lt;&lt; <span class="hljs-built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></tbody></table></figure><p>这种处理方式是 <code>alignas</code> 处理不了的。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1、 在main执行之前和之后执行的代码可能是什么？</title>
    <link href="/posts/3371/"/>
    <url>/posts/3371/</url>
    
    <content type="html"><![CDATA[<p>📝1、 在main执行之前和之后执行的代码可能是什么？::</p><!-- basicblock-end --><p>![[进程的地址空间分布.excalidraw]]</p><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量<strong>赋初值</strong>：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li><code>__attribute__((constructor))</code></li></ul><p><strong>main函数执行之后</strong>：</p><ul><li>全局对象的析构函数会在main函数之后执行；</li><li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;</li><li><code>__attribute__((destructor))</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>阿秀</category>
      
      <category>01-20 基础语法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译与链接</title>
    <link href="/posts/4282/"/>
    <url>/posts/4282/</url>
    
    <content type="html"><![CDATA[<p>📝编译与链接::</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>选择排序, 冒泡排序, 插入排序</title>
    <link href="/posts/58412/"/>
    <url>/posts/58412/</url>
    
    <content type="html"><![CDATA[<p>📝选择排序, 冒泡排序, 插入排序::</p><!-- basicblock-end --><p>‌‌‌　　![[选择排序.excalidraw]]</p><p>‌‌‌　　![[冒泡排序.excalidraw]]</p><p>‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　![[插入排序.excalidraw]]</p><p>![[其他排序 2022-11-21 19.58.14.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法目录</title>
    <link href="/posts/22819/"/>
    <url>/posts/22819/</url>
    
    <content type="html"><![CDATA[<p>📝排序算法目录::</p><!-- basicblock-end --><h1 id="1-选择排序-冒泡排序-插入排序"><a class="markdownIt-Anchor" href="#1-选择排序-冒泡排序-插入排序"></a> 1: [[选择排序, 冒泡排序, 插入排序]]</h1><h1 id="2-归并排序"><a class="markdownIt-Anchor" href="#2-归并排序"></a> 2: [[归并排序]]</h1><h1 id="3-快速排序"><a class="markdownIt-Anchor" href="#3-快速排序"></a> 3: [[快速排序]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/posts/63712/"/>
    <url>/posts/63712/</url>
    
    <content type="html"><![CDATA[<p>📝归并排序::</p><!-- basicblock-end --><p>‌‌‌　　![[归并排序.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/posts/11307/"/>
    <url>/posts/11307/</url>
    
    <content type="html"><![CDATA[<p>📝快速排序::<br><a href="https://www.bilibili.com/video/BV19S4y187Rt/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">6-2 partition_哔哩哔哩_bilibili</a><br><a href="https://www.bilibili.com/video/BV1rV411j7f6/?spm_id_from=333.999.0.0&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">【排序算法精华3】快速排序 (上）_哔哩哔哩_bilibili</a></p><!-- basicblock-end --><p>![[快速排序 2022-11-21 17.41.53.excalidraw]]</p><h1 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h1><p>[[40. 最小的k个数]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣递归</title>
    <link href="/posts/33043/"/>
    <url>/posts/33043/</url>
    
    <content type="html"><![CDATA[<p>📝力扣递归::<a href="https://leetcode.cn/leetbook/read/di-gui-yu-fen-zhi/wrxzci/">登录/注册 - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-递归与分治的理论及进阶"><a class="markdownIt-Anchor" href="#1-递归与分治的理论及进阶"></a> 1: 递归与分治的理论及进阶</h1><p>‌‌‌　　![[递归与分治.excalidraw]]</p><p>递归函数的要点：<br>递归的终止条件<br>递归的内在逻辑</p><p>递归：在函数定义中使用自身的方法<br>分治：“分而治之”，把大问题分成小问题的一种思想</p><ul><li>递归与分治：<ul><li>先「自顶向下」拆分问题,直到不能拆分为止</li><li>再「自底向上」逐层把底层的结果向上汇报,直到得到原问题的解</li></ul></li></ul><p>[[10.斐波那契数列]]</p><p>[[16.数值的整数次方]]</p><h1 id="2-数组中的递归"><a class="markdownIt-Anchor" href="#2-数组中的递归"></a> 2: 数组中的递归</h1><h2 id="21-数组排序"><a class="markdownIt-Anchor" href="#21-数组排序"></a> 2.1: 数组排序</h2><p>![[数组中的递归.excalidraw]]</p><p>[[快速排序]]</p><h1 id="3-二叉树递归"><a class="markdownIt-Anchor" href="#3-二叉树递归"></a> 3: 二叉树递归</h1><p>‌‌‌　　![[力扣递归 - 二叉树递归 .excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>33.二叉搜索树的后序遍历序列</title>
    <link href="/posts/55519/"/>
    <url>/posts/55519/</url>
    
    <content type="html"><![CDATA[<p>📝33.二叉搜索树的后序遍历序列::<a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>![[33.二叉搜索树的后序遍历序列 2022-11-21 11.11.58.excalidraw]]</p><h1 id="1-递归解析"><a class="markdownIt-Anchor" href="#1-递归解析"></a> 1: 递归解析</h1><ul><li><code>定义 l = 0; r = postorder.size() - 1</code></li><li><strong>终止条件：</strong> 当 l≥r ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 true ；</li><li><strong>递推工作：</strong><ul><li><ol><li><strong>划分左右子树：</strong> 遍历后序遍历的 [l,r] 区间元素，寻找 <strong>第一个大于根节点</strong> 的节点，索引记为 i 。</li></ol><ul><li>可划分出左子树区间 [l,i−1] 、</li><li>右子树区间 [i,r] 、根节点索引 r 。</li></ul></li><li><ol start="2"><li><strong>判断是否为二叉搜索树</strong>：</li></ol><ul><li><strong>左子树区间</strong> [l,i−1] 内的所有节点都应 &lt; postorder[r] 。而第 <code>1.划分左右子树</code> 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</li><li><strong>右子树区间</strong> [i,r] 内的所有节点都应 &gt; postorder[r] 。实现方式为遍历，当遇到 ≤postorder[r] 的节点则跳出；则可通过 p=r 判断是否为二叉搜索树。</li></ul></li></ul></li><li><strong>返回值：</strong> 所有子树都需正确才可判定正确，因此使用 <strong>与逻辑符</strong> &amp;&amp; 连接。<ul><li><ol><li><strong>p=r ：</strong> 判断 <strong>此树</strong> 是否正确。</li></ol></li><li><ol start="2"><li><strong>recur(l,i−1) ：</strong> 判断 <strong>此树的左子树</strong> 是否正确。</li></ol></li><li><ol start="3"><li><strong>recur(i,r−1) ：</strong> 判断 <strong>此树的右子树</strong> 是否正确。</li></ol></li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">verifyPostorder</span>(postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>{<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 判断长度为 1, ❗️不能== ,因为下边l, r 有变化</span><br><br>        <span class="hljs-type">int</span> i;<span class="hljs-comment">// 获取第一个小于根节点的下标: 即左子树的结束下标</span><br>        <span class="hljs-keyword">for</span>(i = r; i &gt;= l; i--){<br>            <span class="hljs-keyword">if</span>(postorder[i] &lt; postorder[r]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 发现那个数比根节点小了则退出: 即左子树的结束下标</span><br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &gt;= l; j--){ <span class="hljs-comment">// ❗️j&gt;= l</span><br>            <span class="hljs-keyword">if</span>(postorder[j] &gt; postorder[r]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">verifyPostorder</span>(postorder, l, i) &amp;&amp; <span class="hljs-built_in">verifyPostorder</span>(postorder, i+<span class="hljs-number">1</span>, r<span class="hljs-number">-1</span>);        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[递归解题方法]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>连接器</title>
    <link href="/posts/13757/"/>
    <url>/posts/13757/</url>
    
    <content type="html"><![CDATA[<p>📝连接器::</p><!-- basicblock-end --><h1 id="1-管理连接"><a class="markdownIt-Anchor" href="#1-管理连接"></a> 1: 管理连接</h1><p>连接器-&gt;连接到数据库</p><blockquote><p>[!summary] 第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。<br>连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql -h $ip -P$ port -u$user -p<br></code></pre></td></tr></tbody></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><h1 id="2-权限验证"><a class="markdownIt-Anchor" href="#2-权限验证"></a> 2: 权限验证</h1><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的<strong>TCP握手</strong>后，连接器 就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面 的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211201714468.png" alt=""></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <code>Lost connection to MySQL server during query</code>。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>-&gt; [[长连接&amp;短连接]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>MySQL 45 讲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>执行器</title>
    <link href="/posts/56327/"/>
    <url>/posts/56327/</url>
    
    <content type="html"><![CDATA[<p>📝执行器::</p><!-- basicblock-end --><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。<br>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有 权限的错误，如下所示。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; select * from T where ID=10;<br><br>ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'<br></code></pre></td></tr></tbody></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><h1 id="1-操作引擎-返回结果"><a class="markdownIt-Anchor" href="#1-操作引擎-返回结果"></a> 1: 操作引擎, 返回结果</h1><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>对于有索引的表，执行的逻辑也差不多。<br>第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口<br>这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。</p><blockquote><p>[!note]  <code>rows_examined</code> 就是在执行器每次调用引擎获取数据行的时候累加值。</p></blockquote><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined并不是完全相同的。<br>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>MySQL 45 讲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>优化器</title>
    <link href="/posts/38842/"/>
    <url>/posts/38842/</url>
    
    <content type="html"><![CDATA[<p>📝优化器::</p><!-- basicblock-end --><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><h1 id="1-索引选择"><a class="markdownIt-Anchor" href="#1-索引选择"></a> 1: 索引选择</h1><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；<br>或者在一个语句有多表关联（join） 的时候，决定各个表的连接顺序。<br>比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;<br></code></pre></td></tr></tbody></table></figure><ul><li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否 等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，<strong>而优化器的作用就是决定选择使用哪一个方案</strong>。<br>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。<br>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>MySQL 45 讲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分析器</title>
    <link href="/posts/23025/"/>
    <url>/posts/23025/</url>
    
    <content type="html"><![CDATA[<p>📝分析器::</p><!-- basicblock-end --><p>如果没有命中查询缓存，就要开始真正执行语句了。<br>首先，MySQL需要知道你要做什么，因此 需要对SQL语句做解析。</p><h1 id="1-词法分析"><a class="markdownIt-Anchor" href="#1-词法分析"></a> 1: 词法分析</h1><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><ul><li>example MySQL从你输入的"select"这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</li></ul><h1 id="2-语法分析"><a class="markdownIt-Anchor" href="#2-语法分析"></a> 2: 语法分析</h1><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个 语句select少打了开头的字母“s”。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; elect * from t where ID=1;<br><br>ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to ....<br></code></pre></td></tr></tbody></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“<code>use near</code>”的内容。<br>这个报错信息不全, 估计因为这个原因没有 <code>use near</code></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>MySQL 45 讲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查询缓存</title>
    <link href="/posts/306/"/>
    <url>/posts/306/</url>
    
    <content type="html"><![CDATA[<p>📝查询缓存::</p><!-- basicblock-end --><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p><h1 id="1-简介-命中则直接返回结果"><a class="markdownIt-Anchor" href="#1-简介-命中则直接返回结果"></a> 1: 简介: 命中则直接返回结果</h1><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。<br>之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。</p><p>key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客 户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。<br>执行完成后，执行结果会被存入查询缓存中。<br>你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结 果，这个效率会很高。</p><h1 id="2-建议"><a class="markdownIt-Anchor" href="#2-建议"></a> 2: 建议</h1><p>但是大多数情况下我会建议你<strong>不要使用查询缓存</strong>，为什么呢？因为查询缓存往往弊大于利。</p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。<br>因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。<br>对于更新压力大的数据库来说，<strong>查询缓存的命中率会非常低</strong>。<br>除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数<code>query_cache_type</code>设置成<br><code>DEMAND</code>，这样对于默认的SQL语句都不使用查询缓存。<br>而对于你确定要使用查询缓存的语 句，可以用<code>SQL_CACHE</code>显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysql&gt; select SQL_CACHE * from T where ID=10；<br></code></pre></td></tr></tbody></table></figure><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>MySQL 45 讲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>长连接&amp;短连接</title>
    <link href="/posts/20455/"/>
    <url>/posts/20455/</url>
    
    <content type="html"><![CDATA[<p>📝长连接&amp;短连接::</p><!-- basicblock-end --><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1: 定义</h1><ul><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li><li>短连接 则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ul><h1 id="2-建议"><a class="markdownIt-Anchor" href="#2-建议"></a> 2: 建议</h1><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是<strong>尽量使用长连接</strong>。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，<br>这是因为 MySQL在执行过程中<strong>临时使用的内存是管理在连接对象里面的</strong>。</p><p><strong>这些资源会在连接断开的时候才释放</strong>。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><h1 id="3-解决"><a class="markdownIt-Anchor" href="#3-解决"></a> 3: 解决</h1><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><h2 id="31-定期断开长连接"><a class="markdownIt-Anchor" href="#31-定期断开长连接"></a> 3.1: 定期断开长连接。</h2><p>使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开 连接，之后要查询再重连。</p><h2 id="32-重新初始化连接资源"><a class="markdownIt-Anchor" href="#32-重新初始化连接资源"></a> 3.2: 重新初始化连接资源</h2><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来<strong>重新初始化连接资源</strong>。</p><blockquote><p>[!note] 这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>MySQL 45 讲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01.基础架构：一条SQL查询语句是如何执行的？</title>
    <link href="/posts/35394/"/>
    <url>/posts/35394/</url>
    
    <content type="html"><![CDATA[<p>📝01.服务层：一条SQL查询语句是如何执行的？::</p><!-- basicblock-end --><p>![[MySQL 整体架构图.excalidraw]]</p><p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p><blockquote><p>[!summary] Server层包括连接器、查询缓存、分析器、优化器、执行器等，</p><ul><li>涵盖MySQL的大多数核心服务功能</li><li>所有的内置函数（如日期、时间、数学和加密函数等）</li><li>所有跨存储引擎的功能都在这一层实现<ul><li>比如存储过程、触发器、视图等。</li></ul></li></ul></blockquote><p>不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。<br>接下来我会结合<code>select * from T where ID=10</code>；带你走一遍整个执行流程，依次看下每个组件的作用。</p><p>Server层按顺序执行sql的步骤为：</p><ol><li>客户端请求-&gt;</li><li>连接器（验证用户身份，给予权限） -&gt;</li><li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li><li>分析器（对SQL进行词法分析和语法分析操作） -&gt;</li><li>优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt;</li><li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</li><li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li></ol><p>简单概括：</p><ul><li><strong>连接器</strong>：管理连接权限验证；</li><li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li><li><strong>分析器</strong>：对SQL进行词法分析语法分析；（判断查询的SQL字段是否存在也是在这步）</li><li><strong>优化器</strong>：执行计划生成选择索引；</li><li><strong>执行器</strong>：操作引擎返回结果；</li><li><strong>存储引擎</strong>：存储数据提供读写接口。</li></ul><h1 id="1-连接器"><a class="markdownIt-Anchor" href="#1-连接器"></a> 1: [[连接器]]</h1><h1 id="2-查询缓存"><a class="markdownIt-Anchor" href="#2-查询缓存"></a> 2: [[查询缓存]]</h1><h1 id="3-分析器"><a class="markdownIt-Anchor" href="#3-分析器"></a> 3: [[分析器]]</h1><h1 id="4-优化器"><a class="markdownIt-Anchor" href="#4-优化器"></a> 4: [[优化器]]</h1><h1 id="5-执行器"><a class="markdownIt-Anchor" href="#5-执行器"></a> 5: [[执行器]]</h1><h1 id="6-小结"><a class="markdownIt-Anchor" href="#6-小结"></a> 6: 小结</h1><p>今天我给你介绍了MySQL的逻辑架构，希望你对一个SQL语句完整执行流程的各个阶段有了一 个初步的印象。由于篇幅的限制，我只是用一个查询的例子将各个环节过了一遍。如果你还对每 个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。</p><p>我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？-&gt; [[分析器]]</p><p>感谢你的收听，欢迎你给我留言，也欢迎分享给更多的朋友一起阅读。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汉诺塔问题</title>
    <link href="/posts/59458/"/>
    <url>/posts/59458/</url>
    
    <content type="html"><![CDATA[<p>📝汉诺塔问题::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/hanota-lcci/">面试题 08.06. 汉诺塔问题 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 递归经典问题</span><br><span class="hljs-comment">// 递归经典问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hanota</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C)</span> </span>{<br>        <span class="hljs-type">int</span> n = A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">move</span>(n, A, B, C);<br>    }<br>    <span class="hljs-comment">// 自定义函数: 移动 A 的 n 个元素到 C 上</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-comment">// 基本情况: 只有一个元素的时候</span><br>        {<br>            C.<span class="hljs-built_in">push_back</span>(A.<span class="hljs-built_in">back</span>());<span class="hljs-comment">// ❗️不可以是 front()</span><br>            A.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 删除最后一个元素</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-built_in">move</span>(n - <span class="hljs-number">1</span>, A, C, B); <span class="hljs-comment">// A 中移动n-1个盘子到B</span><br>        <span class="hljs-built_in">move</span>(<span class="hljs-number">1</span>, A, B, C);     <span class="hljs-comment">// A 中最后一个盘子移到C</span><br>        <span class="hljs-built_in">move</span>(n - <span class="hljs-number">1</span>, B, A, C); <span class="hljs-comment">// B 中移动n-1个盘子到C</span><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> −1)。一共需要移动的次数。</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/53/"/>
    <url>/posts/53/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础篇redis"><a class="markdownIt-Anchor" href="#1-基础篇redis"></a> 1: 基础篇Redis</h1><h1 id="2-开篇导读"><a class="markdownIt-Anchor" href="#2-开篇导读"></a> 2: 开篇导读</h1><p><strong>理想课程</strong></p><p>小伙伴们理想的课程一定是能够通过讲解的方式，得到如下这些启发，我们的课程会从基础到精通，从redis小白，到redis大牛，还在等什么，这套课程一定就是你最适合你的课程~</p><p><img src="assets/1652882458107.png" alt="1652882458107"></p><h1 id="3-1redis简单介绍"><a class="markdownIt-Anchor" href="#3-1redis简单介绍"></a> 3: 1.Redis简单介绍</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li>键值型</li><li>NoSql</li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key.value对的形式存储，而value的形式多种多样，可以是字符串.数值.甚至json：</p><p><img src="assets/1652882668159.png%7C200" alt="1652882668159|800"></p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><p>对于存储的数据，没有类似Mysql那么严格的约束，比如唯一性，是否可以为null等等，所以我们把这种松散结构的数据库，称之为NoSQL数据库。</p><h1 id="4-2课程目录"><a class="markdownIt-Anchor" href="#4-2课程目录"></a> 4: 2.课程目录</h1><blockquote><ul><li>初始Redis<ul><li>认识NoSQL</li><li>认识Redis</li><li>安装Redis</li></ul></li><li>Redis常见命令<ul><li>5种常见数据结构</li><li>通用命令</li><li>不同数据结构的操作命令</li></ul></li><li>Redis的Java客户端<ul><li>Jedis客户端</li><li>SpringDataRedis客户端</li></ul></li></ul></blockquote><h1 id="5-3初知识redis"><a class="markdownIt-Anchor" href="#5-3初知识redis"></a> 5: 3.初知识Redis</h1><h2 id="51-31认识nosql"><a class="markdownIt-Anchor" href="#51-31认识nosql"></a> 5.1: 3.1.认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h2 id="52-311结构化与非结构化"><a class="markdownIt-Anchor" href="#52-311结构化与非结构化"></a> 5.2: 3.1.1.结构化与非结构化</h2><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="https://i.imgur.com/4tUgFo6.png" alt=""></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="https://i.imgur.com/GdqOSsj.png" alt=""></p><p>也可以是文档型：</p><p><img src="https://i.imgur.com/zBBQfcc.png" alt=""></p><p>甚至可以是图格式：</p><p><img src="https://i.imgur.com/zBnKxWf.png" alt=""></p><h2 id="53-312关联和非关联"><a class="markdownIt-Anchor" href="#53-312关联和非关联"></a> 5.3: 3.1.2.关联和非关联</h2><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="https://i.imgur.com/tXYSl5x.png" alt=""></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  name<span class="hljs-punctuation">:</span> <span class="hljs-string">"张三"</span><span class="hljs-punctuation">,</span><br>  orders<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">{</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">"荣耀6"</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">4999</span><br>       <span class="hljs-punctuation">}</span><br>    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">{</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">"小米11"</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">3999</span><br>       <span class="hljs-punctuation">}</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h2 id="54-313查询方式"><a class="markdownIt-Anchor" href="#54-313查询方式"></a> 5.4: 3.1.3.查询方式</h2><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="https://i.imgur.com/AzaHOTF.png" alt=""></p><h2 id="55-314事务"><a class="markdownIt-Anchor" href="#55-314事务"></a> 5.5: 3.1.4.事务</h2><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="https://i.imgur.com/J1MqOJM.png" alt=""></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h2 id="56-315总结"><a class="markdownIt-Anchor" href="#56-315总结"></a> 5.6: 3.1.5.总结</h2><p>除了上述四点以外，在存储方式.扩展性.查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="https://i.imgur.com/kZP40dQ.png" alt=""></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h2 id="57-32认识redis"><a class="markdownIt-Anchor" href="#57-32认识redis"></a> 5.7: 3.2.认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存.IO多路复用.良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群.分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h2 id="58-33安装redis"><a class="markdownIt-Anchor" href="#58-33安装redis"></a> 5.8: 3.3.安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h2 id="59-331依赖库"><a class="markdownIt-Anchor" href="#59-331依赖库"></a> 5.9: 3.3.1.依赖库</h2><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></tbody></table></figure><h2 id="510-332上传安装包并解压"><a class="markdownIt-Anchor" href="#510-332上传安装包并解压"></a> 5.10: 3.3.2.上传安装包并解压</h2><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="https://i.imgur.com/SyjanS5.png" alt=""></p><p>例如，我放到了/usr/local/src 目录：</p><p><img src="https://i.imgur.com/01DTNCf.png" alt=""></p><p>解压缩：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-6.2.6.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>解压后：</p><p><img src="https://i.imgur.com/8V6zvCD.png" alt="image-20211211080339076"></p><p>进入redis</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></tbody></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make &amp;&amp; make install<br></code></pre></td></tr></tbody></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="https://i.imgur.com/YSxkGm7.png" alt="|700"></p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h2 id="511-333启动"><a class="markdownIt-Anchor" href="#511-333启动"></a> 5.11: 3.3.3.启动</h2><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h2 id="512-334默认启动"><a class="markdownIt-Anchor" href="#512-334默认启动"></a> 5.12: 3.3.4.默认启动</h2><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span><br></code></pre></td></tr></tbody></table></figure><p>如图：</p><p><img src="https://i.imgur.com/v7xWsqC.png" alt=""></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h2 id="513-335指定配置启动"><a class="markdownIt-Anchor" href="#513-335指定配置启动"></a> 5.13: 3.3.5.指定配置启动</h2><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="assets/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> redis.<span class="hljs-keyword">conf</span> redis.<span class="hljs-keyword">conf</span>.bck<br></code></pre></td></tr></tbody></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 守护进程，修改为yes后即可后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes </span><br><span class="hljs-comment"># 密码，设置后访问Redis必须输入密码</span><br><span class="hljs-attr">requirepass</span> <span class="hljs-string">123321</span><br></code></pre></td></tr></tbody></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志.持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">"redis.log"</span><br></code></pre></td></tr></tbody></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></tbody></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></tbody></table></figure><h2 id="514-336开机自启"><a class="markdownIt-Anchor" href="#514-336开机自启"></a> 5.14: 3.3.6.开机自启</h2><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></tbody></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></tbody></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl daemon-reload<br></code></pre></td></tr></tbody></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span><br>systemctl start redis<br><span class="hljs-comment"># 停止</span><br>systemctl stop redis<br><span class="hljs-comment"># 重启</span><br>systemctl restart redis<br><span class="hljs-comment"># 查看状态</span><br>systemctl status redis<br></code></pre></td></tr></tbody></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> redis<br></code></pre></td></tr></tbody></table></figure><h2 id="515-34redis桌面客户端"><a class="markdownIt-Anchor" href="#515-34redis桌面客户端"></a> 5.15: 3.4.Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h2 id="516-341redis命令行客户端"><a class="markdownIt-Anchor" href="#516-341redis命令行客户端"></a> 5.16: 3.4.1.Redis命令行客户端</h2><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></tbody></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="https://i.imgur.com/OYYWPNo.png" alt=""></p><h2 id="517-342图形化桌面客户端"><a class="markdownIt-Anchor" href="#517-342图形化桌面客户端"></a> 5.17: 3.4.2.图形化桌面客户端</h2><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h2 id="518-343安装"><a class="markdownIt-Anchor" href="#518-343安装"></a> 5.18: 3.4.3.安装</h2><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="https://i.imgur.com/BZ4Agbi.png" alt=""></p><p>解压缩后，运行安装程序即可安装：</p><p><img src="https://i.imgur.com/hguGHbX.png" alt=""></p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="https://i.imgur.com/hwK5LQ8.png" alt=""></p><p>双击即可运行：</p><p><img src="https://i.imgur.com/6hUqslY.png" alt=""></p><h2 id="519-344建立连接"><a class="markdownIt-Anchor" href="#519-344建立连接"></a> 5.19: 3.4.4.建立连接</h2><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="https://i.imgur.com/9qTGyoN.png" alt=""></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="https://i.imgur.com/DshNnKC.png" alt=""></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="https://i.imgur.com/A2cOm7Q.png" alt=""></p><p>点击即可建立连接了。</p><p><img src="https://i.imgur.com/ja8Fd9s.png" alt=""></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选择 0号库</span><br>select 0<br></code></pre></td></tr></tbody></table></figure><h1 id="6-4redis常见命令"><a class="markdownIt-Anchor" href="#6-4redis常见命令"></a> 6: 4.Redis常见命令</h1><h2 id="61-redis数据结构介绍"><a class="markdownIt-Anchor" href="#61-redis数据结构介绍"></a> 6.1: Redis数据结构介绍</h2><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><p><img src="assets/1652887393157.png" alt="1652887393157"></p><p><strong>贴心小建议：命令不要死记，学会查询就好啦</strong></p><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令：</p><p><img src="assets/1652887648826.png" alt="1652887648826"></p><p>当然我们也可以通过Help命令来帮助我们去查看命令</p><p><img src="assets/1652887748279.png" alt="1652887748279"></p><h2 id="62-redis-通用命令"><a class="markdownIt-Anchor" href="#62-redis-通用命令"></a> 6.2: Redis 通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="assets/1652887865189.png%7C900" alt="1652887865189"></p><p>课堂代码如下</p><ul><li>KEYS</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">"name"</span><br>2) <span class="hljs-string">"age"</span><br>127.0.0.1:6379&gt;<br><br><span class="hljs-comment"># 查询以a开头的key</span><br>127.0.0.1:6379&gt; keys a*<br>1) <span class="hljs-string">"age"</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></tbody></table></figure><p><strong>贴心小提示：在生产环境下，不推荐使用keys 命令，因为这个命令在key过多的情况下，效率不高</strong></p><ul><li>DEL</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; <span class="hljs-built_in">help</span> del<br><br>  DEL key [key ...]<br>  summary: Delete a key<br>  since: 1.0.0<br>  group: generic<br><br>127.0.0.1:6379&gt; del name <span class="hljs-comment">#删除单个</span><br>(<span class="hljs-built_in">integer</span>) 1  <span class="hljs-comment">#成功删除1个</span><br><br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">"age"</span><br><br>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 <span class="hljs-comment">#批量添加数据</span><br>OK<br><br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">"k3"</span><br>2) <span class="hljs-string">"k2"</span><br>3) <span class="hljs-string">"k1"</span><br>4) <span class="hljs-string">"age"</span><br><br>127.0.0.1:6379&gt; del k1 k2 k3 k4<br>(<span class="hljs-built_in">integer</span>) 3   <span class="hljs-comment">#此处返回的是成功删除的key，由于redis中只有k1,k2,k3 所以只成功删除3个，最终返回</span><br>127.0.0.1:6379&gt;<br><br>127.0.0.1:6379&gt; keys * <span class="hljs-comment">#再查询全部的key</span><br>1) <span class="hljs-string">"age"</span><span class="hljs-comment">#只剩下一个了</span><br>127.0.0.1:6379&gt;<br></code></pre></td></tr></tbody></table></figure><p><strong>贴心小提示：同学们在拷贝代码的时候，只需要拷贝对应的命令哦~</strong></p><ul><li>EXISTS</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; <span class="hljs-built_in">help</span> EXISTS<br><br>  EXISTS key [key ...]<br>  summary: Determine <span class="hljs-keyword">if</span> a key exists<br>  since: 1.0.0<br>  group: generic<br><br>127.0.0.1:6379&gt; exists age<br>(<span class="hljs-built_in">integer</span>) 1<br><br>127.0.0.1:6379&gt; exists name<br>(<span class="hljs-built_in">integer</span>) 0<br></code></pre></td></tr></tbody></table></figure><ul><li>EXPIRE</li></ul><p><strong>贴心小提示</strong>：内存非常宝贵，对于一些数据，我们应当给他一些过期时间，当过期时间到了之后，他就会自动被删除~</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; expire age 10<br>(<span class="hljs-built_in">integer</span>) 1<br><br>127.0.0.1:6379&gt; ttl age<br>(<span class="hljs-built_in">integer</span>) 8<br><br>127.0.0.1:6379&gt; ttl age<br>(<span class="hljs-built_in">integer</span>) 6<br><br>127.0.0.1:6379&gt; ttl age<br>(<span class="hljs-built_in">integer</span>) -2<br><br>127.0.0.1:6379&gt; ttl age<br>(<span class="hljs-built_in">integer</span>) -2  <span class="hljs-comment">#当这个key过期了，那么此时查询出来就是-2 </span><br><br>127.0.0.1:6379&gt; keys *<br>(empty list or <span class="hljs-built_in">set</span>)<br><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> age 10 <span class="hljs-comment">#如果没有设置过期时间</span><br>OK<br><br>127.0.0.1:6379&gt; ttl age<br>(<span class="hljs-built_in">integer</span>) -1  <span class="hljs-comment"># ttl的返回值就是-1</span><br></code></pre></td></tr></tbody></table></figure><h2 id="63-redis命令-string命令"><a class="markdownIt-Anchor" href="#63-redis命令-string命令"></a> 6.3: Redis命令-String命令</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p><img src="assets/1652890121291.png" alt="1652890121291"></p><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><p><strong>贴心小提示</strong>：以上命令除了INCRBYFLOAT 都是常用命令</p><ul><li>SET 和GET: 如果key不存在则是新增，如果存在则是修改</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; set name Rose  <span class="hljs-comment">//原来不存在</span><br>OK<br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get name <br><span class="hljs-string">"Rose"</span><br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; set name Jack <span class="hljs-comment">//原来存在，就是修改</span><br>OK<br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get name<br><span class="hljs-string">"Jack"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>MSET和MGET</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; MSET k1 v1 k2 v2 k3 v3<br>OK<br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; MGET name age k1 k2 k3<br><span class="hljs-number">1</span>) <span class="hljs-string">"Jack"</span> <span class="hljs-comment">//之前存在的name</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"10"</span>   <span class="hljs-comment">//之前存在的age</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"v1"</span><br><span class="hljs-number">4</span>) <span class="hljs-string">"v2"</span><br><span class="hljs-number">5</span>) <span class="hljs-string">"v3"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>INCR和INCRBY和DECY</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get age <br><span class="hljs-string">"10"</span><br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; incr age <span class="hljs-comment">//增加1</span><br>(integer) <span class="hljs-number">11</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get age <span class="hljs-comment">//获得age</span><br><span class="hljs-string">"11"</span><br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; incrby age <span class="hljs-number">2</span> <span class="hljs-comment">//一次增加2</span><br>(integer) <span class="hljs-number">13</span> <span class="hljs-comment">//返回目前的age的值</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; incrby age <span class="hljs-number">2</span><br>(integer) <span class="hljs-number">15</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; incrby age -<span class="hljs-number">1</span> <span class="hljs-comment">//也可以增加负数，相当于减</span><br>(integer) <span class="hljs-number">14</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; incrby age -<span class="hljs-number">2</span> <span class="hljs-comment">//一次减少2个</span><br>(integer) <span class="hljs-number">12</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; DECR age <span class="hljs-comment">//相当于 incr 负数，减少正常用法</span><br>(integer) <span class="hljs-number">11</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get age <br><span class="hljs-string">"11"</span><br><br></code></pre></td></tr></tbody></table></figure><ul><li>SETNX</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; help setnx<br><br>  SETNX key value<br>  summary: Set the value of a key, only <span class="hljs-keyword">if</span> the key does not exist<br>  since: <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br>  group: string<br><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; set name Jack  <span class="hljs-comment">//设置名称</span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; setnx name lisi <span class="hljs-comment">//如果key不存在，则添加成功</span><br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get name <span class="hljs-comment">//由于name已经存在，所以lisi的操作失败</span><br><span class="hljs-string">"Jack"</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; setnx name2 lisi <span class="hljs-comment">//name2 不存在，所以操作成功</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; get name2 <br><span class="hljs-string">"lisi"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>SETEX</li></ul><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; setex name 10 jack<br>OK<br><br>127.0.0.1:6379&gt; ttl name<br>(<span class="hljs-built_in">integer</span>) 8<br><br>127.0.0.1:6379&gt; ttl name<br>(<span class="hljs-built_in">integer</span>) 7<br><br>127.0.0.1:6379&gt; ttl name<br>(<span class="hljs-built_in">integer</span>) 5<br></code></pre></td></tr></tbody></table></figure><h2 id="64-redis命令-key的层级结构"><a class="markdownIt-Anchor" href="#64-redis命令-key的层级结构"></a> 6.4: Redis命令-Key的层级结构</h2><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:'隔开，格式如下：</p><p><img src="assets/1652941631682.png" alt="1652941631682"></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1, “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据</p><p><img src="assets/1652941883537.png" alt="1652941883537"></p><h2 id="65-redis命令-hash命令"><a class="markdownIt-Anchor" href="#65-redis命令-hash命令"></a> 6.5: Redis命令-Hash命令</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="assets/1652941995945.png" alt="1652941995945"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="assets/1652942027719.png" alt="1652942027719"></p><p><strong>Hash类型的常见命令</strong></p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><p><strong>贴心小提示</strong>：哈希结构也是我们以后实际开发中常用的命令哟</p><ul><li>HSET和HGET</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HSET heima:user:<span class="hljs-number">3</span> name Lucy<span class="hljs-comment">//大key是 heima:user:3 小key是name，小value是Lucy</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HSET heima:user:<span class="hljs-number">3</span> age <span class="hljs-number">21</span><span class="hljs-comment">// 如果操作不存在的数据，则是新增</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HSET heima:user:<span class="hljs-number">3</span> age <span class="hljs-number">17</span> <span class="hljs-comment">//如果操作存在的数据，则是修改</span><br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HGET heima:user:<span class="hljs-number">3</span> name <br><span class="hljs-string">"Lucy"</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HGET heima:user:<span class="hljs-number">3</span> age<br><span class="hljs-string">"17"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>HMSET和HMGET</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HMSET heima:user:<span class="hljs-number">4</span> name HanMeiMei<br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HMSET heima:user:<span class="hljs-number">4</span> name LiLei age <span class="hljs-number">20</span> sex man<br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HMGET heima:user:<span class="hljs-number">4</span> name age sex<br><span class="hljs-number">1</span>) <span class="hljs-string">"LiLei"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"20"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"man"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>HGETALL</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HGETALL heima:user:<span class="hljs-number">4</span><br><span class="hljs-number">1</span>) <span class="hljs-string">"name"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"LiLei"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"age"</span><br><span class="hljs-number">4</span>) <span class="hljs-string">"20"</span><br><span class="hljs-number">5</span>) <span class="hljs-string">"sex"</span><br><span class="hljs-number">6</span>) <span class="hljs-string">"man"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>HKEYS和HVALS</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HKEYS heima:user:<span class="hljs-number">4</span><br><span class="hljs-number">1</span>) <span class="hljs-string">"name"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"age"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"sex"</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HVALS heima:user:<span class="hljs-number">4</span><br><span class="hljs-number">1</span>) <span class="hljs-string">"LiLei"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"20"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"man"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>HINCRBY</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HINCRBY  heima:user:<span class="hljs-number">4</span> age <span class="hljs-number">2</span><br>(integer) <span class="hljs-number">22</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HVALS heima:user:<span class="hljs-number">4</span><br><span class="hljs-number">1</span>) <span class="hljs-string">"LiLei"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"22"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"man"</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HINCRBY  heima:user:<span class="hljs-number">4</span> age -<span class="hljs-number">2</span><br>(integer) <span class="hljs-number">20</span><br></code></pre></td></tr></tbody></table></figure><ul><li>HSETNX</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HSETNX heima:user4 sex <span class="hljs-title function_">woman</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HGETALL heima:user:<span class="hljs-number">3</span><br><span class="hljs-number">1</span>) <span class="hljs-string">"name"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"Lucy"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"age"</span><br><span class="hljs-number">4</span>) <span class="hljs-string">"17"</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HSETNX heima:user:<span class="hljs-number">3</span> sex <span class="hljs-title function_">woman</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; HGETALL heima:user:<span class="hljs-number">3</span><br><span class="hljs-number">1</span>) <span class="hljs-string">"name"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"Lucy"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"age"</span><br><span class="hljs-number">4</span>) <span class="hljs-string">"17"</span><br><span class="hljs-number">5</span>) <span class="hljs-string">"sex"</span><br><span class="hljs-number">6</span>) <span class="hljs-string">"woman"</span><br></code></pre></td></tr></tbody></table></figure><h2 id="66-redis命令-list命令"><a class="markdownIt-Anchor" href="#66-redis命令-list命令"></a> 6.6: Redis命令-List命令</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><p><img src=".%5CRedis.assets%5C1652943604992.png" alt="1652943604992"></p><ul><li>LPUSH和RPUSH</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; LPUSH users <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; RPUSH users <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br>(integer) <span class="hljs-number">6</span><br></code></pre></td></tr></tbody></table></figure><ul><li>LPOP和RPOP</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; LPOP users<br><span class="hljs-string">"3"</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; RPOP users<br><span class="hljs-string">"6"</span><br></code></pre></td></tr></tbody></table></figure><ul><li>LRANGE</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; LRANGE users <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span>) <span class="hljs-string">"1"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"4"</span><br></code></pre></td></tr></tbody></table></figure><h2 id="67-redis命令-set命令"><a class="markdownIt-Anchor" href="#67-redis命令-set命令"></a> 6.7: Redis命令-Set命令</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集.并集.差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li><li>SDIFF key1 key2 … ：求key1与key2的差集</li><li>SUNION key1 key2 …：求key1和key2的并集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="https://i.imgur.com/ha8x86R.png" alt=""></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="https://i.imgur.com/L9vTv2X.png" alt=""></p><p><strong>具体命令</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd s1 a b <span class="hljs-title function_">c</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers s1<br><span class="hljs-number">1</span>) <span class="hljs-string">"c"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"b"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"a"</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem s1 <span class="hljs-title function_">a</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SISMEMBER s1 <span class="hljs-title function_">a</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">0</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SISMEMBER s1 <span class="hljs-title function_">b</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SCARD <span class="hljs-title function_">s1</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure><p><strong>案例</strong></p><ul><li>将下列数据用Redis的Set集合来存储：</li><li>张三的好友有：李四.王五.赵六</li><li>李四的好友有：王五.麻子.二狗</li><li>利用Set的命令实现下列功能：</li><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SADD zs lisi wangwu <span class="hljs-title function_">zhaoliu</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SADD ls wangwu mazi <span class="hljs-title function_">ergou</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SCARD <span class="hljs-title function_">zs</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SINTER zs ls<br><span class="hljs-number">1</span>) <span class="hljs-string">"wangwu"</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SDIFF zs ls<br><span class="hljs-number">1</span>) <span class="hljs-string">"zhaoliu"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"lisi"</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SUNION zs ls<br><span class="hljs-number">1</span>) <span class="hljs-string">"wangwu"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"zhaoliu"</span><br><span class="hljs-number">3</span>) <span class="hljs-string">"lisi"</span><br><span class="hljs-number">4</span>) <span class="hljs-string">"mazi"</span><br><span class="hljs-number">5</span>) <span class="hljs-string">"ergou"</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SISMEMBER zs <span class="hljs-title function_">lisi</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SISMEMBER ls <span class="hljs-title function_">zhangsan</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">0</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SREM zs <span class="hljs-title function_">lisi</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br>    <br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; SMEMBERS zs<br><span class="hljs-number">1</span>) <span class="hljs-string">"zhaoliu"</span><br><span class="hljs-number">2</span>) <span class="hljs-string">"wangwu"</span><br></code></pre></td></tr></tbody></table></figure><h2 id="68-redis命令-sortedset类型"><a class="markdownIt-Anchor" href="#68-redis命令-sortedset类型"></a> 6.8: Redis命令-SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</li><li><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul><h1 id="7-5redis的java客户端-jedis"><a class="markdownIt-Anchor" href="#7-5redis的java客户端-jedis"></a> 7: 5.Redis的Java客户端-Jedis</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="https://i.imgur.com/9f68ivq.png" alt=""></p><p>其中Java客户端也包含很多：</p><p><img src="assets/image-20220609102817435.png" alt="image-20220609102817435"></p><p>标记为❤的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h2 id="71-jedis快速入门"><a class="markdownIt-Anchor" href="#71-jedis快速入门"></a> 7.1: Jedis快速入门</h2><p><strong>入门案例详细步骤</strong></p><p>案例分析：</p><p>0）创建工程：</p><p><img src="%5CRedis.assets%5C1652959239813.png" alt="1652959239813"></p><p>1）引入依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--单元测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 1.建立连接</span><br>    <span class="hljs-comment">// jedis = new Jedis("192.168.150.101", 6379);</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">"123321"</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>3）测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"虎哥"</span>);<br>    System.out.println(<span class="hljs-string">"result = "</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">"name"</span>);<br>    System.out.println(<span class="hljs-string">"name = "</span> + name);<br>}<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 插入hash数据</span><br>    jedis.hset(<span class="hljs-string">"user:1"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"Jack"</span>);<br>    jedis.hset(<span class="hljs-string">"user:1"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"21"</span>);<br><br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">"user:1"</span>);<br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) {<br>        jedis.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="72-jedis连接池"><a class="markdownIt-Anchor" href="#72-jedis连接池"></a> 7.2: Jedis连接池</h2><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</p><p>有关池化思想，并不仅仅是这里会使用，很多地方都有，比如说我们的数据库连接池，比如我们tomcat中的线程池，这些都是池化思想的体现。</p><h2 id="73-521创建jedis的连接池"><a class="markdownIt-Anchor" href="#73-521创建jedis的连接池"></a> 7.3: 5.2.1.创建Jedis的连接池</h2><ul><li></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFacotry</span> {<br><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> JedisPool jedisPool;<br><br>     <span class="hljs-keyword">static</span> {<br>         <span class="hljs-comment">//配置连接池</span><br>         <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>         poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>         poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>         poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>         poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>         <span class="hljs-comment">//创建连接池对象</span><br>         jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,<br>                 <span class="hljs-string">"192.168.150.101"</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">"123321"</span>);<br>     }<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>{<br>          <span class="hljs-keyword">return</span> jedisPool.getResource();<br>     }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>代码说明：</strong></p><ul><li><p>1） JedisConnectionFacotry：工厂设计模式是实际开发中非常常用的一种设计模式，我们可以使用工厂，去降低代的耦合，比如Spring中的Bean的创建，就用到了工厂设计模式</p></li><li><p>2）静态代码块：随着类的加载而加载，确保只能执行一次，我们在加载当前工厂类的时候，就可以执行static的操作完成对 连接池的初始化</p></li><li><p>3）最后提供返回连接池中连接的方法.</p></li></ul><h2 id="74-522改造原始代码"><a class="markdownIt-Anchor" href="#74-522改造原始代码"></a> 7.4: 5.2.2.改造原始代码</h2><p><strong>代码说明:</strong></p><p>1.在我们完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得。</p><p>，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p><p>2.当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis还回连接池的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@BeforeEach</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>{<br>     <span class="hljs-comment">//建立连接</span><br>     <span class="hljs-comment">/*jedis = new Jedis("127.0.0.1",6379);*/</span><br>     jedis = JedisConnectionFacotry.getJedis();<br>      <span class="hljs-comment">//选择库</span><br>     jedis.select(<span class="hljs-number">0</span>);<br> }<br><br><span class="hljs-meta">@AfterEach</span><br> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> {<br>     <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) {<br>         jedis.close();<br>     }<br> }<br></code></pre></td></tr></tbody></table></figure><h1 id="8-6redis的java客户端-springdataredis"><a class="markdownIt-Anchor" href="#8-6redis的java客户端-springdataredis"></a> 8: 6.Redis的Java客户端-SpringDataRedis</h1><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src=".%5CRedis.assets%5C1652976773295.png" alt="1652976773295"></p><h2 id="81-61快速入门"><a class="markdownIt-Anchor" href="#81-61快速入门"></a> 8.1: 6.1.快速入门</h2><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单：</p><h2 id="82-611导入pom坐标"><a class="markdownIt-Anchor" href="#82-611导入pom坐标"></a> 8.2: 6.1.1.导入pom坐标</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--common-pool--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="83-配置文件"><a class="markdownIt-Anchor" href="#83-配置文件"></a> 8.3: .配置文件</h2><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>  <span class="hljs-comment">#最大连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>   <span class="hljs-comment">#最大空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#最小空闲连接</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span> <span class="hljs-comment">#连接等待时间</span><br></code></pre></td></tr></tbody></table></figure><h2 id="84-613测试代码"><a class="markdownIt-Anchor" href="#84-613测试代码"></a> 8.4: 6.1.3.测试代码</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemoApplicationTests</span> {<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"虎哥"</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">"name"</span>);<br>        System.out.println(<span class="hljs-string">"name = "</span> + name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>贴心小提示：SpringDataJpa使用起来非常简单，记住如下几个步骤即可</strong></p><p>SpringDataRedis的使用步骤：</p><ul><li>引入spring-boot-starter-data-redis依赖</li><li>在application.yml配置Redis信息</li><li>注入RedisTemplate</li></ul><h2 id="85-数据序列化器"><a class="markdownIt-Anchor" href="#85-数据序列化器"></a> 8.5: .数据序列化器</h2><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="https://i.imgur.com/OEMcbuu.png" alt=""></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="https://i.imgur.com/5FjtWk5.png" alt=""></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> {<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>{<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://i.imgur.com/XOAq3cN.png" alt=""></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h2 id="86-stringredistemplate"><a class="markdownIt-Anchor" href="#86-stringredistemplate"></a> 8.6: StringRedisTemplate</h2><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p><p><img src=".%5CRedis.assets%5C1653054602930.png" alt="1653054602930"></p><p>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</p><p><img src=".%5CRedis.assets%5C1653054744832.png" alt="1653054744832"></p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="https://i.imgur.com/zXH6Qn6.png" alt=""></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> {<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        stringRedisTemplate.opsForValue().set(<span class="hljs-string">"verify:phone:13600527634"</span>, <span class="hljs-string">"124143"</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">"name"</span>);<br>        System.out.println(<span class="hljs-string">"name = "</span> + name);<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException {<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"虎哥"</span>, <span class="hljs-number">21</span>);<br>        <span class="hljs-comment">// 手动序列化</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>        <span class="hljs-comment">// 写入数据</span><br>        stringRedisTemplate.opsForValue().set(<span class="hljs-string">"user:200"</span>, json);<br><br>        <span class="hljs-comment">// 获取数据</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">"user:200"</span>);<br>        <span class="hljs-comment">// 手动反序列化</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>        System.out.println(<span class="hljs-string">"user1 = "</span> + user1);<br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>此时我们再来看一看存储的数据，小伙伴们就会发现那个class数据已经不在了，节约了我们的空间~</p><p><img src=".%5CRedis.assets%5C1653054945211.png" alt="1653054945211"></p><p>最后小总结：</p><p>RedisTemplate的两种序列化实践方案：</p><ul><li><p>方案一：</p><ul><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ul></li><li><p>方案二：</p><ul><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ul></li></ul><h2 id="87-hash结构操作"><a class="markdownIt-Anchor" href="#87-hash结构操作"></a> 8.7: Hash结构操作</h2><p>在基础篇的最后，咱们对Hash结构操作一下，收一个小尾巴，这个代码咱们就不再解释啦</p><p>马上就开始新的篇章~~~进入到我们的Redis实战篇</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> {<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> {<br>        stringRedisTemplate.opsForHash().put(<span class="hljs-string">"user:400"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"虎哥"</span>);<br>        stringRedisTemplate.opsForHash().put(<span class="hljs-string">"user:400"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"21"</span>);<br><br>        Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="hljs-string">"user:400"</span>);<br>        System.out.println(<span class="hljs-string">"entries = "</span> + entries);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>redis</category>
      
      <category>黑马 redis</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/54/"/>
    <url>/posts/54/</url>
    
    <content type="html"><![CDATA[<h1 id="1-redis快速入门"><a class="markdownIt-Anchor" href="#1-redis快速入门"></a> 1: Redis快速入门</h1><p>Redis的常见命令和客户端使用</p><h1 id="2-1初识redis"><a class="markdownIt-Anchor" href="#2-1初识redis"></a> 2: 1.初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p><p><img src="assets/6U1Rhxo.png%7C600" alt="image-20220502190959608"></p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><h2 id="21-11认识nosql"><a class="markdownIt-Anchor" href="#21-11认识nosql"></a> 2.1: 1.1.认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h3 id="211-111结构化与非结构化"><a class="markdownIt-Anchor" href="#211-111结构化与非结构化"></a> 2.1.1: 1.1.1.结构化与非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="assets/4tUgFo6.png" alt=""></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="assets/GdqOSsj.png" alt=""></p><p>也可以是文档型：</p><p><img src="assets/zBBQfcc.png" alt=""></p><p>甚至可以是图格式：</p><p><img src="assets/zBnKxWf.png" alt=""></p><h3 id="212-112关联和非关联"><a class="markdownIt-Anchor" href="#212-112关联和非关联"></a> 2.1.2: 1.1.2.关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="assets/tXYSl5x.png" alt=""></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">{</span><br>  id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>  name<span class="hljs-punctuation">:</span> <span class="hljs-string">"张三"</span><span class="hljs-punctuation">,</span><br>  orders<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">{</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">"荣耀6"</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">4999</span><br>       <span class="hljs-punctuation">}</span><br>    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">{</span><br>       id<span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>       item<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><br> id<span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span> title<span class="hljs-punctuation">:</span> <span class="hljs-string">"小米11"</span><span class="hljs-punctuation">,</span> price<span class="hljs-punctuation">:</span> <span class="hljs-number">3999</span><br>       <span class="hljs-punctuation">}</span><br>    <span class="hljs-punctuation">}</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">}</span><br></code></pre></td></tr></tbody></table></figure><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h3 id="213-113查询方式"><a class="markdownIt-Anchor" href="#213-113查询方式"></a> 2.1.3: 1.1.3.查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="assets/AzaHOTF.png" alt=""></p><h3 id="214-114事务"><a class="markdownIt-Anchor" href="#214-114事务"></a> 2.1.4: 1.1.4.事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="assets/J1MqOJM.png" alt=""></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h3 id="215-115总结"><a class="markdownIt-Anchor" href="#215-115总结"></a> 2.1.5: 1.1.5.总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="assets/kZP40dQ.png" alt=""></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h2 id="22-12认识redis"><a class="markdownIt-Anchor" href="#22-12认识redis"></a> 2.2: 1.2.认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h2 id="23-13安装redis"><a class="markdownIt-Anchor" href="#23-13安装redis"></a> 2.3: 1.3.安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h3 id="231-131依赖库"><a class="markdownIt-Anchor" href="#231-131依赖库"></a> 2.3.1: 1.3.1.依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum install -y gcc tcl<br></code></pre></td></tr></tbody></table></figure><h3 id="232-132上传安装包并解压"><a class="markdownIt-Anchor" href="#232-132上传安装包并解压"></a> 2.3.2: 1.3.2.上传安装包并解压</h3><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p><img src="assets/SyjanS5.png" alt=""></p><p>例如，我放到了/usr/local/src 目录：</p><p><img src="assets/01DTNCf.png" alt=""></p><p>解压缩：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzf redis-6.2.6.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>解压后：</p><p><img src="assets/8V6zvCD.png" alt="image-20211211080339076"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> redis-6.2.6<br></code></pre></td></tr></tbody></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make &amp;&amp; make install<br></code></pre></td></tr></tbody></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="https://i.imgur.com/YSxkGm7.png" alt=""></p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h3 id="233-133启动"><a class="markdownIt-Anchor" href="#233-133启动"></a> 2.3.3: 1.3.3.启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="234-134默认启动"><a class="markdownIt-Anchor" href="#234-134默认启动"></a> 2.3.4: 1.3.4.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">redis-<span class="hljs-keyword">server</span><br></code></pre></td></tr></tbody></table></figure><p>如图：</p><p><img src="assets/v7xWsqC.png" alt=""></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="235-135指定配置启动"><a class="markdownIt-Anchor" href="#235-135指定配置启动"></a> 2.3.5: 1.3.5.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="assets/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cp</span> redis.<span class="hljs-keyword">conf</span> redis.<span class="hljs-keyword">conf</span>.bck<br></code></pre></td></tr></tbody></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><br><span class="hljs-attr">bind</span> <span class="hljs-string">0.0.0.0</span><br><span class="hljs-comment"># 守护进程，修改为yes后即可后台运行</span><br><span class="hljs-attr">daemonize</span> <span class="hljs-string">yes </span><br><span class="hljs-comment"># 密码，设置后访问Redis必须输入密码</span><br><span class="hljs-attr">requirepass</span> <span class="hljs-string">123321</span><br></code></pre></td></tr></tbody></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 监听的端口</span><br><span class="hljs-attr">port</span> <span class="hljs-string">6379</span><br><span class="hljs-comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="hljs-attr">databases</span> <span class="hljs-string">1</span><br><span class="hljs-comment"># 设置redis能够使用的最大内存</span><br><span class="hljs-attr">maxmemory</span> <span class="hljs-string">512mb</span><br><span class="hljs-comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><br><span class="hljs-attr">logfile</span> <span class="hljs-string">"redis.log"</span><br></code></pre></td></tr></tbody></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 进入redis安装目录 </span><br><span class="hljs-built_in">cd</span> /usr/local/src/redis-6.2.6<br><span class="hljs-comment"># 启动</span><br>redis-server redis.conf<br></code></pre></td></tr></tbody></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span><br><span class="hljs-comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span><br>redis-cli -u 123321 shutdown<br></code></pre></td></tr></tbody></table></figure><h3 id="236-136开机自启"><a class="markdownIt-Anchor" href="#236-136开机自启"></a> 2.3.6: 1.3.6.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi /etc/systemd/system/redis.service<br></code></pre></td></tr></tbody></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Unit]<br>Description=redis-server<br>After=network.target<br><br>[Service]<br>Type=forking<br>ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf<br>PrivateTmp=true<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></tbody></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl daemon-reload<br></code></pre></td></tr></tbody></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span><br>systemctl start redis<br><span class="hljs-comment"># 停止</span><br>systemctl stop redis<br><span class="hljs-comment"># 重启</span><br>systemctl restart redis<br><span class="hljs-comment"># 查看状态</span><br>systemctl status redis<br></code></pre></td></tr></tbody></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl <span class="hljs-built_in">enable</span> redis<br></code></pre></td></tr></tbody></table></figure><h2 id="24-14redis桌面客户端"><a class="markdownIt-Anchor" href="#24-14redis桌面客户端"></a> 2.4: 1.4.Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h3 id="241-141redis命令行客户端"><a class="markdownIt-Anchor" href="#241-141redis命令行客户端"></a> 2.4.1: 1.4.1.Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">redis-cli [options] [commonds]<br></code></pre></td></tr></tbody></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="assets/OYYWPNo.png" alt=""></p><h3 id="242-142图形化桌面客户端"><a class="markdownIt-Anchor" href="#242-142图形化桌面客户端"></a> 2.4.2: 1.4.2.图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h3 id="243-143安装"><a class="markdownIt-Anchor" href="#243-143安装"></a> 2.4.3: 1.4.3.安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="assets/BZ4Agbi.png" alt=""></p><p>解压缩后，运行安装程序即可安装：</p><p><img src="assets/hguGHbX.png" alt=""></p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="assets/hwK5LQ8.png" alt=""></p><p>双击即可运行：</p><p><img src="assets/6hUqslY.png" alt=""></p><h3 id="244-144建立连接"><a class="markdownIt-Anchor" href="#244-144建立连接"></a> 2.4.4: 1.4.4.建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="assets/9qTGyoN.png" alt=""></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="assets/DshNnKC.png" alt=""></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="assets/A2cOm7Q.png" alt=""></p><p>点击即可建立连接了。</p><p><img src="assets/ja8Fd9s.png" alt=""></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 选择 0号库</span><br>select 0<br></code></pre></td></tr></tbody></table></figure><h1 id="3-2redis常见命令"><a class="markdownIt-Anchor" href="#3-2redis常见命令"></a> 3: 2.Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><p><img src="assets/8tli2o9.png" alt=""></p><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a href="https://redis.io/commands">https://redis.io/commands </a>）可以查看到不同的命令：</p><p><img src="assets/5Lcr3BE.png" alt=""></p><p>不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：</p><p><img src="assets/suevOIR.png" alt=""></p><p>接下来，我们就学习常见的五种基本数据类型的相关命令。</p><h2 id="31-21redis通用命令"><a class="markdownIt-Anchor" href="#31-21redis通用命令"></a> 3.1: 2.1.Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 查看keys命令的帮助信息：</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">help</span> keys<br><br>KEYS pattern<br>summary: Find all keys matching the given pattern<br>since: 1.0.0<br>group: generic<br></code></pre></td></tr></tbody></table></figure><h2 id="32-22string类型"><a class="markdownIt-Anchor" href="#32-22string类型"></a> 3.2: 2.2.String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><p><img src="assets/VZqpv73.png" alt=""></p><h3 id="321-221string的常见命令"><a class="markdownIt-Anchor" href="#321-221string的常见命令"></a> 3.2.1: 2.2.1.String的常见命令</h3><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="322-222key结构"><a class="markdownIt-Anchor" href="#322-222key结构"></a> 3.2.2: 2.2.2.Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:'隔开，格式如下：</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">项目名:业务名:类型:<span class="hljs-built_in">id</span><br></code></pre></td></tr></tbody></table></figure><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><p><img src="assets/InWMfeD.png" alt=""></p><h2 id="33-23hash类型"><a class="markdownIt-Anchor" href="#33-23hash类型"></a> 3.3: 2.3.Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="assets/x2zDBjf.png" alt=""></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="assets/VF2EPt0.png" alt=""></p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="34-24list类型"><a class="markdownIt-Anchor" href="#34-24list类型"></a> 3.4: 2.4.List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h2 id="35-25set类型"><a class="markdownIt-Anchor" href="#35-25set类型"></a> 3.5: 2.5.Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="assets/ha8x86R.png" alt=""></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="assets/L9vTv2X.png" alt=""></p><p>练习：</p><ol><li>将下列数据用Redis的Set集合来存储：</li></ol><ul><li>张三的好友有：李四、王五、赵六</li><li>李四的好友有：王五、麻子、二狗</li></ul><ol start="2"><li>利用Set的命令实现下列功能：</li></ol><ul><li>计算张三的好友有几人</li><li>计算张三和李四有哪些共同好友</li><li>查询哪些人是张三的好友却不是李四的好友</li><li>查询张三和李四的好友总共有哪些人</li><li>判断李四是否是张三的好友</li><li>判断张三是否是李四的好友</li><li>将李四从张三的好友列表中移除</li></ul><h2 id="36-26sortedset类型"><a class="markdownIt-Anchor" href="#36-26sortedset类型"></a> 3.6: 2.6.SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><p>练习题：</p><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><p>并实现下列功能：</p><ul><li>删除Tom同学</li><li>获取Amy同学的分数</li><li>获取Rose同学的排名</li><li>查询80分以下有几个学生</li><li>给Amy同学加2分</li><li>查出成绩前3名的同学</li><li>查出成绩80分以下的所有同学</li></ul><h1 id="4-3redis的java客户端"><a class="markdownIt-Anchor" href="#4-3redis的java客户端"></a> 4: 3.Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><p><img src="assets/9f68ivq.png" alt=""></p><p>其中Java客户端也包含很多：</p><p><img src="assets/image-20220609102817435-165735883948534.png" alt="image-20220609102817435"></p><p>标记为*的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h2 id="41-31jedis客户端"><a class="markdownIt-Anchor" href="#41-31jedis客户端"></a> 4.1: 3.1.Jedis客户端</h2><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h3 id="411-311快速入门"><a class="markdownIt-Anchor" href="#411-311快速入门"></a> 4.1.1: 3.1.1.快速入门</h3><p>我们先来个快速入门：</p><p>1）引入依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--单元测试--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br><br><span class="hljs-meta">@BeforeEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 1.建立连接</span><br>    <span class="hljs-comment">// jedis = new Jedis("192.168.150.101", 6379);</span><br>    jedis = JedisConnectionFactory.getJedis();<br>    <span class="hljs-comment">// 2.设置密码</span><br>    jedis.auth(<span class="hljs-string">"123321"</span>);<br>    <span class="hljs-comment">// 3.选择库</span><br>    jedis.select(<span class="hljs-number">0</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>3）测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 存入数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"虎哥"</span>);<br>    System.out.println(<span class="hljs-string">"result = "</span> + result);<br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">"name"</span>);<br>    System.out.println(<span class="hljs-string">"name = "</span> + name);<br>}<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 插入hash数据</span><br>    jedis.hset(<span class="hljs-string">"user:1"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"Jack"</span>);<br>    jedis.hset(<span class="hljs-string">"user:1"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-string">"21"</span>);<br><br>    <span class="hljs-comment">// 获取</span><br>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">"user:1"</span>);<br>    System.out.println(map);<br>}<br></code></pre></td></tr></tbody></table></figure><p>4）释放资源</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> {<br>    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) {<br>        jedis.close();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="412-312连接池"><a class="markdownIt-Anchor" href="#412-312连接池"></a> 4.1.2: 3.1.2.连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.jedis.util;<br><br><span class="hljs-keyword">import</span> redis.clients.jedis.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> {<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;<br><br>    <span class="hljs-keyword">static</span> {<br>        <span class="hljs-comment">// 配置连接池</span><br>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>        poolConfig.setMaxTotal(<span class="hljs-number">8</span>);<br>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);<br>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);<br>        poolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span><br>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig, <span class="hljs-string">"192.168.150.101"</span>, <span class="hljs-number">6379</span>, <span class="hljs-number">1000</span>, <span class="hljs-string">"123321"</span>);<br>    }<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span>{<br>        <span class="hljs-keyword">return</span> jedisPool.getResource();<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="42-32springdataredis客户端"><a class="markdownIt-Anchor" href="#42-32springdataredis客户端"></a> 4.2: 3.2.SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="assets/UFlNIV0.png" alt=""></p><h3 id="421-321快速入门"><a class="markdownIt-Anchor" href="#421-321快速入门"></a> 4.2.1: 3.2.1.快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。</p><p>首先，新建一个maven项目，然后按照下面步骤执行：</p><h4 id="4211-1引入依赖"><a class="markdownIt-Anchor" href="#4211-1引入依赖"></a> 4.2.1.1: 1）引入依赖</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>redis-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--redis依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--common-pool--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h4 id="4212-2配置redis"><a class="markdownIt-Anchor" href="#4212-2配置redis"></a> 4.2.1.2: 2）配置Redis</h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span><br></code></pre></td></tr></tbody></table></figure><h4 id="4213-3注入redistemplate"><a class="markdownIt-Anchor" href="#4213-3注入redistemplate"></a> 4.2.1.3: 3）注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> {<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="4214-4编写测试"><a class="markdownIt-Anchor" href="#4214-4编写测试"></a> 4.2.1.4: 4）编写测试</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStringTests</span> {<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate edisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> {<br>        <span class="hljs-comment">// 写入一条String数据</span><br>        redisTemplate.opsForValue().set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"虎哥"</span>);<br>        <span class="hljs-comment">// 获取string数据</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">"name"</span>);<br>        System.out.println(<span class="hljs-string">"name = "</span> + name);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="422-322自定义序列化"><a class="markdownIt-Anchor" href="#422-322自定义序列化"></a> 4.2.2: 3.2.2.自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="assets/OEMcbuu.png" alt=""></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="assets/5FjtWk5.png" alt=""></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> {<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>{<br>        <span class="hljs-comment">// 创建RedisTemplate对象</span><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 设置连接工厂</span><br>        template.setConnectionFactory(connectionFactory);<br>        <span class="hljs-comment">// 创建JSON序列化工具</span><br>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();<br>        <span class="hljs-comment">// 设置Key的序列化</span><br>        template.setKeySerializer(RedisSerializer.string());<br>        template.setHashKeySerializer(RedisSerializer.string());<br>        <span class="hljs-comment">// 设置Value的序列化</span><br>        template.setValueSerializer(jsonRedisSerializer);<br>        template.setHashValueSerializer(jsonRedisSerializer);<br>        <span class="hljs-comment">// 返回</span><br>        <span class="hljs-keyword">return</span> template;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="assets/XOAq3cN.png" alt=""></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="423-323stringredistemplate"><a class="markdownIt-Anchor" href="#423-323stringredistemplate"></a> 4.2.3: 3.2.3.StringRedisTemplate</h3><p>为了节省内存空间，我们可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="assets/Ip9TKSY.png" alt=""></p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="assets/zXH6Qn6.png" alt=""></p><p>省去了我们自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><span class="hljs-comment">// JSON序列化工具</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException {<br>    <span class="hljs-comment">// 创建对象</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"虎哥"</span>, <span class="hljs-number">21</span>);<br>    <span class="hljs-comment">// 手动序列化</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(user);<br>    <span class="hljs-comment">// 写入数据</span><br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">"user:200"</span>, json);<br><br>    <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">"user:200"</span>);<br>    <span class="hljs-comment">// 手动反序列化</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, User.class);<br>    System.out.println(<span class="hljs-string">"user1 = "</span> + user1);<br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>redis</category>
      
      <category>黑马 redis</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/52/"/>
    <url>/posts/52/</url>
    
    <content type="html"><![CDATA[<h1 id="redis实战课"><a class="markdownIt-Anchor" href="#redis实战课"></a> Redis实战课</h1><p>从基础入门，到企业应用实战，再到底层原理、源码分析，一套课程拿捏Redis.</p><h3 id="面向群体"><a class="markdownIt-Anchor" href="#面向群体"></a> 面向群体</h3><ul><li>完全不懂Redis的新手</li><li>对Redis有基本了解，想进一步增加Redis企业实战经验的同学</li><li>有一定的Redis使用经验，需要深入学习Redis底层原理的同学</li></ul><h3 id="学习要求"><a class="markdownIt-Anchor" href="#学习要求"></a> 学习要求</h3><ul><li>有使用Spring、SpringBoot、SpringMVC、Mybatis的经验</li><li>有一定的Linux使用基础</li></ul><h3 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h3><ul><li><p>windows操作系统</p></li><li><p>Mysql 5.7及以上版本</p></li><li><p>VMware + CentOS7虚拟机</p></li><li><p>JDK8</p></li><li><p>IDEA开发工具<br>环境准备</p></li><li><p>windows操作系统</p></li><li><p>Mysql 5.7及以上版本</p></li><li><p>VMware + CentOS7虚拟机</p></li><li><p>JDK8</p></li><li><p>IDEA开发工具</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>redis</category>
      
      <category>黑马 redis</category>
      
      <category>入门篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sort buffer</title>
    <link href="/posts/55070/"/>
    <url>/posts/55070/</url>
    
    <content type="html"><![CDATA[<p>📝sort buffer::</p><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select city,name,age from t where city='杭州' order by name limit 1000;<br></code></pre></td></tr></tbody></table></figure><p>涉及到⽤户语句的排序，mysql 会给每个线程分配⼀块内存⽤于排序，也就是 sort_buffer。这条语句的执⾏逻辑是：</p><p>1、先初始化 sort_bufer</p><p>2、然后放⼊ city,name,age 字段，不断地由主键 id 索引到整⾏再到三个字段的值，匹配查找的值存⼊ sort_buff</p><p>3、然后按 name 排序，返回前 1000 个值</p><blockquote><p>[!note] 如果 sort_buffer_size 设置的太⼩，⽆法存放所有匹配的字段，排序就⽆法在内存中完成<br>则要借鉴磁盘临时⽂件辅助排序，可以通过 number_of_tmp_files 这个标识来判断是否使 ⽤，<br>其实这个原理和对超⼤数据的排序相同。<br>如果要记录的字段太长，这样内存⾥能够同时放下的⾏数很少，要分成很多个临时⽂件，排序的性能会很差。</p></blockquote><blockquote><p>[!question]<br>这时会换⼀个算法，叫做 rowid 排序，顾名思义，就是对主键 id 以及排序字段进⾏存放，这样就节省了空间，<br>但是最后需要通过主键 id 去找到之前未取出的字段。对⽐全字段排序， rowid 排序多访问了⼀次表 t 的主键索引。</p></blockquote><h1 id="2-结论"><a class="markdownIt-Anchor" href="#2-结论"></a> 2: 结论：</h1><p>如果 MySQL 实在是担⼼排序内存太⼩，会影响排序效率，才会采⽤ rowid 排序算法，这样 排序过程中⼀次可以排序更多⾏，但是需要再回到原表去取数据。</p><p>如果 MySQL 认为内存⾜够⼤，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存⾥⾯返回查询结果了，不⽤再回到原表去取数据。</p><p>如果想要避免排序，可以建⽴对应字段的索引。</p><p>如果想要进⼀步避免主键 id 的回表查询，可以使⽤覆盖索引，这种情况的索引建⽴成本会 ⽐较⼤，需要你去⾃⼰权衡是否使⽤</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leveldb源码解读（一）目录</title>
    <link href="/posts/28222/"/>
    <url>/posts/28222/</url>
    
    <content type="html"><![CDATA[<p>📝Leveldb源码解读（一）目录::</p><!-- basicblock-end --><h1 id="1-leveldb-准备"><a class="markdownIt-Anchor" href="#1-leveldb-准备"></a> 1: leveldb 准备</h1><h2 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1: 简介</h2><p>leveldb是一个key/value型的单机存储引擎，由google开发，并宣布在BSD许可下开放源代码。他是leveling+分区实现的LSM典型代表。</p><h2 id="12-特性"><a class="markdownIt-Anchor" href="#12-特性"></a> 1.2: 特性</h2><ul><li>key、value支持任意的byte类型数组，不单单支持字符串</li><li>LevelDb是一个持久化存储的KV系统，将大部分数据存储到磁盘上</li><li>按照记录key值顺序存储数据，并且LevleDb支持按照用户定义的比较函数进行排序</li><li>操作接口简单，包括写/读记录以及删除记录，也支持针对多条操作的原子批量操作。</li><li>支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。</li><li>支持数据压缩(snappy压缩)操作，有效减小存储空间、并增快IO效率。</li><li>LSM典型实现，适合写多读少。</li></ul><h2 id="13-源码编译与使用"><a class="markdownIt-Anchor" href="#13-源码编译与使用"></a> 1.3: 源码编译与使用</h2><ul><li>源码下载<br>git clone <a href="https://github.com/google/leveldb.git">https://github.com/google/leveldb.git</a><br>git submodule update --init</li><li>执行编译<br>cd leveldb<br>mkdir -p build &amp;&amp; cd build<br>cmake -DCMAKE_BUILD_TYPE=Release(Debug) … &amp;&amp; cmake --build .</li></ul><p><strong>具体操作如下：</strong><br>release版的<br>cmake -DCMAKE_BUILD_TYPE=Release … &amp;&amp; cmake --build .<br>或者debug版的<br>cmake -DCMAKE_BUILD_TYPE=Debug … &amp;&amp; cmake --build .</p><ul><li>头文件加入系统目录(可选)<br>cp -r ./include/leveldb /usr/include/<br>cp build/libleveldb.a /usr/local/lib/</li><li>编写demo</li><li>编译demo<br>g++ -o xxx xxx.cpp libleveldb.a -lpthread</li></ul><h1 id="2-基本组件"><a class="markdownIt-Anchor" href="#2-基本组件"></a> 2: 基本组件</h1><h2 id="21-字节序"><a class="markdownIt-Anchor" href="#21-字节序"></a> 2.1: [[字节序]]</h2><p>leveldb 用的是小端字节序</p><h2 id="22-slice"><a class="markdownIt-Anchor" href="#22-slice"></a> 2.2: slice</h2><p>slice是leveldb中自定义的字符串处理类，主要是因为标准库中的string，<br>•默认语意为拷贝，会损失性能(在可预期的条件下，指针传递即可)<br>•标准库不支持remove_prefix和starts_with等函数，不太方便</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211191920027.png" alt=""></p><h2 id="23-status"><a class="markdownIt-Anchor" href="#23-status"></a> 2.3: status</h2><p>用于记录leveldb中状态信息，保存错误码和对应的字符串错误信息(不过不支持自定义)。<br>其基本组成</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211191910692.png" alt=""></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Code</span> {<span class="hljs-comment">// 错误码</span><br>    kOk = <span class="hljs-number">0</span>,<br>    kNotFound = <span class="hljs-number">1</span>,<br>    kCorruption = <span class="hljs-number">2</span>,<br>    kNotSupported = <span class="hljs-number">3</span>,<br>    kInvalidArgument = <span class="hljs-number">4</span>,<br>    kIOError = <span class="hljs-number">5</span><br>  };<br><br>Status::<span class="hljs-built_in">Status</span>(Code code, <span class="hljs-type">const</span> Slice&amp; msg, <span class="hljs-type">const</span> Slice&amp; msg2) {<br>  <span class="hljs-built_in">assert</span>(code != kOk);<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> len1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(msg.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> len2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(msg2.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> size = len1 + (len2 ? (<span class="hljs-number">2</span> + len2) : <span class="hljs-number">0</span>); <span class="hljs-comment">// +2 因为有冒号和空格</span><br>  <span class="hljs-type">char</span>* result = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[size + <span class="hljs-number">5</span>];<span class="hljs-comment">// +5 因为图片上的 5 个字节</span><br>  std::<span class="hljs-built_in">memcpy</span>(result, &amp;size, <span class="hljs-built_in">sizeof</span>(size));<br>  result[<span class="hljs-number">4</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(code);<br>  std::<span class="hljs-built_in">memcpy</span>(result + <span class="hljs-number">5</span>, msg.<span class="hljs-built_in">data</span>(), len);<br>  <span class="hljs-keyword">if</span> (len2) {<br>    result[<span class="hljs-number">5</span> + len1] = <span class="hljs-string">':'</span>;<br>    result[<span class="hljs-number">6</span> + len1] = <span class="hljs-string">' '</span>;<br>    std::<span class="hljs-built_in">memcpy</span>(result + <span class="hljs-number">7</span> + len1, msg2.<span class="hljs-built_in">data</span>(), len2);<br>  }<br>  state_ = result;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h2 id="24-编码"><a class="markdownIt-Anchor" href="#24-编码"></a> 2.4: 编码</h2><p>leveldb中分为定长和变长编码，其中变长编码目的是为了减少空间占用。其基本思想是：每一个Byte最高位bit用0/1表示该整数是否结束，用剩余7bit表示实际的数值，在protobuf中被广泛使用。<br>见函数char* EncodeVarint32(char* dst, uint32_t v)</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211191926917.png" alt=""></p><h2 id="25-option"><a class="markdownIt-Anchor" href="#25-option"></a> 2.5: Option</h2><p>Option记录了leveldb中参数信息</p><p>![[Leveldb options.excalidraw]]</p><h2 id="26-skiplist"><a class="markdownIt-Anchor" href="#26-skiplist"></a> 2.6: <strong>skiplist</strong></h2><h3 id="261-常规线段跳表"><a class="markdownIt-Anchor" href="#261-常规线段跳表"></a> 2.6.1: <strong>常规线段跳表</strong></h3><p>• 定义</p><p>是一种可以代替平衡树的数据结构，可以看做是<strong>并联的有序链表</strong>。<br>跳跃表通过概率保证平衡，而平衡树采用严格的旋转来保证平衡，因此跳跃表比较容易实现，而且相比平衡树有着较高的运行效率。<br>其中Redis默认的最大level为64。<br>用跳表是因为好并发</p><p>![[线段跳表 .excalidraw]]</p><h3 id="262-redis中的线段跳表"><a class="markdownIt-Anchor" href="#262-redis中的线段跳表"></a> 2.6.2: Redis中的线段跳表</h3><p>redis源码: 了解一下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZSKIPLIST_MAXLEVEL 64 <span class="hljs-comment">/* Should be enough for 2^64 elements */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZSKIPLIST_P 0.25 <span class="hljs-comment">/* Skiplist P = 1/4 */</span></span><br><br><span class="hljs-comment">//可能一个节点会存在多层</span><br><span class="hljs-comment">/* ZSETs use a specialized version of Skiplists */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> {<br> sds ele;<span class="hljs-comment">//成员对象</span><br> <span class="hljs-type">double</span> score;<span class="hljs-comment">//各个节点中分值，在跳跃表中，节点按各自所保存的分值从小到大排列</span><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *backward;<span class="hljs-comment">//指向位于当前节点的前一个节点。后退指针在程序从表尾想表头遍历时使用</span><br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistLevel</span> {<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *forward;<span class="hljs-comment">//用于访问位于表尾方向的其他节点，当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;<span class="hljs-comment">//跨度，他和遍历操作无关，forward才是用来遍历操作的。跨度实际上是用来计算排位的。</span><br> } level[];<br>} zskiplistNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplist</span> {<br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">zskiplistNode</span> *header, *tail;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;<span class="hljs-comment">//节点个数</span><br> <span class="hljs-type">int</span> level;<span class="hljs-comment">//总层数</span><br>} zskiplist;<br><br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211191945582.png" alt=""></p><p>• 特点</p><ol><li>排序按照score来排序，如果是score相等，那么则按照ele来排序</li><li>平均查询时间复杂度为O(logn)。<br>• 常见操作</li><li>level计算</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZSKIPLIST_MAXLEVEL 64 <span class="hljs-comment">/* Should be enough for 2^64 elements */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ZSKIPLIST_P 0.25 <span class="hljs-comment">/* Skiplist P = 1/4 */</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">zslRandomLevel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{<br> <span class="hljs-type">int</span> level = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">random</span>()&amp;<span class="hljs-number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="hljs-number">0xFFFF</span>))<br> level += <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">由上式可以，假设level每增加一层的概率为p。<br>节点层数为<span class="hljs-number">1</span>，概率<span class="hljs-number">1</span>-p<br>节点层数为<span class="hljs-number">2</span>，概率p(<span class="hljs-number">1</span>-p)<br>节点层数为<span class="hljs-number">3</span>，概率p*<span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-number">1</span>-p)</span><br>节点层数为4，概率<span class="hljs-title function_">ppp</span><span class="hljs-params">(<span class="hljs-number">1</span>-p)</span><br>…<br>节点平均层数为=<span class="hljs-number">1</span>(<span class="hljs-number">1</span>-p)+<span class="hljs-number">2</span>(<span class="hljs-number">1</span>-p)p+<span class="hljs-number">3</span>pp(<span class="hljs-number">1</span>-p)+…=<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>-p)，带入redis的<span class="hljs-number">0.25</span>，计算出每个节点的平均指针数<span class="hljs-number">1.33</span><br><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>插入<br>排序按照score来排序，如果是score相等，那么则按照ele来排序<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211191947146.png" alt=""></li><li>查找和删除旧不再给出了</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>leveldb</category>
      
      <category>1. Leveldb源码解读(一）</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双写缓冲区</title>
    <link href="/posts/10403/"/>
    <url>/posts/10403/</url>
    
    <content type="html"><![CDATA[<p>📝双写缓冲区:: #疑问</p><!-- basicblock-end --><p>双写缓冲区<br>Doublewrite Buffer Files<br>双写缓冲区，innoDB 引擎将数据页从 Buffer Pool 刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142231564.png" alt=""></p><p>![[InnoDB磁盘结构图.excalidraw|1000]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>change buffer</title>
    <link href="/posts/1733/"/>
    <url>/posts/1733/</url>
    
    <content type="html"><![CDATA[<p>📝change buffer::</p><!-- basicblock-end --><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），<br>在执行 DML 语句时，如果这些数据 Page 没有在 Buffer Pool 中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，</p><p><strong>在未来数据被读取时</strong>，再将数据更改, 合并到到 Buffer Pool 中，再将合并后的数据刷新到磁盘中。</p><ul><li>当需要更新⼀个数据页：<ul><li>如果数据页在内存中就直接更新</li><li>如果不在<strong>内存</strong>中，在不影响数据⼀致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中。</li></ul></li></ul><p>下次查询需要访问这个数据页的时候，将数据页读⼊内存，然后执⾏ change buffer 中的与这个页有关的操作。</p><p>![[Change Buffer的意义是什么?.excalidraw]]</p><h1 id="1-作用"><a class="markdownIt-Anchor" href="#1-作用"></a> 1: 作用</h1><p>change buffer 是可以持久化的数据。在内存中有拷贝，也会被写⼊到磁盘上</p><p>purge：将 change buffer 中的操作应⽤到原数据页上，得到最新结果的过程，成为 purge<br>访问这个数据页会触发 purge，系统有后台线程定期 purge，在数据库正常关闭的过程中，也会执⾏ purge</p><p>change buffer ⽤的是 buffer pool ⾥的内存，change buffer 的⼤⼩，可以通过参数 innodb_change_buffer_max_size 来动态设置。<br>这个参数设置为 50 的时候，表⽰ change buffer 的⼤⼩最多只能占⽤ buffer pool 的 50%。<br>将数据从磁盘读⼊内存涉及随机 IO 的访问，是数据库⾥⾯成本最⾼的操作之⼀。<br>change buffer 因为减少了随机磁盘访问，所以对更新性能的提升很明显。</p><p>redo log 主要节省的是<strong>随机写</strong>磁盘的 IO 消耗 (转成顺序写)，⽽change buffer 主要节省的则是<strong>随机读</strong>磁盘的 IO 消耗。</p><h1 id="2-使用场景"><a class="markdownIt-Anchor" href="#2-使用场景"></a> 2: 使⽤场景：</h1><p>在⼀个数据页做 purge 之前，change buffer 记录的变更越多，收益就越⼤。</p><p>对于写多读少的业务来说，页⾯在写完以后马上被访问到的概率⽐较⼩，此时 change buffer 的使⽤效果最好。<br>这种业务模型常见的就是账单类、⽇志类的系统。</p><p>反过来，假设⼀个业务的更新模式是写⼊之后马上会做查询，那么即使满⾜了条件，将更新先记录在 change buffer, 但之后由于马上要访问这个数据页，会⽴即触发 purge 过程。<br>这样随机访问 IO 的次数不会减少，反⽽增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反⽽起到了副作⽤。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>广度优先遍历</title>
    <link href="/posts/4605/"/>
    <url>/posts/4605/</url>
    
    <content type="html"><![CDATA[<p>📝广度优先遍历::</p><!-- basicblock-end --><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong><br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif" alt="102二叉树的层序遍历"></p><ol><li><strong>特例处理：</strong> 当根节点为空，则返回空列表 <code>[]</code> ；</li><li><strong>初始化：</strong> 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li><li><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；<ol><li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li><li><strong>当前层打印循环：</strong> 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；<ol><li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li><li><strong>打印：</strong> 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li><li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li></ol></li><li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li></ol></li><li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 加入第一层元素</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<span class="hljs-comment">// 结果集</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//  获取本层元素个数, </span><br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) { <span class="hljs-comment">// 逐个弹出本层元素, 并把每个弹出节点的左右孩子加入进来, 直至弹完本层元素</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<span class="hljs-comment">// for 循环出来后, que 中已经是下层元素了. 在进行一次 while 循环后会在获得这层元素, 反复如此, 直至队列为空</span><br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            temp.<span class="hljs-built_in">clear</span>();<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!note] 复杂度分析</p><ul><li>时间复杂度 O (N)：N 为二叉树的节点数量，即 BFS 需循环 N 次。</li><li>空间复杂度 O (N)：最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O (N) 大小的额外空间。<ul><li>❓不懂</li></ul></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>637.二叉树的层平均值</title>
    <link href="/posts/61789/"/>
    <url>/posts/61789/</url>
    
    <content type="html"><![CDATA[<p>📝637.二叉树的层平均值::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">力扣题目链接</a><br>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p><img src="https://img-blog.csdnimg.cn/20210203151350500.png" alt="637.二叉树的层平均值"></p><p>思路:</p><p>本题就是层序遍历的时候把一层求个总和在取一个均值<br>已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        vector&lt;<span class="hljs-type">double</span>&gt; result;<span class="hljs-comment">// ❗️此时的 result 不是 int, 返回值是 double</span><br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">// ❗️返回值是 double 变量</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                sum += node-&gt;val;<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(sum/size);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>199.二叉树的右视图</title>
    <link href="/posts/38224/"/>
    <url>/posts/38224/</url>
    
    <content type="html"><![CDATA[<p>📝199.二叉树的右视图::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">力扣题目链接</a></p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><img src="https://img-blog.csdnimg.cn/20210203151307377.png" alt="199.二叉树的右视图"></p><p>思路：</p><p>层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// 💡只需要一个元素, 就只是一维数组就行了</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == (size - <span class="hljs-number">1</span>)) result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 💡最后一个元素, 因为下标从 0 开始的</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">if</span>(i == size<span class="hljs-number">-1</span>) result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right)que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>107.二叉树的层次遍历II</title>
    <link href="/posts/43648/"/>
    <url>/posts/43648/</url>
    
    <content type="html"><![CDATA[<p>📝107.二叉树的层次遍历II::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">力扣题目链接</a><br>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><img src="https://img-blog.csdnimg.cn/20210203151058308.png" alt="107.二叉树的层次遍历II"></p><p>最后反转一下 result 数组即可</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 已通过</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>) que.<span class="hljs-built_in">push</span>(root);<span class="hljs-comment">// 💡que 是 push</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){ <span class="hljs-comment">// ❗️要有!, 是不为空的情况</span><br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// ❗️要加入, 别忘了</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp; <span class="hljs-comment">// ❗️不能放到 while 外边, 下边的 while 每用一次都要重置的, 放到大 while 外边就一直往里添东西了</span><br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right)que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>32.1.从上到下打印二叉树</title>
    <link href="/posts/48451/"/>
    <url>/posts/48451/</url>
    
    <content type="html"><![CDATA[<p>📝32. 从上到下打印二叉树::</p><!-- basicblock-end --><p>思路:  [[广度优先遍历]]</p><h1 id="1-输出-vectorint"><a class="markdownIt-Anchor" href="#1-输出-vectorint"></a> 1: 输出 <code>vector&lt;int&gt;</code></h1><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">例如:  <br>给定二叉树:&nbsp;`[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]`,<br><br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>返回：<br><br>[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></tbody></table></figure><p>模板题</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 加入第一层元素</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<span class="hljs-comment">// 结果集</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//  获取本层元素个数, </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) { <span class="hljs-comment">// 逐个弹出本层元素, 并把每个弹出节点的左右孩子加入进来, 直至弹完本层元素</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<span class="hljs-comment">// for 循环出来后, que 中已经是下层元素了. 在进行一次 while 循环后会在获得这层元素, 反复如此, 直至队列为空</span><br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-输出-vectorvectorint"><a class="markdownIt-Anchor" href="#2-输出-vectorvectorint"></a> 2: 输出 <code>vector&lt;vector&lt;int&gt;&gt;</code></h1><p>32.2<a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">Loading Question… - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><br>例如:  <br>给定二叉树:&nbsp;`[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]`,<br><br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>返回其层次遍历结果：<br><br>[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 加入第一层元素</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<span class="hljs-comment">// 结果集</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//  获取本层元素个数, </span><br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) { <span class="hljs-comment">// 逐个弹出本层元素, 并把每个弹出节点的左右孩子加入进来, 直至弹完本层元素</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<span class="hljs-comment">// for 循环出来后, que 中已经是下层元素了. 在进行一次 while 循环后会在获得这层元素, 反复如此, 直至队列为空</span><br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            temp.<span class="hljs-built_in">clear</span>();<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="3-之字形打印二叉树"><a class="markdownIt-Anchor" href="#3-之字形打印二叉树"></a> 3: 之字形打印二叉树</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。<br><br>例如:  <br>给定二叉树:&nbsp;`[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,null,null,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]`,<br><br>    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  \<br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>返回其层次遍历结果：<br><br>[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></tbody></table></figure><p>思路: 层序遍历 + 倒序</p><ul><li><p>此方法的优点是只用列表即可，无需其他数据结构。</p></li><li><p><strong>偶数层倒序：</strong> 若 <code>res</code> 的长度为 <strong>奇数</strong> ，说明当前是偶数层，则对 <code>tmp</code> 执行 <strong>倒序</strong> 操作。</p></li><li><p><strong>时间复杂度 O(N) ：</strong> N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O (1) 。</p></li><li><p><strong>空间复杂度 O(N) ：</strong> 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 <strong>同时</strong> 在 <code>deque</code> 中，使用 O(N) 大小的额外空间。</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">// 加入第一层元素</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<span class="hljs-comment">// 结果集</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//  获取本层元素个数, </span><br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) { <span class="hljs-comment">// 逐个弹出本层元素, 并把每个弹出节点的左右孩子加入进来, 直至弹完本层元素</span><br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<span class="hljs-comment">// for 循环出来后, que 中已经是下层元素了. 在进行一次 while 循环后会在获得这层元素, 反复如此, 直至队列为空</span><br>            <span class="hljs-comment">// 💡在这里</span><br>            <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){<br>                <span class="hljs-built_in">reverse</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>());<br>            }<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br><br>            temp.<span class="hljs-built_in">clear</span>();<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>31.栈的压入、弹出序列</title>
    <link href="/posts/33337/"/>
    <url>/posts/33337/</url>
    
    <content type="html"><![CDATA[<p>📝31.栈的压入、弹出序列::<a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>![[31.栈的压入、弹出序列 2022-11-18 16.38.08.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pushed, vector&lt;<span class="hljs-type">int</span>&gt;&amp; popped)</span> </span>{<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pushed.<span class="hljs-built_in">size</span>(); i++){<br>            st.<span class="hljs-built_in">push</span>(pushed[i]);<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == popped[j]){<br>                st.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            }<br>        }<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stack</title>
    <link href="/posts/64039/"/>
    <url>/posts/64039/</url>
    
    <content type="html"><![CDATA[<p>📝stack::</p><!-- basicblock-end --><h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1: 原理:</h1><p>栈先进后出<br><img src="https://img-blog.csdnimg.cn/20210104235434905.png" alt="栈与队列理论2|400"></p><p>栈是先进后出, 队列是先进先出。<br>![[1. 栈与队列理论基础 2022-08-22 14.08.54.excalidraw|400]]</p><h1 id="2-深层问题"><a class="markdownIt-Anchor" href="#2-深层问题"></a> 2: 深层问题</h1><h2 id="21-我们使用的-stack-是属于哪个版本的-stl"><a class="markdownIt-Anchor" href="#21-我们使用的-stack-是属于哪个版本的-stl"></a> 2.1: [[我们使用的 stack 是属于哪个版本的 STL？]]</h2><h1 id="3-stack-的原理"><a class="markdownIt-Anchor" href="#3-stack-的原理"></a> 3: stack 的原理</h1><p>栈的底层实现可以是<strong>vector，deque，list</strong> 都是可以的，<br>一般都是用 deque, 因为 deque 是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。<br><img src="https://img-blog.csdnimg.cn/20210104235459376.png" alt="栈与队列理论3|600"></p><p><strong>我们常用的 SGI STL，如果没有指定底层实现的话，默认是以 deque 为缺省情况下栈的底层结构。</strong><br><strong>SGI STL 中队列底层实现缺省情况下一样使用 deque 实现的。</strong></p><p>我们也可以指定 vector 为栈的底层实现，初始化语句如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; third;  <span class="hljs-comment">// 使用vector为底层容器的栈</span><br></code></pre></td></tr></tbody></table></figure><p>刚刚讲过栈的特性，对应的队列的情况是一样的。<br>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, <strong>SGI STL 中队列一样是以 deque 为缺省情况下的底部结构。</strong><br>也可以指定 list 为起底层实现，初始化 queue 的语句如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; third; <span class="hljs-comment">// 定义以list为底层容器的队列</span><br></code></pre></td></tr></tbody></table></figure><h2 id="31-源码"><a class="markdownIt-Anchor" href="#31-源码"></a> 3.1: 源码</h2><p>stack这种单向开口的数据结构很容易由<strong>双向开口的deque和list</strong>形成，<br>只需要根据stack的性质对应移除某些接口即可实现，stack的源码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt; <span class="hljs-comment">// 源码是 deque</span><br><span class="hljs-keyword">class</span> stack<br>{<br>...<br><span class="hljs-keyword">protected</span>:<br>    Sequence c;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 去除了一些功能, 保留下一些功能</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">empty</span>();}<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">size</span>();}<br>    <span class="hljs-function">reference <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">back</span>();}<br>    <span class="hljs-function">const_reference <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>{<span class="hljs-keyword">return</span> c.<span class="hljs-built_in">back</span>();}<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; x)</span></span>{c.<span class="hljs-built_in">push_back</span>(x);}<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>{c.<span class="hljs-built_in">pop_back</span>();}<br>};<br></code></pre></td></tr></tbody></table></figure><p>从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而Sequence默认是deque数据结构。</p><p>stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数.</p><p>**栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的<br>（也就是说我们可以控制使用哪种容器来实现栈的功能）。<br>**<br><strong>stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为container adapter而非container</strong><br>所以 STL 队列也不被归类为容器，而被归类为 container adapter（ 容器适配器）。</p><h2 id="32-stack-提供迭代器来遍历-stack-空间么"><a class="markdownIt-Anchor" href="#32-stack-提供迭代器来遍历-stack-空间么"></a> 3.2: stack 提供迭代器来遍历 stack 空间么？::</h2><p>由于stack只能操作顶端的元素，因此其内部元素无法被访问，不能提供迭代器。</p><p>不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素。(这里可能说的是 set, map 里类似的 find 函数)</p><h1 id="4-复杂度"><a class="markdownIt-Anchor" href="#4-复杂度"></a> 4: 复杂度</h1><p>普通栈的 push () 和 pop (）函数的复杂度为 O (1）；<br>而获取栈最小值 min () 函数需要遍历整个栈，复杂度为 O(N)。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>30.包含min函数的栈</title>
    <link href="/posts/29708/"/>
    <url>/posts/29708/</url>
    
    <content type="html"><![CDATA[<p>📝30.包含min函数的栈::<a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/submissions/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><ul><li>push(x)函数：重点为保持栈 B的元素是 非严格降序的。<ul><li>1.将x压入栈 A（即 A.add(x) ）；</li><li><ol start="2"><li>保持两个栈的数量相同</li></ol><ul><li>若 x 小于等于栈 B 的栈顶元素，则压入 B 栈</li><li>否则则将 B 的栈顶元素再次压入栈</li></ul></li></ul></li><li>pop() 函数：重点为保持栈 A,B的元素一致性。<ul><li>A, B 同时弹出栈顶元素</li></ul></li><li>top() 函数：直接返回栈 A 的栈顶元素即可</li><li>min() 函数：直接返回栈 B 的栈顶元素即可</li></ul><p><img src="https://pic.leetcode-cn.com/1628245226-xNbNUW-GIF%202021-8-6%2018-17-13.gif" alt="GIF 2021-8-6 18-17-13.gif"><br>![[30.包含min函数的栈 2022-11-18 16.11.53.excalidraw]]</p><p><img src="https://pic.leetcode-cn.com/1628245428-cWDvKW-GIF%202021-8-6%2018-23-10.gif" alt="GIF 2021-8-6 18-23-10.gif"></p><p>[[stack]]</p><p>通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    stack&lt;<span class="hljs-type">int</span>&gt;data;<br>    stack&lt;<span class="hljs-type">int</span>&gt;currMin;<br>    <span class="hljs-built_in">MinStack</span>() {<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<br>        data.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span> (currMin.<span class="hljs-built_in">empty</span>() || x &lt;= currMin.<span class="hljs-built_in">top</span>() ) currMin.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currMin.<span class="hljs-built_in">empty</span>() || x &gt; currMin.<span class="hljs-built_in">top</span>()) currMin.<span class="hljs-built_in">push</span>(currMin.<span class="hljs-built_in">top</span>());<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{<br>        data.<span class="hljs-built_in">pop</span>();          <br>        currMin.<span class="hljs-built_in">pop</span>();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">top</span>();<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">if</span> (!currMin.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> currMin.<span class="hljs-built_in">top</span>();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>if else 函数</title>
    <link href="/posts/20436/"/>
    <url>/posts/20436/</url>
    
    <content type="html"><![CDATA[<p>📝if else 函数::</p><!-- basicblock-end --><p>多个 if 条件语句要用 else if 连接起来<br>不然有可能报错: [[14-1. 剪绳子]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">没有考虑到所有的情况<br>Line <span class="hljs-number">9</span>: Char <span class="hljs-number">5</span>: error: non-<span class="hljs-type">void</span> function does <span class="hljs-keyword">not</span> <span class="hljs-keyword">return</span> a value in all control paths [-Werror,-Wreturn-type]<br>    }<br>    ^<br><span class="hljs-number">1</span> error generated.<br><br></code></pre></td></tr></tbody></table></figure><p>只有两个极端情况, 可以用三元运算符代替</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>水平分库分表</title>
    <link href="/posts/26338/"/>
    <url>/posts/26338/</url>
    
    <content type="html"><![CDATA[<p>📝水平分库分表::</p><!-- basicblock-end --><p>![[分库分表 水平拆分.excalidraw]]</p><h1 id="1-水平分表"><a class="markdownIt-Anchor" href="#1-水平分表"></a> 1: ⽔平分表</h1><p>需求：</p><p>当⼀张表的数据达到⼏千万时，查询⼀次所花的时间长，需要进⾏优化，缩短查询时间</p><p>都是⼤表拆⼩表</p><p>垂直分表：表结构拆分</p><p>⽔平分表：数据拆分</p><p>⽔平分表：</p><p>把⼀个表的数据分到⼀个数据库的多张表中，每个表只有这个表的部分数据，核⼼是把⼀个 ⼤表，分割 N 个⼩表，每个表的结构是⼀样的，数据不⼀样，全部表的数据合起来就是全部数据</p><p>针对数据量巨⼤的单张表（⽐如订单表），按照某种规则（RANGE,HASH 取模等），切分到多张表⾥⾯去，但是这些表还是在同⼀个库中，所以单数据库操作还是有 IO 瓶颈，主要是解决单表数据量过⼤的问题</p><p>减少锁表时间，没分表前，如果是DDL(create/alter/add等)语句，当需要添加⼀列的时候 mysql会锁表，期间所有的读写操作只能等待</p><h1 id="2-水平分库"><a class="markdownIt-Anchor" href="#2-水平分库"></a> 2: ⽔平分库</h1><p>需求：</p><p>⾼并发的项⽬中，⽔平分表后依旧在单个库上⾯，1个数据库资源瓶颈 CPU/内存/带宽等限 制导致响应慢，需要进⾏优化</p><p>⽔平分库： 把同个表的数据按照⼀定规则分到不同的数据库中，数据库在不同的服务器上。</p><p>⽔平分库是把不同表拆到不同数据库中，它是对数据⾏的拆分，不影响表结构，每个库的结 构都⼀样,但每个库的数据都不⼀样，没有交集，所有库的并集就是全量数据</p><p>⽔平分库的粒度，⽐⽔平分表更⼤</p><h1 id="3-总结水平角度表结构一样"><a class="markdownIt-Anchor" href="#3-总结水平角度表结构一样"></a> 3: 总结⽔平⾓度（表结构⼀样）</h1><p>⽔平分库：</p><p>把同个表的数据按照⼀定规则分到不同的数据库中，数据库在不同的服务器上</p><p>好处：</p><p>多个数据库，降低了系统的IO和CPU压⼒</p><p>原则：</p><p>选择合适的分⽚键和分⽚策略，和业务场景配合 避免数据热点和访问不均衡、避免⼆次扩容难度⼤</p><p>⽔平分表：</p><p>同个数据库内，把⼀个表的数据按照⼀定规则拆分到多个表中，对数据进⾏拆分， 不影响表结构 单个表的数据量少了，业务SQL执⾏效率⾼，降低了系统的IO和CPU压⼒</p><p>原则：</p><p>选择合适的分⽚键和分⽚策略，和业务场景配合 避免数据热点和访问不均衡、避免⼆次扩容难度⼤</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>垂直分库分表</title>
    <link href="/posts/22872/"/>
    <url>/posts/22872/</url>
    
    <content type="html"><![CDATA[<p>📝垂直分库分表::</p><!-- basicblock-end --><blockquote><p>[!principle]<br>![[分库分表 垂直拆分.excalidraw]]</p></blockquote><h1 id="1-垂直分表"><a class="markdownIt-Anchor" href="#1-垂直分表"></a> 1: 垂直分表</h1><p>需求：商品表字段太多，每个字段访问频次不⼀样，浪费了IO资源，需要进⾏优化</p><p>垂直分表介绍：</p><p>也就是“⼤表拆⼩表”，基于列字段进⾏的，拆分原则⼀般是表中的字段较多，</p><ul><li>将不常⽤的或者数据较⼤，长度较长的拆分到“扩展表如 text 类型字段，</li><li>访问频次低、字段⼤的商品描述信息单独存放在⼀张表中，</li><li>访问频次较⾼的商品基本信息单独放在⼀张表中。</li></ul><p>垂直拆分原则：</p><ol><li>把不常⽤的字段单独放在⼀张表;</li><li>把text，blob等⼤字段拆分出来放在附表中;</li><li>业务经常组合查询的列放在⼀张表中</li></ol><h1 id="2-垂直分库"><a class="markdownIt-Anchor" href="#2-垂直分库"></a> 2: 垂直分库</h1><p>需求：C端项⽬⾥⾯，单个数据库的CPU、内存长期处于90%+的利⽤率，数据库连接经常不够，需 要进⾏优化</p><p>垂直分库讲解：</p><p>垂直分库针对的是⼀个系统中的不同业务进⾏拆分， 数据库的连接资源⽐较宝贵且单机处 理能⼒也有限，没拆分之前全部都是落到单⼀的库上的，单库处理能⼒成为瓶颈，还有磁盘 空间，内存，tps等限制</p><p>拆分之后，避免不同库竞争同⼀个物理机的CPU、内存、⽹络IO、磁盘，所以在⾼并发场 景下，垂直分库⼀定程度上能够突破IO、连接数及单机硬件资源的瓶颈</p><p>垂直分库可以更好解决业务层⾯的耦合，业务清晰，且⽅便管理和维护</p><p>⼀般从单体项⽬升级改造为微服务项⽬，就是垂直分库</p><p>仍然存在的问题：</p><p>垂直分库分表可以提⾼并发，但是依然没有解决单表数据量过⼤的问题</p><h1 id="3-总结垂直角度表结构不一样"><a class="markdownIt-Anchor" href="#3-总结垂直角度表结构不一样"></a> 3: 总结垂直⾓度（表结构不⼀样）</h1><h2 id="31-垂直分表"><a class="markdownIt-Anchor" href="#31-垂直分表"></a> 3.1: 垂直分表：</h2><p>将⼀个表字段拆分多个表，每个表存储部分字段</p><p>好处：</p><p>避免IO时锁表的次数，分离热点字段和⾮热点字段，避免⼤字段IO导致性能下降</p><p>原则：</p><p>业务经常组合查询的字段⼀个表；不常⽤字段⼀个表；text、blob 类型字段作为附属表</p><h2 id="32-垂直分库"><a class="markdownIt-Anchor" href="#32-垂直分库"></a> 3.2: 垂直分库：</h2><p>根据业务将表分类，放到不同的数据库服务器上</p><p>好处：<br>避免表之间竞争同个物理机的资源，⽐如 CPU/内存/硬盘/⽹络 IO</p><p>原则：<br>根据业务相关性进⾏划分，领域模型，微服务划分⼀般就是垂直分库</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>隐藏字段</title>
    <link href="/posts/47644/"/>
    <url>/posts/47644/</url>
    
    <content type="html"><![CDATA[<p>📝隐藏字段::</p><!-- basicblock-end --><p>隐藏字段<br>聚簇索引记录中有两个必要的隐藏列：<br><strong>trx_id</strong>：用来存储每次对某条聚簇索引记录进行修改的时候的事务 id。<br><strong>roll_pointer</strong>：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入 undo 日志中。<br>这个 roll_pointer 就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的 undo 日志没有这个属性，因为它没有老版本)<br>‌‌‌![[mvcc 2022-11-15 15.20.59.excalidraw]]<br><a href="marginnote3app://note/8DF982E3-4423-4613-8936-D415D6F6272A">margin: 测试隐藏字段</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>29.顺时针打印矩阵</title>
    <link href="/posts/63844/"/>
    <url>/posts/63844/</url>
    
    <content type="html"><![CDATA[<p>📝29.顺时针打印矩阵::<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[6.螺旋矩阵II]]</p><p>‌‌‌　　‌‌‌　　![[29.顺时针打印矩阵 2022-11-17 17.03.27.excalidraw]]</p><h1 id="1-算法流程"><a class="markdownIt-Anchor" href="#1-算法流程"></a> 1: 算法流程：</h1><ol><li><strong>空值处理：</strong> 当 <code>matrix</code> 为空时，直接返回空列表 <code>{ }</code> 即可。</li><li><strong>初始化：</strong> 矩阵 左、右、上、下 四个边界 <code>l</code> , <code>r</code> , <code>t</code> , <code>b</code> ，用于打印的结果列表 <code>res</code> 。</li><li><strong>循环打印：</strong> “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表）_；<ol><li>根据边界打印，即将元素按顺序添加至列表 <code>res</code> 尾部；</li><li>边界向内收缩 1 （代表已被打）；</li><li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li></ol></li><li><strong>返回值：</strong> 返回 <code>res</code> 即可。</li></ol><ul><li>时间复杂度 O (MN) ： M,N 分别为矩阵行数和列数。<ul><li>要操作每一个元素: eg 3×3 矩阵, 要操作 9 次</li></ul></li><li>空间复杂度 O (1)  ： 四个边界 l , r , t , b 使用常数大小的额外空间（ res 为必须使用的空间）。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> {};<span class="hljs-comment">// ❗️vector得使用 empty() 不能用!matrix</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;                      <span class="hljs-comment">//左边界</span><br>        <span class="hljs-type">int</span> r = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;   <span class="hljs-comment">//右边界</span><br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;                      <span class="hljs-comment">//上边界</span><br>        <span class="hljs-type">int</span> b = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;      <span class="hljs-comment">//下边界</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        {<br>            <span class="hljs-comment">//left -&gt; right</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) res.<span class="hljs-built_in">push_back</span>(matrix[t][i]);<br>            <span class="hljs-keyword">if</span> (++t &gt; b) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// break 直接跳出 while 循环</span><br>            <span class="hljs-comment">//top -&gt; bottom</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t; i &lt;= b; i++) res.<span class="hljs-built_in">push_back</span>(matrix[i][r]);<br>            <span class="hljs-keyword">if</span> (--r &lt; l) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//right -&gt; left</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &gt;= l; i--) res.<span class="hljs-built_in">push_back</span>(matrix[b][i]);<br>            <span class="hljs-keyword">if</span> (--b &lt; t) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//bottom -&gt; top</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b; i &gt;= t; i--) res.<span class="hljs-built_in">push_back</span>(matrix[i][l]);<br>            <span class="hljs-keyword">if</span> (++l &gt; r) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>100. 相同的树</title>
    <link href="/posts/28565/"/>
    <url>/posts/28565/</url>
    
    <content type="html"><![CDATA[<p>📝100. 相同的树::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a><br>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt=""></p><p>输入：p = [1,2,3], q = [1,2,3]<br>输出：true</p><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt=""></p><p>输入：p = [1,2], q = [1,null,2]<br>输出：false</p><h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1: 思路::</h1><p>[[8. 对称二叉树]], 稍作修改即可<br>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* tree1, TreeNode* tree2)</span> </span>{<br>        <span class="hljs-keyword">if</span> (tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree1 != <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree1-&gt;val != tree2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 注意这里我没有使用else</span><br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-type">bool</span> compareLeft = <span class="hljs-built_in">compare</span>(tree1-&gt;left, tree2-&gt;left);       <span class="hljs-comment">// 左子树：左、 右子树：左</span><br>        <span class="hljs-type">bool</span> compareRight = <span class="hljs-built_in">compare</span>(tree1-&gt;right, tree2-&gt;right);    <span class="hljs-comment">// 左子树：右、 右子树：右</span><br>        <span class="hljs-type">bool</span> isSame = compareLeft &amp;&amp; compareRight;                  <span class="hljs-comment">// 左子树：中、 右子树：中（逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(p, q);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v1 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span> <span class="hljs-params">(TreeNode* tree1 , TreeNode* tree2)</span></span>{<br>        <span class="hljs-keyword">if</span>(tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree1 != <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree1 == <span class="hljs-literal">NULL</span> &amp;&amp; tree2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// ❗️不要忘了两个都是空的情况, ❗️要在比较 val 值的上边, 不然下边操作空指针了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree1-&gt;val != tree2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><br>        <span class="hljs-type">bool</span> compareleft = <span class="hljs-built_in">compare</span>(tree1-&gt;left, tree2-&gt;left);<span class="hljs-comment">// 💡比较他俩相同位置的节点</span><br>        <span class="hljs-type">bool</span> compareright = <span class="hljs-built_in">compare</span>(tree1-&gt;right, tree2-&gt;right);<br>        <span class="hljs-type">bool</span> isSame = compareleft &amp;&amp; compareright;<br>        <span class="hljs-keyword">return</span> isSame;<span class="hljs-comment">// 💡每一个节点得到结果都返回一次 </span><br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(p ,q);<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28. 对称的二叉树</title>
    <link href="/posts/5839/"/>
    <url>/posts/5839/</url>
    
    <content type="html"><![CDATA[<p>📝28. 对称的二叉树::<a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/solution/">剑指 Offer 28. 对称的二叉树 题解 - 力扣（LeetCode）</a></p><!-- basicblock-end --><blockquote><p>[!参考资料]<br>[[8. 对称二叉树]]<br>[[对称性递归]]<br>[[递归目录]]<br><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/">Loading Question… - 力扣（LeetCode）</a></p></blockquote><h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1: 思路：</h1><p>构造一个辅助函数判断两棵树是否是镜像对称的，</p><blockquote><p>[!tip] 比较两棵树是否镜像对称，<br>即一棵树的左子树和另一棵树的右子树，<br>及一棵树的右子树和另一棵树的左子树<br>是否镜像对称</p></blockquote><p><strong>特殊判断</strong>：都是空树满足条件；其中有一棵空树不满足条件</p><p>isSymmetric (root)<br>特例处理：若根节点 root 为空，则直接返回 true<br>返回值：即 recur (root. left, root. right)<br>recur(L, R):<br>终止条件：<br>当工和 R 同时越过叶节点：此树从顶至底的节点都对称，因此返回 true<br>当工或 R 中只有一个越过叶节点： 此树不对称，因此返回 false<br>当节点L值≠节点 R 值：此树不对称，因此返回 false<br>递推工作：<br>判断两节点 L.left 和 R.right 是否对称，即 recur (L. Left, R. right）；<br>判断两节点 L.right 和 R.left 是否对称，即 recur (L.right, R. Left)<br>返回值：<br>两对节点都对称时，才是对称树，因此用与逻辑符 8&amp; 连接。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 此函数比较二叉树中位置对称的两个节点</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>{<br>        <span class="hljs-comment">// 结束条件1：如果对称两个节点都为空，则返回true</span><br>        <span class="hljs-keyword">if</span>(!left &amp;&amp; !right){<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-comment">// 结束条件2：如果单独一个节点为空，另一个节点不为空，又或者是对称节点间的val值不等，则返回false</span><br>        <span class="hljs-keyword">if</span>(!left || !right || left-&gt;val != right-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 该层符合对称二叉树的要求，开始比较下一层</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="hljs-built_in">isSymmetric</span>(left-&gt;right, right-&gt;left);      <br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-comment">// 如果是空树</span><br>        <span class="hljs-keyword">if</span>(!root)<span class="hljs-comment">// if(!0) 进入循环</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);<br>    }<br>    <br><br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>27.二叉树的镜像</title>
    <link href="/posts/9080/"/>
    <url>/posts/9080/</url>
    
    <content type="html"><![CDATA[<p>📝27.二叉树的镜像::<a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[前中后序遍历]]<br>[[6. 反转二叉树]]</p><h1 id="1-前序遍历"><a class="markdownIt-Anchor" href="#1-前序遍历"></a> 1: 前序遍历</h1><ul><li>[ ] 觉得 swap 的复杂度要高点</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// ❓</span><br>    }<br>        <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root);<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2:</h1><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/solution/mian-shi-ti-27-er-cha-shu-de-jing-xiang-di-gui-fu-/">Loading Question… - 力扣（LeetCode）</a></p><p>不是很懂哎</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mirrorTree</span> <span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* tmp = root-&gt;left;<br>        root-&gt;left = <span class="hljs-built_in">mirrorTree</span> (root-&gt;right);<br>        root-&gt;right = <span class="hljs-built_in">mirrorTree</span> (tmp);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称性递归解题模板</title>
    <link href="/posts/23822/"/>
    <url>/posts/23822/</url>
    
    <content type="html"><![CDATA[<p>📝对称性递归解题模板::</p><!-- basicblock-end --><h1 id="1-递归结束条件"><a class="markdownIt-Anchor" href="#1-递归结束条件"></a> 1: 递归结束条件</h1><p>特殊情况的判断<br>如果是单树问题，一般来说只要进行以下判断：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>; <br><span class="hljs-keyword">if</span>(!root-&gt;left) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>/递归函数; <br><span class="hljs-keyword">if</span>(!root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>/递归函数;<br></code></pre></td></tr></tbody></table></figure><p>如果是双树问题(根节点分别为p,q)，一般来说进行以下判断：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!p &amp;&amp; !q)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>; <br><span class="hljs-keyword">if</span>(!p || !q)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>;<br></code></pre></td></tr></tbody></table></figure><p>当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析</p><h1 id="2-返回值"><a class="markdownIt-Anchor" href="#2-返回值"></a> 2: 返回值</h1><p>通常对称性递归的返回值是多个条件的复合判断语句</p><blockquote><p>[!note] 可能是以下几种条件判断的组合：<br>节点非空的判断<br>节点值比较判断<br>(单树)调用根节点左右子树的递归函数进行递归判断<br>(双树) 调用两棵树的左右子树的递归函数进行判断</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称性递归</title>
    <link href="/posts/5032/"/>
    <url>/posts/5032/</url>
    
    <content type="html"><![CDATA[<p>📝对称性递归:: <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1: 引言</h1><p>力扣上很多树的题目都是可以用递归很快地解决的，而这一系列递归解法中蕴含了一种很强大的递归思维：对称性递归 (symmetric recursion)</p><p>什么是对称性递归？<br>就是对一个对称的数据结构（这里指二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，<br>即不是单独考虑一部分(比如树的左子树)，而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码</p><h1 id="2-题型分类"><a class="markdownIt-Anchor" href="#2-题型分类"></a> 2: 题型分类</h1><p>可以用对称性递归解决的二叉树问题大多是判断性问题 (bool 类型函数),<br>这一类问题又可以分为以下两类：</p><h2 id="21-不需要构造辅助函数"><a class="markdownIt-Anchor" href="#21-不需要构造辅助函数"></a> 2.1: 不需要构造辅助函数。</h2><p>这一类题目有两种情况：<br>第一种是单树问题，<br>且不需要用到子树的某一部分 (比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。</p><p>第二种是双树问题，<br>即本身题目要求比较两棵树，那么不需要构造新函数。该类型题目如下：</p><p><a href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a><br><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a><br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a><br><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a><br><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a><br><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a><br><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一个树的子树</a><br><a href="https://leetcode.cn/problems/univalued-binary-tree/">965. 单值二叉树</a></p><h2 id="22-需要构造辅助函数"><a class="markdownIt-Anchor" href="#22-需要构造辅助函数"></a> 2.2: 需要构造辅助函数。</h2><p>这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，<strong>即要调用辅助函数比较两个部分子树</strong>。<br>形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。</p><p>该类型题目如下：<br>[[28. 对称的二叉树|剑指offer 28. 对称的二叉树]]</p><p>[[26.树的子结构|剑指 offer 26.树的子结构]]</p><h1 id="3-对称性递归解题模板"><a class="markdownIt-Anchor" href="#3-对称性递归解题模板"></a> 3: [[对称性递归解题模板]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归目录</title>
    <link href="/posts/3310/"/>
    <url>/posts/3310/</url>
    
    <content type="html"><![CDATA[<p>📝递归目录::</p><!-- basicblock-end --><h1 id="1-递归思想"><a class="markdownIt-Anchor" href="#1-递归思想"></a> 1: [[递归思想]]</h1><h1 id="2-递归解题方法"><a class="markdownIt-Anchor" href="#2-递归解题方法"></a> 2: [[递归解题方法]]</h1><h1 id="3-递归算法的复杂度"><a class="markdownIt-Anchor" href="#3-递归算法的复杂度"></a> 3: [[递归算法的复杂度]]</h1><h1 id="4-力扣递归"><a class="markdownIt-Anchor" href="#4-力扣递归"></a> 4: [[力扣递归]]</h1><h1 id="5-待练习题目"><a class="markdownIt-Anchor" href="#5-待练习题目"></a> 5: 待练习题目</h1><ul><li>[ ]  <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">Loading Question… - 力扣（LeetCode）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归解题方法</title>
    <link href="/posts/41382/"/>
    <url>/posts/41382/</url>
    
    <content type="html"><![CDATA[<p>📝递归解题方法::<a href="https://www.bilibili.com/video/BV1214y157HG/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">【递归1】递归中的逆向思维_哔哩哔哩_bilibili</a></p><!-- basicblock-end --><p>‌‌‌![[递归解题方法 2022-11-20 15.03.16.excalidraw]]<br>[[汉诺塔问题]]</p><h1 id="1-递归函数定义"><a class="markdownIt-Anchor" href="#1-递归函数定义"></a> 1: 递归函数定义</h1><p>明确函数的使命<br>明确原问题与子问题<br>兼顾原问题与子问题<br>递归函数的定义需要兼容”超级操作”。</p><ol><li><strong>确定递归函数的参数和返回值：</strong><ol><li>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，</li><li>并且还要明确每次递归的返回值是什么, 进而确定递归函数的返回类型。</li></ol></li></ol><h2 id="11-void"><a class="markdownIt-Anchor" href="#11-void"></a> 1.1: void</h2><p><strong>二叉树: 一般是传入一个根节点, 传入一个数组(用来放我们的结果)</strong><br>也可以在外边全局定义数组, 在递归中修改数组, 最后在返回<br>一般是 void, 因为我们把想要的结果都放到参数了</p><h3 id="111-遍历整棵树"><a class="markdownIt-Anchor" href="#111-遍历整棵树"></a> 1.1.1: 遍历整棵树</h3><p>eg: 遍历整棵树[[18. 路径总和]]</p><h1 id="2-基础情况处理"><a class="markdownIt-Anchor" href="#2-基础情况处理"></a> 2: 基础情况处理</h1><p>数据规模较小时直接返回答案<br>2.  <strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。<br>递归出口：<br>对于传入下标的有序数组递归，end &lt; start 是一种比较标准的递归出口<br><code>if (left &gt; right) return nullptr;// eg：-10大于-3了，当然要退出循环</code>  [[33.将有序数组转换为二叉搜索树]]<br>if(root == NULL) return</p><h1 id="3-递归调用"><a class="markdownIt-Anchor" href="#3-递归调用"></a> 3: 递归调用</h1><p>超级操作<br>看成整体，忽略细节<br>相信它一定能完成使命</p><ol start="3"><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><h1 id="4-递推到当前层"><a class="markdownIt-Anchor" href="#4-递推到当前层"></a> 4: 递推到当前层</h1><p>微操作</p><h1 id="5-对称性递归"><a class="markdownIt-Anchor" href="#5-对称性递归"></a> 5: [[对称性递归]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26.树的子结构</title>
    <link href="/posts/19927/"/>
    <url>/posts/19927/</url>
    
    <content type="html"><![CDATA[<p>📝26.树的子结构::<a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>方法:  [[对称性递归]]<br>都是操作两颗子树:  [[8. 对称二叉树]]</p><p>判断一棵树是否是另一棵树的子结构，注意子结构与子树的区别<br>子结构不能只利用根节点进行<strong>对称性递归</strong>，<br>需要构造辅助函数，判断当两棵树根节点值相同时一棵树是否为另一棵树子结构</p><p><img src="https://pic.leetcode-cn.com/1621740243-LSOaVf-src=http___images.xiaozhuanlan.com_photo_2019_aac0e1692d3c9810c6f4a91863598320.gif&amp;refer=http___images.xiaozhuanlan.gif" alt="src=http___images.xiaozhuanlan.com_photo_2019_aac0e1692d3c9810c6f4a91863598320.gif&amp;refer=http___images.xiaozhuanlan.gif"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br><br><br>    <span class="hljs-comment">// 判断B是否为A的子结构,其中B子结构的起点为A的根节点</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span></span>{<br>        <span class="hljs-comment">// 若B走完了,说明查找完毕,B为A的子结构</span><br>        <span class="hljs-keyword">if</span>(B == <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-comment">// 若B不为空并且A为空或者A与B的值不相等,直接可以判断B不是A的子结构</span><br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">NULL</span> || A-&gt;val != B-&gt;val){<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-comment">// 当A与B当前节点值相等,若要判断B为A的子结构</span><br>        <span class="hljs-comment">// 还需要判断B的左子树是否为A左子树的子结构 &amp;&amp; B的右子树是否为A右子树的子结构</span><br>        <span class="hljs-comment">// 若两者都满足就说明B是A的子结构,并且该子结构以A根节点为起点</span><br><br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">recur</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="hljs-built_in">recur</span>(A-&gt;right, B-&gt;right);<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 死死记住isSubStructure()的定义:判断B是否为A的子结构</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>{<br>        <span class="hljs-keyword">if</span>(A == <span class="hljs-literal">NULL</span> || B == <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-comment">// B为A的子结构有3种情况,满足任意一种即可:</span><br>        <span class="hljs-comment">// 1.B的子结构起点为A的根节点,此时结果为recur(A,B)</span><br>        <span class="hljs-comment">// 2.B的子结构起点隐藏在A的左子树中,而不是直接为A的根节点,此时结果为isSubStructure(A.left, B)</span><br>        <span class="hljs-comment">// 3.B的子结构起点隐藏在A的右子树中,此时结果为isSubStructure(A.right, B)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(A, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) || <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[! 参考资料]<br><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">Loading Question… - 力扣（LeetCode）</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25.合并两个排序的链表</title>
    <link href="/posts/31330/"/>
    <url>/posts/31330/</url>
    
    <content type="html"><![CDATA[<p>📝25.合并两个排序的链表::<a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-迭代"><a class="markdownIt-Anchor" href="#1-迭代"></a> 1: 迭代</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>){<br>        <span class="hljs-comment">// 💡以下 if else语句可以用三元运算符写     </span><br>        <span class="hljs-keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val){ <br>            cur-&gt;next = l1; <span class="hljs-comment">// ❗️不是 l1-&gt;val 是l1, 链表对链表</span><br>            l1 = l1-&gt;next;<br>        }<br>        <span class="hljs-keyword">else</span>{<br>            cur-&gt;next = l2;<br>            l2 = l2-&gt;next;<br>        }<br>        cur = cur-&gt;next; <br>    }<br>    <span class="hljs-comment">// l1 不为空, 接 l1, 反之接l2</span><br>    cur-&gt;next = (l1 ? l1 : l2);<br>    <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>}<br>    <br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-递归"><a class="markdownIt-Anchor" href="#2-递归"></a> 2: 递归</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> {<br>    <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> l2;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> l1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.val &lt;= l2.val) {<br>        l1.next = mergeTwoLists(l1.next, l2);<br>        <span class="hljs-keyword">return</span> l1;<br>    } <span class="hljs-keyword">else</span> {<br>        l2.next = mergeTwoLists(l1, l2.next);<br>        <span class="hljs-keyword">return</span> l2;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//(1,1):代表第一次进入递归函数，并且从第一个口进入，并且记录进入前链表的状态</span><br>merge(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>): <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span><br><span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)</span>: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span><br><span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)</span>: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span><br><span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)</span>: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span><br><span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>)</span>: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span><br><span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>)</span>: <span class="hljs-number">5</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span><br><span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-number">7</span>)</span>: <span class="hljs-literal">null</span>, <span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span><br><span class="hljs-keyword">return</span> l2<br>l1.next --- <span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-keyword">return</span> l1<br>l1.next --- <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-keyword">return</span> l1<br>l2.next --- <span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-keyword">return</span> l2<br>l2.next --- <span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-keyword">return</span> l2<br>l2.next --- <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-keyword">return</span> l2<br>l1.next --- <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-literal">null</span>, <span class="hljs-keyword">return</span> l1<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24. 反转链表</title>
    <link href="/posts/12088/"/>
    <url>/posts/12088/</url>
    
    <content type="html"><![CDATA[<p>📝24. 反转链表::<a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[4. 反转链表]]</p><blockquote><p>[!tip] 完全没必要用虚拟头节点</p></blockquote><p>‌‌‌</p><p>![[4. 翻转链表.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span>){<br>            ListNode* temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22.链表中倒数第k个节点</title>
    <link href="/posts/27233/"/>
    <url>/posts/27233/</url>
    
    <content type="html"><![CDATA[<p>📝22.链表中倒数第k个节点::<a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[6.删除链表的倒数第N个节点]]</p><p>![[22.链表中倒数第k个节点 2022-11-15 21.35.23.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <br>        <span class="hljs-keyword">while</span>(k--){ <br>            fast = fast-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>){<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> slow;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>[[while 循环]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++){ <span class="hljs-comment">// ❗️不是&lt;=, 因为下标是从 0 开始的</span><br>            fast = fast-&gt;next;<br>        }<br><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️不是 fast-&gt;next != NULL, 要求的是 fast 走到尾停止</span><br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> slow;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21.调整数组顺序使奇数位于偶数前面</title>
    <link href="/posts/17755/"/>
    <url>/posts/17755/</url>
    
    <content type="html"><![CDATA[<p>📝21. 调整数组顺序使奇数位于偶数前面::<br><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 力扣（LeetCode）</a></p><!-- basicblock-end --><ul><li>定义头指针 left，尾指针 right.</li><li>left一直往右移，直到它指向的值为偶数, right 一直往左移，直到它指向的值为奇数</li><li><pre><code class="hljs">交换  nums[left] 和 nums[right]</code></pre></li><li>重复上述操作，直到 left== right.<br><img src="https://pic.leetcode-cn.com/f25bd8d3c3fd5d30969be2954685a21f67e254a6487c6d9d27edf6589a0fca55.gif" alt=""></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">exchange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r){<br>            <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l]%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>) l++; <span class="hljs-comment">// ❗️要重申条件l&lt;r, 是奇数就往前走</span><br>            <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r]%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  r--;<span class="hljs-comment">// 是偶数就往后走</span><br>            <span class="hljs-keyword">if</span>(l &lt; r) <span class="hljs-built_in">swap</span>(nums[l++], nums[r--]); <span class="hljs-comment">// ❗️不要忘了++ -- </span><br>        }<br>        <span class="hljs-keyword">return</span> nums;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[while 循环]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>读写分离目录</title>
    <link href="/posts/29379/"/>
    <url>/posts/29379/</url>
    
    <content type="html"><![CDATA[<p>📝读写分离目录::</p><!-- basicblock-end --><h1 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1: 介绍</h1><p>读写分离, 简单地说是把对数据库的读和写操作分开, 以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。通过 MyCat 即可轻易实现上述功能，不仅可以支持 MySQL，也可以支持 Oracle 和 SQL Server。</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211152010979.png" alt=""></p><h1 id="2-一主一从"><a class="markdownIt-Anchor" href="#2-一主一从"></a> 2: 一主一从</h1><p>![[主从复制 原理.excalidraw]]</p><p>在测试中，我们可以发现当主节点 Master 宕机之后，业务系统就只能够读，而不能写入数据了。</p><p>那如何解决这个问题呢？这个时候我们就得通过另外一种主从复制结构来解决了，也就是我们接下来讲 解的双主双从。</p><h1 id="3-双主双从"><a class="markdownIt-Anchor" href="#3-双主双从"></a> 3: 双主双从</h1><p>![[读写分离目录 双主双从.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyCat</title>
    <link href="/posts/12782/"/>
    <url>/posts/12782/</url>
    
    <content type="html"><![CDATA[<p>📝MyCat::</p><!-- basicblock-end --><h1 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1: 介绍</h1><p>Mycat 是开源的、活跃的、基于 Java 语言编写的 MySQL 数据库中间件。可以像使用 mysql 一样来使用 mycat，对于开发人员来说根本感觉不到 mycat 的存在。</p><p>开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数 据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211151951352.png" alt=""></p><p>优势：<br>性能可靠稳定<br>强大的技术团队<br>体系完善<br>社区活跃</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/posts/18708/"/>
    <url>/posts/18708/</url>
    
    <content type="html"><![CDATA[<p>📝分库分表目录::</p><!-- basicblock-end --><h1 id="1-数据库为什么要进行分库和分表呢"><a class="markdownIt-Anchor" href="#1-数据库为什么要进行分库和分表呢"></a> 1: [[数据库为什么要进行分库和分表呢？]]</h1><h1 id="2-问题分析"><a class="markdownIt-Anchor" href="#2-问题分析"></a> 2: 问题分析</h1><blockquote><p>[!example]-<br>![[分库分表 问题分析.excalidraw]]</p></blockquote><p>⾃研⼯具类、tddl、shardingsphere、mycat等</p><blockquote><p>[!example] 【⾯试题】业务增长-数据库性能优化：<br>这边有个数据库-单表1千万数据，未来1年还会增长多500万，性能⽐较慢，说下你的优化 思路</p></blockquote><p>思路：</p><p>千万不要⼀上来就说分库分表，这个是最忌讳的事项，⼀定要根据实际情况分析，两个⾓度 思考</p><h2 id="21-不分库分表"><a class="markdownIt-Anchor" href="#21-不分库分表"></a> 2.1: 不分库分表：</h2><p>（1）软优化：</p><ol><li>数据库参数调优</li><li>分析慢查询SQL语句，分析执⾏计划，进⾏sql改写和程序改写</li><li>优化数据库索引结构</li><li>优化数据表结构优化</li><li>引⼊NOSQL和程序架构调整</li></ol><p>（2）硬优化<br>提升系统硬件（更快的IO、更多的内存）：带宽、CPU、硬盘</p><h2 id="22-分库分表"><a class="markdownIt-Anchor" href="#22-分库分表"></a> 2.2: 分库分表</h2><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。<br>而拆分的粒度，一般又分为分库和分表，所以组成的拆分策略最终如下：</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211151937274.png" alt=""></p><p>在业务系统中，为了缓解磁盘 IO 及 CPU 的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。<br>根据业务情况⽽定，选择合适的分库分表策略（没有通⽤的策略），外卖、物流、电商领域。</p><p>先看只分表是否满⾜业务的需求和未来增长，数据库分表能够解决单表数据量很⼤的时,数 据查询的效率问题。</p><p>⽆法给数据库的并发操作带来效率上的提⾼，分表的实质还是在⼀个数据库上进⾏的操作，受数据库 IO 性能的限制如果单分表满⾜不了需求，再分库分表⼀起。</p><p>结论：在数据量及访问压⼒不是特别⼤的情况，⾸先考虑缓存、读写分离、索引技术等⽅ 案，如果数据量极⼤，且业务持续增长快，再考虑分库分表⽅案。</p><h3 id="221-垂直分库分表"><a class="markdownIt-Anchor" href="#221-垂直分库分表"></a> 2.2.1: [[垂直分库分表]]</h3><h3 id="222-水平分库分表"><a class="markdownIt-Anchor" href="#222-水平分库分表"></a> 2.2.2: [[水平分库分表]]</h3><h1 id="3-实现技术"><a class="markdownIt-Anchor" href="#3-实现技术"></a> 3: 实现技术</h1><ul><li>shardingJDBC：基于 AOP 原理，在应用程序中对本地执行的 SQL 进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持 java 语言，性能较高。</li><li>[[MyCat]]：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211151949160.png" alt=""><br>本次课程，我们选择了是 MyCat 数据库中间件，通过 MyCat 中间件来完成分库分表操作。</p><h1 id="4-分库分表总结"><a class="markdownIt-Anchor" href="#4-分库分表总结"></a> 4: 分库分表总结</h1><h2 id="41-技术负责人前瞻性思维"><a class="markdownIt-Anchor" href="#41-技术负责人前瞻性思维"></a> 4.1: 技术负责⼈前瞻性思维</h2><ol><li><p>需要提前考虑系统⼀年到两年左右的业务增长情况</p></li><li><p>对数据库服务器的QPS、连接数、容量等做合理评估和规划</p></li><li><p>很多⼈觉得“分库分表”是宜早不宜迟-----其实不然</p></li></ol><p>常规开发⾥⾯单表建议1千万内，推荐是百万级别单表存储，常规sql和索引优化先⾏，然后 结合缓存+异步+nosql+mq</p><h2 id="42-互联网公司实际使用和跳槽面试"><a class="markdownIt-Anchor" href="#42-互联网公司实际使用和跳槽面试"></a> 4.2: 互联⽹公司实际使⽤和跳槽⾯试</h2><p>公司业务稳定发展，多数情况是为了解决【单库单表】数据量过多问题</p><p>重点是⽔平⾓度的【分库分表】</p><h1 id="5-mysql-数据库分库分表后带来的优点优点"><a class="markdownIt-Anchor" href="#5-mysql-数据库分库分表后带来的优点优点"></a> 5: [[MySQL 数据库分库分表后带来的优点|优点]]</h1><h1 id="6-分库分表的问题"><a class="markdownIt-Anchor" href="#6-分库分表的问题"></a> 6: [[分库分表的问题]]</h1><h1 id="7-场景"><a class="markdownIt-Anchor" href="#7-场景"></a> 7: 场景</h1><h2 id="71-24-一道场景题假如你所在的公司选择mysql数据库作数据存储一天五万条以上的增量预计运维三年你有哪些优化手段"><a class="markdownIt-Anchor" href="#71-24-一道场景题假如你所在的公司选择mysql数据库作数据存储一天五万条以上的增量预计运维三年你有哪些优化手段"></a> 7.1: [[24、一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？]]</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主从复制</title>
    <link href="/posts/27421/"/>
    <url>/posts/27421/</url>
    
    <content type="html"><![CDATA[<p>📝主从复制::</p><!-- basicblock-end --><h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1: 概述</h1><blockquote><p>[!summary] 概念<br>数据可以从⼀个 MySQL 数据库服务器主节点复制到⼀个或者多个从节点。<br>MySQL 默认采⽤异步复制⽅式，这样从节点就不⽤⼀直访问主服务器来更新最新数据。<br>从节点可以复制主节点数据库中的所有数据库、特定的数据库或者特定的表。</p></blockquote><p>![[主从复制 概述.excalidraw]]</p><blockquote><p>[!summary] 主从复制模式：</p><ol><li>异步模式</li><li>半同步模式</li><li>全同步模式</li><li>GTID复制模式</li></ol></blockquote><blockquote><p>[!question] 什么是异步复制</p></blockquote><h1 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2: 原理</h1><p>![[主从复制 原理.excalidraw]]</p><blockquote><p>[!question] MySQL 主从复制涉及到三个线程<br>⼀个运⾏在主节点： binary log dump thread<br>两个运⾏在从节点： I/O thread、SQL thread</p></blockquote><h2 id="21-binary-log-dump"><a class="markdownIt-Anchor" href="#21-binary-log-dump"></a> 2.1: binary log dump</h2><p>当从节点连接主节点的时候，主节点创建该线程，⽤于发送 bin-log 内容</p><h2 id="22-io-thread"><a class="markdownIt-Anchor" href="#22-io-thread"></a> 2.2: I/O thread</h2><p>当从节点执⾏“start slave”命令之后，从节点会创建⼀个 I/O 线程⽤来连接主节点，请求其中的数据。I/O 线程接收到主节点 binlog dump 的更新数据之后，保存在本地的 relay log 中</p><h2 id="23-sql-线程"><a class="markdownIt-Anchor" href="#23-sql-线程"></a> 2.3: SQL 线程</h2><p>该线程负责读取 relay log 中的内容，解析或具体的操作并执⾏，最终保证主从数据的⼀致性</p><blockquote><p>[!question]</p></blockquote><h1 id="3-基本过程-疑问"><a class="markdownIt-Anchor" href="#3-基本过程-疑问"></a> 3: 基本过程::   #疑问</h1><h2 id="31-从节点-io-进程连接主节点"><a class="markdownIt-Anchor" href="#31-从节点-io-进程连接主节点"></a> 3.1: 从节点 I/O 进程连接主节点</h2><p>请求指定⽇志⽂件的指定位置后⾯的内容</p><h2 id="32-主节点接收到请求之后"><a class="markdownIt-Anchor" href="#32-主节点接收到请求之后"></a> 3.2: 主节点接收到请求之后</h2><p>通过负责复制的 I/O 进程根据请求的信息读取指定的⽇志位置之后的⽇志信息，返回给从节点。返回信息中除了⽇志所包含的指定⽇志信息还包含了本次返回信息的 bin-log file 以及 bin-log position</p><h2 id="33-从节点的-io-线程接收到内容之后"><a class="markdownIt-Anchor" href="#33-从节点的-io-线程接收到内容之后"></a> 3.3: 从节点的 I/O 线程接收到内容之后</h2><p>将接收到的⽇志内容更新到本机的 relay log 中，并且把读取到的 binary log ⽂件名和位置保存到 master-info ⽂件中，⽅便下⼀次告知 master 从节点需要更新的位置</p><h2 id="34-slave-的-sql-线程检测到-relay-log-中新增了内容"><a class="markdownIt-Anchor" href="#34-slave-的-sql-线程检测到-relay-log-中新增了内容"></a> 3.4: Slave 的 SQL 线程检测到 relay-log 中新增了内容</h2><p>将 relay-log 的内容解析成在主节点上实际执⾏的操作，并在数据库中执⾏</p><h1 id="4-用途优点"><a class="markdownIt-Anchor" href="#4-用途优点"></a> 4: 用途&amp;优点</h1><h2 id="41-数据实时备份"><a class="markdownIt-Anchor" href="#41-数据实时备份"></a> 4.1: 数据实时备份</h2><p>主库出现问题，可以快速切换到从库提供服务<br>当系统中某个节点发⽣故障时，可以⽅便故障切换</p><h2 id="42-读写分离"><a class="markdownIt-Anchor" href="#42-读写分离"></a> 4.2: 读写分离</h2><p>在开发过程中，如果遇到某个 sql 语句需要锁表，导致暂时不能使⽤读的服务</p><p>使⽤主从复制，让主数据库负责写，从数据库负责读，<br>即使主库出现锁表的情景，也可以通过从库正常读数据</p><h2 id="43-不影响备份"><a class="markdownIt-Anchor" href="#43-不影响备份"></a> 4.3: 不影响备份</h2><p>可以在从库中执行备份，以避免备份期间影响主库服务。</p><h2 id="44-架构扩展"><a class="markdownIt-Anchor" href="#44-架构扩展"></a> 4.4: 架构扩展</h2><p>随着系统中业务访问量的增加，如果是单机部署数据，会导致 I/O 访问频率过⾼<br>通过主从复制，增加多个数据存储结点，将负载分布在多个从节点上，降低单机的 I/O 访问频率，提⾼单机的 I/O 性能</p><h1 id="5-测试"><a class="markdownIt-Anchor" href="#5-测试"></a> 5: 测试</h1><p>想看, 在看这个吧<br><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=160&amp;spm_id_from=pageDriver&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">08. 运维-主从复制-主库配置_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二进制日志 bin log</title>
    <link href="/posts/64891/"/>
    <url>/posts/64891/</url>
    
    <content type="html"><![CDATA[<p>📝二进制日志 bin log::</p><!-- basicblock-end --><h1 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1: 介绍</h1><blockquote><p>[!summary] 二进制日志（binlog）记录了所有的 ddl（数据定义语言）语句和 dml（数据操纵语言）语句，但不包括数据查询（select、show）语句。</p></blockquote><h1 id="2-作用"><a class="markdownIt-Anchor" href="#2-作用"></a> 2: 作用</h1><p>①. 灾难时的数据恢复；<br>因为记录了数据库表和数据的变更, 所以下次执行的语句就行了</p><p>②. MySQL 的主从复制。<br>在 MySQL8 版本中，默认二进制日志是开启着的，涉及到的参数如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">show variables like '%log_bin%';<br></code></pre></td></tr></tbody></table></figure><p>![[二进制日志 bin log 2022-11-17 17.21.04.excalidraw]]</p><h1 id="3-其他"><a class="markdownIt-Anchor" href="#3-其他"></a> 3: 其他</h1><p>![[bin log 文件格式.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日志</title>
    <link href="/posts/32354/"/>
    <url>/posts/32354/</url>
    
    <content type="html"><![CDATA[<p>📝日志::</p><!-- basicblock-end --><h1 id="1-错误日志"><a class="markdownIt-Anchor" href="#1-错误日志"></a> 1: 错误日志</h1><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过 程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日 志。</p><p>该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志 位置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">show variables like '%log_error%';<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211151740551.png" alt=""></p><h1 id="2-二进制日志-bin-log"><a class="markdownIt-Anchor" href="#2-二进制日志-bin-log"></a> 2: [[二进制日志 bin log]]</h1><h1 id="3-查询日志"><a class="markdownIt-Anchor" href="#3-查询日志"></a> 3: 查询日志</h1><p>查询日志中记录了客户端的所有操作语句，而二进制日志 (bin log) 不包含查询数据的 SQL 语句 (select)。默认情况下，查询日志是未开启的。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211151759624.png" alt=""></p><p>如果需要开启查询日志，可以修改 MySQL 的配置文件 /etc/my.cnf 文件，添加如下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 <br>general_log=1<br><br>#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log <br><br>general_log_file=mysql_query.log<br><br></code></pre></td></tr></tbody></table></figure><p>开启了查询日志之后，在 MySQL 的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，该日志文件将会非常大。</p><h1 id="4-慢查询日志"><a class="markdownIt-Anchor" href="#4-慢查询日志"></a> 4: 慢查询日志</h1><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的 SQL 语句的日志，默认未开启。long_query_time 默认为 10 秒，最小为 0，精度可以到微秒。</p><p>如果需要开启慢查询日志，需要在 MySQL 的配置文件 /etc/my.cnf 中配置如下参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">#慢查询日志 <br>slow_query_log=1 <br>#执行时间参数 <br>long_query_time=2<br></code></pre></td></tr></tbody></table></figure><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements 和更改此行为 log_queries_not_using_indexes，如下所述。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">#记录执行较慢的管理语句 <br>log_slow_admin_statements =1 <br>#记录执行较慢的未使用索引的语句 <br>log_queries_not_using_indexes = 1<br><br><br></code></pre></td></tr></tbody></table></figure><p>上述所有的参数配置完成之后，都需要重新启动 MySQL 服务器才可以生效。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>运维篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVCC 原理分析</title>
    <link href="/posts/22359/"/>
    <url>/posts/22359/</url>
    
    <content type="html"><![CDATA[<p>📝MVCC 原理分析::</p><!-- basicblock-end --><p>![[MVCC 原理分析 2022-11-15 17.12.45.excalidraw]]</p><h1 id="1-rc-隔离级别"><a class="markdownIt-Anchor" href="#1-rc-隔离级别"></a> 1: RC 隔离级别</h1><p>RC 隔离级别下，在事务中每一次执行快照读时生成 ReadView。</p><p>‌‌‌</p><h1 id="2-rr-隔离级别"><a class="markdownIt-Anchor" href="#2-rr-隔离级别"></a> 2: RR 隔离级别</h1><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ReadView</title>
    <link href="/posts/47203/"/>
    <url>/posts/47203/</url>
    
    <content type="html"><![CDATA[<p>📝ReadView::</p><!-- basicblock-end --><p>ReadView（读视图）是快照读 SQL 执行时 MVCC 提取数据的依据，<br>记录并维护系统当前活跃的事务 （未提交的）id。</p><p>![[ReadView.excalidraw]]</p><p>不同的隔离级别，生成 readview 的时机不同：<br>read committed：在事务中每一次执行快照读时生成readview。<br>repeatable read：仅在事务中第一次执行快照读时生成readview，后续复用该readview。<br>保证了可重复读</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快照读 &amp; 当前读</title>
    <link href="/posts/9332/"/>
    <url>/posts/9332/</url>
    
    <content type="html"><![CDATA[<p>📝快照读 &amp; 当前读::</p><!-- basicblock-end --><p>![[快照读 &amp; 当前读.excalidraw]]</p><h1 id="1-快照读"><a class="markdownIt-Anchor" href="#1-快照读"></a> 1: 快照读:</h1><p><strong>快照读</strong>读取的是快照数据。<strong>不加锁</strong>的简单的 SELECT都属于快照读</p><p>简单的 select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次 select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><h1 id="2-当前读"><a class="markdownIt-Anchor" href="#2-当前读"></a> 2: 当前读:</h1><p><strong>当前读</strong>就是读取最新数据，而不是历史版本的数据。<br><strong>加锁</strong>的 SELECT，或者对数据进行增删改都会进行当前读。</p><p>指代执行下列语句时进行数据读取的方式<br>Insert、 Update、 Delete (排他锁)、<br>Select… for update<br>Select…lock in share mode (共享锁)</p><p><strong>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</strong>。</p><p>由于当前读都是先读后写, 只能读当前的值, 所以为当前读会更新事务内的 up_limit_id 为该事务的事务 ID<br>事务在启动时, 找到已提交的最⼤事务 ID 记为 up_limit_id。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19. 正则表达式匹配</title>
    <link href="/posts/38652/"/>
    <url>/posts/38652/</url>
    
    <content type="html"><![CDATA[<p>📝19. 正则表达式匹配::<a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[1.动态规划理论基础]]</p><p>暂时跳过<br><a href="https://yft.github.io/yft/#/zheng-ze-biao-da-shi-pi-pei-lcof">Vite App</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟头结点</title>
    <link href="/posts/26719/"/>
    <url>/posts/26719/</url>
    
    <content type="html"><![CDATA[<p>📝虚拟头结点::</p><!-- basicblock-end --><p>虚拟头结点<br>如何设置一个虚拟头结点来操持一个统一的删除操作::</p><ol><li>先创建一个表头链表 dummyHead : <code>new ListNode(0</code>); [^1]</li><li>在把 head 链表接到dummyhead 上 : dummyHead -&gt; next = head</li><li>创建一个新 cur 链表, 以后在 cur 链表上操作, 因为 cur 要不断变化, 不能让影响到原来的数组了</li></ol><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208111134829.gif" alt="|1100"></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18 删除链表的节点</title>
    <link href="/posts/19238/"/>
    <url>/posts/19238/</url>
    
    <content type="html"><![CDATA[<p>📝18 删除链表的节点::<a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[虚拟头结点]]<br>[[2. 移除链表元素]]<br>![[移除链表元素.excalidraw]]</p><p>v2通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;val != val){<br>            cur = cur-&gt;next;<br>        }<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = temp-&gt;next;<br>        head = dummyHead-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!question] 不知道为啥没有通过: 因为 delete 了 temp 没有通过, 为什么呢</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head; <span class="hljs-comment">// ❗️不要忘了-&gt;next</span><br>        ListNode* cur = dummyHead;<br><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 💡想极端情况再反推</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val){<br>                ListNode* temp = cur-&gt;next;<br>                cur-&gt;next = temp-&gt;next;<br>                <span class="hljs-keyword">delete</span> temp;<br>            }<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;next;<br>        }<br>        head = dummyHead-&gt;next;<br>        <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// ❗️直接返回 dummyhead-&gt;next 没通过</span><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17. 打印从1到最大的n位数</title>
    <link href="/posts/5652/"/>
    <url>/posts/5652/</url>
    
    <content type="html"><![CDATA[<p>📝17. 打印从1到最大的n位数::<a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/submissions/">剑指 Offer 17. 打印从1到最大的n位数 - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-简单解法"><a class="markdownIt-Anchor" href="#1-简单解法"></a> 1: 简单解法</h1><p>v2, 无法通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> length = (<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, n) - <span class="hljs-number">1</span>;<br>        std::cout&lt;&lt;length;<br>        <span class="hljs-type">int</span> res[length] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= length; i++){<br>            res[i] = i+<span class="hljs-number">1</span>;<br>        } <br>        <span class="hljs-keyword">return</span> res;<br><br><br>    }<br>};```<br><br>-  **时间复杂度 <span class="hljs-built_in">O</span>(<span class="hljs-number">10</span>^n) ：** 生成长度为 <span class="hljs-number">10</span>^n 的列表需使用 <span class="hljs-built_in">O</span>(<span class="hljs-number">10</span>^n) 时间。<br>-  **空间复杂度 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) ：** 建立列表需使用 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>) 大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。<br>    - question 咋感觉不对呢<br>```c++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> maxNum = <span class="hljs-number">1</span>;<span class="hljs-comment">// 初始值为1, 下面为了*10</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++){<br>            maxNum *= <span class="hljs-number">10</span>; <span class="hljs-comment">// 取到最大值</span><br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; maxNum; i++){<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>        }<br>        <span class="hljs-keyword">return</span> res;<br><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-大数"><a class="markdownIt-Anchor" href="#2-大数"></a> 2: 大数</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16.数值的整数次方</title>
    <link href="/posts/24310/"/>
    <url>/posts/24310/</url>
    
    <content type="html"><![CDATA[<p>📝16.数值的整数次方::<a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>利用快速幂可以将 O (n) 的复杂度, 降到 O (logn)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">y^<span class="hljs-number">15</span> = y^<span class="hljs-number">1</span> * y*<span class="hljs-number">2</span> * y*<span class="hljs-number">4</span>*y^<span class="hljs-number">8</span><br>y^<span class="hljs-number">5</span>  = y^<span class="hljs-number">1</span> * y*<span class="hljs-number">4</span><br></code></pre></td></tr></tbody></table></figure><p>这里要注意两点<br>1 边界条件 32位<br>负次幂</p><p>![[16.数值的整数次方 2022-11-15 10.12.47.excalidraw]]<br>[[计算时间复杂度]]</p><ul><li>时间复杂度：O(log⁡n)，即为对 n 进行二进制拆分的时间复杂度。</li><li>空间复杂度：O(1)。</li></ul><p>v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">double</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> absn = <span class="hljs-built_in">abs</span>(n);<span class="hljs-comment">// ❗️经测试 abs 没有用撒</span><br>        <span class="hljs-keyword">while</span>(absn){<br>            <span class="hljs-keyword">if</span>(absn&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span>) res *= x;<br>            x *= x;<br>            absn &gt;&gt;= <span class="hljs-number">1</span>;<br>        }<br>        <br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span>? res : <span class="hljs-number">1</span>/res;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ln = <span class="hljs-built_in">abs</span>(n);<br>        <span class="hljs-type">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">while</span>(ln){<br>            <span class="hljs-keyword">if</span>(ln &amp; <span class="hljs-number">1</span>){<br>                res = res * x;<span class="hljs-comment">// 对应的二进制 1, 乘上 x 的幂</span><br>            }<br>            <br>            ln &gt;&gt;= <span class="hljs-number">1</span>;<br>            x = x*x; <span class="hljs-comment">// 取到对应的x幂</span><br>        }<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span>/res;<br>        <span class="hljs-keyword">return</span> res;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑运算符</title>
    <link href="/posts/2225/"/>
    <url>/posts/2225/</url>
    
    <content type="html"><![CDATA[<p>📝逻辑运算符::</p><!-- basicblock-end --><h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1: &amp;</h1><h2 id="11"><a class="markdownIt-Anchor" href="#11"></a> 1.1:</h2><p>判断二进制位<br>根据 <code>与运算</code> 定义，设二进制数字 n ，则有：<br>若 n&amp;1=0，则 n 二进制<strong>最右一位</strong> 为 0 ；<br>若 n&amp;1=1 ，则 n 二进制最右一位为 1。</p><p>根据以上特点，考虑以下 循环判断 ：<br>判断 n最右一位是否为 1 ，根据结果计数。<br>将 n 右移一位（本题要求把数字 n 看作无符号数，因此使用 无符号右移 操作）。</p><p>[[16.数值的整数次方]]</p><p>n &gt;&gt;= 1 是右移之后再赋值，相当于 n = n &gt;&gt; 1 是一种简便的写</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15 二进制中1的个数</title>
    <link href="/posts/19969/"/>
    <url>/posts/19969/</url>
    
    <content type="html"><![CDATA[<p>📝15 二进制中1的个数::<a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[运算符]]<br>目标<br>学会逻辑运算&amp;<br>学会右移操作</p><h1 id="1-方法一逐位判断"><a class="markdownIt-Anchor" href="#1-方法一逐位判断"></a> 1: 方法一：逐位判断</h1><p>根据 <code>与运算</code> 定义，设二进制数字 n ，则有：<br>若 n&amp;1=0，则 n 二进制<strong>最右一位</strong> 为 0 ；<br>若 n&amp;1=1 ，则 n 二进制最右一位为 1。<br>这是为什么呢</p><p>根据以上特点，考虑以下 循环判断 ：<br>判断 n最右一位是否为 1 ，根据结果计数。<br>将 n 右移一位, 💡继续看前一位的最右位是否为 1</p><p>v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>){<br>           (n&amp;<span class="hljs-number">1</span>) == <span class="hljs-number">1</span> ? count++, n/=<span class="hljs-number">2</span> : n/=<span class="hljs-number">2</span>; <br>        }<br>        <span class="hljs-keyword">return</span> count;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>){ <br>        <span class="hljs-comment">// ❗️必须得有&amp;操作, 不然不通过</span><br>            <span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) count++; <span class="hljs-comment">// ❗️n 的最右位不为 1</span><br>            n &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 💡相当于/2, n &gt;&gt;= 1 是右移之后再赋值，相当于 n = n &gt;&gt; 1 是一种简便的写 [[逻辑运算符]]</span><br>        }<br>        <span class="hljs-keyword">return</span> count;<br><br>        <br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>[[计算时间复杂度]]</p><ul><li><strong>时间复杂度 O(log2n) ：</strong><ul><li>此算法循环内部仅有 <strong>移位、与、加</strong> 等基本运算，占用 O(1) ；</li><li>question 逐位判断需循环 log2n 次，其中 log2n 代表数字 n 最高位 1 的所在位数（例如 log24=2, log216=4）。</li></ul></li><li><strong>空间复杂度 O(1) ：</strong> 变量 res 使用常数大小额外空间。</li></ul><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2:</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 巧用n&amp;(n - 1) （将n最右边的1置0，在n=0之前 该操作的次数即为1的个数）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> counts = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) {      <span class="hljs-comment">// 每次循环都将n最右边的1置0，累加次数。直到所有1都置为0时，循环终止</span><br>            n &amp;= n - <span class="hljs-number">1</span>;   <br>            ++counts;<br>        }<br><br>        <span class="hljs-keyword">return</span> counts;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li><strong>时间复杂度 O(M) ：</strong><ul><li>n&amp;(n−1) 操作仅有减法和与运算，占用 O(1) ；</li><li>设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M)</li></ul></li><li><strong>空间复杂度 O(1) ：</strong> 变量 res 使用常数大小额外空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 后台线程</title>
    <link href="/posts/52625/"/>
    <url>/posts/52625/</url>
    
    <content type="html"><![CDATA[<p>📝InnoDB 后台线程::</p><!-- basicblock-end --><p>![[InnoDB 后台线程 2022-11-14 22.37.39.excalidraw]]</p><p>在 InnoDB 的后台线程中，分为 4 类，分别是：<br>Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。</p><h1 id="1-master-thread"><a class="markdownIt-Anchor" href="#1-master-thread"></a> 1: Master Thread</h1><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性， 还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><h1 id="2-io-thread"><a class="markdownIt-Anchor" href="#2-io-thread"></a> 2: IO Thread</h1><p>在 InnoDB 存储引擎中大量使用了 AIO 来处理 IO 请求, 这样可以极大地提高数据库的性能，而 IO Thread 主要负责这些 IO 请求的回调。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142239653.png" alt=""><br>我们可以通过以下的这条指令，查看到 InnoDB 的状态信息，其中就包含 IO Thread 信息。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">show engine innodb status \G;<br></code></pre></td></tr></tbody></table></figure><p>![[InnoDB 后台线程 2022-11-14 22.40.22.excalidraw]]</p><h1 id="3-purge-thread"><a class="markdownIt-Anchor" href="#3-purge-thread"></a> 3: Purge Thread</h1><p>主要用于回收事务已经提交了的 undo log，在事务提交之后，undo log 可能不用了，就用它来回收。</p><h1 id="4-page-cleaner-thread"><a class="markdownIt-Anchor" href="#4-page-cleaner-thread"></a> 4: Page Cleaner Thread</h1><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻 塞。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB磁盘结构</title>
    <link href="/posts/20850/"/>
    <url>/posts/20850/</url>
    
    <content type="html"><![CDATA[<p>📝InnoDB磁盘结构::</p><!-- basicblock-end --><p>接下来，再来看看 InnoDB 体系结构的右边部分，也就是磁盘结构：</p><p>![[InnoDB磁盘结构图.excalidraw|1000]]</p><p>[[redo log &amp; 脏页 &amp; WAL.excalidraw]]</p><h1 id="1-system-tablespace"><a class="markdownIt-Anchor" href="#1-system-tablespace"></a> 1: System Tablespace</h1><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><p>参数：innodb_data_file_path<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142224313.png" alt="|600"></p><p>系统表空间，默认的文件名叫 ibdata1。</p><h1 id="2-file-per-table-tablespaces"><a class="markdownIt-Anchor" href="#2-file-per-table-tablespaces"></a> 2: File-Per-Table Tablespaces</h1><p>如果开启了 innodb_file_per_table 开关，则每个表的文件表空间包含单个 InnoDB 表的数据和索引，并存储在文件系统上的单个数据文件中。</p><p>开关参数：innodb_file_per_table ，该参数默认开启。</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142225196.png" alt="|700"></p><p>那也就是说，我们每创建一个表，都会产生一个表空间文件，如图<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142225534.png" alt="|700"></p><h1 id="3-general-tablespaces"><a class="markdownIt-Anchor" href="#3-general-tablespaces"></a> 3: General Tablespaces</h1><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142227602.png" alt=""></p><p>可以在创建表的时候指定表空间, 直接存在那个表里<br>这个用的不多</p><h1 id="4-undo-tablespaces"><a class="markdownIt-Anchor" href="#4-undo-tablespaces"></a> 4: Undo Tablespaces</h1><p>撤销表空间，MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小 16M），用于存储 undo log 日志。</p><h1 id="5-temporary-tablespaces"><a class="markdownIt-Anchor" href="#5-temporary-tablespaces"></a> 5: Temporary Tablespaces</h1><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的<strong>临时表</strong>等数据。</p><h1 id="6-双写缓冲区"><a class="markdownIt-Anchor" href="#6-双写缓冲区"></a> 6: [[双写缓冲区]]</h1><h1 id="7-redo-log"><a class="markdownIt-Anchor" href="#7-redo-log"></a> 7: [[redo log]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 内存结构</title>
    <link href="/posts/38836/"/>
    <url>/posts/38836/</url>
    
    <content type="html"><![CDATA[<p>📝InnoDB 内存结构::</p><!-- basicblock-end --><p>InnoDB 内存结构<br>主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。接下来介绍一下这四个部分。</p><p>![[InnoDB 内存结构.excalidraw|500]]</p><h1 id="1-buffer-pool"><a class="markdownIt-Anchor" href="#1-buffer-pool"></a> 1: Buffer Pool</h1><p>InnoDB 存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的 I/O 效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘随机 I/O, 💡找个时间来顺序 I/O</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以 Page 页为单位，底层采用链表数据结构管理 Page。根据状态，将 Page 分为三种类型：</p><p>• free page：空闲page，未被使用。<br>• clean page：被使用page，数据没有被修改过。<br>• dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</p><p><strong>在专用服务器上，通常将多达 80％的物理内存分配给缓冲池, 通过缓冲区就可以提高并发</strong><br>参数设置： show variables like ‘innodb_buffer_pool_size’;<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142204148.png" alt=""></p><h1 id="2-change-buffer"><a class="markdownIt-Anchor" href="#2-change-buffer"></a> 2: [[change buffer]]</h1><h1 id="3-adaptive-hash-index"><a class="markdownIt-Anchor" href="#3-adaptive-hash-index"></a> 3: Adaptive Hash Index</h1><p>自适应 hash 索引，用于优化对 Buffer Pool 数据的查询。<br>InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下 hash 索引可以提升速度，则建立 hash 索引，称之为自适应 hash 索引。<br>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</p><blockquote><p>[!note] 原因<br>MySQL 的 innoDB 引擎中虽然没有直接支持 hash 索引，但是给我们提供了一个功能就是这个自适应 hash 索引。<br>因为前面我们讲到过，hash 索引在进行等值匹配时，一般性能是要高于 B+树的，<br>因为 hash 索引一般只需要一次 IO 即可，而 B+树，可能需要几次匹配，所以 hash 索引的效率要高，但是 hash 索引又不适合做范围查询、模糊匹配等。</p></blockquote><p>参数： adaptive_hash_index<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142213193.png" alt=""></p><h1 id="4-log-buffer"><a class="markdownIt-Anchor" href="#4-log-buffer"></a> 4: Log Buffer</h1><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的 log 日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p><p>![[log buffer.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 架构</title>
    <link href="/posts/30661/"/>
    <url>/posts/30661/</url>
    
    <content type="html"><![CDATA[<p>📝InnoDB 架构::</p><!-- basicblock-end --><h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1: 概述</h1><p>MySQL5.5 版本开始，默认使用 InnoDB 存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是 InnoDB 架构图，左侧为内存结构，右侧为磁盘结构。</p><p>![[InnoDB 架构图.excalidraw]]</p><h1 id="2-innodb-内存结构"><a class="markdownIt-Anchor" href="#2-innodb-内存结构"></a> 2: [[InnoDB 内存结构]]</h1><h1 id="3-innodb磁盘结构"><a class="markdownIt-Anchor" href="#3-innodb磁盘结构"></a> 3: [[InnoDB磁盘结构]]</h1><h1 id="4-innodb-后台线程"><a class="markdownIt-Anchor" href="#4-innodb-后台线程"></a> 4: [[InnoDB 后台线程]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB 逻辑存储结构：</title>
    <link href="/posts/58833/"/>
    <url>/posts/58833/</url>
    
    <content type="html"><![CDATA[<p>📝InnoDB 逻辑存储结构：::</p><!-- basicblock-end --><p>![[InnoDB 逻辑存储结构.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>undo log</title>
    <link href="/posts/14132/"/>
    <url>/posts/14132/</url>
    
    <content type="html"><![CDATA[<p>📝undo log::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。<br>当事务已经被提交之后，就无法再次回滚了。</p><p>当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。<ul><li>物理日记: 这个数据里边的内容是什么样的</li><li>逻辑日志:  <strong>记录操作是什么</strong></li></ul></li></ul><blockquote><p>[!multi-column]</p><blockquote><p>[!example]- [[undo log.excalidraw]]</p></blockquote><blockquote><p>[!example]- 这个例子不好理解<br>可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，<br>当 update 一条记录时，它记录一条对应相反的 update 记录。<br>记录的是执行 update 之前的这个数据长什么样子</p></blockquote></blockquote><h1 id="2-mysql中为什么要有事务回滚机制"><a class="markdownIt-Anchor" href="#2-mysql中为什么要有事务回滚机制"></a> 2: [[MySQL中为什么要有事务回滚机制？]]</h1><h1 id="3-删除"><a class="markdownIt-Anchor" href="#3-删除"></a> 3: 删除</h1><p>Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于 MVCC。</p><ul><li>当 <strong>insert</strong> 的时候, 产生的 undo log 日志只在回滚时需要, 在事务提交后, 可被立即删除。</li><li>而 <strong>update、delete</strong> 的时候, 产生的 undo log 日志不仅在回滚时需要, 在快照读时也需要, 不会立即被删除。</li></ul><h1 id="4-undo-log-存储"><a class="markdownIt-Anchor" href="#4-undo-log-存储"></a> 4: Undo log 存储：</h1><blockquote><p>[!question] 不知道在哪里啊<br>undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。::   #疑问</p></blockquote><p>[[InnoDB 架构]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redo log</title>
    <link href="/posts/4559/"/>
    <url>/posts/4559/</url>
    
    <content type="html"><![CDATA[<p>📝redo log::</p><!-- basicblock-end --><p><strong>重做日志, 记录的是事务提交时数据页的物理修改, 是用来实现事务的持久性</strong>。<br>该日志文件由两部分组成: 重做日志缓冲 (redo log buffer) 以及重做日志文件 (redo log file),<br>前者是在内存中, 后者在磁盘中。<br>当事务提交之后会把<strong>所有修改信息</strong>都存到该日志文件中, 用于在刷新脏页到磁盘, 发生错误时, 进行数据恢复使用。<br>以循环方式写入重做日志文件，涉及两个文件：<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211142231471.png" alt="|200"></p><p>如果没有redolog,可能会存在什么问题的? 我们一起来分析一下</p><p>![[redo log &amp; 脏页 &amp; WAL.excalidraw]]</p><blockquote><p>[!note] 啥是脏页？ 啥是⼲净页？<br>当内存数据页跟磁盘数据页内容不⼀致的时候，我们称这个内存页为“脏页”。<br>内存数据写⼊到磁盘后，内存和磁盘上的数据页的内容就⼀致了，称为“⼲净页”。</p></blockquote><blockquote><p>[!note] 脏页是咋产⽣的？<br>因为使⽤了 WAL 技术，这个技术会把数据库的随机写转化为顺序写，但副作⽤就是会产⽣ 脏页。</p></blockquote><p>WAL 怎么把随机写转化为顺序写的？<br>写redolog是顺序写的，先写redolog等合适的时候再写磁盘，间接的将随机写变成了顺序 写，性能确实会提⾼不少。</p><blockquote><p>[!note] 啥是随机写？为啥那么耗性能？ &amp;&amp; 啥是顺序写？<br>随机写我的理解是，这次写磁盘的那个扇区和上⼀次没啥关系，需要重新定位位置，<br>机械硬盘机械运动是很慢的, 即使不是机械运动重新定位写磁盘的位置也是很耗时的。</p></blockquote><p>顺序写我的理解是，这次写磁盘那个扇区就在上⼀次的下⼀个位置，不需要重新定位写磁盘 的位置速度当然会快⼀些。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原子性 (Atomicity)</title>
    <link href="/posts/37673/"/>
    <url>/posts/37673/</url>
    
    <content type="html"><![CDATA[<p>📝原子性 (Atomicity)::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><ul><li>事务是不可分割的最小操作单元, 要么全部成功, 要么全部失败, <code>不能结束在中间环节</code>。</li><li>如果事务在执⾏过程中发⽣错误，会被回滚到事务开始之前的状态, 就像这个事务从来没有执行过一样。</li><li>summary 因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li></ul><blockquote><p>[!tip]  通常情况下，⼀个事务对应⼀个完整的业务<br>事务是一组操作的集合,<br><strong>事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求, 即这些操作要么同时成功, 要么同时失败。</strong></p></blockquote><p>就比如: 张三给李四转账 1000 块钱, 张三银行账户的钱减少 1000, 而李四银行账户的钱要增加 1000。这一组操作就必须在一个事务的范围内, 要么都成功, 要么都失败。</p><blockquote><p>[!example]-<br>![[6. 事务简介.excalidraw]]</p></blockquote><h1 id="2-保障事务的原子性-undo-log"><a class="markdownIt-Anchor" href="#2-保障事务的原子性-undo-log"></a> 2: 保障事务的原子性:  [[undo log]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>持久性 (Durability)</title>
    <link href="/posts/57032/"/>
    <url>/posts/57032/</url>
    
    <content type="html"><![CDATA[<p>📝持久性 (Durability)::</p><!-- basicblock-end --><h1 id="1-持久性-durability"><a class="markdownIt-Anchor" href="#1-持久性-durability"></a> 1: 持久性 (Durability)</h1><p>事务处理结束了以后，对数据的修改是永久的，即使是发⽣了系统故障，数据也不会丢失</p><blockquote><p>[!question] 回滚还对数据改变了吗, 应该不是吧</p></blockquote><p>事务一旦提交或回滚, 它对数据库中的数据的改变就是永久的。</p><h1 id="2-原理-redo-log"><a class="markdownIt-Anchor" href="#2-原理-redo-log"></a> 2: 原理 [[redo log]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务操作</title>
    <link href="/posts/7733/"/>
    <url>/posts/7733/</url>
    
    <content type="html"><![CDATA[<p>📝事务操作::</p><!-- basicblock-end --><p>事务操作<br>看方法 1️⃣即可</p><blockquote><p>[!example]- 未控制事务的情况<br>![[6. 事务 2022-11-01 16.03.53.excalidraw]]</p></blockquote><h2 id="01-控制事务方法-1️⃣"><a class="markdownIt-Anchor" href="#01-控制事务方法-1️⃣"></a> 0.1: 控制事务方法 1️⃣</h2><blockquote><p>[!example]-<br>![[6. 事务 2022-11-01 16.13.54.excalidraw]]</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>-- 显式启动事务语句<br><br>1). 开启事务<br>start transaction 或 begin<br><br>2). 提交事务<br>commit<br><br>3). 回滚事务<br>rollback<br><br><br>-- 关闭线程的⾃提交<br>set autocommit=0;<br>事务会持续存在直到你主动执⾏commit或者rollback，或者断开连接，<br>所以，如果采取了这种⽅法，就导致了接下来的查询都在事务中，如果是长连接，就导致了长事务。<br>所以，建议使⽤<br>set autocommit=1 # ❓开启线程的自提交<br><br></code></pre></td></tr></tbody></table></figure><p>[[长事务]]</p><h2 id="02-控制事务方法-2️⃣"><a class="markdownIt-Anchor" href="#02-控制事务方法-2️⃣"></a> 0.2: 控制事务方法 2️⃣</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">1). 查看/设置事务提交方式<br>select  @@autocommit ; <br>set   @@autocommit = 0 ;<br><br>2). 提交事务<br>commit<br><br>3). 回滚事务 <br>rollback<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!tip]<br>注意:上述的这种方式,我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 数据库分库分表后带来的优点</title>
    <link href="/posts/703/"/>
    <url>/posts/703/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 数据库分库分表后带来的优点::</p><!-- basicblock-end --><p>分库分表解决的现状问题：</p><p>可以解决<strong>数据库本⾝的瓶颈</strong>以及<strong>系统本⾝的瓶颈</strong><br>连接数： 连接数过多时，就会出现‘too many connections’的错误，访问量太⼤或者数据库设置的最 ⼤连接数太⼩的原因<br>Mysql 默认的最⼤连接数为 100 可以修改，⽽mysql 服务允许的最⼤连接数为 16384。</p><h1 id="1-具体问题"><a class="markdownIt-Anchor" href="#1-具体问题"></a> 1: 具体问题</h1><ul><li>数据库分表可以解决单表海量数据的查询性能问题</li><li>数据库分库可以解决单台数据库的并发访问压⼒问题<ul><li>⽹络 IO 瓶颈，请求的数据太多，数据传输⼤，⽹络带宽不够，链路响应时间变长 CPU 瓶颈，尤其在基础数据量⼤单机复杂 SQL 计算，SQL 语句执⾏占⽤CPU 使⽤率⾼，也有扫描⾏数⼤、锁冲突、锁等待等原因</li></ul></li><li>解决系统本⾝IO、CPU 瓶颈<ul><li>磁盘读写 IO 瓶颈，热点数据太多，尽管使⽤了数据库本⾝缓存，但是依旧有⼤量 IO, 导致 sql 执⾏速度慢</li></ul></li></ul><h1 id="2-查询"><a class="markdownIt-Anchor" href="#2-查询"></a> 2: 查询</h1><p>可以通过 show processlist; 、show full processlist，发现 CPU 使⽤率⽐较⾼的 SQL</p><p>常见的对于查询时间长，State 列值是 Sending data，Copying to tmp table，Copying to tmp table on disk，Sorting result，Using filesort 等都是可能有性能问题 SQL，清楚相关影响问题的情况可以 kill 掉</p><p>也存在执⾏时间短，但是 CPU 占⽤率⾼的 SQL，通过上⾯命令查询不到，这个时候最好通过执⾏计划分析 explain 进⾏分析</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表的问题</title>
    <link href="/posts/30550/"/>
    <url>/posts/30550/</url>
    
    <content type="html"><![CDATA[<p>📝分库分表的问题::</p><!-- basicblock-end --><p>分库分表解决了问题，同时也带来了问题。<br>如</p><ul><li>跨库查询</li><li>分布式事务</li><li>分库之后的排序（翻页，函数的计算问题）</li><li>全局主键问题</li><li>容量规划（⼆次扩容问题）</li><li>技术选型问题</li></ul><h1 id="1-跨节点数据库-join-关联查询"><a class="markdownIt-Anchor" href="#1-跨节点数据库-join-关联查询"></a> 1: 跨节点数据库 Join 关联查询</h1><p>数据库切分前： 多表关联查询，可以通过 sql join 进⾏实现</p><p>分库分表后：数据可能分布在不同的节点上，sql join 带来的问题就⽐较⿇烦</p><h1 id="2-分库操作带来的分布式事务问题"><a class="markdownIt-Anchor" href="#2-分库操作带来的分布式事务问题"></a> 2: 分库操作带来的分布式事务问题</h1><blockquote><p>[!question]<br>操作内容同时分布在不同库中，不可避免会带来跨库事务问题，即分布式事务::   #疑问<br>[[分布式]]</p></blockquote><h1 id="3-执行的sql排序-翻页-函数计算问题"><a class="markdownIt-Anchor" href="#3-执行的sql排序-翻页-函数计算问题"></a> 3: 执⾏的SQL排序、翻页、函数计算问题</h1><p>分库后：</p><p>数据分布再不同的节点上，跨节点多库进⾏查询时，会出现limit分页、order by排序等问题</p><blockquote><p>[!note] 也会带来更多的CPU/IO资源损耗<br>当排序字段⾮分⽚字段时<br>要在不同的分⽚节点中将数据进⾏排序并返回，<br>然后将不同分⽚返回的结果集进⾏汇总和再次排序</p></blockquote><h1 id="4-数据库全局主键重复问题"><a class="markdownIt-Anchor" href="#4-数据库全局主键重复问题"></a> 4: 数据库全局主键重复问题</h1><p>常规表的id是使⽤⾃增id进⾏实现，</p><p>分库分表后，<br>由于表中数据同时存在不同数据库中，如 果⽤⾃增id，则会出现冲突问题</p><h1 id="5-容量规划分库分表后二次扩容问题"><a class="markdownIt-Anchor" href="#5-容量规划分库分表后二次扩容问题"></a> 5: 容量规划,分库分表后⼆次扩容问题</h1><p>业务发展快，初次分库分表后，满⾜不了数据存储，导致需要多次扩容</p><h1 id="6-分库分表技术选型问题"><a class="markdownIt-Anchor" href="#6-分库分表技术选型问题"></a> 6: 分库分表技术选型问题</h1><p>市场分库分表中间件相对较多，框架各有各的优势与短板，应该如何选择</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL架构升级之路</title>
    <link href="/posts/18486/"/>
    <url>/posts/18486/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL架构升级之路::</p><!-- basicblock-end --><p>数据库的演变升级</p><h1 id="1-单机"><a class="markdownIt-Anchor" href="#1-单机"></a> 1: 单机</h1><p>（1）请求量⼤查询慢 （<br>2）单机故障导致业务不可⽤</p><h1 id="2-主从"><a class="markdownIt-Anchor" href="#2-主从"></a> 2: 主从</h1><p>（1）数据库主从同步，从库可以⽔平扩展，满⾜更⼤读需求<br>（2）但单服务器 TPS，内存，IO 都是有限的<br>（3）可以考虑⽤主节点负责业务，从节点负责统计</p><h1 id="3-双主"><a class="markdownIt-Anchor" href="#3-双主"></a> 3: 双主</h1><p>（1）⽤户量级上来后，写请求越来越多<br>（2）⼀个 Master 是不能解决问题的，添加多了个主节点进⾏写⼊<br>（3）多个主节点数据要保存⼀致性，写操作需要2个master之间同步更加复杂</p><h1 id="4-分库分表目录"><a class="markdownIt-Anchor" href="#4-分库分表目录"></a> 4: [[分库分表目录]]</h1><h1 id="5-mysql-数据库分库分表后带来的优点"><a class="markdownIt-Anchor" href="#5-mysql-数据库分库分表后带来的优点"></a> 5: [[MySQL 数据库分库分表后带来的优点]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库排序思路</title>
    <link href="/posts/33120/"/>
    <url>/posts/33120/</url>
    
    <content type="html"><![CDATA[<p>📝数据库排序思路::</p><!-- basicblock-end --><h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1: 思路</h1><p>整体的思路和海量数据排序类似，不过考虑更加好⼀些</p><p>正常思路：</p><p>在分割段的阶段，使⽤内部排序，⽣成n个⼤⼩等于可⽤内存的顺串，最后再进⾏归并，使 得数据整体有序。</p><p>但是，为了避免I/O操作带来的影响，所以使⽤替换-选择排序的⽅式，可以使得在分割段阶 段⽣成的顺串⼤⼩⼤于可⽤内存⼤⼩。</p><p>同时为了能够再次减⼩I/O开销，合并阶段，可适量的增加归并的路数</p><p>不过增⼤路数也就意味着内部每个缓冲区数量增加（⼀个缓冲区放⼀个顺串），每次要在更 多的缓冲区中选取最⼩值，所以引⼊败者树（和堆排很像），减少增加归并路数，⽽影响内部归并。</p><h1 id="2-练习题与小总结"><a class="markdownIt-Anchor" href="#2-练习题与小总结"></a> 2: 练习题与⼩总结</h1><ol><li>练习内部排序的各种算法<ol><li>LC_排序数组:<a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 - 力扣（LeetCode）</a></li></ol></li><li>练习⼆路归并<ol><li>LC_归并排序 :<a href="https://leetcode.cn/problems/merge-sorted-array/">Loading Question… - 力扣（LeetCode）</a></li></ol></li></ol><p>总结：<br>为了提升效率，避免速度不匹配的问题，真的是精益求情，OS⾥⾯有各种⾼速缓存、缓冲 区等，数据库会利⽤磁盘的预读，顺序性读，以及设计特殊的数据结构。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>17：以独立语句将 newed 对象置入智能指针</title>
    <link href="/posts/46579/"/>
    <url>/posts/46579/</url>
    
    <content type="html"><![CDATA[<p>📝17：以独立语句将 newed 对象置入智能指针::</p><!-- basicblock-end --><p>![[17：以独立语句将 newed 对象置入智能指针 2022-11-14 17.48.44.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16：成对使用 new 和 delete 时候要采取相同形式</title>
    <link href="/posts/47461/"/>
    <url>/posts/47461/</url>
    
    <content type="html"><![CDATA[<p>📝16：成对使用 new 和 delete 时候要采取相同形式::</p><!-- basicblock-end --><p>![[16：成对使用 new 和 delete 时候要采取相同形式 2022-11-14 17.44.54.excalidraw]]</p><hr><p>categories:</p><ul><li>“\U0001F468\U0001F3FB‍\U0001F4BBcode”</li><li>C++</li><li>Effective C++<br>abbrlink: 60</li></ul><hr><p>16：成对使用 new 和 delete 时候要采取相同形式</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15：在资源管理类中提供对原始资源的访问</title>
    <link href="/posts/50093/"/>
    <url>/posts/50093/</url>
    
    <content type="html"><![CDATA[<p>📝15：在资源管理类中提供对原始资源的访问::</p><!-- basicblock-end --><p>![[15：在资源管理类中提供对原始资源的访问 2022-11-14 17.41.48.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14：在资源管理类小心 copying 行为</title>
    <link href="/posts/29656/"/>
    <url>/posts/29656/</url>
    
    <content type="html"><![CDATA[<p>📝14：在资源管理类小心 copying 行为::</p><!-- basicblock-end --><p>![[14：在资源管理类小心 copying 行为 2022-11-14 17.32.18.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shared_ptr</title>
    <link href="/posts/53861/"/>
    <url>/posts/53861/</url>
    
    <content type="html"><![CDATA[<p>📝shared_ptr::</p><!-- basicblock-end --><p>顾名思义 共享指针可以被共享 不像唯一指针 共享指针可以被多个所有者共享这意味着你可以将一个原始指针分配给多个所有者</p><p>![[shared_ptr.excalidraw]]</p><p>1、shared_ptr的实现机制是在拷贝构造时使用<strong>同一份</strong>引用计数<br>(1)一个模板指针<code>T*ptr</code> 指向实际的对象<br>(2)<strong>❓一个引用次数必须 new 出来的</strong>，不然会多个 shared_ptr 里面会有不同的引用次数而导致多次 delete<br>上面用的是： make_shared<br>(3)重载<code>operator*</code>和operator-&gt; 使得能像指针一样使用shared_ptr<br>(4)重载copy constructor 使其引用次数加一（拷贝构造函数）<br>(5)重载operatora=(赋值运算符) 如果原来的shared ptri已经有对象，则让其引用次数减一并判断引用是否为零（是否调用delete),然后将新的对象引用次数加一<br>(6)重载析构函数使引用次数减一并判断引用是否为零；（是否调用delete)</p><p>2、线程安全问题<br>(1)同一个shared_ptr被多个线程"读"是安全的；<br>(2)同一个shared_ptr被多个线程"写"是不安全的；<br>证明：在多个线程中同时对一个shared_ptr循环执行两遍swap。shared_ptr的swap函数的作用就是和另外一个shared_ptr交换引用对象和引用计数，是写操作。执行两遍swap之后，shared_ptr引用的对象的值应该不变<br>(3)共享引用计数的不同的shared_ptri被多个线程"写"是安全的。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>unique_ptr</title>
    <link href="/posts/39843/"/>
    <url>/posts/39843/</url>
    
    <content type="html"><![CDATA[<p>📝unique_ptr::</p><!-- basicblock-end --><blockquote><p>[!example]- unique_ptr‌ 例子<br>![[unique_ptr.excalidraw]]</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 源码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> D = default_delete&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> unique_ptr<br>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">explicit</span> <span class="hljs-built_in">unique_ptr</span>(pointer p) <span class="hljs-keyword">noexcept</span>;<span class="hljs-comment">// 不可用于转换函数。</span><br>~<span class="hljs-built_in">unique_ptr</span>() <span class="hljs-keyword">noexcept</span>;    <br>T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span>;            <span class="hljs-comment">// 重载*操作符。</span><br>T* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 重载-&gt;操作符。</span><br><span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr &amp;) = <span class="hljs-keyword">delete</span>;   <span class="hljs-comment">// 禁用拷贝构造函数。</span><br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr &amp;) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// 禁用赋值函数。</span><br><span class="hljs-built_in">unique_ptr</span>(unique_ptr &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 右值引用。</span><br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr &amp;&amp;) <span class="hljs-keyword">noexcept</span>;  <span class="hljs-comment">// 右值引用。</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">private</span>:<br>pointer ptr;  <span class="hljs-comment">// 内置的指针。</span><br>};<br><br></code></pre></td></tr></tbody></table></figure><p>智能指针就是类，类中有一个成员，管理着原始指针<br>❓因为内置的类型中没有析构函数, 所以自己创建一个类</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">测试类AA的定义：<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span><br>{<br><span class="hljs-keyword">public</span>:<br>string m_name;<br><span class="hljs-built_in">AA</span>() { cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">"调用构造函数AA()。\n"</span>; }<br><span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp; name) : <span class="hljs-built_in">m_name</span>(name) { cout &lt;&lt; <span class="hljs-string">"调用构造函数AA("</span>&lt;&lt; m_name &lt;&lt; <span class="hljs-string">")。\n"</span>; }<br>~<span class="hljs-built_in">AA</span>() { cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">"调用了析构函数~AA("</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">")。\n"</span>; }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="1-用法"><a class="markdownIt-Anchor" href="#1-用法"></a> 1: 用法</h1><h2 id="11-初始化"><a class="markdownIt-Anchor" href="#11-初始化"></a> 1.1: 初始化</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>方法一：(推荐)<br><span class="hljs-comment">// 分配内存并初始化。💡把西施对象交给智能指针 P0 来管理</span><br><span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">p0</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">"西施"</span>))</span></span>;     <br><br>方法二:(不推荐, 暂时没落地)<br>unique_ptr&lt;AA&gt; p0 = <span class="hljs-built_in">make_unique</span>&lt;AA&gt;(<span class="hljs-string">"西施"</span>);   <span class="hljs-comment">// C++14标准, 💡现在落地的是 C++</span><br><span class="hljs-number">11</span><br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; pp1=<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;();         <span class="hljs-comment">// 数据类型为int。</span><br>unique_ptr&lt;AA&gt; pp2 = <span class="hljs-built_in">make_unique</span>&lt;AA&gt;();       <span class="hljs-comment">// 数据类型为AA，默认构造函数。</span><br>unique_ptr&lt;AA&gt; pp3 = <span class="hljs-built_in">make_unique</span>&lt;AA&gt;(<span class="hljs-string">"西施"</span>);  <span class="hljs-comment">// 数据类型为AA，一个参数的构造函数。</span><br>unique_ptr&lt;AA&gt; pp4 = <span class="hljs-built_in">make_unique</span>&lt;AA&gt;(<span class="hljs-string">"西施"</span>,<span class="hljs-number">8</span>); <span class="hljs-comment">// 数据类型为AA，两个参数的构造函数。</span><br>方法三（不推荐）：<br>AA* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">"西施"</span>);<br><span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">p0</span><span class="hljs-params">(p)</span></span>;                  <span class="hljs-comment">// 用已存在的地址初始化。</span><br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="12-使用方法"><a class="markdownIt-Anchor" href="#12-使用方法"></a> 1.2: 使用方法</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">智能指针重载了*和-&gt;操作符，可以像使用指针一样使用unique_ptr。<br>不支持普通的拷贝和赋值。<br>AA* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">"西施"</span>);<br>unique_ptr&lt;AA&gt; pu2 = p;              <span class="hljs-comment">// 错误，不能把普通指针直接赋给智能指针。</span><br>unique_ptr&lt;AA&gt; pu3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">"西施"</span>); <span class="hljs-comment">// 错误，不能把普通指针直接赋给智能指针。</span><br>unique_ptr&lt;AA&gt; pu2 = pu1;           <span class="hljs-comment">// 错误，不能用其它unique_ptr拷贝构造。</span><br>unique_ptr&lt;AA&gt; pu3;<br>pu3 = pu1;                            <span class="hljs-comment">// 错误，不能用=对unique_ptr进行赋值。</span><br><br><span class="hljs-comment">// 💡因为 unique_ptr 的设计思想是独享, 如果多一个 unique_ptr 指向同一块内存, 那么其中一个 unique_ptr 释放了资源, 其他的指针再释放内存就造成了操作野指针. 所以禁用掉拷贝构造和拷贝赋值函数</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!note]</p><ul><li>不要用同一个裸指针初始化多个 unique_ptr 对象。<ul><li><code>裸指针: 是普通指针，也叫原始指针</code></li></ul></li><li>get () 方法返回裸指针。</li><li>不要用 unique_ptr 管理不是 new 分配的内存。</li><li>[[unique_ptr 2022-11-14 16.49.57.excalidraw]]</li></ul></blockquote><h2 id="13-用于函数的参数"><a class="markdownIt-Anchor" href="#13-用于函数的参数"></a> 1.3: 用于函数的参数</h2><p>引用（不能传值，因为 unique_ptr 没有拷贝构造函数）。<br>裸指针。<br>‌‌‌![[unique_ptr 2022-11-14 17.07.04.excalidraw]]</p><h2 id="14-不支持指针的运算-"><a class="markdownIt-Anchor" href="#14-不支持指针的运算-"></a> 1.4: 不支持指针的运算（+、-、++、–）</h2><h1 id="2-更多技巧"><a class="markdownIt-Anchor" href="#2-更多技巧"></a> 2: 更多技巧</h1><p><a href="https://www.bilibili.com/video/BV1gV4y1G7fH/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">独占智能指针unique_ptr使用技巧_哔哩哔哩_bilibili</a><br>1）将一个 unique_ptr 赋给另一个时，如果源 unique_ptr 是一个临时右值，编译器允许这样做；<br>如果源 unique_ptr 将存在一段时间，编译器禁止这样做。<br>一般用于函数的返回值。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;AA&gt; p0;<br>p0 = <span class="hljs-built_in">unique_ptr</span>&lt;AA&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span> (<span class="hljs-string">"西瓜"</span>));<br></code></pre></td></tr></tbody></table></figure><p>2）用 nullptr 给 unique_ptr 赋值将释放对象，空的 unique_ptr == nullptr</p><p>3）release()释放对原始指针的控制权，将unique_ptr置为空，返回裸指针。（可用于把unique_ptr传递给子函数，子函数将负责释放对象）</p><p>4）std::move () 可以转移对原始指针的控制权。（可用于把 unique_ptr 传递给子函数，子函数形参也是 unique_ptr）<br>5）reset()释放对象。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(T * _ptr= (T *) <span class="hljs-literal">nullptr</span>)</span></span>;<br>pp.<span class="hljs-built_in">reset</span>();        <span class="hljs-comment">// 释放pp对象指向的资源对象。</span><br>pp.<span class="hljs-built_in">reset</span>(<span class="hljs-literal">nullptr</span>);  <span class="hljs-comment">// 释放pp对象指向的资源对象</span><br>pp.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">AA</span>(<span class="hljs-string">"bbb"</span>));  <span class="hljs-comment">// 释放pp指向的资源对象，同时指向新的对象。</span><br><span class="hljs-number">6</span>）<span class="hljs-built_in">swap</span>()交换两个unique_ptr的控制权。<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(unique_ptr&lt;T&gt; &amp;_Right)</span></span>;<br></code></pre></td></tr></tbody></table></figure><p>7）unique_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样。<br>8）unique_ptr不是绝对安全，如果程序中调用exit()退出，全局的unique_ptr可以自动释放，但局部的unique_ptr无法释放。<br>9）unique_ptr提供了支持数组的具体化版本。<br>数组版本的unique_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">parr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>])</span></span>;          <span class="hljs-comment">// 不指定初始值。</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">parr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>]{ <span class="hljs-number">33</span>,<span class="hljs-number">22</span>,<span class="hljs-number">11</span> })</span></span>;  <span class="hljs-comment">// 指定初始值。</span><br>cout &lt;&lt; <span class="hljs-string">"parr1[0]="</span> &lt;&lt; parr1[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"parr1[1]="</span> &lt;&lt; parr1[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"parr1[2]="</span> &lt;&lt; parr1[<span class="hljs-number">2</span>] &lt;&lt; endl;<br><span class="hljs-function">unique_ptr&lt;AA[]&gt; <span class="hljs-title">parr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA[<span class="hljs-number">3</span>]{string(<span class="hljs-string">"西施"</span>), string(<span class="hljs-string">"冰冰"</span>), string(<span class="hljs-string">"幂幂"</span>)})</span></span>;<br>cout &lt;&lt; <span class="hljs-string">"parr2[0].m_name="</span> &lt;&lt; parr2[<span class="hljs-number">0</span>].m_name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"parr2[1].m_name="</span> &lt;&lt; parr2[<span class="hljs-number">1</span>].m_name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"parr2[2].m_name="</span> &lt;&lt; parr2[<span class="hljs-number">2</span>].m_name &lt;&lt; endl;<br><br></code></pre></td></tr></tbody></table></figure><h2 id="21-实例"><a class="markdownIt-Anchor" href="#21-实例"></a> 2.1: 实例</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例<span class="hljs-number">1</span>：<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span>  <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span><br>{<br><span class="hljs-keyword">public</span>:<br>string m_name;<br><span class="hljs-built_in">AA</span>() { cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">"调用构造函数AA()。\n"</span>; }<br><span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp; name) : <span class="hljs-built_in">m_name</span>(name) { cout &lt;&lt; <span class="hljs-string">"调用构造函数AA("</span>&lt;&lt; m_name &lt;&lt; <span class="hljs-string">")。\n"</span>; }<br>~<span class="hljs-built_in">AA</span>() { cout &lt;&lt; <span class="hljs-string">"调用了析构函数~AA("</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">")。\n"</span>; }<br>};<br><br><span class="hljs-comment">// 函数func1()需要一个指针，但不对这个指针负责。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">const</span> AA* a)</span> </span>{<br>cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;<br>}<br><br><span class="hljs-comment">// 函数func2()需要一个指针，并且会对这个指针负责。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(AA* a)</span> </span>{<br>cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> a;<br>}<br><br><span class="hljs-comment">// 函数func3()需要一个unique_ptr，不会对这个unique_ptr负责。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-type">const</span> unique_ptr&lt;AA&gt; &amp;a)</span> </span>{<br>cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;<br>}<br><br><span class="hljs-comment">// 函数func4()需要一个unique_ptr，并且会对这个unique_ptr负责。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">(unique_ptr&lt;AA&gt; a)</span> </span>{<br>cout &lt;&lt; a-&gt;m_name &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">pu</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">"西施"</span>))</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">"开始调用函数。\n"</span>;<br><span class="hljs-comment">//func1(pu.get());        // 函数func1()需要一个指针，但不对这个指针负责。</span><br><span class="hljs-comment">//func2(pu.release());  // 函数func2()需要一个指针，并且会对这个指针负责。</span><br><span class="hljs-comment">//func3(pu);                // 函数func3()需要一个unique_ptr，不会对这个unique_ptr负责。</span><br><span class="hljs-built_in">func4</span>(<span class="hljs-built_in">move</span>(pu));     <span class="hljs-comment">// 函数func4()需要一个unique_ptr，并且会对这个unique_ptr负责。</span><br>cout &lt;&lt; <span class="hljs-string">"调用函数完成。\n"</span>;<br><br><span class="hljs-keyword">if</span> (pu == <span class="hljs-literal">nullptr</span>) cout &lt;&lt; <span class="hljs-string">"pu是空指针。\n"</span>;<br>}<br>示例<span class="hljs-number">2</span>：<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span>  <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span><br>{<br><span class="hljs-keyword">public</span>:<br>string m_name;<br><span class="hljs-built_in">AA</span>() { cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">"调用构造函数AA()。\n"</span>; }<br><span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> string &amp; name) : <span class="hljs-built_in">m_name</span>(name) { cout &lt;&lt; <span class="hljs-string">"调用构造函数AA("</span>&lt;&lt; m_name &lt;&lt; <span class="hljs-string">")。\n"</span>; }<br>~<span class="hljs-built_in">AA</span>() { cout &lt;&lt; <span class="hljs-string">"调用了析构函数~AA("</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">")。\n"</span>; }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-comment">//AA* parr1 = new AA[2];   // 普通指针数组。</span><br><span class="hljs-comment">////AA* parr1 = new AA[2]{ string("西施"), string("冰冰") };</span><br><span class="hljs-comment">//parr1[0].m_name = "西施1";</span><br><span class="hljs-comment">//cout &lt;&lt; "parr1[0].m_name=" &lt;&lt; parr1[0].m_name &lt;&lt; endl;</span><br><span class="hljs-comment">//parr1[1].m_name = "西施2";</span><br><span class="hljs-comment">//cout &lt;&lt; "parr1[1].m_name=" &lt;&lt; parr1[1].m_name &lt;&lt; endl;</span><br><span class="hljs-comment">//delete [] parr1;</span><br><br><span class="hljs-function">unique_ptr&lt;AA[]&gt; <span class="hljs-title">parr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA[<span class="hljs-number">2</span>])</span></span>;   <span class="hljs-comment">// unique_ptr数组。</span><br><span class="hljs-comment">//unique_ptr&lt;AA[]&gt; parr2(new AA[2]{ string("西施"), string("冰冰") });</span><br>parr2[<span class="hljs-number">0</span>].m_name = <span class="hljs-string">"西施1"</span>;<br>cout &lt;&lt; <span class="hljs-string">"parr2[0].m_name="</span> &lt;&lt; parr2[<span class="hljs-number">0</span>].m_name &lt;&lt; endl;<br>parr2[<span class="hljs-number">1</span>].m_name = <span class="hljs-string">"西施2"</span>;<br>cout &lt;&lt; <span class="hljs-string">"parr2[1].m_name="</span> &lt;&lt; parr2[<span class="hljs-number">1</span>].m_name &lt;&lt; endl;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-八股"><a class="markdownIt-Anchor" href="#3-八股"></a> 3: 八股</h1><p>unique_ptr 独享它指向的对象，也就是说，同时只有一个 unique_ptr 指向同一个对象，当这个 unique_ptr 被销毁时，指向的对象也随即被销毁。</p><p>1、unique_ptr"唯一"拥有其所指对象<br>同一时刻只能有一个 unique_ptr 指向给定对象，离开作用域时，若其指向对象，则将其所指对象销毁（默认 delete)</p><p>2、定义 unique_ptr 时<br>需要将其绑定到一个 new /make_unique 返回的指针上</p><p>3、unique_ptr 不支持普通的拷贝和赋值（因为拥有指向的对象）<br>但是可以拷贝和赋值一个将要被销毁的 unique_ptr; 可以通过 move /  (❓或者 release reset) 将指针所有权从一个（非 const) unique_ptr 转移到另一个 unique。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13：以对象管理资源</title>
    <link href="/posts/11317/"/>
    <url>/posts/11317/</url>
    
    <content type="html"><![CDATA[<p>📝13：以对象管理资源::</p><!-- basicblock-end --><p>![[13：以对象管理资源 2022-11-14 15.47.47.excalidraw]]</p><p>[[智能指针]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06：若不想使用编译器自动生成的函数，就应该明确拒绝</title>
    <link href="/posts/22043/"/>
    <url>/posts/22043/</url>
    
    <content type="html"><![CDATA[<p>📝06：若不想使用编译器自动生成的函数，就应该明确拒绝::</p><!-- basicblock-end --><p>![[06：若不想使用编译器自动生成的函数，就应该明确拒绝 2022-11-14 15.44.46.excalidraw]]</p><blockquote><p>[!example] 问题场景：<br>⽐如说想要禁⽌⼀个类对象的拷贝操作，就要禁⽌拷贝构造函数和拷贝赋值运算符。<br>但是不声明这两个函数，编译器可能会⾃动⽣成；<br>要想避免编译器⾃动⽣成，又要⾃⼰声明⼀份； 怎样都避免不了产⽣这两个函数。</p></blockquote><h1 id="1-解决方案-1"><a class="markdownIt-Anchor" href="#1-解决方案-1"></a> 1: 解决⽅案 1：</h1><p>将<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>声明为private函数，这样在类外部不能以拷贝构造和复 制的形式公然调⽤这两个函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp;); <br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp;);<br><br>};<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!bug] 解决⽅案 1 存在的问题：<br>以 class A 为例，A 的其他成员函数和友元函数还是能调⽤class A 的 private 函数。<br>由此引出解决⽅案2</p></blockquote><h1 id="2-解决方案-2"><a class="markdownIt-Anchor" href="#2-解决方案-2"></a> 2: 解决⽅案 2：</h1><p>定义⼀个基类专门阻⽌拷贝动作</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">unCopyable</span> { <br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">unCopyable</span>() {} <br>    ~<span class="hljs-built_in">unCopyable</span>() {}<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">unCopyable</span>(<span class="hljs-type">const</span> unCopyable&amp;) {} <br>unCopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unCopyable&amp;) {}<br><br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-keyword">private</span> unCopyable{ <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br><br>};<br><br></code></pre></td></tr></tbody></table></figure><p>此时，就算是 class A 的成员函数和友元函数，在尝试拷贝 A 的对象时，编译器会“试着“⽣成拷贝构造函数和拷贝赋值运算符，但是这种”试着“会被基类阻⽌，因为基类的对应函数时 private，⼦类不能调⽤</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01：视C++为一个语言联邦</title>
    <link href="/posts/53489/"/>
    <url>/posts/53489/</url>
    
    <content type="html"><![CDATA[<p>📝01：视C++为一个语言联邦::</p><!-- basicblock-end --><h1 id="1-c是一个多重范式的编程语言"><a class="markdownIt-Anchor" href="#1-c是一个多重范式的编程语言"></a> 1: C++是一个多重范式的编程语言，</h1><p>同时支持</p><ul><li>过程形式</li><li>面向过程形式</li><li>函数形式</li><li>泛型形式</li><li>元编程形式</li></ul><h1 id="2-为了理解c其主要的次语言有以下几个"><a class="markdownIt-Anchor" href="#2-为了理解c其主要的次语言有以下几个"></a> 2: 为了理解C++，其主要的次语言有以下几个</h1><p><strong>C</strong>：说到底 C+ +仍然是以 C 为基础</p><p><strong>Object-Oriented C++</strong>：这也就是 C with class 所诉求的，包括封装，继承，多态，virtual 函数（动态绑定）等等。<br>这一部分面向对象设计之古典守则在C++上最直接实施</p><p><strong>Template C++</strong>：C++的泛型编程部分，他们的威力强大，可以带来模板元编程</p><p><strong>STL</strong>：这是一个 Template 程序库，他对于容器，迭代器，算法，函数对象的规则有着极佳的紧密配合和协调，然而 templates 及程序库也可以用其他想法建置出来。<br>STL有着自己特殊的办事方式，你需要遵守它的约定</p><blockquote><p>[!summary] 请记住：C<ins>高效编程守则, 视情况而变化，取决于你用 C</ins>的那一部分</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12：复制对象时，勿忘其每一个成分</title>
    <link href="/posts/34778/"/>
    <url>/posts/34778/</url>
    
    <content type="html"><![CDATA[<p>📝12：复制对象时，勿忘其每一个成分::</p><!-- basicblock-end --><p>12：复制对象时，勿忘其每一个成分</p><h1 id="1-情景-1对于自己写的-copying-函数小心且负责"><a class="markdownIt-Anchor" href="#1-情景-1对于自己写的-copying-函数小心且负责"></a> 1: 情景 1：对于自己写的 copying 函数，小心且负责</h1><p>copying 函数：copy 构造函数，copy assignment 操作符<br>如果你自己声明copying函数，意思就是告诉编译器你并不喜欢缺省实现中某些行为。编译器仿佛被冒犯死 的，会以一种奇怪的方式回敬：当你实现的代码几乎必然出错时候却不告诉你</p><p>如果你为class添加一个成员变量，你必须同时修改copying函数，如果你忘记，编译器是不会提醒你的</p><h1 id="2-情景2对于继承的函数记得在继承类调用基类的copying函数"><a class="markdownIt-Anchor" href="#2-情景2对于继承的函数记得在继承类调用基类的copying函数"></a> 2: 情景2：对于继承的函数，记得在继承类调用基类的copying函数</h1><p>任何时候只要你承担起来为derived class撰写copying函数的重大责任，必须很小心的复制base class部 分，而不能将任务直接交给编译器（坐视不理？）</p><p>base class的那些成分往往都是private的，你无法直接访问他们，但是你应该让derived class 的 copying 函数调用相应的 base class函数<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211141536405.png" alt=""></p><p>当你编写一个 copying 函数，请确保<br>复制所有的 local 成员变量<br>调用所有 base classes 内适当的 copying 函数</p><p>补充<br>在行使情景二的建议的时候，你不应该</p><p>令copy assignment 操作符调用copy构造函数，因为你在试图构造一个已经存在的对象。但是这根本 不可行</p><p>令copy构造函数调用copy assignment操作符——同样毫无意义。</p><p>如果你发现你的copy构造函数和copy assignment 操作符有相似的代码，消除重复代码的做法是：建立一 个新的成员函数给两者调用。这样的函数往往是private的</p><blockquote><p>[!summary] 请记住：<br>copying 函数应该确保复制”对象内所有成员变量“以及”所有 base class 成分“.</p></blockquote><p>不要尝试以某个copying函数实现另外一个copying函数，应该将共同机能放进入第三个函数中，并由两 个copying函数共同调用</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11：在 operator=中处理自我赋值</title>
    <link href="/posts/8963/"/>
    <url>/posts/8963/</url>
    
    <content type="html"><![CDATA[<p>📝11：在 operator=中处理自我赋值::</p><!-- basicblock-end --><p>![[11：在operator=中处理自我赋值.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>10 令 operator=返回⼀个绑定到 `this` 的引⽤</title>
    <link href="/posts/56095/"/>
    <url>/posts/56095/</url>
    
    <content type="html"><![CDATA[<p>📝10 令 operator=返回⼀个绑定到 <code>this</code> 的引⽤::</p><!-- basicblock-end --><p>形式</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> { <br><span class="hljs-keyword">public</span>:<br>    ...<br><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; other) {<br>        ...<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>这是为了实现连锁赋值，即：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x, y, z;<br><br>x = y = z = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">//运⾏原理</span><br><br>x = (y = (z = <span class="hljs-number">100</span>))<br></code></pre></td></tr></tbody></table></figure><p>![[令operator=返回一个 reference to *this.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>联合索引不会用索引的情况</title>
    <link href="/posts/4746/"/>
    <url>/posts/4746/</url>
    
    <content type="html"><![CDATA[<p>📝联合索引不会用索引的情况::数据不相邻的情况</p><!-- basicblock-end --><p>有⼀个联合索引 (A,B,C),select * from test where a,c 会不会使⽤索引？</p><p>不会，<br>根据索引的创建过程，这棵 b+ 树的叶⼦节点的记录以及 ⼆级索引记录是按照 abc 的规则来排序的，</p><p>也就是说，先按照 a 的⼤⼩来排序，a 相等的情况下，再按照 b 的⼤⼩来排序，b 相等的话，最后再是 c 。</p><p>这样的话，符合 where 条件的 记录不⼀定相邻， 也就是说，并不能在某⼀个区间中找，还是得⼀条条找，查询效率并没有变⾼。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>⼀张表可以存储多少条信息</title>
    <link href="/posts/37902/"/>
    <url>/posts/37902/</url>
    
    <content type="html"><![CDATA[<p>📝⼀张表可以存储多少条信息::</p><!-- basicblock-end --><p>根据 B+树的形式，确定了该 B+树为1️⃣⼏阶的 B+树，以及2️⃣树的⾼度，就能确定叶⼦节点有最多有多少个。</p><p>假设: 树高为 3, 一个叶子节点可以存储 16 条记录</p><blockquote><p>[!summary]<br>主键 bigint 类型:  8 个字节 ➕ 指针 6 个字节 -&gt; 能存 2200w 左右<br>主键 int 类型: 4 个字节 ➕ 指针 6 个字节 -&gt; 4300w 左右</p></blockquote><p>假设采⽤的是InnoDB引擎<br>那么数据结构的⾓度来看，本着索引即数据的思路，就是求⼀个 B+树 能够存储多少数据， 根据 B+树 定义也就转变成了 2 个⼦问题：</p><ol><li>每个叶⼦结点存储能存储多少条记录</li><li>⼀共有多少个叶⼦结点</li></ol><p><strong>每个叶⼦结点能存储多少条记录</strong><br>假设⼀条记录的⼤⼩为1kb, 树高 3, InnoDB中默认每页为16kb，则⼀个叶⼦节点可存储16条数据</p><p><strong>⼀共有多少个叶⼦结点</strong><br>假设主键 bigint 类型:  8 个字节 ➕ 指针 6 个字节 : 一个单位为 14 个字节<br>一个叶子节点可以存储: (1024 * 16)/14 = 1170 个节点</p><p>树高为 2<br>有 1170 个叶子-&gt; 总存储记录: 1170 * 16</p><p>树高为 3<br>有 1170 * 1170 个叶子 -&gt; 总存储: 1170 * 1170 * 16</p><p>‌‌‌　　<br>![[一张表能存多少数据.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>group-by 使⽤原则</title>
    <link href="/posts/64963/"/>
    <url>/posts/64963/</url>
    
    <content type="html"><![CDATA[<p>📝group-by 使⽤原则::</p><!-- basicblock-end --><p>如果对 group by 语句的结果没有排序要求，要在语句后⾯加 order by null；</p><p>尽量让 group by 过程⽤上表的索引，确认⽅法是 explain 结果⾥没有 Using temporary 和 Using filesort；</p><p>如果 group by 需要统计的数据量不⼤，尽量只使⽤<strong>内存临时表</strong>；也可以通过适当调⼤ tmp_table_size 参数，来避免⽤到磁盘临时表；</p><p>如果数据量实在太⼤，使⽤ SQL_BIG_RESULT 这个提⽰，来告诉优化器直接使⽤排序算法 得到 group by 的结果，不要使⽤内存临时表。</p><p>[[DQL#^246cb8]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么临时表可以起别名？</title>
    <link href="/posts/46099/"/>
    <url>/posts/46099/</url>
    
    <content type="html"><![CDATA[<p>📝为什么临时表可以起别名？::</p><!-- basicblock-end --><blockquote><p>[!summary] 为什么临时表可以起别名？<br>在实际应⽤中，临时表⼀般⽤于处理⽐较复杂的计算逻辑。<br><strong>由于临时表是每个线程⾃⼰可见的，所以不需要考虑多个线程执⾏同⼀个处理逻辑时，临时表的重名问题。</strong><br>在线程退出的时候，临时表也能⾃动删除，省去了收尾和异常处理的⼯作。</p></blockquote><p>在 binlog_format='row’的时候，临时表的操作不记录到 binlog 中，也省去了不少⿇烦，防⽌出现主备不⼀致的情况<br>这⾥说到的临时表是⽤户临时表，⽽不是内存临时表</p><blockquote><p>[!question]<br>什么是主备一致呢, 还有主从一致又是什么::   #疑问</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么我只查⼀⾏的语句，也执⾏这么慢？</title>
    <link href="/posts/12920/"/>
    <url>/posts/12920/</url>
    
    <content type="html"><![CDATA[<p>📝为什么我只查⼀⾏的语句，也执⾏这么慢？::</p><!-- basicblock-end --><p>为什么我只查⼀⾏的语句，也执⾏这么慢？<br>原因从⼤到⼩可分为四种情况</p><ul><li>第⼀: MySQL 数据库本⾝被堵住了，⽐如：系统或⽹络资源不够, 刷脏页</li><li>第⼆: SQL 语句被堵住了，⽐如：<strong>表锁，⾏锁</strong>等，导致存储引擎不执⾏对应的 SQL 语句</li><li>第三: 索引使⽤不当，没有⾛索引，eg [[为什么 SQL 语句逻辑相同，性能却差异巨⼤？]]</li><li>第四: 是表中数据的特点导致的，⾛了索引，但由于⼀致性读，需要回滚多次才能读取出当前事务对应的值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么 SQL 语句逻辑相同，性能却差异巨⼤？</title>
    <link href="/posts/49816/"/>
    <url>/posts/49816/</url>
    
    <content type="html"><![CDATA[<p>📝为什么 SQL 语句逻辑相同，性能却差异巨⼤？::</p><!-- basicblock-end --><blockquote><p>[!summary] 总结：对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃⾛树搜索功能</p></blockquote><blockquote><p>[!question] 索引值的有序性与 B+树的有序性有什么关系呢</p></blockquote><h1 id="1-案例一条件字进行段函数操作"><a class="markdownIt-Anchor" href="#1-案例一条件字进行段函数操作"></a> 1: 案例⼀：条件字进行段函数操作</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- t_modified 上建⽴了索引<br>select count(*) from tradelog where month(t_modified)=7;<br></code></pre></td></tr></tbody></table></figure><p>你以为对字段⽣成了索引，应该会返回的很快，<br>但是 mysql 有⼀个规则：<strong>就是如果对字段做了函数计算，就⽤不上索引了</strong>。</p><p><strong>实际上，mysql 使⽤的 [[MySQL B+Tree .excalidraw| B+Tree]]提供的对于索引的快速定位能⼒，来源于同⼀层兄弟节点的有序性</strong>。<br>对索引字段做函数操作，可能会破坏索引值的有序性，<br>因此优化器就决定放弃⾛树搜索功能，转⽽进⾏全表扫描，所以运⾏就变慢了</p><p>‌‌‌</p><h1 id="2-案例二隐式类型转换"><a class="markdownIt-Anchor" href="#2-案例二隐式类型转换"></a> 2: 案例⼆：隐式类型转换：</h1><p>如果在限制语句中: 错误的将字符串与数字进⾏⽐较，<br>mysql 会将可以转化成数字的字符串转化成数字，没法转换的话，就会变成数字 0，<br>因此如果出现这种输⼊的失误，相当于调⽤了字符串转数字的函数，还是会使得优化器会放弃⾛树搜索功能，进⾏全表扫描</p><h1 id="3-案例三隐式字符编码转换"><a class="markdownIt-Anchor" href="#3-案例三隐式字符编码转换"></a> 3: 案例三：隐式字符编码转换</h1><p>如果执⾏两个表的联合查询，两个表通过外键进⾏联结，<br><strong>如果两个表使⽤的字符集不同，会对低⽔平的字符集执⾏升级转换函数，</strong><br>（相当于将 int 赋给 double 的这个思路, 需要将 int 转化为 double）。</p><p>如果限制语句是 where d.tradeid=l.tradeid，如果 d 的字符集低⽔平，就会执⾏函数操作，<br>使得优化器会放弃⾛树搜索功能，进⾏全表扫描</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何正确的显示随机消息</title>
    <link href="/posts/39719/"/>
    <url>/posts/39719/</url>
    
    <content type="html"><![CDATA[<p>📝如何正确的显示随机消息::</p><!-- basicblock-end --><blockquote><p>[!example] 场景<br>英语学习 App ⾸页有⼀个随机显⽰单词的功能，也就是根据每个⽤户的级别有⼀个单词表，<br>然后这个⽤户每次访问⾸页的时候，都会随机滚动显⽰三个单词。<br>他们发现随着单词表变⼤，选单词这个逻辑变得越来越慢，甚⾄影响到了⾸页的打开速度</p></blockquote><h1 id="1-1-order-by-rand-实现"><a class="markdownIt-Anchor" href="#1-1-order-by-rand-实现"></a> 1: 1、order by rand () 实现</h1><p>创建临时表→按主键顺序取出所有的单词，并给他们⼀个随机⼩数→初始化 sort_buffer，<br>从内存临时表取出数据放⼊ sort_buffer，按随机数排序，取出前三个，总扫描⾏数是 2×n+3</p><h1 id="2-2-磁盘临时表"><a class="markdownIt-Anchor" href="#2-2-磁盘临时表"></a> 2: 2、磁盘临时表</h1><p>如果 sort_buffer_size 设置的⼩，就会使⽤到磁盘临时表⽤于辅助排序，<br>当然 mysql ⾼版本 使⽤了优先队列排序的⽅法，就是只取三个值，构成⼀个堆，然后不断把剩下的值输⼊，⽤于更新队列。</p><p>这个过程不需要临时⽂件，因此对应的 number_of_tmp_files 是 0。<br>当然，如果堆的⼤⼩设 置的很⼤，sort_buffer 放不下，就会舍弃优先队列，重新使⽤临时表+归并排序来实现，number_of_tmp_files 就不再为 0。</p><h1 id="3-3-随机-id方法"><a class="markdownIt-Anchor" href="#3-3-随机-id方法"></a> 3: 3、随机 id⽅法</h1><p>我们实际上并不需要真正的为每⾏赋予⼀个随机值，然后进⾏排序，这样的成本就太⾼了。</p><p>可以借鉴主键 id 的唯⼀性，⽣成⼀个介于主键 id 最⼩值和最⼤值之间的随机数，<br>然后取不⼩ 于这个随机数的主键 id 的那⼀⾏即可。<br>总扫描⾏数是3，的那hi是如果主键id有空洞，就会 导致选择不同⾏的概率不同，不是真正的随机</p><h1 id="4-4-严格随机-id方法"><a class="markdownIt-Anchor" href="#4-4-严格随机-id方法"></a> 4: 4、严格随机 id⽅法</h1><p>取出表的总⾏数，⽣成⼀个总⾏数对应的随机值，取不⼩于这个随机数的主键id的那⼀⾏， 总扫描⾏数是C+Y+1</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>order by 是怎样⼯作的？</title>
    <link href="/posts/58678/"/>
    <url>/posts/58678/</url>
    
    <content type="html"><![CDATA[<p>📝order by 是怎样⼯作的？::</p><!-- basicblock-end --><h1 id="1-sort-buffer"><a class="markdownIt-Anchor" href="#1-sort-buffer"></a> 1: [[sort buffer]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>count 字段</title>
    <link href="/posts/25681/"/>
    <url>/posts/25681/</url>
    
    <content type="html"><![CDATA[<p>📝count 字段::</p><!-- basicblock-end --><blockquote><p>[!summary] 总结来说, 一行一行的取出行的数据判断不为空, 就累加 1</p></blockquote><p>按照效率排序的话： <code>count (字段) &lt; count (主键 id) &lt; count (1) ≈ count (*)</code></p><p><code>count (*)</code> 这么慢，我该怎么办？<br>要么忍，要么⾃⼰动⼿记录。。。</p><blockquote><p>[!summary] 下面 count () 的原则如下：<br>server 层要什么就给什么； InnoDB 只给必要的值；<br>现在的优化器只优化了 <code>count (*)</code> 的语义为“取⾏数”，其他“显⽽易见”的优化并没有做。</p></blockquote><h1 id="1-count-的语义是啥"><a class="markdownIt-Anchor" href="#1-count-的语义是啥"></a> 1: count ( ) 的语义是啥？</h1><p>⾸先，不同的存储引擎实现⽅式不同<br>MyISAM 引擎把⼀个表的总⾏数存在了磁盘上，因此执⾏ <code>count (*)</code> 的时候会直接返回这个数，效率很⾼；<br>⽽ InnoDB 引擎就⿇烦了，它执⾏ <code>count(*)</code> 的时候，需要把数据⼀⾏⼀⾏地从引擎⾥⾯读出来，然后累积计数<br>以下针对 innodb 来说 count () 是⼀个聚合函数，对于返回的结果集，⼀⾏⾏地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p><blockquote><p>[!summary] <code>count (*)</code> 怎么计数？<br>对于<code>count(*)</code>来说，并不会把全部字段取出来，⽽是专门做了优化，不取值。 <code>count(*)</code> 肯定不是 null，按⾏累加。</p></blockquote><h1 id="2-count-字段-怎么计数"><a class="markdownIt-Anchor" href="#2-count-字段-怎么计数"></a> 2: count (字段) 怎么计数？</h1><p>1、如果这个“字段”是定义为 not null 的话</p><p>⼀⾏⾏地从记录⾥⾯读出这个字段，判断不能为 null，<strong>按⾏累加</strong>；</p><p>2、如果这个“字段”定义允许为 null</p><p>执⾏的时候，判断到有可能是 null，还要把值取出来再判断⼀下，不是 null 才累加。</p><p>从引擎返回的字段会涉及到解析数据⾏，以及拷贝字段值的操作。</p><h1 id="3-count-主键-id-怎么计数"><a class="markdownIt-Anchor" href="#3-count-主键-id-怎么计数"></a> 3: count (主键 id) 怎么计数？</h1><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每⼀⾏的 id 值都取出来，返回给 server 层。</p><p>server 层拿到 id 后，判断是不可能为空的，就按⾏累加。</p><p>从引擎返回的 主键id 会涉及到解 析数据⾏，以及拷贝字段值的操作。</p><h1 id="4-count-1-怎么计数"><a class="markdownIt-Anchor" href="#4-count-1-怎么计数"></a> 4: count (1) 怎么计数？</h1><p>对于 count (1) 来说，InnoDB 引擎遍历整张表，但不取值。<br>server 层对于返回的每⼀⾏，放 ⼀个数字“1”进去，判断是不可能为空的，按⾏累加。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>表文件</title>
    <link href="/posts/42122/"/>
    <url>/posts/42122/</url>
    
    <content type="html"><![CDATA[<p>📝表文件::</p><!-- basicblock-end --><p>[[InnoDB磁盘结构]]</p><h1 id="1-表的数据信息存在哪里"><a class="markdownIt-Anchor" href="#1-表的数据信息存在哪里"></a> 1: 表的数据信息存在哪⾥？</h1><p>表数据信息可能较⼩也可能巨⼤⽆⽐，可以存储在共享表空间⾥，也可以单独存储在⼀个以.ibd 为后缀的⽂件⾥，由参数 innodb_file_per_table (默认开启)来控制，</p><p>建议总是作为⼀个单独的⽂ 件来存储，这样⾮常容易管理，<br>并且在不需要的时候，使⽤ drop table 命令也能直接把对应的⽂件删除，<br>如果存储在<strong>共享空间</strong>之中即使表删除了空间也不会释放。</p><h1 id="2-表的结构信息存在哪里"><a class="markdownIt-Anchor" href="#2-表的结构信息存在哪里"></a> 2: 表的结构信息存在哪⾥？</h1><p>⾸先，表结构定义占有的存储空间⽐较⼩</p><p>MySQL8.0 之前：表结构的定义信息存在以.frm 为后缀的⽂件⾥</p><p>MySQL8.0 之后：则允许把表结构的定义信息存在系统数据表之中<br>系统数据表，主要⽤于存储 MySQL 的系统数据，⽐如：数据字典、undo_log (默认) 等⽂件</p><h1 id="3-为啥删除了表的一半数据表文文件大小没变化"><a class="markdownIt-Anchor" href="#3-为啥删除了表的一半数据表文文件大小没变化"></a> 3: 为啥删除了表的⼀半数据，表⽂⽂件⼤⼩没变化？</h1><p>因为 delete 命令其实只是把记录的位置，或者数据页标记为了“可复⽤”，但磁盘⽂件的⼤⼩ 是不会变的。<br>也可以认为是⼀种逻辑删除，所以物理空间没有实际释放，只是标记为可复⽤，表⽂件的⼤⼩当然是不变的啦！</p><blockquote><p>[!success] 什么是可复用啊 : 就是可以再次利用</p></blockquote><h2 id="31-如何才能删除表数据后表文件大小就变小"><a class="markdownIt-Anchor" href="#31-如何才能删除表数据后表文件大小就变小"></a> 3.1: 如何才能删除表数据后，表⽂件⼤⼩就变⼩？</h2><p><strong>重建表</strong>，消除表因为进⾏⼤量的增删改操作⽽产⽣的空洞，使⽤如下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">alter table t engine=InnoDB <br>optimize table t ( 等于 recreate+analyze)<br>truntace table t (等于drop+create)<br></code></pre></td></tr></tbody></table></figure><h2 id="32-空洞是啥咋产生的"><a class="markdownIt-Anchor" href="#32-空洞是啥咋产生的"></a> 3.2: 空洞是啥？咋产⽣的？</h2><p>空洞就是那些被标记可复⽤但是还没被使⽤的存储空间。<br>使⽤delete 命令删除数据会产⽣空洞，标记为可复⽤ 插⼊新的数据可能引起页分裂，也可能产⽣空洞<br>修改操作，有时是⼀种先删后插的动作也可能产⽣空洞</p><blockquote><p>[!todo] - [ ] 下次找一下页段区的概念</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 抖了⼀下的问题</title>
    <link href="/posts/8290/"/>
    <url>/posts/8290/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 抖了⼀下的问题::</p><!-- basicblock-end --><h1 id="1-mysql-抖一下是什么意思"><a class="markdownIt-Anchor" href="#1-mysql-抖一下是什么意思"></a> 1: MySQL 抖⼀下是什么意思</h1><p>因为运⾏的不正常了，或者不稳定了，要花费更多的资需源处理别的事情，会使SQL语句的 执⾏效率明显变慢。</p><blockquote><p>[!summary] 针对 innoDB 导致 MySQL 抖的原因，<br><strong>主要是 InnoDB 会在后台刷脏页</strong>，⽽刷脏页的过程是要将内存页写⼊磁盘。[[redo log]]<br>所以，⽆论是你的查询语句在需要内存的时候可能要求淘汰⼀个脏页，还是由于刷脏页的逻辑会占⽤ IO 资源并可能影响到了你的更新语句，<br>都可能是造成你从业务端感知 MySQL“抖”了⼀下的原因。</p></blockquote><blockquote><p>[!note] MySQL 抖⼀下有啥问题？<br>很明显系统不稳定，性能突然下降对业务端是很不友好的</p></blockquote><blockquote><p>[!note] 怎么让 MySQL 不抖？</p><ul><li>设置合理参数配配置，尤其是设置好innodb_io_capacity 的值，</li><li>并且平时要多关注脏页⽐ 例，不要让它经常接近 75%</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>char 和 varchar 的区别？</title>
    <link href="/posts/34329/"/>
    <url>/posts/34329/</url>
    
    <content type="html"><![CDATA[<p>📝char 和 varchar 的区别？::</p><!-- basicblock-end --><h1 id="1-区别一定长和变长"><a class="markdownIt-Anchor" href="#1-区别一定长和变长"></a> 1: 区别一，定长和变长</h1><p>char 表示定长，长度固定，<br>char 如果插入的长度小于定义长度时，则用<strong>空格填充</strong>；</p><p>varchar 表示变长，即长度可变。<br>varchar 小于定义长度时，还是按实际长度存储，插入多长就存多长。</p><p>因为其长度固定，<strong>char 的存取速度还是要比 varchar 要快得多</strong>，方便程序的存储与查找；<br>但是 char 也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。<br>varchar则刚好相反，以时间换空间。</p><h1 id="2-区别之二存储的容量不同"><a class="markdownIt-Anchor" href="#2-区别之二存储的容量不同"></a> 2: 区别之二，存储的容量不同</h1><p>对 char 来说，最多能存放的字符个数 255，和编码无关。</p><p>而 varchar 呢，最多能存放 65532 个字符。<br>varchar 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65, 532 字节。</p><h1 id="3-存储方式"><a class="markdownIt-Anchor" href="#3-存储方式"></a> 3: 存储方式</h1><ul><li>char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。</li><li>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</li></ul><h1 id="4-其他"><a class="markdownIt-Anchor" href="#4-其他"></a> 4: 其他</h1><blockquote><p>[!question] 存储情况不同<br>下面的暂时不学了, 不明白还, 背住上边的</p></blockquote><p>以 compact ⾏格式为例：</p><p>⼀条完整的记录由两部分组成</p><ol><li><p>变长字段的真正数据内容</p></li><li><p>该变长字段所占⽤的字节数</p></li></ol><p>该变长字段所占⽤的字节数被放在变长字段列表中，并且按照列的顺序逆序存放。</p><p>⽽ char 类型的数据则只需要存储其真正的数据内容。</p><p>对于类型为 char (M) 的列</p><p>如果采⽤的是变长编码的字符集：</p><p>那么该列的值占⽤的字节数也会被存储到变长字段列表中，采⽤ 变长编码字符集的 CHAR (M) 类型的值要求⾄少占⽤ M 个字节，<br>但是 varchar(M) 没有这个要求。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择普通索引还是唯⼀索引？</title>
    <link href="/posts/57548/"/>
    <url>/posts/57548/</url>
    
    <content type="html"><![CDATA[<p>📝选择普通索引还是唯⼀索引？::</p><!-- basicblock-end --><h1 id="1-对于查询过程来说"><a class="markdownIt-Anchor" href="#1-对于查询过程来说"></a> 1: 对于查询过程来说</h1><p>（1）普通索引查到满⾜条件的第⼀个记录后，继续查找下⼀个记录，直到第⼀个不满⾜条件的记录<br>（2）唯⼀索引由于索引唯⼀性，查到第⼀个满⾜条件的记录后，停⽌检索</p><p>两者的性能差距微乎其微。因为 InnoDB 根据数据页来读写的。</p><h1 id="2-对于更新过程来说"><a class="markdownIt-Anchor" href="#2-对于更新过程来说"></a> 2: 对于更新过程来说</h1><p><strong>唯⼀索引的更新不能使⽤ [[change buffer]]</strong></p><h1 id="3-索引的选择和实践"><a class="markdownIt-Anchor" href="#3-索引的选择和实践"></a> 3: 索引的选择和实践</h1><p>尽可能使⽤普通索引。<br>redo log 主要节省的是<strong>随机写</strong>磁盘的 IO 消耗 (转成顺序写)，⽽change buffer 主要节省的则是<strong>随机读</strong>磁盘的 IO 消耗。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVCC</title>
    <link href="/posts/48520/"/>
    <url>/posts/48520/</url>
    
    <content type="html"><![CDATA[<p>📝MVCC::</p><!-- basicblock-end --><h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1: 基本概念</h1><h2 id="11-快照读-当前读"><a class="markdownIt-Anchor" href="#11-快照读-当前读"></a> 1.1: [[快照读 &amp; 当前读]]</h2><h2 id="12-mvcc"><a class="markdownIt-Anchor" href="#12-mvcc"></a> 1.2: MVCC</h2><p>全称 Multi-Version Concurrency Control，多版本并发控制。<br>指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。<br>MVCC 的具体实现，还需要依赖于数据库记录中的<strong>三个隐式字段、undo log 日志、readView</strong>。</p><h1 id="2-隐藏字段"><a class="markdownIt-Anchor" href="#2-隐藏字段"></a> 2: [[隐藏字段]]</h1><h1 id="3-undo-log"><a class="markdownIt-Anchor" href="#3-undo-log"></a> 3: [[undo log]]</h1><h1 id="4-readview"><a class="markdownIt-Anchor" href="#4-readview"></a> 4: [[ReadView]]</h1><h1 id="5-mvcc-原理分析"><a class="markdownIt-Anchor" href="#5-mvcc-原理分析"></a> 5: [[MVCC 原理分析]]</h1><blockquote><p>[!example]-<br>　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　![[什么是 mvcc .excalidraw]]</p></blockquote><p><strong>mvcc 只在 read committed 和 repeatable read 两个隔离级别下工作</strong>。<br>其他两个隔离级别够和 mvcc 不兼容,<br>因为 read uncommitted 总是读取最新的数据行, 而不是符合当前事务版本的数据行。<br>而 serializable 则会对所有读取的行都加锁。</p><p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。</p><h1 id="6-为什么-rr-能实现可重复读而-rc-不能-分两种情况"><a class="markdownIt-Anchor" href="#6-为什么-rr-能实现可重复读而-rc-不能-分两种情况"></a> 6: 为什么 rr 能实现可重复读⽽ rc 不能, 分两种情况</h1><blockquote><p>[!question] 应该是复用 readview 的问题吧<br>（1）快照读的情况下：<br>rr 不能更新事务内的 up_limit_id ,<br>⽽ rc 每次会把 up_limit_id 更新为快照读之前最新已提交事务的 transaction id, 则 rc 不能可重复读<br>（2）当前读的情况下：<br>rr 是利⽤ record lock+gap lock 来实现的,<br>⽽ rc 没有 gap,所以 rc 不能可重复读</p></blockquote><h1 id="7-当前读-快照读-mvcc-的关系"><a class="markdownIt-Anchor" href="#7-当前读-快照读-mvcc-的关系"></a> 7: 当前读, 快照读, MVCC 的关系</h1><p>MVCC: 维持一个数据的多个版本, 使读写操作没有冲突</p><p>快照读: MySQL 实现 MVCC 的一个非阻塞读功能</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常见函数的时间复杂度</title>
    <link href="/posts/14795/"/>
    <url>/posts/14795/</url>
    
    <content type="html"><![CDATA[<p>📝常见函数的时间复杂度::</p><!-- basicblock-end --><h1 id="1-原则"><a class="markdownIt-Anchor" href="#1-原则"></a> 1: 原则</h1><blockquote><p>[!summary] 时间复杂的是看<strong>次数</strong><br>![[时间复杂度分析 2022-08-05 18.11.16.excalidraw]]</p></blockquote><h2 id="11-普通类型"><a class="markdownIt-Anchor" href="#11-普通类型"></a> 1.1: 普通类型</h2><p><s>乘法：乘法操作的时间复杂度 = O(1) ：O(n) 就是乘n次</s><br><s>加法：一般忽略，但从0加到n的为O(n)的复杂度</s></p><h2 id="12-函数类型"><a class="markdownIt-Anchor" href="#12-函数类型"></a> 1.2: 函数类型</h2><ol><li>for循环嵌套：循环</li><li>if else：选择分支内最大的复杂度</li><li>[[递归算法的复杂度]]：递归次数 * 每次递归的操作次数</li></ol><h2 id="13-其他类型"><a class="markdownIt-Anchor" href="#13-其他类型"></a> 1.3: 其他类型</h2><ol><li>两端算法相加时，取两者最大值：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>O</mi><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>O</mi><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)+T_2(n)=max(Of_1(n),Of_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，eg：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>5</mn></msup><mo>+</mo><mi>n</mi><mo>=</mo><msup><mi>n</mi><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n^5+n=n^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li>两段算法嵌套时：为两者相乘：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)*T_2(n)=O(f_1(n)*f_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，eg：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^{2}*n^{2}=n^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></li><li>有两算法时,本质是时间复杂度为两个函数相加, 但最终结果还是取的大头:  [[4. 有序数组的平方]]</li></ol><h1 id="2-常见的时间复杂度"><a class="markdownIt-Anchor" href="#2-常见的时间复杂度"></a> 2: 常见的时间复杂度</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121507462.png" alt="|600"><br>快速排序：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> : sort 函数 [[sort()函数]]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208051803308.png" alt=""></p><p><strong>移位、与、加、减</strong> 等基本运算，占用 O(1) ；</p><blockquote><p>[!question] [[15 二进制中1的个数]]<br>逐位判断&gt;&gt;1: 需循环 log2n 次，其中 log2n 代表数字 n 最高位 1 的所在位数（例如 log24=2, log216=4）。<br>对 n 进行二进制拆分的时间复杂度: O(log⁡n)，</p></blockquote><p>反转函数 reverse(): O(n)</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>复杂度</title>
    <link href="/posts/22674/"/>
    <url>/posts/22674/</url>
    
    <content type="html"><![CDATA[<p>📝复杂度::</p><!-- basicblock-end --><h1 id="1-时间复杂度分析"><a class="markdownIt-Anchor" href="#1-时间复杂度分析"></a> 1: [[时间复杂度分析]]</h1><p>[[计算时间复杂度]]</p><h1 id="2-空间复杂度分析"><a class="markdownIt-Anchor" href="#2-空间复杂度分析"></a> 2: [[空间复杂度分析]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>拷贝构造 &amp; 拷贝赋值</title>
    <link href="/posts/34869/"/>
    <url>/posts/34869/</url>
    
    <content type="html"><![CDATA[<p>📝拷贝构造 &amp; 拷贝赋值::</p><!-- basicblock-end --><blockquote><p>[!summary] 有指针成员函数的类, 一定要有拷贝构造和拷贝赋值函数　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　<br>![[拷贝构造 &amp; 拷贝赋值.excalidraw]]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11-20</title>
    <link href="/posts/17911/"/>
    <url>/posts/17911/</url>
    
    <content type="html"><![CDATA[<p>📝11-20::</p><!-- basicblock-end --><h1 id="1-11-在-operator中处理自我赋值"><a class="markdownIt-Anchor" href="#1-11-在-operator中处理自我赋值"></a> 1: 11 在 operator=中处理⾃我赋值</h1><p>⾃我赋值的意思就是： 等号右边的东西和等号左边的东西是同⼀份（地址相同）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">a[i] = a[j];<span class="hljs-comment">// i == j 成⽴</span><br><br><br><br><span class="hljs-comment">// ⼀般的做法是在赋值前做⼀个检查：</span><br>A&amp; A::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; other) {<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-comment">// ⽐较双⽅地址 </span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>    <span class="hljs-keyword">delete</span> pb; <br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(*other.pb); <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-12-赋值对象时勿忘其每一个成分"><a class="markdownIt-Anchor" href="#2-12-赋值对象时勿忘其每一个成分"></a> 2: 12 赋值对象时勿忘其每⼀个成分</h1><p>复制函数包括：拷贝构造函数、拷贝赋值运算符 当⾃定义了复制函数后，编译器不会再⽣成补充版本（即便⾃定义的有问题）</p><ol><li>当为class添加⼀个成员变量，必须同时修改复制函数</li><li>为⼦类⾃定义复制函数时，要注意对基类成员的复制。基类成员通常是 private， ⼦类⽆法直接访问，应该让⼦类的复制函数调⽤相应的基类复制函数</li></ol><p>不能为了简化代码，就在拷贝构造函数中调⽤拷贝赋值运算符，也不能在拷贝赋值运算符中 调⽤拷贝构造函数。因为构造函数⽤来初始化新对象，⽽赋值运算符只能⽤于已初始化的对 象之上。</p><p>要想消除复制函数的重复代码，可以建⽴⼀个新的成员函数给复制函数调⽤，这个函数通常 是private且命名为init</p><hr><p>categories:</p><ul><li>“\U0001F468\U0001F3FB‍\U0001F4BBcode”</li><li>C++</li><li>Effective C++<br>abbrlink: 31</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09 绝不在构造和析构过程中调⽤virtual 函数</title>
    <link href="/posts/30357/"/>
    <url>/posts/30357/</url>
    
    <content type="html"><![CDATA[<p>📝09 绝不在构造和析构过程中调⽤virtual 函数::</p><!-- basicblock-end --><p>⼦类对象调⽤⼦类构造函数之前，会先调⽤⽗类构造函数。<br>若⼦类重写了⽗类中的⼀个虚函数 func ()，⽗类的构造函数中调⽤了 func () 函数，<br>那么当⼦类对象调⽤⽗类的构造函数执⾏ 到这⼀句时，会调⽤⽗类版本的func()函数。</p><p>这是因为：<br><strong>⽗类的构造函数的执⾏早于⼦类的构造函数</strong>，<br>当⽗类的构造函数执⾏时，⼦类的成员变量尚 未初始化，如果此时调⽤的虚函数下降⾄⼦类层次，会存在使⽤⼦类未初始化成员的风险， 因此C++禁⽌这种危险。</p><p>更根本的原因是：</p><p>⼦类对象在调⽤⽗类构造函数期间，对象类型是基类⽽不是⼦类，不仅虚函数会使⽤⽗类版 本，此时使⽤dynamic_cast和typeid，也会把对象视为基类类型</p><p>析构函数也是⼀样的原因</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>08. 别让异常逃离析构函数</title>
    <link href="/posts/730/"/>
    <url>/posts/730/</url>
    
    <content type="html"><![CDATA[<p>📝08. 别让异常逃离析构函数::</p><!-- basicblock-end --><ol><li>C++并不禁⽌析构函数抛出异常，但是不建议这样做</li><li>有两个异常存在的情况下，程序不是结束执⾏就是导致不明确的⾏为</li></ol><p>如果⽆法避免析构函数产⽣异常的可能性，有两种办法：</p><p>1、若析构函数爬出异常，就调⽤abort 结束程序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">A::~<span class="hljs-built_in">A</span>() {<br>    <span class="hljs-keyword">try</span> {a.<span class="hljs-built_in">func</span>();} <br>    <span class="hljs-built_in">catch</span>(...) {<br>    <span class="hljs-comment">//记录调⽤a.func()过程中出现异常</span><br>    <span class="hljs-built_in">abort</span>(); <br>    }<br><br>}<br></code></pre></td></tr></tbody></table></figure><p>2、吞下异常，当做什么也没发⽣过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">A::~<span class="hljs-built_in">A</span>() { <br>    <span class="hljs-keyword">try</span> {a.<span class="hljs-built_in">func</span>();} <br>    <span class="hljs-built_in">catch</span>(...) { <br>    <span class="hljs-comment">//记录调⽤a.func()过程中出现异常 </span><br>    } <br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚函数的实现原理</title>
    <link href="/posts/7627/"/>
    <url>/posts/7627/</url>
    
    <content type="html"><![CDATA[<p>📝虚函数的实现原理::</p><!-- basicblock-end --><hr><p>deck: “source::_posts::\U0001F468\U0001F3FB‍\U0001F4BBcode::C++::Effective C++::虚函数的实现原理.md”<br>title: 虚函数的实现原理<br>date: ‘2022-11-11 20:16’<br>categories:</p><ul><li>“\U0001F468\U0001F3FB‍\U0001F4BBcode”</li><li>C++</li><li>Effective C++<br>abbrlink: 7625<br>tags:</li></ul><hr><!-- basicblock-start oid="Obs6a7menwleqmQFdTzp9vzC"  -->  <p>📝虚函数的实现原理::</p><!-- basicblock-end --><hr><p>deck: “source::_posts::\U0001F468\U0001F3FB‍\U0001F4BBcode::C++::Effective C++::虚函数的实现原理.md”<br>title: 虚函数的实现原理<br>date: ‘2022-11-11 20:16’<br>categories:</p><ul><li>“\U0001F468\U0001F3FB‍\U0001F4BBcode”</li><li>C++</li><li>Effective C++<br>abbrlink: 7620<br>tags:</li></ul><hr><!-- basicblock-start oid="ObsD2d2SB3qjh9adnqUDnJQE"  --> <p>📝虚函数的实现原理::</p><!-- basicblock-end --><hr><p>abbrlink: 24<br>categories:</p><ul><li>“\U0001F468\U0001F3FB‍\U0001F4BBcode”</li><li>C++</li><li>Effective C++</li></ul><hr><p>虚函数的实现原理<br>![[虚函数的实现原理.excalidraw]]</p><ol><li><p>每个含有virtual函数的class都有⼀个vtbl（虚函数表），vtbl中存储的是指向各个 虚函数的函数指针；</p></li><li><p>每个对象内存空间内存在⼀个vptr（虚指针），这个vptr指向类的vtbl</p></li><li><p>当对象调⽤某个virtual函数的时候，编译器根据对象的vptr找到类的vtbl，在vtbl 中寻找适当的函数指针</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14-1. 剪绳子</title>
    <link href="/posts/56072/"/>
    <url>/posts/56072/</url>
    
    <content type="html"><![CDATA[<p>📝14-1. 剪绳子::<a href="https://leetcode.cn/problems/jian-sheng-zi-lcof/submissions/">剑指 Offer 14- I. 剪绳子 - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-数学推导"><a class="markdownIt-Anchor" href="#1-数学推导"></a> 1: 数学推导</h1><p>切分规则：</p><ol><li>最优：3。把绳子尽可能切为多个长度为3的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情<br>况。</li><li>次优：2。若最后一段绳子长度为2；则保留，不再拆为1+1。</li><li>最差：1。若最后一段绳子长度为 1；则应把一份 3+1 替换为 2+2，因为 2×2 &gt; 3×1。</li></ol><p>算法流程：</p><ul><li><ol><li>当 n＜3 时，按照规则应不切分，但由于题目要求必须剪成 m＞1 段，因此必须剪出一段长度为 1 的绳子，即返回 n 一 1。</li></ol></li><li><ol start="2"><li>当 n＞3 时，求 n 除以 3 的整数部分 a 和余数部分 b（即 n=3a +b），并分为以下三种情况：</li></ol><ul><li>当 b = 0 时，直接返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">3^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span>；</li><li>当 b = 1 时，要将一个 1+3 转换为 2+2，因此返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3^{a-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> × (2×2);</li><li>当 b = 2 时，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">3^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span> ×2。</li></ul></li></ul><p>错误未通过: [[if else 函数]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><p>v2: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a = n / <span class="hljs-number">3</span>, b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>  <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>  <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<br>    }<br>};<br><br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="11-复杂度"><a class="markdownIt-Anchor" href="#11-复杂度"></a> 1.1: 复杂度</h2><p>时间复杂度 O (1)：仅有求整、求余、次方运算。<br>求整和求余运算：资料提到不超过机器数的整数可以看作是 O (1)；<br>pow幂运算：查阅资料，提到浮点取幂为 O (1)。<br>空间复杂度 O(1)：变量a 和 b 使用常数大小额外空间。</p><p>if</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.机器人的运动范围</title>
    <link href="/posts/52524/"/>
    <url>/posts/52524/</url>
    
    <content type="html"><![CDATA[<p>📝13. 机器人的运动范围::<a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><blockquote><p>[! 参考资料]<br><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/">面试题13. 机器人的运动范围 题解 - 力扣（LeetCode）</a></p></blockquote><h1 id="1-方法一深度优先遍历-dfs"><a class="markdownIt-Anchor" href="#1-方法一深度优先遍历-dfs"></a> 1: 方法一：深度优先遍历 DFS</h1><ul><li>深度优先搜索：可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li>剪枝：在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为可行性剪枝。</li><li>算法解析：<ul><li>递归参数：当前元素在矩阵中的行列索引i和j，两者的数位和 si，sj。</li><li>终止条件：<ul><li>当①行列索引越界或</li><li>②数位和超出目标值 k 或</li><li>③ 当前元素已访问过时，返回0，代表不计入可达解。</li></ul></li></ul></li><li>递推工作：<ul><li>1.标记当前单元格：将索引（i，j）存入Set visited 中，代表此单元格已被访问过。</li><li><ol start="2"><li>搜索下一单元格：计算当前元素的下、右 两个方向元素的数位和，并开启下层递归。</li></ol></li></ul></li><li>回溯返回值：<ul><li>返回1 + 右方搜索的可达解总数 +下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; vis;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sumij</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>{<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(a!=<span class="hljs-number">0</span>){<br>            ret += a%<span class="hljs-number">10</span>;<br>            a=a/<span class="hljs-number">10</span>;<br>        }<br>        <span class="hljs-keyword">return</span> ret;<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>{<br>        <span class="hljs-comment">// ❓为啥要=号呢✅应该是下标 0</span><br>        <span class="hljs-keyword">if</span>( i &gt;= m || j &gt;= n||<span class="hljs-built_in">Sumij</span>(i)+<span class="hljs-built_in">Sumij</span>(j) &gt; k || vis[i][j] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 1️⃣越界 2️⃣超过 K3️⃣被访问过</span><br>        vis[i][j] = <span class="hljs-number">1</span>; <br>        <span class="hljs-comment">// 💡机器人只会往右走或者往下走</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>, j, k, m, n) + <span class="hljs-built_in">dfs</span>(i, j+<span class="hljs-number">1</span>, k, m, n);<span class="hljs-comment">// 如果能走到递归会自然加 1</span><br>        <br>    }<br><br><span class="hljs-keyword">public</span>:<br>           <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>{<br>        vis = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n)); <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,k, m, n);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>for update 的使⽤场景</title>
    <link href="/posts/51930/"/>
    <url>/posts/51930/</url>
    
    <content type="html"><![CDATA[<p>📝for update 的使⽤场景::</p><!-- basicblock-end --><p>⼀般这些操作都是很长⼀串并且是开启事务的。</p><p>如果库存刚开始读的时候是1，⽽⽴马另⼀个进程进⾏了update将库存更新为0了，⽽事务 还没有结束，会将错的数据⼀直执⾏下去，就会有问题。</p><p>需要 for upate <strong>进⾏数据加锁防⽌⾼并发时候数据出错，即 使事务保持 当前读 状态。</strong></p><blockquote><p>[!success]  当前读是可重复读吗, 下面的我也没看到 for update 的命令啊<br>当前读是每次都读到最新版本<br>下面的命令无所谓, 看[[行锁 (共享锁, 排他锁)#^6d5896|排它锁]]</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- ❓如果只给定⼀个参数，表示记录数。<br>select * from table limit [offset,] rows | rows offset offset; <br><br>-- 检索前5条记录(1-5)<br>mysql&gt; select * from orange limit 5;<br><br><br>-- 相当于<br><br>mysql&gt; select * from orange limit 0,5;<br><br>-- 两个参数，第⼀个参数表⽰offset, 第⼆个参数为记录数。<br><br>mysql&gt; select * from orange limit 10,15; // 检索记录11-25<br><br></code></pre></td></tr></tbody></table></figure><p>如果你想要清除⼀些 MySQL 使⽤内部缓存，你应该使⽤FLUSH 命令</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加锁规则</title>
    <link href="/posts/62856/"/>
    <url>/posts/62856/</url>
    
    <content type="html"><![CDATA[<p>📝加锁规则::</p><!-- basicblock-end --><p>加锁规则⾥⾯，包含了两个“原则”、两个“优化”和⼀个“bug”</p><h1 id="1-两个原则"><a class="markdownIt-Anchor" href="#1-两个原则"></a> 1: 两个原则</h1><ol><li><p>加锁的基本单位是 next-key lock。(next-key lock 是前开后闭区间)。</p></li><li><p>查找过程中访问到的对象才会加锁。</p></li></ol><h1 id="2-两个优化"><a class="markdownIt-Anchor" href="#2-两个优化"></a> 2: 两个优化</h1><ol><li><p>索引上的等值查询，给唯⼀索引加锁的时候，next-key lock 退化为⾏锁。如果不存在这个索引，退化为间隙锁。</p></li><li><p>索引上的等值查询，向右遍历时且最后⼀个值不满⾜等值条件的时候，next-key lock 退化为间隙锁。</p></li></ol><h1 id="3-一个bug"><a class="markdownIt-Anchor" href="#3-一个bug"></a> 3: ⼀个"bug"</h1><ol><li>唯⼀索引上的范围查询会访问到不满⾜</li><li>条件的第⼀个值为⽌。（MySQL8.0之后的 版本已经修复）</li></ol><blockquote><p>[!tip] 注意：</p><ol><li>⾮唯⼀索引的范围查询：范围查询都会访问到不满⾜条件的第⼀个值，并且不会执 ⾏上述的两个优化。唯⼀索引的范围查询仍旧会执⾏上述的优化。</li><li>delete 语句的和查询的加锁⽅式相同</li><li>limit 语句，遍历到满⾜条件的 n 条数据后，之后不再加 next-key lock</li></ol></blockquote><p>以上规则是在可重复读隔离级别 (repeatable-read) 下验证的。同时，可重复读隔离级别遵守两阶段锁协议，所有加锁的资源，都是在事务提交或者回滚的时候才释放的。如果切换到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下⾏锁的部分。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 死锁</title>
    <link href="/posts/42416/"/>
    <url>/posts/42416/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 死锁::</p><!-- basicblock-end --><blockquote><p>[!summary] 不同线程可以给同⼀个间隙加锁<br>意思时只有我这个线程可以操控这个间隙，其他线程不能使⽤，加锁时不会检测是否冲突的，但是如果两个都给同⼀个间隙上锁，之后两个线程都没办法在这个间隙上更新数据了，都会陷⼊等待另⼀个线程的间隙锁释放，也就是死锁。</p></blockquote><blockquote><p>[!note] 怎么解决<br>如果使⽤读提交隔离级别，那么只加⾏锁，不加间隙锁<br>语句执⾏过程中加上的⾏锁，在语句执⾏完成后，就要把“不满⾜条件的⾏”上的⾏锁直接释放了，不需要等到事务提交才释 放。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>间隙锁&amp;临键锁</title>
    <link href="/posts/61878/"/>
    <url>/posts/61878/</url>
    
    <content type="html"><![CDATA[<p>📝间隙锁&amp;临键锁::</p><!-- basicblock-end --><p>InnoDB 在 repeatable read (可重复读级别) 事务隔离级别运行间隙锁与临键锁，</p><p>InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询 (唯一索引)，给不存在的记录加锁时, 优化为间隙锁。</li><li>索引上的等值查询 (非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><blockquote><p>[!question]- 以上三种情况的例子<br>‌‌‌![[间隙锁&amp;临键锁.excalidraw]]</p></blockquote><blockquote><p>[!note]<br>注意：间隙锁唯一目的是防止其他事务插入间隙。<br>间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p></blockquote><h1 id="1-间隙锁"><a class="markdownIt-Anchor" href="#1-间隙锁"></a> 1: 间隙锁</h1><p>它锁的了⾏与⾏之间的间隙，能够阻塞新插⼊的操作 -&gt;即解决了幻读</p><p>怎么加间隙锁呢？使用写锁（又叫[[行锁 (共享锁, 排他锁)#^d2fd98 | 排它锁]]，X锁）时自动生效，也就是说我们执行 <code>SELECT * FEOM t FOR UPDATE</code>时便会自动触发间隙锁。</p><blockquote><p>[!tip]<br>读锁: 允许读, 允许写<br>写锁: 不允许读, 不允许写: 就是完全不想让其它事务操作该数据<br><img src="https://img-blog.csdnimg.cn/20201210160046264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzk5NjE1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>间隙锁之间是不冲突的 : eg: A事务对(5, 10]加了间隙锁以后，B事务也可以对这个区间加间隙锁。</p></blockquote><blockquote><p>[!note] 带来的问题<br>间隙锁的引⼊也带来了⼀些新的问题，⽐如：降低并发度，可能导致[[MySQL 死锁|死锁]]。</p></blockquote><h1 id="2-next-key-lock"><a class="markdownIt-Anchor" href="#2-next-key-lock"></a> 2: next-key lock</h1><p>⾏锁和间隙锁合称 next-key lock，这个锁是左开右闭的区间。<br>MySQL 为了解决幻读问题，在线程更新数据并 next-key lock 的过程中，⾸先必须在可重复读的隔离级别下，<br>执⾏以下的原则和优化： [[加锁规则]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>幻读</title>
    <link href="/posts/48403/"/>
    <url>/posts/48403/</url>
    
    <content type="html"><![CDATA[<p>📝幻读::</p><!-- basicblock-end --><h1 id="1-什么是幻读"><a class="markdownIt-Anchor" href="#1-什么是幻读"></a> 1: 什么是幻读？</h1><blockquote><p>[!summary]<br><code>A查询不到这个数据，不代表这个数据不存在</code>。<br><code>查询得到了某条数据，不代表它真的存在</code>。<br>这样是是而非的查询，就像是幻觉一样，似真似假，故为幻读<br>产生幻读的原因归根到底是由于查询得到的结果与真实的结果不匹配。</p></blockquote><blockquote><p>[!example] 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了"幻影"。<br>![[幻读 .excalidraw]]</p></blockquote><p>MySQL使用的InnoDB引擎默认的隔离级别是<code>可重复读</code>，也就是说在同一个事务中，两次执行同样的查询，得到的效果应该是一样的。因此，尽管B事务在A事务还未结束的时候，增加了表中的数据，但是为了维护可重复读，A事务中不管怎么查询，是查询不了新增的数据的。但是对于真实的表而言，表中的数据是的的确确增加了。</p><h1 id="2-为啥会出现幻读"><a class="markdownIt-Anchor" href="#2-为啥会出现幻读"></a> 2: 为啥会出现幻读？</h1><p>注意，幻读出现的场景：</p><ol><li>事务的隔离级别为<strong>可重复读</strong>，且是<strong>当前读</strong></li><li>幻读仅指新插⼊的⾏</li></ol><blockquote><p>[!question]<br>⾏锁只能锁定存在的⾏，针对新插⼊的操作没有限定</p></blockquote><p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。<br>幻读每次查找都是最新的版本, 所以才会出现原本没有的数据有了, 即幻读在[[快照读 &amp; 当前读|当前读]] 下才会出现。</p><p>![[为什么会出现幻读.excalidraw]]</p><h1 id="3-幻读带来的问题"><a class="markdownIt-Anchor" href="#3-幻读带来的问题"></a> 3: 幻读带来的问题？</h1><ol><li>对⾏锁语义的破坏</li><li>破坏了数据⼀致性</li></ol><h1 id="4-怎么避免幻读"><a class="markdownIt-Anchor" href="#4-怎么避免幻读"></a> 4: 怎么避免幻读？</h1><ul><li>存储引擎采⽤加间隙锁的⽅式来避免出现幻读</li><li>隔离级别设置最高可以解决这个问题 (这个会引起性能很低, 但数据安全性很高)</li></ul><h2 id="41-间隙锁是啥它怎么避免出现幻读的它引入了什么新的问题"><a class="markdownIt-Anchor" href="#41-间隙锁是啥它怎么避免出现幻读的它引入了什么新的问题"></a> 4.1: 间隙锁是啥？它怎么避免出现幻读的？它引⼊了什么新的问题？</h2><p>[[间隙锁&amp;临键锁]]</p><h1 id="5-幻读-vs-不可重复读"><a class="markdownIt-Anchor" href="#5-幻读-vs-不可重复读"></a> 5: 幻读 VS 不可重复读</h1><p><strong>幻读</strong>是说数据是否存在，原本不存在的数据存在了<br><strong>不可重复读</strong>是说数据的内容是否发生了变化，原本存在的数据的内容发生了改变</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 常见问题</title>
    <link href="/posts/8770/"/>
    <url>/posts/8770/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 常见问题::</p><!-- basicblock-end --><h1 id="1-幻读"><a class="markdownIt-Anchor" href="#1-幻读"></a> 1: [[幻读]]</h1><h1 id="2-for-update-的使用场景"><a class="markdownIt-Anchor" href="#2-for-update-的使用场景"></a> 2: [[for update 的使⽤场景]]</h1><h1 id="3-mvcc"><a class="markdownIt-Anchor" href="#3-mvcc"></a> 3: [[MVCC]]</h1><h1 id="4-选择普通索引还是唯一索引"><a class="markdownIt-Anchor" href="#4-选择普通索引还是唯一索引"></a> 4: [[选择普通索引还是唯⼀索引？]]</h1><h1 id="5-char-和-varchar-的区别"><a class="markdownIt-Anchor" href="#5-char-和-varchar-的区别"></a> 5: [[char 和 varchar 的区别？]]</h1><h1 id="6-mysql-抖了一下的问题"><a class="markdownIt-Anchor" href="#6-mysql-抖了一下的问题"></a> 6: [[MySQL 抖了⼀下的问题]]</h1><h1 id="7-表文件"><a class="markdownIt-Anchor" href="#7-表文件"></a> 7: [[表文件]]</h1><h1 id="8-count-字段"><a class="markdownIt-Anchor" href="#8-count-字段"></a> 8: [[count 字段]]</h1><h1 id="9-order-by-是怎样工作的"><a class="markdownIt-Anchor" href="#9-order-by-是怎样工作的"></a> 9: [[order by 是怎样⼯作的？]]</h1><h1 id="10-如何正确的显示随机消息"><a class="markdownIt-Anchor" href="#10-如何正确的显示随机消息"></a> 10: [[如何正确的显示随机消息]]</h1><h1 id="11-为什么-sql-语句逻辑相同性能却差异巨大"><a class="markdownIt-Anchor" href="#11-为什么-sql-语句逻辑相同性能却差异巨大"></a> 11: [[为什么 SQL 语句逻辑相同，性能却差异巨⼤？]]</h1><h1 id="12-为什么我只查一行的语句也执行这么慢"><a class="markdownIt-Anchor" href="#12-为什么我只查一行的语句也执行这么慢"></a> 12: [[为什么我只查⼀⾏的语句，也执⾏这么慢？]]</h1><h1 id="13-为什么临时表可以起别名"><a class="markdownIt-Anchor" href="#13-为什么临时表可以起别名"></a> 13: [[为什么临时表可以起别名？]]</h1><h1 id="14-group-by-使用原则"><a class="markdownIt-Anchor" href="#14-group-by-使用原则"></a> 14: [[group-by 使⽤原则]]</h1><h1 id="15-一张表可以存储多少条信息"><a class="markdownIt-Anchor" href="#15-一张表可以存储多少条信息"></a> 15: [[⼀张表可以存储多少条信息]]</h1><h1 id="16-联合索引不会用索引的情况"><a class="markdownIt-Anchor" href="#16-联合索引不会用索引的情况"></a> 16: [[联合索引不会用索引的情况]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>长事务</title>
    <link href="/posts/63607/"/>
    <url>/posts/63607/</url>
    
    <content type="html"><![CDATA[<p>📝长事务::</p><!-- basicblock-end --><blockquote><p>[!note] 长事务的查询<br>在informationschema库下的innodbtrx表中查询。</p></blockquote><h1 id="1-如何避免长事务对业务的影响"><a class="markdownIt-Anchor" href="#1-如何避免长事务对业务的影响"></a> 1: 如何避免长事务对业务的影响？</h1><h2 id="11-从应用开发端来看"><a class="markdownIt-Anchor" href="#11-从应用开发端来看"></a> 1.1: 从应⽤开发端来看</h2><ol><li><p>确定是否使⽤了set autocommit=0，如是，则改成1</p></li><li><p>确定是否有不必要的只读事务</p></li><li><p>业务连接数据库的时候，控制每个语句执⾏的最长时间 set maxexecutiontime</p></li></ol><h2 id="12-从数据库端来看"><a class="markdownIt-Anchor" href="#12-从数据库端来看"></a> 1.2: 从数据库端来看</h2><ol><li><p>监控相关表，设置长事务阈值，超过就报警/kill</p></li><li><p>可使⽤percona的pt-kill⼯具</p></li><li><p>在功能测试阶段输出所有的log，分析⽇志提前发现问题</p></li><li><p>把innodbundotablespaces设置成2或者更⼤的值</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 事务隔离</title>
    <link href="/posts/47615/"/>
    <url>/posts/47615/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 事务隔离::</p><!-- basicblock-end --><p>![[MySQL 事务隔离 2022-11-10 20.12.44.excalidraw]]</p><p>MySQL 原⽣引擎 MyISAM 不⽀持事务，所以被 InnoDB 取代。</p><p>[[事务隔离(目录)]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01-字节</title>
    <link href="/posts/30620/"/>
    <url>/posts/30620/</url>
    
    <content type="html"><![CDATA[<p>📝01-字节::</p><!-- basicblock-end --><h1 id="1-操作系统"><a class="markdownIt-Anchor" href="#1-操作系统"></a> 1: 操作系统</h1><ol><li><p>进程与线程区别，进程通信⽅式，说⼀下 socket，socket 在本机和在⽹络通信区别</p></li><li><p>多进程与多线程的区别以及使⽤场景?</p></li></ol><h1 id="2-计算机网络"><a class="markdownIt-Anchor" href="#2-计算机网络"></a> 2: 计算机网络</h1><p>1、http 和 https 的区别？</p><p>（1） 端口<br>HTTP 的 URL 由“http://”起始且默认使⽤端⼜80<br>HTTPS 的 URL 由“https://”起始且默认使⽤端⼜443。</p><p>（2）安全性和资源消耗</p><p>HTTP 协议运⾏在 TCP 之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅ 的⾝份</p><p>HTTPS 是运⾏在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运⾏在 TCP 之上。<br>所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。<br>所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP 耗费更多服务器资源;</p><p>（3）对称加密<br>密钥只有⼀个，加密解密为同⼀个密码，且加解密速度快，典型的对称加密算法有 DES、 AES 等;</p><p>（4）⾮对称加密<br>密钥成对出现（且根据公钥⽆法推知私钥，根据私钥也⽆法推知公钥），加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的 ⾮对称加密算法有 RSA、DSA 等。</p><blockquote><p>[!attention] 剩下的暂时没看</p></blockquote><h1 id="3-数据库"><a class="markdownIt-Anchor" href="#3-数据库"></a> 3: 数据库</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>面经</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL⾼可⽤⽅案类型</title>
    <link href="/posts/46761/"/>
    <url>/posts/46761/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL⾼可⽤⽅案类型::</p><!-- basicblock-end --><p>（1）基于主从复制</p><ol><li><p>⼀般情况下，采⽤双节点主从+keepalived/heartbeat⽅案</p></li><li><p>在master节点发⽣故障以后，复⽤keepalived/heartbeat的⾼可⽤机制实现快速切 换到slave节点</p></li></ol><p>（2）基于 Galera 协议<br>（3）基于 NDB 协议<br>（4）基于中间件/proxy<br>（5）基于共享存储<br>（6）基于主机⾼可⽤</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/posts/18708/"/>
    <url>/posts/18708/</url>
    
    <content type="html"><![CDATA[<p>📝分库分表::</p><!-- basicblock-end --><h1 id="1-原因"><a class="markdownIt-Anchor" href="#1-原因"></a> 1: 原因</h1><p>1、单库太⼤</p><p>单个数据库处理能⼒有限，所在的服务器上的磁盘空间也有限，单库存在 I/O 操作瓶颈。</p><p>主要⽅案：切分成更多更⼩的库</p><p>2、单表太⼤<br>CRUD 都成问题，索引膨胀，查询超时。<br>主要⽅案：切分成多个数据集更⼩的表</p><h1 id="2-拆分方案"><a class="markdownIt-Anchor" href="#2-拆分方案"></a> 2: 拆分⽅案</h1><p>1、垂直拆分</p><p>（1）垂直分表</p><ol><li>“⼤表拆⼩表“，基于列的字段进⾏</li><li>⼀般表中字段较多，将不常⽤的，数据较⼤的，长度较长的，拆分到“扩展表”</li></ol><p>（2）垂直分库</p><ol><li>⼀般情况下，针对⼀个系统中不同业务进⾏拆分</li><li>⼀般我们拆分之后，放到多个服务器上</li></ol><p>2、⽔平拆分<br>（1）⽔平分表<br>针对数据量巨⼤的单张表（⽐如订单），按照某种规则（RANGE，HASH 取模），切分到多张表中，这些表还在⼀个数据库中</p><p>（2）⽔平分库将单张表的数据切分到多个服务器上，每个服务器都有相应的库和表，只是表中的数据集合不同<br>⽔平分库能够有效的缓解单机和单库的性能瓶颈，I/O，连接数和硬件资源等瓶颈</p><blockquote><p>[!note] ⽔平分库分表切分规则：<br>range： 根据范围，⽐如 0-1000⼀个表，1001 到 2000⼀个表<br>hash 取模： ⽐如取 ID，进⾏hash 取模，根据模数分配到不同的数据库中<br>地理区域： 按照地理范围进⾏划分<br>时间范围： 按照时间进⾏切分</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 主从复制</title>
    <link href="/posts/33976/"/>
    <url>/posts/33976/</url>
    
    <content type="html"><![CDATA[<p>[[主从复制]] ::</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 高性能</title>
    <link href="/posts/43139/"/>
    <url>/posts/43139/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 高性能::</p><!-- basicblock-end --><h1 id="1-mysql-主从复制"><a class="markdownIt-Anchor" href="#1-mysql-主从复制"></a> 1: [[MySQL 主从复制]]</h1><h1 id="2-分库分表"><a class="markdownIt-Anchor" href="#2-分库分表"></a> 2: [[分库分表]]</h1><h1 id="3-mysql高可用方案类型"><a class="markdownIt-Anchor" href="#3-mysql高可用方案类型"></a> 3: [[MySQL⾼可⽤⽅案类型]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>⼦查询的执⾏⽅式</title>
    <link href="/posts/33542/"/>
    <url>/posts/33542/</url>
    
    <content type="html"><![CDATA[<p>📝⼦查询的执⾏⽅式:: <a href="marginnote3app://note/81C5DF66-9219-466E-AB9E-81607D0AEFA7">margin: 子查询的执行方式</a></p><!-- basicblock-end --><p>（1）不优化对于不相关⼦查询，先执⾏⼦查询，再将⼦查询的结果作为外层查询的参数对于相关⼦查询，先从外层查询中取⼀条记录，取相关列进⾏⼦查询，如此循环</p><p>（2）in⼦查询的优化</p><p>（3）物化<br>将⼦查询的结果写⼊临时表中，该临时表就是物化表基于内存的物化表建⽴哈希索引，基于磁盘的物化表建⽴B+树索引</p><p>（4）半连接<br>s1 表和 s2 表半连接的意思是：对于 s1 表的某条肌理，只关⼼在 s2 表中是否存在与之匹配的记录，⽽不关⼼与多少条记录与之匹配<br>这只是 MySQL 内部执⾏⼦查询的⼀种⽅式，不⾯向⽤户</p><p>（5）实现⽅式</p><p>（6）table pullout（表上拉）</p><p>查询列表只有主键或唯⼀索引列是，将⼦查询中的表上拉到外层查询的 from⼦句中</p><p>（7）重复值消除</p><ol><li>⽤临时表消除半连接结果集的重复值</li><li>松散扫描</li><li>半连接物化</li></ol><p>⾸次匹配</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL查询优化</title>
    <link href="/posts/55105/"/>
    <url>/posts/55105/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 查询优化:: <a href="marginnote3app://note/54965CD2-853C-47E1-BBF3-10202C67363A">margin: MySQL查询优化</a></p><!-- basicblock-end --><p>查询优化就是 MySQl 会将程序员编写的⼀些⽐较耗费性能的语句进⾏查询重写</p><h1 id="1-条件化简"><a class="markdownIt-Anchor" href="#1-条件化简"></a> 1: 条件化简</h1><h1 id="2-移除不必要的括号"><a class="markdownIt-Anchor" href="#2-移除不必要的括号"></a> 2: 移除不必要的括号</h1><h1 id="3-常量传递"><a class="markdownIt-Anchor" href="#3-常量传递"></a> 3: 常量传递：</h1><p>（1）某个表达式是某个列和某个常量的等值匹配，会直接⽤常量替换列名</p><h1 id="4-移除没用的条件"><a class="markdownIt-Anchor" href="#4-移除没用的条件"></a> 4: 移除没⽤的条件：</h1><p>（1）⽐如永远为 true 或 false：</p><h1 id="5-表达式计算"><a class="markdownIt-Anchor" href="#5-表达式计算"></a> 5: 表达式计算：</h1><p>（1）表达式只包含常量的话，值会被计算出来<br>（2）如果某个列在函数中或者以运算形式出现，优化器不会进⾏化简</p><h1 id="6-having和where子句的合并"><a class="markdownIt-Anchor" href="#6-having和where子句的合并"></a> 6: having和where⼦句的合并：</h1><p>（1）查询语句中没有 sum、max 这样的聚集函数以及 group⼦句的话，优化器会将 having 和 where⼦句合并<br>（2）having⼦句⽤于分组后过滤，where⽤于分组前合并</p><h1 id="7-常量表检测"><a class="markdownIt-Anchor" href="#7-常量表检测"></a> 7: 常量表检测：</h1><p>（1）使⽤主键等值匹配、使⽤唯⼀⼆级索引列等值匹配进⾏查询的表称为常量表<br>（2）优化器会优先执⾏常量表查询，因为速度⾮常快</p><h1 id="8-外连接消除"><a class="markdownIt-Anchor" href="#8-外连接消除"></a> 8: 外连接消除</h1><h1 id="9-优化器会将右连接转换为左连接查询"><a class="markdownIt-Anchor" href="#9-优化器会将右连接转换为左连接查询"></a> 9: 优化器会将右连接转换为左连接查询</h1><h1 id="10-空值拒绝"><a class="markdownIt-Anchor" href="#10-空值拒绝"></a> 10: 空值拒绝</h1><p>（1）在外连接查询中，指定的 where⼦句中包含被驱动表的列不为 null 值的条件（就是不允许查出来的记录中含有 null 值）<br>（2）被驱动表的 where⼦句符合空值拒绝的条件后，外连接和内连接可以相互转换</p><h1 id="11-子查询优化"><a class="markdownIt-Anchor" href="#11-子查询优化"></a> 11: ⼦查询优化</h1><h1 id="12-子查询简介"><a class="markdownIt-Anchor" href="#12-子查询简介"></a> 12: [[子查询简介]]</h1><h1 id="13-子查询的执行方式"><a class="markdownIt-Anchor" href="#13-子查询的执行方式"></a> 13: [[⼦查询的执⾏⽅式]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁的划分</title>
    <link href="/posts/54703/"/>
    <url>/posts/54703/</url>
    
    <content type="html"><![CDATA[<p>📝锁的划分::</p><!-- basicblock-end --><h1 id="1-数据库角度"><a class="markdownIt-Anchor" href="#1-数据库角度"></a> 1: 数据库角度</h1><h2 id="11-行锁-共享锁-排他锁1-共享锁共享锁也叫读锁或-s-锁-共享锁"><a class="markdownIt-Anchor" href="#11-行锁-共享锁-排他锁1-共享锁共享锁也叫读锁或-s-锁-共享锁"></a> 1.1: [[行锁 (共享锁, 排他锁)#1 共享锁（共享锁也叫读锁或 S 锁 ）|共享锁]]</h2><h2 id="12-行锁-共享锁-排他锁2-排他锁排它锁也叫独占锁-写锁或-x-锁排他锁"><a class="markdownIt-Anchor" href="#12-行锁-共享锁-排他锁2-排他锁排它锁也叫独占锁-写锁或-x-锁排他锁"></a> 1.2: [[行锁 (共享锁, 排他锁)#2 排他锁（排它锁也叫独占锁、写锁或 X 锁）|排他锁]]</h2><h2 id="13-行锁-共享锁-排他锁3-共享锁和排他锁共享锁和排他锁"><a class="markdownIt-Anchor" href="#13-行锁-共享锁-排他锁3-共享锁和排他锁共享锁和排他锁"></a> 1.3: [[行锁 (共享锁, 排他锁)#3 共享锁和排他锁|共享锁和排他锁]]</h2><h2 id="14-意向锁-intent-lock"><a class="markdownIt-Anchor" href="#14-意向锁-intent-lock"></a> 1.4: [[意向锁 (Intent lock)]]</h2><h1 id="2-程序员角度"><a class="markdownIt-Anchor" href="#2-程序员角度"></a> 2: 程序员角度</h1><h2 id="21-乐观锁悲观锁"><a class="markdownIt-Anchor" href="#21-乐观锁悲观锁"></a> 2.1: [[乐观锁&amp;悲观锁]]</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>意向锁 (Intent lock)</title>
    <link href="/posts/28386/"/>
    <url>/posts/28386/</url>
    
    <content type="html"><![CDATA[<p>📝意向锁 (Intent lock)::</p><!-- basicblock-end --><p>意向锁 (Intent lock)<br>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，<strong>使用意向锁来减少表锁的检查</strong>。</p><blockquote><p>[!example]- 简单来说就是在更⼤⼀级别的空间⽰意⾥⾯是否已经上过锁。<br>你可以给整个房⼦设置⼀个标识，告诉它⾥⾯有⼈，即使你只是获取了房⼦中某⼀个房间的锁。这样其他⼈如果想要获取整个房⼦的控制权，只需要看这个房⼦的标识即可，不需要再对房⼦中的每个房间进⾏查找。这样是不是很⽅便？</p></blockquote><p>‌‌‌</p><p>返回数据表的场景，如果我们给某⼀⾏数据加上了排它锁，数据库会⾃动给更⼤⼀级的空间，⽐如数据页或数据表加上意向锁，告诉其他⼈这个数据页或数据表已经有⼈上过排它锁了，这样当其他⼈想要获取数据表排它锁的时候，只需要了解是否有⼈已经获取了这个数据表的意向排他锁即可。</p><p>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理， 事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。这时，意向 锁会告诉其他事务已经有⼈锁定了表中的某些记录，不能对整个表进⾏全表扫描。</p><p>‌![[意向锁.excalidraw]]</p><h2 id="01-分类"><a class="markdownIt-Anchor" href="#01-分类"></a> 0.1: 分类</h2><p>意向共享锁 (IS): 由语句 select … lock in share mode 添加。<br>兼容性: 与表锁共享锁 (read) 兼容，与表锁排他锁 (write) 互斥.</p><p>意向排他锁 (IX): 由 insert、update、delete、select…for update 添加。<br>兼容性: 与表锁共享锁 (read) 及排他锁 (write) 都互斥，</p><p><strong>意向锁之间不会互斥。</strong></p><blockquote><p>[!tip] 一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p></blockquote><p>一个客户端对某一行加上了行锁，那么系统也会对其加上一个意向锁，当别的客户端来想要对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。</p><blockquote><p>[!example]<br>‌‌‌　　‌‌![[意向共享锁与表读锁.excalidraw]]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>行锁 (共享锁, 排他锁)</title>
    <link href="/posts/12215/"/>
    <url>/posts/12215/</url>
    
    <content type="html"><![CDATA[<p>📝行锁 (共享锁, 排他锁)::</p><!-- basicblock-end --><p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]<br>‌‌‌　　‌‌‌　　‌‌‌　　![[行锁-&gt;(共享锁, 排他锁) .excalidraw]]<br><a href="marginnote3app://note/745119B4-9CA9-46D2-A8E3-6D9A90EAC990">margin: 示例演示</a></p></blockquote><p>InnoDB 实现了以下两种类型的行锁：</p><h1 id="1-共享锁共享锁也叫读锁或-s-锁"><a class="markdownIt-Anchor" href="#1-共享锁共享锁也叫读锁或-s-锁"></a> 1: 共享锁（共享锁也叫读锁或 S 锁 ）</h1><p>共享锁锁定的资源可以被其他⽤户读取，但不能修改。<br>允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p><p>在进⾏SELECT 的时候，会将对象进⾏共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。</p><p>如果我们想要给某⼀⾏加上共享锁呢，⽐如想对 user_id=10 的数据⾏加上共享锁，可以像下⾯这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select user_id from product_comment where user_id = 10 lock in share mode;<br></code></pre></td></tr></tbody></table></figure><h1 id="2-排他锁"><a class="markdownIt-Anchor" href="#2-排他锁"></a> 2: 排他锁</h1><p>（排它锁也叫独占锁、写锁或 X 锁）</p><p>^d2fd98</p><p>排它锁锁定的数据只允许进⾏锁定操作的事务使⽤，其他事务⽆法对已锁定的数据进⾏查询或修改。</p><p>如果我们想要在某个数据⾏上添加排它锁，⽐如针对 user_id=10 的数据⾏，则写成如下这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select user_id from product_comment where user_id = 10 for update;<br></code></pre></td></tr></tbody></table></figure><p>^6d5896<br>[[for update 的使⽤场景]]</p><p>另外当我们对数据进⾏更新的时候，也就是 INSERT、DELETE 或者 UPDATE 的时候，数据库也会⾃动使⽤排它锁，防⽌其他事务对该数据⾏进⾏操作。</p><h1 id="3-共享锁和排他锁"><a class="markdownIt-Anchor" href="#3-共享锁和排他锁"></a> 3: 共享锁和排他锁</h1><blockquote><p>[!question] 这个好像不是属于行锁类型的</p></blockquote><p>共享锁和排他锁不仅可以锁住⼀⾏，也可以锁住⼀张表，如下所⽰：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">⽐如我们想给 product_comment 在表上加共享锁，可以使⽤下⾯这⾏命令<br><br>lock table product_comment read;<br><br>如果我们想要对表上的共享锁进⾏解锁，可以使⽤下⾯这⾏命令：<br><br>unlock table;<br><br>如果我们想给 product_comment 数据表添加排它锁，可以使⽤下⾯这⾏命令<br>lock table product_comment write;<br><br>这时只有获得排它锁的事务可以对 product_comment 进⾏查询或修改，其他事务如果想要 在 product_comment 表上查询数据，则需要等待。<br><br>你可以⾃⼰开两个 mysql 客户端来模拟下。这时我们释放掉排它锁，使⽤这⾏命令即可<br><br>unlock table;<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12.矩阵中的路径</title>
    <link href="/posts/23812/"/>
    <url>/posts/23812/</url>
    
    <content type="html"><![CDATA[<p>📝12. 矩阵中的路径::<br>v2 还是不太懂啊</p><!-- basicblock-end --><h1 id="1-剑指-offer-12-矩阵中的路径"><a class="markdownIt-Anchor" href="#1-剑指-offer-12-矩阵中的路径"></a> 1: <a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h1><p>给定一个&nbsp;<code>m x n</code> 二维字符网格&nbsp;<code>board</code> 和一个字符串单词&nbsp;<code>word</code> 。如果&nbsp;<code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt=""></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>：<br><br>输入：board = [[<span class="hljs-string">"A"</span>,<span class="hljs-string">"B"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"E"</span>],[<span class="hljs-string">"S"</span>,<span class="hljs-string">"F"</span>,<span class="hljs-string">"C"</span>,<span class="hljs-string">"S"</span>],[<span class="hljs-string">"A"</span>,<span class="hljs-string">"D"</span>,<span class="hljs-string">"E"</span>,<span class="hljs-string">"E"</span>]], word = <span class="hljs-string">"ABCCED"</span><br>输出：<span class="hljs-literal">true</span><br><br>示例 <span class="hljs-number">2</span>：<br><br>输入：board = [[<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>],[<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>]], word = <span class="hljs-string">"abcd"</span><br>输出：<span class="hljs-literal">false</span><br><br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>m = board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><p>[[1.回溯算法理论基础]]</p><p>‌‌‌　　![[12.矩阵中的路径 2022-11-09 10.54.12.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span></span>{<br>        <span class="hljs-keyword">if</span>(i &gt;= rows || i &lt; <span class="hljs-number">0</span> || j &gt;= cols || j &lt;<span class="hljs-number">0</span> || board[i][j] != word[k]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(k == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        board[i][j] = <span class="hljs-string">'\0'</span>;<br>        <span class="hljs-comment">// k+1去到下一个字母位置</span><br>        <span class="hljs-type">bool</span> res = <span class="hljs-built_in">dfs</span>(board, word, i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || <span class="hljs-built_in">dfs</span>(board, word, i - <span class="hljs-number">1</span>, j , k + <span class="hljs-number">1</span>) ||<br>                   <span class="hljs-built_in">dfs</span>(board, word, i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || <span class="hljs-built_in">dfs</span>(board, word, i, j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// ❓回溯的时候不是每一个元素都是 word[K]吧 ✅如果到这里了说明是符合条件的元素</span><br>        board[i][j] = word[k]; <br>        <span class="hljs-keyword">return</span> res;<br>    }<br><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> rows, cols; <span class="hljs-comment">// 如果放在函数中, 一会 private 访问不到了</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>{<br>        rows = board.<span class="hljs-built_in">size</span>();<br>        cols = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++){<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board, word, i, j, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[! 参考资料]<br><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/">剑指 Offer 12. 矩阵中的路径 题解 - 力扣（LeetCode）</a><br><a href="https://www.bilibili.com/video/BV1CK411c7gx/?p=10&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">12. 矩阵中的路径_哔哩哔哩_bilibili</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>行锁</title>
    <link href="/posts/13824/"/>
    <url>/posts/13824/</url>
    
    <content type="html"><![CDATA[<p>📝行锁::</p><!-- basicblock-end --><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1: 简介</h1><p>特点：</p><ol><li>每次操作锁住⼀⾏数据</li><li>开销⼤，加锁慢</li><li>发⽣锁冲突的概率是最低的，并发度是最⾼的</li></ol><p>在 InnoDB 事务中，⾏锁是在需要的时候才加上的，但并不是不需要了就⽴刻释放，⽽是要 等到事务结束时才释放。这个就是两阶段锁协议。<br>知道了这个设定，对我们使⽤事务有什么帮助呢？那就是，如果你的事务中需要锁多个⾏，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。</p><p>InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li><strong>行锁（Record Lock</strong>: 锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC（read commit ）、RR（repeat read）隔离级别下都支持。</li><li><strong>间隙锁（GapLock</strong>）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生[[脏读, 幻读, 不可重复读.excalidraw|幻读]]。在 RR 隔离级别下都支持。比如说两个临近叶子节点为 15 23，那么间隙就是指 [15 , 23], 锁的是这个间隙。</li><li><strong>临键锁（Next-Key Lock</strong>）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持。</li></ol><blockquote><p>[!summary]<br>![[行锁分类.excalidraw]]</p></blockquote><h2 id="11-行锁-共享锁-排他锁"><a class="markdownIt-Anchor" href="#11-行锁-共享锁-排他锁"></a> 1.1: [[行锁 (共享锁, 排他锁)]]</h2><h2 id="12-间隙锁临键锁"><a class="markdownIt-Anchor" href="#12-间隙锁临键锁"></a> 1.2: [[间隙锁&amp;临键锁]]</h2><h1 id="2-加锁规则"><a class="markdownIt-Anchor" href="#2-加锁规则"></a> 2: [[加锁规则]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>表级锁</title>
    <link href="/posts/22239/"/>
    <url>/posts/22239/</url>
    
    <content type="html"><![CDATA[<p>📝表级锁::</p><!-- basicblock-end --><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>应用在 MyISAM、InnoDB、BDB 等存储引擎中。</p><blockquote><p>[!summary] 对于表级锁，主要分为以下三类：<br>表锁<br>元数据锁（meta data lock，MDL）<br>意向锁</p></blockquote><blockquote><p>[!tip] 使⽤表锁的情况<br>（1）表⽐较⼤，事务需要更新全部或者⼤部分数据<br>（2）事务涉及到多个表，⽐较复杂，可能引起死锁，造成⼤量的事务回滚</p></blockquote><h1 id="1-表锁"><a class="markdownIt-Anchor" href="#1-表锁"></a> 1 表锁</h1><blockquote><p>[!summary] 对于表锁，分为两类：</p><ol><li><p>表共享读锁（read lock）</p><ol><li>所有的事物都只能读（当前加锁的客户端也只能读，不能写），不能写</li></ol></li><li><p>表独占写锁（write lock），</p><ol><li>对当前加锁的客户端，可读可写，对于其他的客户端，不可读也不可写。</li></ol></li></ol></blockquote><p>读锁不会阻塞其他客户端的读，但是会阻塞写。<br>写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">语法：<br>加锁：lock tables 表名... read/write。 <br>释放锁：unlock tables / 客户端断开连接 。<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>![[表级锁.excalidraw]]</p></blockquote><p>特点：</p><ol><li>每次操作锁住整张表</li><li>开销⼩，加锁快</li><li>并发度最低</li></ol><p>表锁的语法是 lock tables … read/write。<br>与 FTWRL 类似，可以⽤ unlock tables 主动释放锁，也可以在客户端断开的时候⾃动释 放。<br>需要注意： lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><h1 id="2-元数据锁meta-data-lockmdl"><a class="markdownIt-Anchor" href="#2-元数据锁meta-data-lockmdl"></a> 2 元数据锁（meta data lock，MDL）</h1><p>MDL 加锁过程是系统<strong>自动控制</strong>，无需显式使用，在访问一张表的时候会<strong>自动加上</strong>。<br><strong>MDL 锁主要作用是维护表元数据的数据一致性</strong>，在表上有活动事务的时候，不可以对元数据进行写入操作。<br><strong>为了避免 DML 与 DDL 冲突，保证读写的正确性</strong>。</p><blockquote><p>[! cite] 这里的元数据，大家可以简单理解为就是一张表的表结构。也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p></blockquote><blockquote><p>[!note] 在 MySQL5.5 中引入了 MDL，<br>当对一张表进行增删改查的时候，加 MDL 读锁（共享）<br>当对表结构进行变更操作的时候，加 MDL 写锁（排他）。</p></blockquote><p>读锁之间不互斥，因此你可以有多个线程同时对⼀张表增删改查。读写锁之间、写锁之间是互斥的，⽤来保证变更表结构操作的安全性。因此，如果有两个线程要同时给⼀个表加字段，其中⼀个要等另⼀个执⾏完才能开始执⾏。</p><blockquote><p>[!attention] 事务中的 MDL 锁，在语句执⾏开始时申请，但是语句结束后并不会马上释放，⽽会等到整个事务提交后再释放。（这可能会产⽣死锁的问题）</p></blockquote><blockquote><p>[!example]<br>‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　![[元数据锁.excalidraw]]</p></blockquote><h1 id="3-意向锁-intent-lock"><a class="markdownIt-Anchor" href="#3-意向锁-intent-lock"></a> 3 [[意向锁 (Intent lock)]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>全局锁</title>
    <link href="/posts/47660/"/>
    <url>/posts/47660/</url>
    
    <content type="html"><![CDATA[<p>📝全局锁::</p><!-- basicblock-end --><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，<br>以下语句均会被阻塞</p><ul><li>[[DML]]</li><li>[[DDL]] ，</li><li>更新类事务的提交语句</li></ul><blockquote><p>[!example] 其典型的使用场景<br>是做全库的逻辑备份，把整个库的表都 select 出来存成⽂本<br>对所有的表进行锁定，从而获取<strong>一致性</strong>视图，保证数据的完整性。</p></blockquote><p>‌‌‌![[全局锁.excalidraw]]</p><h1 id="1-语法"><a class="markdownIt-Anchor" href="#1-语法"></a> 1 语法</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">1). 加全局锁<br><br>flush tables with read lock ;<br><br>2). 数据备份<br><br>mysqldump- uroot –p1234 itcast &gt; D:/itcast.sql<br>mysqldump -u"用户名" -p"密码" "要备份的哪个数据库" "存到哪个 sql 文件中"<br><br>数据备份的相关指令, 在后面MySQL管理章节, 还会详细讲解. <br><br>3). 释放锁<br>unlock tables ;<br></code></pre></td></tr></tbody></table></figure><h1 id="2-特点"><a class="markdownIt-Anchor" href="#2-特点"></a> 2 特点</h1><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。<br>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。</p><blockquote><p>[!cite] 这里听不明白主从库的先不要着急，耐心把后面的运维篇看完之后，再回来看这个就明白了</p></blockquote><blockquote><p>[!summary] InnoDB 不加锁的备份<br>在 InnoDB 引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">mysqldump --single-transaction -uroot –p123456 itcast &gt; D:/itcast.sql<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL 锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github MySQL 笔记</title>
    <link href="/posts/14623/"/>
    <url>/posts/14623/</url>
    
    <content type="html"><![CDATA[<p>📝github MySQL 笔记::</p><!-- basicblock-end --><h1 id="1-基础篇"><a class="markdownIt-Anchor" href="#1-基础篇"></a> 1: 基础篇</h1><h2 id="11-通用语法及分类"><a class="markdownIt-Anchor" href="#11-通用语法及分类"></a> 1.1: 通用语法及分类</h2><ul><li>DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>DML: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>DQL: 数据查询语言，用来查询数据库中表的记录</li><li>DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><h3 id="111-ddl数据定义语言"><a class="markdownIt-Anchor" href="#111-ddl数据定义语言"></a> 1.1.1: DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="1111-数据库操作"><a class="markdownIt-Anchor" href="#1111-数据库操作"></a> 1.1.1.1: 数据库操作</h4><p>查询所有数据库:<br><code>SHOW DATABASES;</code><br>查询当前数据库：<br><code>SELECT DATABASE();</code><br>创建数据库：<br><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code><br>删除数据库:<br><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code><br>使用数据库：<br><code>USE 数据库名;</code></p><h5 id="11111-注意事项"><a class="markdownIt-Anchor" href="#11111-注意事项"></a> 1.1.1.1.1: 注意事项</h5><ul><li>UTF8 字符集长度为 3 字节，有些符号占 4 字节，所以推荐用 utf8mb4 字符集</li></ul><h4 id="1112-表操作"><a class="markdownIt-Anchor" href="#1112-表操作"></a> 1.1.1.2: 表操作</h4><p>查询当前数据库所有表：<br><code>SHOW TABLES;</code><br>查询表结构：<br><code>DESC 表名;</code><br>查询指定表的建表语句：<br><code>SHOW CREATE TABLE 表名;</code></p><p>创建表：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段1 字段1类型 [COMMENT 字段1注释],<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br></code></pre></td></tr></tbody></table></figure><p>所有的要用英文的格式<br><strong>最后一个字段后面没有逗号</strong></p><p>添加字段：<br><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称';</code></p><p>修改数据类型：<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p><p>修改字段名和字段类型：<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></p><p>例：将emp表的nickname字段修改为username，类型为varchar(30)<br><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称';</code></p><p>删除字段：<br><code>ALTER TABLE 表名 DROP 字段名;</code></p><p>修改表名：<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p><p>删除表：<br><code>DROP TABLE [IF EXISTS] 表名;</code></p><p>删除表，并重新创建该表：<br><code>TRUNCATE TABLE 表名;</code></p><h3 id="112-dml数据操作语言"><a class="markdownIt-Anchor" href="#112-dml数据操作语言"></a> 1.1.2: DML（数据操作语言）</h3><h4 id="1121-添加数据"><a class="markdownIt-Anchor" href="#1121-添加数据"></a> 1.1.2.1: 添加数据</h4><p>指定字段：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code><br>全部字段：<br><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p><p>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p><h5 id="11211-注意事项"><a class="markdownIt-Anchor" href="#11211-注意事项"></a> 1.1.2.1.1: 注意事项</h5><ul><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul><h4 id="1122-更新和删除数据"><a class="markdownIt-Anchor" href="#1122-更新和删除数据"></a> 1.1.2.2: 更新和删除数据</h4><p>修改数据：<br><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br>例：<br><code>UPDATE emp SET name = 'Jack' WHERE id = 1;</code></p><p>删除数据：<br><code>DELETE FROM 表名 [ WHERE 条件 ];</code></p><h3 id="113-dql数据查询语言"><a class="markdownIt-Anchor" href="#113-dql数据查询语言"></a> 1.1.3: DQL（数据查询语言）</h3><p>语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>字段列表<br>FROM<br>表名字段<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后的条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></tbody></table></figure><h4 id="1131-基础查询"><a class="markdownIt-Anchor" href="#1131-基础查询"></a> 1.1.3.1: 基础查询</h4><p>查询多个字段：<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br><code>SELECT * FROM 表名;</code></p><p>设置别名：<br><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code><br><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p><p>去除重复记录：<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p><p>转义：<br><code>SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'</code><br>/ 之后的_不作为通配符</p><h4 id="1132-条件查询"><a class="markdownIt-Anchor" href="#1132-条件查询"></a> 1.1.3.2: 条件查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></p><p>条件：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN (…)</td><td>在 in 之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是 NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 ||</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 年龄等于30<br>select * from employee where age = 30;<br>-- 年龄小于30<br>select * from employee where age &lt; 30;<br>-- 小于等于<br>select * from employee where age &lt;= 30;<br>-- 没有身份证<br>select * from employee where idcard is null or idcard = '';<br>-- 有身份证<br>select * from employee where idcard;<br>select * from employee where idcard is not null;<br>-- 不等于<br>select * from employee where age != 30;<br>-- 年龄在20到30之间<br>select * from employee where age between 20 and 30;<br>select * from employee where age &gt;= 20 and age &lt;= 30;<br>-- 下面语句不报错，但查不到任何信息<br>select * from employee where age between 30 and 20;<br>-- 性别为女且年龄小于30<br>select * from employee where age &lt; 30 and gender = '女';<br>-- 年龄等于25或30或35<br>select * from employee where age = 25 or age = 30 or age = 35;<br>select * from employee where age in (25, 30, 35);<br>-- 姓名为两个字<br>select * from employee where name like '__';<br>-- 身份证最后为X<br>select * from employee where idcard like '%X';<br></code></pre></td></tr></tbody></table></figure><h4 id="1133-聚合查询聚合函数"><a class="markdownIt-Anchor" href="#1133-聚合查询聚合函数"></a> 1.1.3.3: 聚合查询（聚合函数）</h4><p>常见聚合函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>语法：<br><code>SELECT 聚合函数 (字段列表) FROM 表名;</code><br>例：<br><code>SELECT count (id) from employee where workaddress = "广东省";</code></p><h4 id="1134-分组查询"><a class="markdownIt-Anchor" href="#1134-分组查询"></a> 1.1.3.4: 分组查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></p><p>where 和 having 的区别：</p><ul><li>执行时机不同：where 是分组之前进行过滤，不满足 where 条件不参与分组；having 是分组后对结果进行过滤。</li><li>判断条件不同：where 不能对聚合函数进行判断，而 having 可以。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）<br>select count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性数量<br>select gender, count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性的平均年龄<br>select gender, avg(age) from employee group by gender;<br>-- 年龄小于45，并根据工作地址分组<br>select workaddress, count(*) from employee where age &lt; 45 group by workaddress;<br>-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址<br>select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;<br></code></pre></td></tr></tbody></table></figure><h5 id="11341-注意事项"><a class="markdownIt-Anchor" href="#11341-注意事项"></a> 1.1.3.4.1: 注意事项</h5><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="1135-排序查询"><a class="markdownIt-Anchor" href="#1135-排序查询"></a> 1.1.3.5: 排序查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></p><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据年龄升序排序<br>SELECT * FROM employee ORDER BY age ASC;<br>SELECT * FROM employee ORDER BY age;<br>-- 两字段排序，根据年龄升序排序，入职时间降序排序(如果年龄相同那么就按这个)<br>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;<br></code></pre></td></tr></tbody></table></figure><h5 id="11351-注意事项"><a class="markdownIt-Anchor" href="#11351-注意事项"></a> 1.1.3.5.1: 注意事项</h5><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h4 id="1136-分页查询"><a class="markdownIt-Anchor" href="#1136-分页查询"></a> 1.1.3.6: 分页查询</h4><p>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询第一页数据，展示10条<br>SELECT * FROM employee LIMIT 0, 10;<br>-- 查询第二页<br>SELECT * FROM employee LIMIT 10, 10;<br></code></pre></td></tr></tbody></table></figure><h5 id="11361-注意事项"><a class="markdownIt-Anchor" href="#11361-注意事项"></a> 1.1.3.6.1: 注意事项</h5><ul><li>起始索引从 0 开始，起始索引 = （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL 是 LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><h4 id="1137-dql-执行顺序"><a class="markdownIt-Anchor" href="#1137-dql-执行顺序"></a> 1.1.3.7: DQL 执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h3 id="114-dcl"><a class="markdownIt-Anchor" href="#114-dcl"></a> 1.1.4: DCL</h3><h4 id="1141-管理用户"><a class="markdownIt-Anchor" href="#1141-管理用户"></a> 1.1.4.1: 管理用户</h4><p>查询用户：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USER mysql;<br>SELECT * FROM user;<br></code></pre></td></tr></tbody></table></figure><p>创建用户:<br><code>CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';</code></p><p>修改用户密码：<br><code>ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';</code></p><p>删除用户：<br><code>DROP USER '用户名'@'主机名';</code></p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建用户test，只能在当前主机localhost访问<br>create user 'test'@'localhost' identified by '123456';<br>-- 创建用户test，能在任意主机访问<br>create user 'test'@'%' identified by '123456';<br>create user 'test' identified by '123456';<br>-- 修改密码<br>alter user 'test'@'localhost' identified with mysql_native_password by '1234';<br>-- 删除用户<br>drop user 'test'@'localhost';<br></code></pre></td></tr></tbody></table></figure><h5 id="11411-注意事项"><a class="markdownIt-Anchor" href="#11411-注意事项"></a> 1.1.4.1.1: 注意事项</h5><ul><li>主机名可以使用 % 通配</li></ul><h4 id="1142-权限控制"><a class="markdownIt-Anchor" href="#1142-权限控制"></a> 1.1.4.2: 权限控制</h4><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><p>查询权限：<br><code>SHOW GRANTS FOR '用户名'@'主机名';</code></p><p>授予权限：<br><code>GRANT 权限列表 ON 数据库名. 表名 TO '用户名'@'主机名';</code></p><p>撤销权限：<br><code>REVOKE 权限列表 ON 数据库名. 表名 FROM '用户名'@'主机名';</code></p><h5 id="11421-注意事项"><a class="markdownIt-Anchor" href="#11421-注意事项"></a> 1.1.4.2.1: 注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="12-函数"><a class="markdownIt-Anchor" href="#12-函数"></a> 1.2: 函数</h2><p>函数是指一段可以直接被另外一段程序调用的程序或代码。</p><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="121-字符串函数"><a class="markdownIt-Anchor" href="#121-字符串函数"></a> 1.2.1: 字符串函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT (s1, s2, …, sn)</td><td>字符串拼接，将 s1, s2, …, sn 拼接成一个字符串</td></tr><tr><td>LOWER (str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER (str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD (str, n, pad)</td><td>左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符串长度</td></tr><tr><td>RPAD (str, n, pad)</td><td>右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符串长度</td></tr><tr><td>TRIM (str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING (str, start, len)</td><td>返回从字符串 str 从 start 位置起的 len 个长度的字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 拼接<br>SELECT CONCAT('Hello', 'World');<br>-- 小写<br>SELECT LOWER('Hello');<br>-- 大写<br>SELECT UPPER('Hello');<br>-- 左填充<br>SELECT LPAD('01', 5, '-');<br>-- 右填充<br>SELECT RPAD('01', 5, '-');<br>-- 去除空格<br>SELECT TRIM(' Hello World ');<br>-- 切片（起始索引为1）<br>SELECT SUBSTRING('Hello World', 1, 5);<br></code></pre></td></tr></tbody></table></figure><h3 id="122-数值函数"><a class="markdownIt-Anchor" href="#122-数值函数"></a> 1.2.2: 数值函数</h3><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL (x)</td><td>向上取整</td></tr><tr><td>FLOOR (x)</td><td>向下取整</td></tr><tr><td>MOD (x, y)</td><td>返回 x/y 的模</td></tr><tr><td>RAND ()</td><td>返回 0~1 内的随机数</td></tr><tr><td>ROUND (x, y)</td><td>求参数 x 的四舍五入值，保留 y 位小数</td></tr></tbody></table><h3 id="123-日期函数"><a class="markdownIt-Anchor" href="#123-日期函数"></a> 1.2.3: 日期函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE ()</td><td>返回当前日期</td></tr><tr><td>CURTIME ()</td><td>返回当前时间</td></tr><tr><td>NOW ()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR (date)</td><td>获取指定 date 的年份</td></tr><tr><td>MONTH (date)</td><td>获取指定 date 的月份</td></tr><tr><td>DAY (date)</td><td>获取指定 date 的日期</td></tr><tr><td>DATE_ADD (date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔 expr 后的时间值</td></tr><tr><td>DATEDIFF (date1, date2)</td><td>返回起始时间 date1 和结束时间 date2 之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- DATE_ADD<br>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);<br></code></pre></td></tr></tbody></table></figure><h3 id="124-流程函数"><a class="markdownIt-Anchor" href="#124-流程函数"></a> 1.2.4: 流程函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF (value, t, f)</td><td>如果 value 为 true，则返回 t，否则返回 f</td></tr><tr><td>IFNULL (value1, value2)</td><td>如果 value1 不为空，返回 value1，否则返回 value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果 val1 为 true，返回 res1，… 否则返回 default 默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果 expr 的值等于 val1，返回 res1，… 否则返回 default 默认值</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>name,<br>(case when age &gt; 30 then '中年' else '青年' end)<br>from employee;<br>select<br>name,<br>(case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'<br>from employee;<br></code></pre></td></tr></tbody></table></figure><h2 id="13-约束"><a class="markdownIt-Anchor" href="#13-约束"></a> 1.3: 约束</h2><ol><li>概念：约束是用来作用于表中字段上的规则，用于限制存储在表中的数据。</li><li>目的：保证数据库中的数据的正确、有效性和完整性</li></ol><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为 null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.1 版本后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p><h3 id="131-常用约束"><a class="markdownIt-Anchor" href="#131-常用约束"></a> 1.3.1: 常用约束</h3><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>id int primary key auto_increment,<br>name varchar(10) not null unique,<br>age int check(age &gt; 0 and age &lt; 120),<br>status char(1) default '1',<br>gender char(1)<br>);<br></code></pre></td></tr></tbody></table></figure><h3 id="132-外键约束"><a class="markdownIt-Anchor" href="#132-外键约束"></a> 1.3.2: 外键约束</h3><p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p>添加外键：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型,<br>...<br>[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)<br>);  <br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);<br><br>-- 例子  <br>alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);  <br></code></pre></td></tr></tbody></table></figure><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h4 id="1321-删除更新行为"><a class="markdownIt-Anchor" href="#1321-删除更新行为"></a> 1.3.2.1: 删除/更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与 RESTRICT 一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与 NO ACTION 一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 null（要求该外键允许为 null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb 不支持）</td></tr></tbody></table><p>更改删除/更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p><h2 id="14-多表查询"><a class="markdownIt-Anchor" href="#14-多表查询"></a> 1.4: 多表查询</h2><h3 id="141-多表关系"><a class="markdownIt-Anchor" href="#141-多表关系"></a> 1.4.1: 多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="1411-一对多"><a class="markdownIt-Anchor" href="#1411-一对多"></a> 1.4.1.1: 一对多</h4><p>案例：部门与员工</p><p>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="1412-多对多"><a class="markdownIt-Anchor" href="#1412-多对多"></a> 1.4.1.2: 多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="1413-一对一"><a class="markdownIt-Anchor" href="#1413-一对一"></a> 1.4.1.3: 一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="142-查询"><a class="markdownIt-Anchor" href="#142-查询"></a> 1.4.2: 查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合 A 集合和 B 集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="143-内连接查询"><a class="markdownIt-Anchor" href="#143-内连接查询"></a> 1.4.3: 内连接查询</h3><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工姓名，及关联的部门的名称<br>-- 隐式<br>select e.name, d.name from employee as e, dept as d where e.dept = d.id;<br>-- 显式<br>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="144-外连接查询"><a class="markdownIt-Anchor" href="#144-外连接查询"></a> 1.4.4: 外连接查询</h3><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表 1 LEFT [ OUTER ] JOIN 表 2 ON 条件 ...;</code><br>相当于查询表 1 的所有数据，包含表 1 和表 2 交集部分数据</p><p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 左<br>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;  <br>select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样  <br>-- 右<br>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;  <br></code></pre></td></tr></tbody></table></figure><p>左连接可以查询到没有 dept 的 employee，右连接可以查询到没有 employee 的 dept</p><h3 id="145-自连接查询"><a class="markdownIt-Anchor" href="#145-自连接查询"></a> 1.4.5: 自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工及其所属领导的名字  <br>select a.name, b.name from employee a, employee b where a.manager = b.id;  <br>-- 没有领导的也查询出来  <br>select a.name, b.name from employee a left join employee b on a.manager = b.id;  <br></code></pre></td></tr></tbody></table></figure><h3 id="146-联合查询-union-union-all"><a class="markdownIt-Anchor" href="#146-联合查询-union-union-all"></a> 1.4.6: 联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表A ...<br>UNION [ALL]<br>SELECT 字段列表 FROM 表B ...<br></code></pre></td></tr></tbody></table></figure><h4 id="1461-注意事项"><a class="markdownIt-Anchor" href="#1461-注意事项"></a> 1.4.6.1: 注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用 or 效率高，不会使索引失效</li></ul><h3 id="147-子查询"><a class="markdownIt-Anchor" href="#147-子查询"></a> 1.4.7: 子查询</h3><p>SQL 语句中嵌套 SELECT 语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="1471-标量子查询"><a class="markdownIt-Anchor" href="#1471-标量子查询"></a> 1.4.7.1: 标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部所有员工<br>select id from dept where name = '销售部';<br>-- 根据销售部部门ID，查询员工信息<br>select * from employee where dept = 4;<br>-- 合并（子查询）  <br>select * from employee where dept = (select id from dept where name = '销售部');  <br><br>-- 查询xxx入职之后的员工信息  <br>select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx');  <br></code></pre></td></tr></tbody></table></figure><h4 id="1472-列子查询"><a class="markdownIt-Anchor" href="#1472-列子查询"></a> 1.4.7.2: 列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与 ANY 等同，使用 SOME 的地方都可以使用 ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部和市场部的所有员工信息  <br>select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');<br>-- 查询比财务部所有人工资都高的员工信息<br>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部'));<br>-- 查询比研发部任意一人工资高的员工信息<br>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部'));<br></code></pre></td></tr></tbody></table></figure><h4 id="1473-行子查询"><a class="markdownIt-Anchor" href="#1473-行子查询"></a> 1.4.7.3: 行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：=, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx的薪资及直属领导相同的员工信息  <br>select * from employee where (salary, manager) = (12500, 1);  <br>select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx');  <br></code></pre></td></tr></tbody></table></figure><h4 id="1474-表子查询"><a class="markdownIt-Anchor" href="#1474-表子查询"></a> 1.4.7.4: 表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx1，xxx2的职位和薪资相同的员工<br>select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');<br>-- 查询入职日期是2006-01-01之后的员工，及其部门信息<br>select e.*, d.* from (select * from employee where entrydate &gt; '2006-01-01') as e left join dept as d on e.dept = d.id;<br></code></pre></td></tr></tbody></table></figure><h2 id="15-事务"><a class="markdownIt-Anchor" href="#15-事务"></a> 1.5: 事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1. 查询张三账户余额<br>select * from account where name = '张三';<br>-- 2. 将张三账户余额-1000<br>update account set money = money - 1000 where name = '张三';<br>-- 此语句出错后张三钱减少但是李四钱没有增加<br>模拟sql语句错误<br>-- 3. 将李四账户余额+1000<br>update account set money = money + 1000 where name = '李四';<br><br>-- 查看事务提交方式<br>SELECT @@AUTOCOMMIT;<br>-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效<br>SET @@AUTOCOMMIT = 0;<br>-- 提交事务<br>COMMIT;<br>-- 回滚事务<br>ROLLBACK;<br><br>-- 设置手动提交后上面代码改为：<br>select * from account where name = '张三';  <br>update account set money = money - 1000 where name = '张三';  <br>update account set money = money + 1000 where name = '李四';  <br>commit;  <br></code></pre></td></tr></tbody></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction; <br>select * from account where name = '张三';<br>update account set money = money - 1000 where name = '张三';<br>update account set money = money + 1000 where name = '李四';<br>commit;<br></code></pre></td></tr></tbody></table></figure><p>开启事务后，只有手动提交才会改变数据库中的数据。</p><h3 id="151-四大特性-acid"><a class="markdownIt-Anchor" href="#151-四大特性-acid"></a> 1.5.1: 四大特性 ACID</h3><ul><li>原子性 (Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性 (Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性 (Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性 (Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="152-并发事务"><a class="markdownIt-Anchor" href="#152-并发事务"></a> 1.5.2: 并发事务</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a></p></blockquote><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read (默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="2-进阶篇"><a class="markdownIt-Anchor" href="#2-进阶篇"></a> 2: 进阶篇</h1><h2 id="21-存储引擎"><a class="markdownIt-Anchor" href="#21-存储引擎"></a> 2.1: 存储引擎</h2><p>MySQL 体系结构：</p><p>![结构图](<a href="https://dhc.pythonanywhere.com/media/editor/MySQL">https://dhc.pythonanywhere.com/media/editor/MySQL</a> 体系结构_20220315034329549927.png “结构图”)<br>![层级描述](<a href="https://dhc.pythonanywhere.com/media/editor/MySQL">https://dhc.pythonanywhere.com/media/editor/MySQL</a> 体系结构层级含义_20220315034359342837.png “层级描述”)</p><p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是 InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询建表语句<br>show create table account;  <br>-- 建表时指定存储引擎<br>CREATE TABLE 表名(<br>...<br>) ENGINE=INNODB;<br>-- 查看当前数据库支持的存储引擎<br>show engines;<br></code></pre></td></tr></tbody></table></figure><h3 id="211-innodb"><a class="markdownIt-Anchor" href="#211-innodb"></a> 2.1.1: InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx 代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like 'innodb_file_per_table';</code></p><p>从 idb 文件提取表结构数据：<br>（在 cmd 运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_20220316030616590001.png" alt="InnoDB 逻辑存储结构" title="InnoDB 逻辑存储结构"></p><h3 id="212-myisam"><a class="markdownIt-Anchor" href="#212-myisam"></a> 2.1.2: MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="213-memory"><a class="markdownIt-Anchor" href="#213-memory"></a> 2.1.3: Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash 索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="214-存储引擎特点"><a class="markdownIt-Anchor" href="#214-存储引擎特点"></a> 2.1.4: 存储引擎特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6 版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h3 id="215-存储引擎的选择"><a class="markdownIt-Anchor" href="#215-存储引擎的选择"></a> 2.1.5: 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="22-性能分析"><a class="markdownIt-Anchor" href="#22-性能分析"></a> 2.2: 性能分析</h2><h3 id="221-查看执行频次"><a class="markdownIt-Anchor" href="#221-查看执行频次"></a> 2.2.1: 查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE 'Com_______';</code> 或者 <code>SHOW SESSION STATUS LIKE 'Com_______';</code><br>例：<code>show global status like 'Com_______'</code></p><h3 id="222-慢查询日志"><a class="markdownIt-Anchor" href="#222-慢查询日志"></a> 2.2.2: 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有 SQL 语句的日志。<br>MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件（/etc/my.cnf）中配置如下信息：<br># 开启慢查询日志开关<br>slow_query_log=1<br># 设置慢查询日志的时间为 2 秒，SQL 语句执行时间超过 2 秒，就会视为慢查询，记录慢查询日志<br>long_query_time=2<br>更改后记得重启 MySQL 服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like 'slow_query_log';</code></p><h3 id="223-profile"><a class="markdownIt-Anchor" href="#223-profile"></a> 2.2.3: profile</h3><p>show profile 能在做 SQL 优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过 set 语句在 session/global 级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定 query_id 的 SQL 语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定 query_id 的 SQL 语句 CPU 的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="224-explain"><a class="markdownIt-Anchor" href="#224-explain"></a> 2.2.4: explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br># 直接在 select 语句之前加上关键字 explain / desc<br>EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id 相同，执行顺序从上到下；id 不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、   SUBQUERY（SELECT/WHERE 之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL 认为必须要执行的行数，在 InnoDB 引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好</li></ul><h2 id="23-索引"><a class="markdownIt-Anchor" href="#23-索引"></a> 2.3: 索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的 IO 成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="231-索引结构"><a class="markdownIt-Anchor" href="#231-索引结构"></a> 2.3.1: 索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持 B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree (空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text (全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6 版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2311-b-tree"><a class="markdownIt-Anchor" href="#2311-b-tree"></a> 2.3.1.1: B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树形成链表的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为 5（5 阶）的 b-tree 为例（每个节点最多存储 4 个 key，5 个指针）</p><p>![B-Tree 结构](<a href="https://dhc.pythonanywhere.com/media/editor/B-Tree">https://dhc.pythonanywhere.com/media/editor/B-Tree</a> 结构_20220316163813441163.png “B-Tree 结构”)</p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="2312-btree"><a class="markdownIt-Anchor" href="#2312-btree"></a> 2.3.1.2: B+Tree</h4><p>结构图：</p><p>![B+Tree 结构图](<a href="https://dhc.pythonanywhere.com/media/editor/B+Tree">https://dhc.pythonanywhere.com/media/editor/B+Tree</a> 结构图_20220316170700591277.png “B+Tree 结构图”)</p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="2313-hash"><a class="markdownIt-Anchor" href="#2313-hash"></a> 2.3.1.3: Hash</h4><p>哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了 hash 冲突（也称为 hash 碰撞），可以通过链表来解决。</p><p>![Hash 索引原理图](<a href="https://dhc.pythonanywhere.com/media/editor/Hash">https://dhc.pythonanywhere.com/media/editor/Hash</a> 索引原理图_20220317143226150679.png “Hash 索引原理图”)</p><p>特点：</p><ul><li>Hash 索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应 hash 功能，hash 索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="2314-面试题"><a class="markdownIt-Anchor" href="#2314-面试题"></a> 2.3.1.4: 面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="232-索引分类"><a class="markdownIt-Anchor" href="#232-索引分类"></a> 2.3.2: 索引分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引 (Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引 (Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一 (UNIQUE) 索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="2321-思考题"><a class="markdownIt-Anchor" href="#2321-思考题"></a> 2.3.2.1: 思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 10;<br>select * from user where name = 'Arm';<br>-- 备注：id为主键，name字段创建的有索引<br></code></pre></td></tr></tbody></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为 1k，一页中可以存储 16 行这样的数据。InnoDB 的指针占用 6 个字节的空间，主键假设为 bigint，占用字节数为 8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的 key 的数量，(n + 1) 表示指针数量（比 key 多一个）。算出 n 约为 1170。</p><p>如果树的高度为 2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为 3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="233-语法"><a class="markdownIt-Anchor" href="#233-语法"></a> 2.3.3: 语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>-- 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br>-- 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br><br>-- 删除索引  <br>drop index idx_user_email on tb_user;  <br></code></pre></td></tr></tbody></table></figure><h3 id="234-使用规则"><a class="markdownIt-Anchor" href="#234-使用规则"></a> 2.3.4: 使用规则</h3><h4 id="2341-最左前缀法则"><a class="markdownIt-Anchor" href="#2341-最左前缀法则"></a> 2.3.4.1: 最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。跳过的话，后面的排序就无从说起了。最左前缀法则在用 select 的时候，和放的位置是没有关系的，只要存在就行。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p><h4 id="2342-索引失效情况"><a class="markdownIt-Anchor" href="#2342-索引失效情况"></a> 2.3.4.2: 索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code> 换成 <code>explain select * from tb_user where phone = '17799990015';</code> 这是可以的。</li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处 phone 的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。<code>explain select * from tb_user where profession like '软件%';</code> 这个是不会失效的，只有前面加了%才会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。因为只要有一个没有索引，另外一个用不用索引都没有意义，都要进行全表扫描。所以就无需用索引。</li></ol><h4 id="2343-sql-提示"><a class="markdownIt-Anchor" href="#2343-sql-提示"></a> 2.3.4.3: SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession="软件工程";</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession="软件工程";</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force 就是无论如何都强制使用该索引。</p><h4 id="2344-覆盖索引回表查询"><a class="markdownIt-Anchor" href="#2344-覆盖索引回表查询"></a> 2.3.4.4: 覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code> ：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code> ：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>覆盖索引：<br>如果在生成的二级索引（辅助索引）中可以一次性获得 select 所需要的字段，不需要回表查询。</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是 select *；<br>如果在辅助索引（二级索引）中找聚集索引，如 <code>select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引 (name) 查找到对应的 id，返回 name 和 name 索引对应的 id 即可，只需要一次查询；<br>如果是通过辅助索引查找其他字段，则需要回表查询，如 <code>select id, name, gender from xxx where name='xxx';</code></p><p>所以尽量不要用 <code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下 SQL 语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username='itcast';</code></p><p>解：给 username 和 password 字段建立联合索引，则不需要回表查询，直接覆盖索引。<br>username 和 password 字段建立联合索引的叶子节点挂的就是 id 所以不需要三者同时建索引。</p><h4 id="2345-前缀索引"><a class="markdownIt-Anchor" href="#2345-前缀索引"></a> 2.3.4.5: 前缀索引</h4><p>当字段类型为字符串（varchar, text 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p><p>求选择性公式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(distinct email) / count(*) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;<br></code></pre></td></tr></tbody></table></figure><p>前缀索引中是有可能碰到相同的索引的情况的（因为选择性可能不为 1），所以使用前缀索引进行查询的时候，mysql 会有一个回表查询的过程，确定是否为所需数据。如图中的查询到 lvbu6 之后还要进行回表，回表完再查 xiaoy，看到 xiaoy 是不需要的数据，则停止查下一个。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/pre.png" alt="images" title="索引流程"></p><p>show index 里面的 sub_part 可以看到接取的长度</p><h4 id="2346-单列索引联合索引"><a class="markdownIt-Anchor" href="#2346-单列索引联合索引"></a> 2.3.4.6: 单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：</p><p><code>explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code><br>phone 和 name 都建立了索引情况下，这句只会用到 phone 索引字段。</p><p>联合索引的数据组织图：</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/uion.png" alt="images"></p><h5 id="23461-注意事项"><a class="markdownIt-Anchor" href="#23461-注意事项"></a> 2.3.4.6.1: 注意事项</h5><ul><li>多条件联合查询时，MySQL 优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</li></ul><h3 id="235-设计原则"><a class="markdownIt-Anchor" href="#235-设计原则"></a> 2.3.5: 设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="24-sql-优化"><a class="markdownIt-Anchor" href="#24-sql-优化"></a> 2.4: SQL 优化</h2><h3 id="241-插入数据"><a class="markdownIt-Anchor" href="#241-插入数据"></a> 2.4.1: 插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过 1000 条，500 - 1000 为宜）</li><li>手动提交事务</li><li>主键顺序插入（主键顺序插入的效率大于乱序插入）</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的 load 指令插入。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）<br>mysql --local-infile -u root -p<br># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>select @@local_infile;<br># 执行load指令将准备好的数据，加载到表结构中，先要把表建立起来。<br>load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\n';<br></code></pre></td></tr></tbody></table></figure><h3 id="242-主键优化"><a class="markdownIt-Anchor" href="#242-主键优化"></a> 2.4.2: 主键优化</h3><p>数据组织方式：在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>主键的顺序的插入过程如下：</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/keySort.png" alt="images"></p><p>但是如果主键是乱序插入的话，就会导致需要插入的位置为中间的位置，会有页分裂的过程。</p><p>页分裂：页可以为空，也可以填充一般，也可以填充 100%，每个页包含了 2-N 行数据（如果一行数据过大，会行溢出），根据主键排列。</p><p>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的 50%），InnoDB 会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的 PPT 演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度，二级索引的叶子节点保存的就是主键，所以主键小占用的空间也就会少。</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号，占用的空间大。</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="243-order-by-优化"><a class="markdownIt-Anchor" href="#243-order-by-优化"></a> 2.4.3: order by 优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果 order by 字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain 的 extra 信息显示的是 <code>Using index, Using filesort</code>，如果要优化掉 Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用 <code>select id, age, phone from tb_user order by age asc, phone desc;</code> 会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认 256k）</li></ul><h3 id="244-group-by-优化"><a class="markdownIt-Anchor" href="#244-group-by-优化"></a> 2.4.4: group by 优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为 <code>idx_user_pro_age_stat</code>，则句式可以是 <code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="245-limit-优化"><a class="markdownIt-Anchor" href="#245-limit-优化"></a> 2.4.5: limit 优化</h3><p>常见的问题如 <code>limit 2000000, 10</code>，此时需要 MySQL 排序前 2000000 条记录，但仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 此语句耗时很长<br>select * from tb_sku limit 9000000, 10;<br>-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询<br>select id from tb_sku order by id limit 9000000, 10;<br>-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit<br>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);<br>-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度<br>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="246-count-优化"><a class="markdownIt-Anchor" href="#246-count-优化"></a> 2.4.6: count 优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count (*) 的时候会直接返回这个数，效率很高（前提是不适用 where）；<br>InnoDB 在执行 count (*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建 key-value 表存储在内存或硬盘，或者是用 redis</p><p>count 的几种用法：</p><ul><li>如果 count 函数的参数（count 里面写的那个字段）不是 NULL（字段值不为 NULL），累计值就加一，最后返回累计值</li><li>用法：count (*)、count (主键)、count (字段)、count (1)</li><li>count (主键) 跟 count (*) 一样，因为主键不能为空；count (字段) 只计算字段值不为 NULL 的行；count (1) 引擎会为每行添加一个 1，然后就 count 这个 1，返回结果也跟 count (*) 一样；count (null) 返回 0</li></ul><p>各种用法的性能：</p><ul><li>count (主键)：InnoDB 引擎会遍历整张表，把每行的主键 id 值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count (字段)：没有 not null 约束的话，InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null，不为 null，计数累加；有 not null 约束的话，InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count (1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count (*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count (字段) &lt; count (主键) &lt; count (1) &lt; count (*)，所以尽量使用 count (*)</p><h3 id="247-update-优化避免行锁升级为表锁"><a class="markdownIt-Anchor" href="#247-update-优化避免行锁升级为表锁"></a> 2.4.7: update 优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = '123' where id = 1;</code>，这句由于 id 有主键索引，所以只会锁这一行；<br><code>update student set no = '123' where name = 'test';</code>，这句由于 name 没有索引，所以会把整张表都锁住进行数据更新，解决方法是给 name 字段添加索引，就可以由表锁变成行锁。</p><h2 id="25-视图"><a class="markdownIt-Anchor" href="#25-视图"></a> 2.5: 视图</h2><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。<br>通俗的讲，视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上。</p><h3 id="251-创建视图"><a class="markdownIt-Anchor" href="#251-创建视图"></a> 2.5.1: 创建视图</h3><p><code>CREATE [ OR REPLACE ] VIEW 视图名称[（列名列表）] AS SELECT 语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]</code></p><blockquote><p>例子： <code>create or replace view stu_wll as select id,name from student where id&lt;=10;</code></p></blockquote><h3 id="252-查询视图"><a class="markdownIt-Anchor" href="#252-查询视图"></a> 2.5.2: 查询视图</h3><p>查看创建视图语句： <code>SHOW CREATE VIEW</code> 视图名称；</p><p>查看视图数据：<code>SELECT*FROM</code> 视图名称；<br><code>show create view stu_v_1;</code></p><h3 id="253-修改视图"><a class="markdownIt-Anchor" href="#253-修改视图"></a> 2.5.3: 修改视图</h3><p>方式一：<code>CREATE[OR REPLACE] VIEW 视图名称[（列名列表)）] AS SELECT 语句[ WITH[ CASCADED | LOCAL ] CHECK OPTION ]</code></p><p>方式二：<code>ALTER VIEW 视图名称 [（列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]</code></p><h3 id="254-删除视图"><a class="markdownIt-Anchor" href="#254-删除视图"></a> 2.5.4: 删除视图</h3><p><code>DROP VIEW [IF EXISTS] 视图名称 [视图名称]</code></p><h3 id="255-视图检查选项"><a class="markdownIt-Anchor" href="#255-视图检查选项"></a> 2.5.5: 视图检查选项</h3><p>当使用 WITH CHECK QPTION 子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql 提供了两个选项：CASCADED 和 LOCAL ，默认值为 CASCADED。</p><p>NOTE：如果没有开检查选项就不会进行检查。不同版本是不同含义的，要看版本。</p><h4 id="2551-cascaded"><a class="markdownIt-Anchor" href="#2551-cascaded"></a> 2.5.5.1: CASCADED</h4><p><code>级联，一旦选择了这个选项，除了会检查创建视图时候的条件，还会检查所依赖视图的条件。</code></p><blockquote><p>比如下面的例子：创建 stu_V_l 视图，id 是小于等于 20 的。<br><code>create or replace view stu_V_l as select id,name from student where id &lt;=20;</code><br>再创建 stu_v_2 视图，20 &gt;= id &gt;=10。<br><code>create or replace view stu_v_2 as select id,name from stu_v_1 where id &gt;=10 with cascaded check option;</code><br>再创建 stu_v_3 视图。<br><code>create or replace view stu_v_3 as select id,name from stu_v_2 where id&lt;=15;</code><br>这条数据能够成功，stu_v_3 没有开检查选项所以不会去判断 id 是否小于等于 15, 直接检查是否满足 stu_v_2。<br><code>insert into stu_v_3 values(17,'Tom');</code></p></blockquote><h4 id="2552-local"><a class="markdownIt-Anchor" href="#2552-local"></a> 2.5.5.2: LOCAL</h4><p>本地的条件也会检查，还会向上检查。在向上找的时候，就要看是否上面开了检查选项，如果没开就不检查。和 CASCADED 的区别就是 CASCADED 不管上面开没开检查选项都会进行检查。</p><h3 id="256-更新及作用"><a class="markdownIt-Anchor" href="#256-更新及作用"></a> 2.5.6: 更新及作用</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新</p><ol><li>聚合函数或窗口函数 ( SUM ()、MIN ()、MAX ()、COUNT () 等 )</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者 UNION ALL</li></ol><blockquote><p>例子： 使用了聚合函数，插入会失败。<br><code>create view stu_v_count as select count(*) from student;</code><br><code>insert into stu_v_count values(10);</code></p></blockquote><p>作用</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p><blockquote><p>安全<br>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据<br>数据独立<br>视图可帮助用户屏蔽真实表结构变化带来的影响。</p></blockquote><p>总而言之类似于给表加上了一个外壳，通过这个外壳访问表的时候，只能按照所设计的方式进行访问与更新。</p><h2 id="26-存储过程"><a class="markdownIt-Anchor" href="#26-存储过程"></a> 2.6: 存储过程</h2><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。<br>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p>特点</p><ol><li>封装</li><li>复用</li><li>可以接收参数，也可以返回数据减少网络交互，效率提升</li></ol><h3 id="261-创建"><a class="markdownIt-Anchor" href="#261-创建"></a> 2.6.1: 创建</h3><pre><code class="hljs">CREATE PROCEDURE 存储过程名称( [参数列表] ) BEGIN SQL 语句 END;</code></pre><p>NOTE: 在命令行中，执行创建存储过程的 SQL 时，需要通过关键字 delimiter 指定 SQL 语句的结束符。默认是分号作为结束符。</p><p>delimiter $ ，则 $ 符作为结束符。</p><h3 id="262-调用"><a class="markdownIt-Anchor" href="#262-调用"></a> 2.6.2: 调用</h3><p>CALL 名称 ( [参数])</p><h3 id="263-查看"><a class="markdownIt-Anchor" href="#263-查看"></a> 2.6.3: 查看</h3><p>查询指定数据库的存储过程及状态信息</p><p><code>SELECT* FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'</code></p><p>存储过程名称；–查询某个存储过程的定义</p><p><code>SHOW CREATE PROCEDURE</code></p><h3 id="264-删除"><a class="markdownIt-Anchor" href="#264-删除"></a> 2.6.4: 删除</h3><p><code>DROP PROCEDURE [ IFEXISTS ] 存储过程名称</code></p><h3 id="265-游标"><a class="markdownIt-Anchor" href="#265-游标"></a> 2.6.5: 游标</h3><p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><blockquote><p>声明游标：<br><code>DECLARE 游标名称 CURSOR FOR 查询语句</code></p></blockquote><blockquote><p>打开游标：<br><code>OPEN 游标名称</code></p></blockquote><blockquote><p>获取游标记录：<br><code>FETCH 游标名称INTO变量[变量]</code></p></blockquote><p>条件处理程序：<br>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><blockquote><p>DECLARE handler action HANDLER FOR condition value L condition value]…statement</p></blockquote><p>handler_action CONTINUE：继续执行当前程序</p><p>EXIT：终止执行当前程序</p><p>condition_value :</p><p><code>SQLSTATE sqlstate_value：状态码，如02000</code></p><p><code>SQLWARNING：所有以01开头的SQLSTATE代码的简写</code></p><p><code>NOT FOUND：所有以02开头的SQLSTATE代码的简写</code></p><p><code>SQLEXCEPTION：所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写</code></p><p>例子：</p><p>NOTE：要先声明普通变量，再申请游标。</p><p>要求：<br><code>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表（id，name，profession）中。</code></p><pre><code class="hljs">create procedure p1l (in uage int)begindeclare uname varchar(100); decLare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage; 当 条件处理程序的处理的状态码为02000的时候，就会退出。declare exit handler for SQLSTATE '02000'close u_cursor;drop table if exists tb_user_pro; create table if not exists tb_user_pro(id int primary key auto_increment, name varchar (100), profession varchar(100));open u_cursor; while true do fetch u_cursor into uname,Upro; insert into tb_user_pro values(null,uname,Upro); end while;close u_cursor; end;</code></pre><h2 id="27-触发器"><a class="markdownIt-Anchor" href="#27-触发器"></a> 2.7: 触发器</h2><p>介绍<br>触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。<br>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发（比如说一条语句影响了 5 行则会被触发 5 次），不支持语句级触发（比如说一条语句影响了 5 行则会被触发 1 次）。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE</td><td>OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h2 id="28-锁"><a class="markdownIt-Anchor" href="#28-锁"></a> 2.8: 锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>NOTE : 针对事物才有加锁的意义。</p><p>分类：MySQL 中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ol><p>全局锁：</p><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞。<br>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>表锁：</p><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、BDB 等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ol><li><p>表锁：对于表锁，分为两类：1. 表共享读锁（read lock）所有的事物都只能读（当前加锁的客户端也只能读，不能写），不能写 2. 表独占写锁（write lock），对当前加锁的客户端，可读可写，对于其他的客户端，不可读也不可写。<br>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p></li><li><p>元数据锁（meta data lock，MDL），MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。在 MySQL5.5 中引入了 MDL，当对一张表进行增删改查的时候，加 MDL 读锁（共享）; 当对表结构进行变更操作的时候，加 MDL 写锁（排他）。</p></li><li><p>意向锁: 为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。<br>一个客户端对某一行加上了行锁，那么系统也会对其加上一个意向锁，当别的客户端来想要对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。</p></li></ol><p>意向锁兼容性：</p><ol><li>意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。</li><li>意向排他锁（lX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。</li></ol><p>行锁：</p><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。<br>InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC（read commit ）、RR（repeat read）隔离级别下都支持。</li><li>间隙锁（GapLock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持。比如说两个临近叶子节点为 15 23，那么间隙就是指 [15 , 23], 锁的是这个间隙。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持。</li></ol><p>InnoDB 实现了以下两种类型的行锁：</p><ol><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li></ol><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>insert</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>update</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>delete</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>select</td><td>不加任何锁</td><td></td></tr><tr><td>select　lock　in　share mode</td><td>排他锁</td><td>需要手动在 SELECT 之后加 LOCK IN SHARE MODE</td></tr><tr><td>select　for　update</td><td>排他锁</td><td>需要手动在 SELECT 之后加 FOR UPDATE</td></tr></tbody></table><p>行锁 - 演示</p><p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时就会升级为表锁。</li></ol><p>间隙锁/临键锁-演示</p><p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li><li>索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止。</li></ol><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p><h2 id="29-innodb-引擎"><a class="markdownIt-Anchor" href="#29-innodb-引擎"></a> 2.9: InnoDB 引擎</h2><h3 id="291-逻辑存储结构"><a class="markdownIt-Anchor" href="#291-逻辑存储结构"></a> 2.9.1: 逻辑存储结构</h3><p>表空间（ibd 文件），一个 mysql 实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB 是索引组织表，数据段就是 B+树的叶子节点，索引段即为 B+树的非叶子节点。段用来管理多个 Extent（区）。</p><p>区，表空间的单元结构，每个区的大小为 1M。默认情况下，InnoDB 存储引擎页大小为 16K，即一个区中一共有 64 个连续的页。</p><p>页，是 InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每从磁盘申请 4-5 个区。一页包含若干行。</p><p>行，InnoDB 存储引擎数据是按进行存放的。</p><h3 id="292-架构"><a class="markdownIt-Anchor" href="#292-架构"></a> 2.9.2: 架构</h3><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic.png" alt="images"></p><p>Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘 I0，加快处理速度。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic2.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic3.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic4.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic5.png" alt="images"></p><p>磁盘架构：<br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic6.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic7.png" alt="images"><br><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/artic8.png" alt="images"></p><p>InnoDB 的整个体系结构为：</p><p>当业务操作的时候直接操作的是内存缓冲区，如果缓冲区当中没有数据，则会从磁盘中加载到缓冲区，增删改查都是在缓冲区的，后台线程以一定的速率刷新到磁盘。</p><h2 id="210-事务原理"><a class="markdownIt-Anchor" href="#210-事务原理"></a> 2.10: 事务原理</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时败。具有 ACID 四大特征。</p><p>原子性，一致性，持久性这三大特性由 redo log 和 undo log 日志来保证的。<br>隔离性是由锁机制和 MVCC 保证的。</p><p>redo log:</p><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。<br>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><blockquote><p>个人理解： 事物每次提交的时候都会将数据刷到 redo log 中而不是直接将 buffer pool 中的数据直接刷到磁盘中（ibd 文件中），是因为 redo log 是顺序写，性能处理的够快，直接刷到 ibd 中，是随机写，性能慢。所以脏页是在下一次读的时候，或者后台线程采用一定的机制进行刷盘到 ibd 中。</p></blockquote><p>undo log:<br>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和 MVCC（多版本并发控制）。<br>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p><blockquote><p>Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于 MVCC。<br>Undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。</p></blockquote><h2 id="211-mvcc"><a class="markdownIt-Anchor" href="#211-mvcc"></a> 2.11: MVCC</h2><h3 id="2111-当前读"><a class="markdownIt-Anchor" href="#2111-当前读"></a> 2.11.1: 当前读:</h3><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p><ul><li>select…lock in share mode（共享锁）。</li><li>select……for update、update、insert、delete（排他锁）都是一种当前读。</li></ul><h3 id="2112-快照读"><a class="markdownIt-Anchor" href="#2112-快照读"></a> 2.11.2: 快照读:</h3><p>简单的 select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次 select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个 select 语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><h3 id="2113-mvcc"><a class="markdownIt-Anchor" href="#2113-mvcc"></a> 2.11.3: MVCC:</h3><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 日志、readView。</p><h4 id="21131-mvcc-实现原理"><a class="markdownIt-Anchor" href="#21131-mvcc-实现原理"></a> 2.11.3.1: MVCC 实现原理:</h4><p>有三个隐藏的字段:</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCC.png" alt="images"></p><blockquote><p>undo log 回滚日志，在 insert、update、delete 的时候产生的便于数据回滚的日志。<br>当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。<br>而 update、delete 的时候，产生的 undo log 日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p></blockquote><p>undo log 版本链： ^935630</p><p>undo log 日志会记录原来的版本的数据，因为是通过 undo log 日志进行回滚的。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/MVCCList.png" alt="images"></p><p>如何确定返回哪一个版本这是由 read view 决定返回 undo log 中的哪一个版本。</p><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/readview0.png" alt="images"></p><blockquote><p>RC 隔离级别下，在事务中每一次执行快照读时生成 ReadView。<br>RR 隔离级别下，在事务中第一次执行快照读时生成 ReadView，后续会复用。</p></blockquote><blockquote><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&amp;spm_id_from=pageDriver&amp;vd_source=bbc04b831b54029788a178a7c2e9ae20">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=145&amp;spm_id_from=pageDriver&amp;vd_source=bbc04b831b54029788a178a7c2e9ae20</a></p></blockquote><p>MVCC 靠隐藏字段 , undo log 版本链 , read view 实现的。</p><ul><li>原子性-undo log</li><li>持久性-redo log</li><li>一致性-undo log + redo log</li><li>隔离性-锁 + MVCC</li></ul><p><img src="https://github.com/Buildings-Lei/mysql_note/blob/main/images/readview.png" alt="images"></p><h1 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型"></a> 3: 数据类型</h1><h2 id="31-整型"><a class="markdownIt-Anchor" href="#31-整型"></a> 3.1: 整型</h2><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1 个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2 个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3 个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4 个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8 个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="32-浮点型"><a class="markdownIt-Anchor" href="#32-浮点型"></a> 3.2: 浮点型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h2 id="33-日期和时间"><a class="markdownIt-Anchor" href="#33-日期和时间"></a> 3.3: 日期和时间</h2><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM: SS</td><td>-838:59: 59 ~ 838:59: 59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM: SS</td><td>1000-01-01 00:00: 00 ~ 9999-12-31 23:59: 59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM: SS</td><td>1980-01-01 00:00: 01 UTC ~ 2040-01-19 03:14: 07 UTC</td><td>4 个字节</td></tr></tbody></table><h2 id="34-字符串"><a class="markdownIt-Anchor" href="#34-字符串"></a> 3.4: 字符串</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR (M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;=M&lt;=255</td></tr><tr><td>VARCHAR (M)</td><td>变长非二进制字符串</td><td>L+1 字节，在此，L&lt; = M 和 1&lt;=M&lt;=255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4 字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1 或 2 个字节，取决于枚举值的数目 (最大值为 65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或多个 SET 成员</td><td>1、2、3、4 或 8 个字节，取决于集合成员的数量（最多 64 个成员）</td></tr></tbody></table><h2 id="35-二进制类型"><a class="markdownIt-Anchor" href="#35-二进制类型"></a> 3.5: 二进制类型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT (M)</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY (M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的 BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的 BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的 BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="4-权限一览表"><a class="markdownIt-Anchor" href="#4-权限一览表"></a> 4: 权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Grant Table Column</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td style="text-align:left">Synonym for “all privileges”</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td style="text-align:left"><code>Alter_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td style="text-align:left"><code>Alter_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td style="text-align:left"><code>Create_priv</code></td><td style="text-align:left">Databases, tables, or indexes</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td style="text-align:left"><code>Create_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td style="text-align:left"><code>Create_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td style="text-align:left"><code>Create_tablespace_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td style="text-align:left"><code>Create_tmp_table_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td style="text-align:left"><code>Create_user_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td style="text-align:left"><code>Create_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td style="text-align:left"><code>Delete_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td style="text-align:left"><code>Drop_priv</code></td><td style="text-align:left">Databases, tables, or views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td style="text-align:left"><code>Drop_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td style="text-align:left"><code>Event_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td style="text-align:left"><code>Execute_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td style="text-align:left"><code>File_priv</code></td><td style="text-align:left">File access on server host</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td style="text-align:left"><code>Grant_priv</code></td><td style="text-align:left">Databases, tables, or stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td style="text-align:left"><code>Index_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td style="text-align:left"><code>Insert_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td style="text-align:left"><code>Lock_tables_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td style="text-align:left"><code>Process_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td style="text-align:left">See <code>proxies_priv</code> table</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td style="text-align:left"><code>References_priv</code></td><td style="text-align:left">Databases or tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td style="text-align:left"><code>Reload_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td style="text-align:left"><code>Repl_client_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td style="text-align:left"><code>Repl_slave_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td style="text-align:left"><code>Select_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td style="text-align:left"><code>Show_db_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td style="text-align:left"><code>Show_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td style="text-align:left"><code>Shutdown_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td style="text-align:left"><code>Super_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td style="text-align:left"><code>Trigger_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td style="text-align:left"><code>Update_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td style="text-align:left">Synonym for “no privileges”</td><td style="text-align:left">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td style="text-align:left">Dual password administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td style="text-align:left">Allow queries blocked by audit log filter</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td style="text-align:left">Audit log administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td style="text-align:left">Backup administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td style="text-align:left">Clone administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td style="text-align:left">Redo log archiving administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td style="text-align:left">NDB Cluster</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td style="text-align:left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr></tbody></table><h1 id="5-图形化界面工具"><a class="markdownIt-Anchor" href="#5-图形化界面工具"></a> 5: 图形化界面工具</h1><ul><li>Workbench (免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat (收费，试用版 30 天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro (开源免费，仅支持 Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL (免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin (免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h1 id="6-安装"><a class="markdownIt-Anchor" href="#6-安装"></a> 6: 安装</h1><h1 id="7-小技巧"><a class="markdownIt-Anchor" href="#7-小技巧"></a> 7: 小技巧</h1><ol><li>在 SQL 语句之后加上 <code>\G</code> 会将结果的表格形式转换成行文本形式</li><li>查看 Mysql 数据库占用空间：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table_schema "Database Name"<br>     , SUM(data_length + index_length) / (1024 * 1024) "Database Size in MB"<br>FROM information_schema.TABLES<br>GROUP BY table_schema;<br></code></pre></td></tr></tbody></table></figure><h1 id="8-参考文献"><a class="markdownIt-Anchor" href="#8-参考文献"></a> 8: 参考文献</h1><blockquote><p><a href="https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868">https://dhc.pythonanywhere.com/entry/share/?key=3ad29aad765a2b98b2b2a745d71bef715507ee9db8adbec98257bac0ad84cbe4#h1-u6743u9650u4E00u89C8u8868</a><br>这篇笔记是在别人的基础上完善而来，感谢 B 站的黑马程序员 up 主，也感谢路途博客。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/posts/21632/"/>
    <url>/posts/21632/</url>
    
    <content type="html"><![CDATA[<p>📝锁::</p><!-- basicblock-end --><blockquote><p>[!note] NOTE : 针对事物才有加锁的意义。<br>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。<br>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p></blockquote><blockquote><p>[!summary]<br>分类：MySQL 中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表。锁的范围大</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。锁的范围最小</li></ol></blockquote><h1 id="1-全局锁"><a class="markdownIt-Anchor" href="#1-全局锁"></a> 1 [[全局锁]]</h1><p>‌‌‌</p><h1 id="2-表级锁"><a class="markdownIt-Anchor" href="#2-表级锁"></a> 2 [[表级锁]]</h1><h1 id="3-行锁"><a class="markdownIt-Anchor" href="#3-行锁"></a> 3 [[行锁]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>淘汰算法</title>
    <link href="/posts/4959/"/>
    <url>/posts/4959/</url>
    
    <content type="html"><![CDATA[<p>📝淘汰算法::</p><!-- basicblock-end --><h1 id="1-lfulatest-frequently-used"><a class="markdownIt-Anchor" href="#1-lfulatest-frequently-used"></a> 1 LFU（Latest frequently used）</h1><p>概念：最近经常使⽤，如果数据最近被访问过，那么将来被访问的⼏率也⾼ 实现：<br>（1）设计⼀个链表来缓存数据<br>（2）新数据插⼊到链表头部<br>（3）每当缓存命中（也就是缓存数据被访问），将数据移动到链表头部当链表满的时候，将链表尾部的数据丢弃</p><h1 id="2-lruleast-recently-used"><a class="markdownIt-Anchor" href="#2-lruleast-recently-used"></a> 2 LRU（Least recently used）</h1><p>原理：最不经常使⽤，如果⼀个数据在最近⼀段时间内使⽤次数很少，那么它在将来的⼀段时间内被使⽤的可能性也很⼩<br>实现<br>（1）LFU 每个数据块设计⼀个引⽤计数<br>（2）所有数据块按照引⽤计数排序，具有相同引⽤计数的数据块按照时间排序<br>（3）新加⼊的数据插⼊到队列尾部<br>（4）在队列中某⼀个数据被访问，该数据引⽤计数加1，队列重新排序 需要删除数据时，将已排序的列表最后的数据库删除</p><h1 id="3-fifofirst-in-first-out"><a class="markdownIt-Anchor" href="#3-fifofirst-in-first-out"></a> 3 FIFO（First in first out）</h1><p>原理：先进先出，如果⼀个数据最先进⼊缓存中，就最早淘汰掉<br>实现 : 直接⽤队列实现</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式</title>
    <link href="/posts/41896/"/>
    <url>/posts/41896/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!question]<br>📝分布式::</p></blockquote><!-- basicblock-end --><h1 id="1-幂等操作"><a class="markdownIt-Anchor" href="#1-幂等操作"></a> 1: 幂等操作</h1><p>⽤户对同⼀操作发起⼀次请求或者多次请求的结果是⼀致的，不会因为多次点击⽽产⽣副作⽤</p><h1 id="2-lvs负载均衡"><a class="markdownIt-Anchor" href="#2-lvs负载均衡"></a> 2: lvs负载均衡</h1><p>Linux virtual server：⼀个实现负载均衡的开源软件项⽬</p><p>⽬标： 通过LVS的负载均衡技术与Linux操作系统实现⼀个⾼性能，⾼可⽤的Linux服务器集 群</p><p>逻辑架构</p><p>（1）调度层<br>（2）server 集群层<br>（3）共享存储</p><p>基本⼯作原理 关键词 IPVS：使⽤户定义的策略⽣效 ipvsadn：⽤于⽤户定义和集群服务管理的⼯具 原理 IVS的IP负载均衡技术主要通过IPVS实现，IPVS虚拟⼀个IP地址，⽤户必须通过这个虚拟的 IP地址访问服务器。该虚拟IP被称为LVS的VIP，访问的请求⾸先经过LVS的VIP，访问的请 求⾸先经过LVS的VIP，到达负载调度器，由负载调度器从real server列表中选取⼀个服务节 点响应⽤户的请求</p><h1 id="3-lvs和nginx的区别"><a class="markdownIt-Anchor" href="#3-lvs和nginx的区别"></a> 3: lvs和Nginx的区别</h1><p>负载均衡</p><p>LVS：4 层负载均衡 Nginx：7 层负载均衡</p><p>技术原理</p><p>LVS：IP+TCP端⼜ Nginx：URL应⽤层（内容交换）</p><p>优点：</p><p>LVS： 配置简单，效率⾼ Nginx： 智能化，可以对客户端请求服务端响应进⾏⾃定义修改。极⼤的提升了应⽤系统 在⽹络层的灵活性</p><p>缺点</p><p>LVS： 不理解http，ftp等应⽤协议，满⾜不了特定需求，⽐如动静分离等 Nginx： 对负载均衡的设备要求很⾼，配置复杂</p><h1 id="4-consul-etcd区别"><a class="markdownIt-Anchor" href="#4-consul-etcd区别"></a> 4: consul、etcd区别</h1><p>分布式微服务架构：⼀个应⽤可能由⼀组职责单⼀的服务组成</p><p>consul与etcd都提供了相关的服务管理功能</p><p>区别</p><p>服务健康检查</p><p>consul：服务状态、内存、硬盘等 etcd：连接⼼跳</p><p>多数据中⼼</p><p>consul：⽀持 etcd：不⽀持</p><p>使⽤接口<br>consul：http/dns<br>etcd：http/grpc</p><h1 id="5-分布式事务-保证在分布式环境中不同的数据的数据一致性"><a class="markdownIt-Anchor" href="#5-分布式事务-保证在分布式环境中不同的数据的数据一致性"></a> 5: 分布式事务 保证在分布式环境中，不同的数据的数据⼀致性</h1><h1 id="6-分布式锁"><a class="markdownIt-Anchor" href="#6-分布式锁"></a> 6: 分布式锁</h1><p>将多线程的锁机制应⽤到了分布式的部署环境中<br>特点<br>（1）互斥性<br>（2）可重⼊：同⼀个节点上的同⼀个线程，获取到锁之后还可以两次获取这个锁<br>（3）锁超时：⽀持锁超时，防⽌死锁<br>（4）⾼效，⾼可⽤<br>（5）⽀持阻塞和⾮阻塞<br>（6）⽀持公平锁和⾮公平锁</p><p>公平锁：按照请求加锁的顺序获取锁</p><p>⾮公平锁：⽆序获取锁</p><p>常见分布式锁</p><p>（1）MySQL<br>（2）Redis<br>（3）ZK（Zookeeper）</p><h1 id="7-淘汰算法"><a class="markdownIt-Anchor" href="#7-淘汰算法"></a> 7: [[淘汰算法]]</h1><h1 id="8-一致性-hash-算法"><a class="markdownIt-Anchor" href="#8-一致性-hash-算法"></a> 8: ⼀致性 hash 算法</h1><p>作⽤：该算法通常⽤于负载均衡中要求资源被均匀的分布到所有节点上，并且对资源的请求能够快速路由到对应的节点上⾯<br>特点<br>（1）平衡性：哈希结果要均匀的分配在整个输出空间中<br>（2）单调性：当数据发⽣变动的时候，对相同的数据始终映射到相同的节点，或者新增加的缓冲节点中，避免⽆法找到原来的数据<br>（3）稳定性：当出现节点坏掉或者需要动态扩容时，尽量减少数据的移动 原理</p><p>关键词<br>（1）哈希环：将整个哈希的输出空间设置为⼀个环形区域<br>（2）设置哈希环<br>（3）将服务器进⾏哈希，可以考虑使⽤服务器的编号或者 ip 等作为输⼊，得到⼀个输出值，将该输出值映射到输出空间的环形区域上<br>（4）对⽤户数据进⾏同样的 hash 操作，映射在环形区域上。然后让数据按照顺时针⽅向移动，遇到的第⼀个服务器就是它分配的服务器<br>（5）通过将整个哈希输出空间设置为⼀个环形区别，可以有效的减⼩输出空间的变化对于 哈希结果的影响</p><h1 id="9-cap-原理基本概念"><a class="markdownIt-Anchor" href="#9-cap-原理基本概念"></a> 9: CAP 原理基本概念：</h1><p>（1）C（⼀致性）：对于分布在不同节点上的数据，如果⼀个节点更新数据之后，其他节点都能读到这个最新的数据<br>（2）A（可⽤性）：⾮故障节点在合理的时间内返回合理的响应<br>（3）P（分区容错性）：出现⽹络错误，系统还能继续⼯作</p><p><strong>CAP</strong>不能同时共存：</p><p>CA：分布式中⼀般不会选择 CP：<br>CP 的代表是 Zookeeper，放弃可⽤性，追求⼀致性和容错性<br>AP：追求分区容错性与可⽤性</p><h1 id="10-base-理论"><a class="markdownIt-Anchor" href="#10-base-理论"></a> 10: BASE 理论</h1><p>Basically Available（基本可⽤）：分布式系统在出现故障时，允许损失部分可⽤功能<br>Soft State（软状态）：允许系统中存在中间状态，这个状态不影响系统可⽤性<br>Eventually consistent（最终⼀致性）：在经过⼀段时间之后，所有节点的数据都会达到⼀ 致</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>事务的四大特性  ACID</title>
    <link href="/posts/49301/"/>
    <url>/posts/49301/</url>
    
    <content type="html"><![CDATA[<p>📝事务的四大特性  ACID::</p><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211151720853.png" alt=""><br>MVCC➕锁实现隔离性<br>redo log ➕ undo log 实现一致性</p><h1 id="1-原子性-atomicity"><a class="markdownIt-Anchor" href="#1-原子性-atomicity"></a> 1: [[原子性 (Atomicity)]]</h1><h1 id="2-一致性-consistency"><a class="markdownIt-Anchor" href="#2-一致性-consistency"></a> 2: [[一致性 (Consistency)]]</h1><h1 id="3-隔离性-isolation"><a class="markdownIt-Anchor" href="#3-隔离性-isolation"></a> 3: [[隔离性 (Isolation)]]</h1><h1 id="4-持久性-durability"><a class="markdownIt-Anchor" href="#4-持久性-durability"></a> 4: [[持久性 (Durability)]]</h1><p>上述就是事务的四大特性, 简称 ACID。</p><p>^f3fe25</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/posts/23120/"/>
    <url>/posts/23120/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL事务::</p><!-- basicblock-end --><h1 id="1-事务目录"><a class="markdownIt-Anchor" href="#1-事务目录"></a> 1: [[事务目录]]</h1><h1 id="2-分布式"><a class="markdownIt-Anchor" href="#2-分布式"></a> 2: [[分布式]]</h1><p>[[MySQL 事务隔离]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>binlog,redo log,undo log</title>
    <link href="/posts/20109/"/>
    <url>/posts/20109/</url>
    
    <content type="html"><![CDATA[<p>📝binlog,redo log,undo log::</p><!-- basicblock-end --><ul><li>[[二进制日志 bin log]]</li><li>[[redo log]]</li><li>[[undo log]]</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL语句执行</title>
    <link href="/posts/2168/"/>
    <url>/posts/2168/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL语句执行::</p><!-- basicblock-end --><h1 id="1-查询语句运行"><a class="markdownIt-Anchor" href="#1-查询语句运行"></a> 1 查询语句运行</h1><h2 id="11-连接器"><a class="markdownIt-Anchor" href="#11-连接器"></a> 1.1 连接器</h2><p>负责跟客户端建⽴连接、获取权限、维持和管理连接</p><p>Mysql 会定期⾃动清理"空闲"连接，由参数 wait_timeout 控制的，默认值是 8 ⼩时。</p><p>由于建⽴连接⽐较复杂，所以<strong>尽量</strong>使⽤长连接，⽽不是短连接<code>（少量查询后，就断开连接)</code></p><p>但是，当长连接 过多时，可能导致内存占⽤太⼤，被系统强⾏杀掉（OOM），即会导致 MySQL 异常重启</p><p>解决⽅案为:</p><ol><li>定期断开长连接</li><li>MySQL 5.7以后版本，可以通过执⾏ mysql_reset_connection 来重新初始化连接资 源</li></ol><h2 id="12-查询缓存"><a class="markdownIt-Anchor" href="#12-查询缓存"></a> 1.2 查询缓存</h2><p>执⾏查询语句前，<strong>先看下查询缓存中是否有结果</strong></p><ul><li>如果有，则不必执⾏查询语句，直接取出缓存结果</li><li>如果没命中缓存，则执⾏查询语句，并将执⾏查询语句后的结果，放⼊查询缓存中</li></ul><p>Note: 不建议使⽤查询缓存（当 数据表频繁更新时，最新查询结果可能和查询缓存中存放的 结果不⼀致)</p><blockquote><p>[!attention] MySQL 8.0 版本直接将查询缓存的整块功能删掉</p></blockquote><h2 id="13-分析器"><a class="markdownIt-Anchor" href="#13-分析器"></a> 1.3 分析器</h2><ol><li>词法分析</li><li>语法分析</li></ol><h2 id="14-优化器"><a class="markdownIt-Anchor" href="#14-优化器"></a> 1.4 优化器</h2><p>优化器是在表⾥⾯有多个索引的时候，决定使⽤哪个索引；<br>或者在⼀个语句有多表关联 （join）的时候，决定各个表的连接顺序</p><h2 id="15-执行器"><a class="markdownIt-Anchor" href="#15-执行器"></a> 1.5 执⾏器</h2><p>执⾏语句时，⾸先判断当前⽤户是否有执⾏权限</p><ul><li>如果没有执⾏权限，则终⽌</li></ul><ul><li>如果有执⾏权限，则执⾏器就会根据表的引擎定义，去使⽤这个引擎提供的接口。</li></ul><h1 id="2-更新语句执行"><a class="markdownIt-Anchor" href="#2-更新语句执行"></a> 2 更新语句执⾏</h1><blockquote><p>[!question]<br>[[binlog,redo log,undo log]]::   #疑问</p></blockquote><h2 id="21-redo-log-vs-binlob-3点不同"><a class="markdownIt-Anchor" href="#21-redo-log-vs-binlob-3点不同"></a> 2.1 redo log VS. binlob （3点不同)</h2><ol><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都 可以使⽤。</p></li><li><p>redo log 是物理⽇志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑⽇ 志，记录的是这个语句的原始逻辑，⽐如“给 ID=2 这⼀⾏的 c 字段加 1</p></li><li><p>redo log 是循环写的，空间固定会⽤完；binlog 是可以追加写⼊的。“追加写”是指 binlog ⽂件写到⼀定⼤⼩后会切换到下⼀个，并不会覆盖以前的⽇志。</p></li></ol><h2 id="22-数据恢复"><a class="markdownIt-Anchor" href="#22-数据恢复"></a> 2.2 数据恢复</h2><p>先找到最新的 全量备份，恢复之； 然后，依次执⾏ 该全量备份以后得所有 binlog</p><h2 id="23-为什么必须有两阶段提交呢"><a class="markdownIt-Anchor" href="#23-为什么必须有两阶段提交呢"></a> 2.3 为什么必须有“两阶段提交”呢？</h2><p>这是为了让两份⽇志之间的逻辑⼀致性</p><p>![[MySQL  两阶段提交 .excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 用户管理(DCL)</title>
    <link href="/posts/10996/"/>
    <url>/posts/10996/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 用户管理(DCL)::数据控制语言，用来创建数据库用户、控制数据库的控制权限</p><!-- basicblock-end --><blockquote><p>[!summary] 目的：<br>为了保证 MySql 服务器的安全，每个 MySql 的用户应该对他们需要的数据具有适当的访问权；</p></blockquote><p>例如：</p><ol><li>多数用户只能够用到读写权限，只有少数用户能够创建表格和删除表格</li><li>一些用户只能访问某个数据库而不能访问其他的数据库</li><li>一些用户可以管理其他用户的账号，但大多数人不需要管理别人的账号<br>每个用户需要用到什么权限，就只给他们什么权限<br>如果每个用户的权限都很高，那数据库会变得十分危险，随时都需要面临很多误操作，所以要进行访问权限控制</li></ol><h1 id="1-用户账号管理"><a class="markdownIt-Anchor" href="#1-用户账号管理"></a> 1 用户账号管理</h1><p>注意事项：</p><ul><li>在 MySQL 中需要通过<strong>用户名@主机名</strong>的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。</li><li>这类 SQL 开发人员操作的比较少，主要是 DBA ( Database Administrator 数据库管理员）使用。</li></ul><blockquote><p>[!example]- 案例<br>![[MySQL 用户账号管理.excalidraw]]</p></blockquote><blockquote><p>[!summary]- 不建议直接 insert 用户到 user 表中, 因为可能伤害到服务器<br>既然 mysql 中的 user 表格中存放着当前 mysql 的用户，那么新增用户只需要在 user 表中使用 insert 语句新增一条记录即可。<br>不过为了安全起见不建议这样做，mysql数据库存放着很重要的数据，这样直接对 mysql数据库直接操作可能会伤害到 mysql服务器。</p></blockquote><h2 id="11-查询用户"><a class="markdownIt-Anchor" href="#11-查询用户"></a> 1.1 查询用户</h2><p>在 MySql 下，所有的用户的账号，密码，对数据库的操作权限，都存储在 mysql 下（数据库的名字就叫 mysql）的 user 表格中。</p><p>user 表格有一个 user 属性，user 属性就是当前所有的用户名，通过以下操作可以查看当前<br>mysql 的用户一共有多少。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from mysql.user;<br>或者<br>use mysql<br>select user from user<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]<br>![[MySQL 查询用户.excalidraw]]</p></blockquote><h2 id="12-新增用户"><a class="markdownIt-Anchor" href="#12-新增用户"></a> 1.2 新增用户</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">新增一个用户的语法：<br>create user [user_name] identified by [user_pwd]<br><br>例如：新增用户 zhangsan， pwd=123456<br>create user zhangsan identified by '123456'<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"># 黑马实例<br>create user '用户名' @ '主机名' identified by '密码'; # 💡这个密码是你自己设置的密码<br><br>-- 1. 创建用户test，只能在当前主机localhost访问<br>create user 'test' @ 'localhost' identified by '123456';<br><br>-- 创建用户test，能在任意主机访问<br>create user 'test' @ '%' identified by '123456';<br>create user 'test' identified by '123456'; # 如果不加 '@', 默认是在任意主机<br></code></pre></td></tr></tbody></table></figure><h2 id="13-修改用户名"><a class="markdownIt-Anchor" href="#13-修改用户名"></a> 1.3 修改用户名</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">修改用户名的语法: <br>rename user [user_name] to [new_user_name]<br><br>例如:例如将账号名从 zhangsan 改为 lisi<br><br>rename user zhangsan to lisi<br><br></code></pre></td></tr></tbody></table></figure><h2 id="14-修改用户密码"><a class="markdownIt-Anchor" href="#14-修改用户密码"></a> 1.4 修改用户密码</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">修改用户密码语法: <br>set password for [user_name] = password('[new_pwd]')<br><br>这里使用 password 函数对新密码进行加密。<br>如果不指定用户名: <br><br>set password = password('[new_pwd]')<br><br>默认为修改当前登陆的用户的密码。<br>例如:修改 lisi 账号的密码<br>set password for lisi = password('135790')<br><br><br><br>## 黑马实例<br>alter user '用户名' @ '主机名' identified with mysql_native_password by '新密码' ; # with 后边的是字符串, 不是原来的密码<br><br>-- 2. 💡修改访问密码<br>alter user 'test' @ 'localhost' identified with mysql_native_password by '1234'; # 💡这里不是存在隐患吗, ✅修改的是访问密码<br><br></code></pre></td></tr></tbody></table></figure><h2 id="15-用户账号删除"><a class="markdownIt-Anchor" href="#15-用户账号删除"></a> 1.5 用户账号删除</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">删除用户账号语法：<br>drop user [user_name ]<br><br>例如：删除 lisi 的账号<br>drop user lisi<br><br><br># 黑马实例<br>DROP USER '用户名' @ '主机名' ;<br><br>-- 3. 删除用户<br>drop user 'test' @ 'localhost';<br></code></pre></td></tr></tbody></table></figure><p>如果 mysql 版本低于 mysql5, 需要先 revoke 用户所有的权限, 才能删除账号。更高版本则可以一次性删除权限和账号。</p><h1 id="2-用户权限控制"><a class="markdownIt-Anchor" href="#2-用户权限控制"></a> 2 用户权限控制</h1><p>常用权限：</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>更多权限请看<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html">权限一览表</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">查询权限：<br>show grants for '用户名' @ '主机名';<br><br>授予权限：<br>grant 权限列表 on 数据库名.表名 to '用户名' @ '主机名';<br><br>撤销权限：<br>revoke 权限列表 on 数据库名.表名 from '用户名' @ '主机名';<br><br>-- 案例<br>A. 查询 'heima'@ '%' 用户的权限<br>show grants for 'heima'@ '%';<br><br>B. 授予 'heima'@ '%' 用户itcast数据库所有表的所有操作权限<br>grant all on itcast.* to 'heima'@ '%'; <br><br>C. 撤销 'heima'@ '%' 用户的itcast数据库的所有权限 <br>revoke all on itcast.* from 'heima'@ '%';<br><br></code></pre></td></tr></tbody></table></figure><p>案例<br>![[MySQL 用户权限控制.excalidraw]]</p><blockquote><p>[!summary] 注意事项</p><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB收集统计数据</title>
    <link href="/posts/39477/"/>
    <url>/posts/39477/</url>
    
    <content type="html"><![CDATA[<p>📝InnoDB收集统计数据::</p><!-- basicblock-end --><p>[[InnoDB]]</p><blockquote><p>[!summary]<br>表的统计数据: show table status;<br>索引的统计数据: show index;</p></blockquote><h1 id="1-统计数据的存储"><a class="markdownIt-Anchor" href="#1-统计数据的存储"></a> 1 统计数据的存储:</h1><h2 id="11-永久性存储"><a class="markdownIt-Anchor" href="#11-永久性存储"></a> 1.1 永久性存储</h2><p>存储于磁盘上, 服务器重启后数据仍然存在<br>实际存储在磁盘内的两个表中</p><ol><li>innodb_index_stats</li><li>innodb_table_stats</li></ol><h2 id="12-非永久性存储"><a class="markdownIt-Anchor" href="#12-非永久性存储"></a> 1.2 非永久性存储</h2><p>存储于内存中,服务器重启时,重新收集统计数据</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>InnoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法</title>
    <link href="/posts/3511/"/>
    <url>/posts/3511/</url>
    
    <content type="html"><![CDATA[<p>📝二分法::</p><!-- basicblock-end --><h1 id="1-二分法使用的前提"><a class="markdownIt-Anchor" href="#1-二分法使用的前提"></a> 1: 二分法使用的前提::</h1><ol><li><strong>有序数组</strong><ol><li>能够循环在左右区间内查找</li></ol></li><li><strong>无重复的元素</strong><ol><li>有重复的元素返回的下标不唯 1,</li></ol></li></ol><blockquote><p>[!example]<br>![[二分查找法.excalidraw]]</p></blockquote><blockquote><p>[!example] 适用情景</p><ul><li>整体有序: [[2.  二分查找]]</li><li>区间分为两部分, 彼此都要序 (递增, 递减):  [[11.旋转数组的最小数字]]</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.旋转数组的最小数字</title>
    <link href="/posts/2703/"/>
    <url>/posts/2703/</url>
    
    <content type="html"><![CDATA[<p>📝11.旋转数组的最小数字::<a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-题目"><a class="markdownIt-Anchor" href="#1-题目"></a> 1: 题目</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><ul><li>cite 也可不搬<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为 1。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><p>二分查找不只能用于递增递减的区间<br>对于某点左边和右边具有同样性质的区间也可以使用</p><p>对于本题目 就是 <strong>寻找某点</strong> 该点左边的元素都大于等于尾部元素，该点的右边元素都小于等于尾部元素</p><p>![[11.旋转数组的最小数字 2022-11-08 10.53.18.excalidraw]]<br>[[二分法]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r){<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[r]) r = mid; <span class="hljs-comment">// 第二区间在缩小</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[r]) l = mid+<span class="hljs-number">1</span>;<span class="hljs-comment">// 到第二区间去, 我要找最小值, 肯定取不到 mid 了, 所以+1</span><br>            <span class="hljs-keyword">else</span> r--; <span class="hljs-comment">// 无法判断在哪个区间, 所以后移一位继续判断</span><br>        }<br>        <span class="hljs-keyword">return</span> nums[l];<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!参考资料]-<br><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-by-leetcode-s/">剑指 Offer 11. 旋转数组的最小数字 题解 - 力扣（LeetCode）</a><br><a href="https://www.bilibili.com/video/BV1CK411c7gx?p=9&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">11. 旋转数组的最小数字_哔哩哔哩_bilibili</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.斐波那契数列</title>
    <link href="/posts/12443/"/>
    <url>/posts/12443/</url>
    
    <content type="html"><![CDATA[<p>📝10.斐波那契数列::<a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列 - 力扣（LeetCode）</a></p><!-- basicblock-end --><h1 id="1-题目"><a class="markdownIt-Anchor" href="#1-题目"></a> 1: 题目</h1><h2 id="11-10-1-斐波那契"><a class="markdownIt-Anchor" href="#11-10-1-斐波那契"></a> 1.1: 10-1 斐波那契</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F (N)）。斐波那契数列的定义如下：</p><p>F (0) = 0,   F (1) = 1<br>F (N) = F (N - 1) + F (N - 2), 其中 N &gt; 1.</p><ul><li>example 0 1 1 2 3 5 8 13 21<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是<strong>由之前的两数相加而得出</strong>。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>：<br><br>输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br><br>示例 <span class="hljs-number">2</span>：<br><br>输入：n = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br><br></code></pre></td></tr></tbody></table></figure><p>提示：</p><pre><code class="hljs">0 &lt;= n &lt;= 100</code></pre><h2 id="12-10-2-青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#12-10-2-青蛙跳台阶问题"></a> 1.2: 10-2. 青蛙跳台阶问题</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>：<br>输入：n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br><br>示例 <span class="hljs-number">2</span>：<br>输入：n = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">21</span><br><br><span class="hljs-comment">// 实例 3 不一样</span><br>示例 <span class="hljs-number">3</span>：<br>输入：n = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">1</span><br><br></code></pre></td></tr></tbody></table></figure><p>提示：</p><pre><code class="hljs">0 &lt;= n &lt;= 100</code></pre><h3 id="121-分析"><a class="markdownIt-Anchor" href="#121-分析"></a> 1.2.1: 分析</h3><p>设跳上 n 级台阶有 f (n)种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。</p><pre><code class="hljs">当为 1 级台阶： 剩 n−1 个台阶，此情况共有 f(n−1)种跳法；当为 2 级台阶： 剩 n−2 个台阶，此情况共有 f(n−2) 种跳法。</code></pre><p><strong>f (n) 为以上两种情况之和，即 f (n)=f (n−1)+f (n−2)</strong>，以上递推性质为斐波那契数列。本题可转化为求斐波那契数列第 nn 项的值，与面试题 10- I. 斐波那契数列等价，<strong>唯一的不同在于起始数字不同。</strong></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><h2 id="21-递归"><a class="markdownIt-Anchor" href="#21-递归"></a> 2.1: 递归</h2><p>![[10.斐波那契数列 2022-11-20 15.39.52.excalidraw]]</p><p>用递归每次都要重新计算之前的值, 最后超出时间限制</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// ❗️fib(0) = 0; 怎么能直接写函数值呢</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// ❗️fib(1) = 1;</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>) + <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>))%<span class="hljs-number">1000000007</span>;<br><br>    }<br>};<br><br><span class="hljs-comment">// v2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-comment">// 一</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 二</span><br>        <span class="hljs-type">int</span> temp1 = <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> temp2 = <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>);<br>        <span class="hljs-comment">// 三</span><br>        <span class="hljs-keyword">return</span> temp1+temp2;<br><br><br><br>    }<br>};<br><br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="22-动态规划"><a class="markdownIt-Anchor" href="#22-动态规划"></a> 2.2: 动态规划</h2><p>[[1.动态规划理论基础]]<br>用一个数组保存之前用的值效率会大大提升<br>避免重复计算了</p><p>通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-comment">// ❓这两行要放在函数体内, 放在外边不通过, 不知道为什么</span><br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// 0 &lt;= n &lt;= 100, 所以取 101 即可</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n ; i++){<br>            dp[i] = (dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>])%<span class="hljs-number">1000000007</span>;<span class="hljs-comment">// ❗️不要忘记取模</span><br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03：尽可能使用const</title>
    <link href="/posts/37571/"/>
    <url>/posts/37571/</url>
    
    <content type="html"><![CDATA[<p>📝03：尽可能使用const::</p><!-- basicblock-end --><h1 id="1-总结"><a class="markdownIt-Anchor" href="#1-总结"></a> 1: 总结</h1><h2 id="11-将某些东西声明为-const-可帮助编译器侦测出来错误的用法const-可以用于被施加于任何作用域内的对象函数参数函数返回类型成员函数本体"><a class="markdownIt-Anchor" href="#11-将某些东西声明为-const-可帮助编译器侦测出来错误的用法const-可以用于被施加于任何作用域内的对象函数参数函数返回类型成员函数本体"></a> 1.1: 将某些东西声明为 const 可帮助编译器侦测出来错误的用法，const 可以用于被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数本体</h2><h2 id="12-编译器使用-bitwise-constness但是你编写程序的时候应该使用概念上的常量性"><a class="markdownIt-Anchor" href="#12-编译器使用-bitwise-constness但是你编写程序的时候应该使用概念上的常量性"></a> 1.2: 编译器使用 bitwise constness，但是你编写程序的时候应该使用“概念上的常量性”</h2><h2 id="13-当const和non-const成员函数有着实质等价的实现的时候令non-const版本调用const版本可避免代码重复"><a class="markdownIt-Anchor" href="#13-当const和non-const成员函数有着实质等价的实现的时候令non-const版本调用const版本可避免代码重复"></a> 1.3: 当const和non-const成员函数有着实质等价的实现的时候，令non-const版本调用const版本可避免代码重复</h2><blockquote><p>[!cite]  简述<br>const 的一件奇妙的事情是：允许你指定一个语义约束：（也就是一个"不该被改<br>动的对象"，而编译器会强制施行这项约束<br>关键词const多才多艺，你可以用它来修饰各种你需要的东西</p></blockquote><h1 id="2-const-的使用"><a class="markdownIt-Anchor" href="#2-const-的使用"></a> 2: const 的使用</h1><p>[[const 关键字]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>02：尽量以 const enum inline 替换define（宁可以编译器替换预处理器）</title>
    <link href="/posts/55724/"/>
    <url>/posts/55724/</url>
    
    <content type="html"><![CDATA[<p>📝02：尽量以 const enum inline 替换define（宁可以编译器替换预处理器）::</p><!-- basicblock-end --><blockquote><p>[!tip] 简述:<br>宏定义是预处理阶段，会把相对应的值进行简单的替换，但是对应的名称可能不会进入记号表<br>宏定义不会被编译器看见，万一正好bug出现在#define这里，那么后面调试起来可能会很麻烦，尤其是代码量比较大的时候</p></blockquote><h1 id="1-使用常量替换define-的时候的两个特殊情景"><a class="markdownIt-Anchor" href="#1-使用常量替换define-的时候的两个特殊情景"></a> 1: 使用常量替换#define 的时候的两个特殊情景</h1><h2 id="11-情景-1-定义常量指针"><a class="markdownIt-Anchor" href="#11-情景-1-定义常量指针"></a> 1.1: 情景 1: 定义常量指针</h2><p>常量表达式通常被放在头文件中<br>对于 <code>char-based</code> 字符串：记得书写 <code>const</code> 两次：<code>const char*</code> <code>const name="xxx";</code><br>对于 <code>std::string</code> 只用写一次：<code>const std::string name="xxx";</code><br><strong>当然一般使用 string 会好些</strong></p><h2 id="12-情景-2-class-的专属常量"><a class="markdownIt-Anchor" href="#12-情景-2-class-的专属常量"></a> 1.2: 情景 2: class 的专属常量</h2><p>![[class的专属常量.excalidraw]]</p><h1 id="2-第二种替换的define的小方法"><a class="markdownIt-Anchor" href="#2-第二种替换的define的小方法"></a> 2: 第二种替换的#define的小方法</h1><h2 id="21-情景-3"><a class="markdownIt-Anchor" href="#21-情景-3"></a> 2.1: 情景 3：</h2><p>如果编译器不允许上面的 in-class 做法，或者不太希望使用者去读取已经设定 const 的地址：可以采用下面的 the enum hack 补偿做法<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211072159164.png" alt=""></p><p>间接：把一个属于枚举类型的数值当数组用<br>好处：和#define类似：取地址不合法，和#define一样不会造成非必要的内存分配<br>其他：enum hack 也是模板元编程的基础技术</p><h1 id="3-情景-4误用define-去写宏"><a class="markdownIt-Anchor" href="#3-情景-4误用define-去写宏"></a> 3: 情景 4：误用#define 去写宏</h1><p>一般情况下，虽然我们能用#define 写类似函数的宏并不会带来额外的开销，但是在调用这个宏的时候可能会因为使用不当带来麻烦<br>我们可以过使用 template [[inline(内联函数)]]，他不仅能获得宏带来的效率以及一般函数会有的可预料行为和安全性</p><blockquote><p>[!summary]<br>对于单纯变量，以 const 对象或 enums 将#defines 替换之</p></blockquote><p>对于形似函数的宏，使用 inline 函数替换#defines。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>define</title>
    <link href="/posts/62311/"/>
    <url>/posts/62311/</url>
    
    <content type="html"><![CDATA[<p>📝define::</p><!-- basicblock-end --><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1: 概念</h1><p>define</p><ul><li>define被称为宏定义, 是 C 语言的一种预处理指令, 宏定义的本质是</li><li><strong>单纯的字符替换</strong>,<strong>相当于直接插入了代码</strong><ul><li>是在编译的预处理阶段, 直接进行文本替换</li><li>不分配内存，给出的是立即数，有多少次使用就进行多少次替换</li></ul></li><li><strong>没有类型检查</strong>, 不安全</li><li>question 可以用来防止头文件重复引用</li><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209142145810.png" alt=""><br><a href="https://www.bilibili.com/video/BV1si4y1x781?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C语言：typedef和define到底有什么不同_哔哩哔哩_bilibili</a></li></ul><h1 id="2-宏定义和函数有何区别"><a class="markdownIt-Anchor" href="#2-宏定义和函数有何区别"></a> 2: 宏定义和函数有何区别？</h1><ul><li>宏在预处理阶段完成替换，之后被替换的文本参与编译，<strong>相当于直接插入了代码</strong>，运行时不存在函数调用，执行起来更快；</li><li>函数调用在运行时需要跳转到具体调用函数。</li><li></li><li>宏定义属于在结构中插入代码，没有返回值；</li><li>函数调用具有返回值。</li><li></li><li>宏定义参数没有类型，不进行类型检查；</li><li>函数参数具有类型，需要检查类型。</li><li></li><li>宏定义不要在最后加分号。</li></ul><h1 id="3-变量声明和定义区别"><a class="markdownIt-Anchor" href="#3-变量声明和定义区别"></a> 3: 变量声明和定义区别？</h1><blockquote><p>[!question] 声明是什么意思</p></blockquote><p>变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。</p><p>变量声明：用于向程序表明变量的类型和名字。</p><ul><li><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；</p></li><li><p>定义要在定义的地方为其分配存储空间。</p></li><li><p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> i; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">//声明，不是定义  </span><br><span class="hljs-type">int</span> i; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">//声明，也是定义，未初始化  </span><br>带有初始化式的声明必定式定义<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>inline(内联函数)</title>
    <link href="/posts/63426/"/>
    <url>/posts/63426/</url>
    
    <content type="html"><![CDATA[<p>📝inline::</p><!-- basicblock-end --><p>inline<br>调用简单函数时, 直接把简单函数的内容放到调用的地方</p><p>inline是先将内联函数编译完成生成了函数体直接插入被调用的地方，减少了压栈，跳转和返回的操作。没有普通函数调用时的额外开销；</p><p>内联函数是一种特殊的函数，会进行类型检查, 这是比 define 宏定义的优势</p><p>对编译器的一种<strong>建议</strong>，编译器有可能拒绝这种请求,</p><ul><li>&amp; 自己不定义内联函数, 编译器也会为简单函数执行内联操作</li><li>&amp; 自己定义的内联函数, 如果太复杂, 编译器也会拒绝</li></ul><p>![[C++基础 2022-09-14 22.23.18.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关键字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-10</title>
    <link href="/posts/29068/"/>
    <url>/posts/29068/</url>
    
    <content type="html"><![CDATA[<p>📝1-10::</p><!-- basicblock-end --><h1 id="1-01视c为一个语言联邦"><a class="markdownIt-Anchor" href="#1-01视c为一个语言联邦"></a> 1: [[01：视C++为一个语言联邦]]</h1><h1 id="2-02尽量以-const-enum-inline-替换define宁可以编译器替换预处理器"><a class="markdownIt-Anchor" href="#2-02尽量以-const-enum-inline-替换define宁可以编译器替换预处理器"></a> 2: [[02：尽量以 const enum inline 替换define（宁可以编译器替换预处理器）]]</h1><h1 id="3-03尽可能使用const"><a class="markdownIt-Anchor" href="#3-03尽可能使用const"></a> 3: [[03：尽可能使用const]]</h1><h1 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4:</h1><h1 id="5-05-了解-c默默编写并调用哪些函数"><a class="markdownIt-Anchor" href="#5-05-了解-c默默编写并调用哪些函数"></a> 5: 05 了解 C++默默编写并调⽤哪些函数</h1><p>一个空类，编译器会⾃动声明：</p><ol><li><p>默认构造函数（对于⾮空类：只在没有⾃定义任何构造函数的时候，才会由编译器 补充）</p></li><li><p>拷贝构造函数</p></li><li><p>拷贝赋值运算符</p></li><li><p>析构函数（⾮虚函数） 注意： 当⼀个class内含有reference/const成员时，编译器不提供拷贝赋值运算符的补充，只能由 程序员⾃⼰编写 这是因为C++不允许改变reference成员的指向，也不允许更改const成员</p></li></ol><h1 id="6-06若不想使用编译器自动生成的函数就应该明确拒绝"><a class="markdownIt-Anchor" href="#6-06若不想使用编译器自动生成的函数就应该明确拒绝"></a> 6: [[06：若不想使用编译器自动生成的函数，就应该明确拒绝]]</h1><h1 id="7-07-为多态基类声明-virtual-析构函数"><a class="markdownIt-Anchor" href="#7-07-为多态基类声明-virtual-析构函数"></a> 7: 07. 为多态基类声明 virtual 析构函数</h1><p>当⼀个基类指针指向⼀个⼦类对象时，若基类的析构函数不是 virtual 函数，那么在 delete 基类指针的时候，只会释放基类对象的资源，不会释放⼦类对象的资源，从⽽造成内存泄漏</p><p><strong>任何带有virtual函数的class都应该有⼀个virtual析构函数</strong></p><p>[[虚函数的实现原理]]</p><blockquote><p>[!tip] 注意：<br>不作为基类使⽤的 class 不要声明析构函数为 virtual 函数，因为虚表和虚表指针会占⽤额外的内存；<br>同时，std::string和STL容器的析构函数都是non-virtual，不要作为基类使⽤</p></blockquote><h1 id="8-08-别让异常逃离析构函数"><a class="markdownIt-Anchor" href="#8-08-别让异常逃离析构函数"></a> 8: [[08. 别让异常逃离析构函数]]</h1><h1 id="9-09-绝不在构造和析构过程中调用virtual-函数"><a class="markdownIt-Anchor" href="#9-09-绝不在构造和析构过程中调用virtual-函数"></a> 9: [[09 绝不在构造和析构过程中调⽤virtual 函数]]</h1><h1 id="10-10-令-operator返回一个绑定到-this-的引用"><a class="markdownIt-Anchor" href="#10-10-令-operator返回一个绑定到-this-的引用"></a> 10: [[10 令 operator=返回⼀个绑定到 <code>this</code> 的引⽤]]</h1><h1 id="11-11在-operator中处理自我赋值"><a class="markdownIt-Anchor" href="#11-11在-operator中处理自我赋值"></a> 11: [[11：在 operator=中处理自我赋值]]</h1><h1 id="12-12复制对象时勿忘其每一个成分"><a class="markdownIt-Anchor" href="#12-12复制对象时勿忘其每一个成分"></a> 12: [[12：复制对象时，勿忘其每一个成分]]</h1><h1 id="13-13以对象管理资源"><a class="markdownIt-Anchor" href="#13-13以对象管理资源"></a> 13: [[13：以对象管理资源]]</h1><h1 id="14-14在资源管理类小心-copying-行为"><a class="markdownIt-Anchor" href="#14-14在资源管理类小心-copying-行为"></a> 14: [[14：在资源管理类小心 copying 行为]]</h1><h1 id="15-15在资源管理类中提供对原始资源的访问"><a class="markdownIt-Anchor" href="#15-15在资源管理类中提供对原始资源的访问"></a> 15: [[15：在资源管理类中提供对原始资源的访问]]</h1><h1 id="16-16成对使用-new-和-delete-时候要采取相同形式"><a class="markdownIt-Anchor" href="#16-16成对使用-new-和-delete-时候要采取相同形式"></a> 16: [[16：成对使用 new 和 delete 时候要采取相同形式]]</h1><h1 id="17-17以独立语句将-newed-对象置入智能指针"><a class="markdownIt-Anchor" href="#17-17以独立语句将-newed-对象置入智能指针"></a> 17: [[17：以独立语句将 newed 对象置入智能指针]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>索引维护</title>
    <link href="/posts/9209/"/>
    <url>/posts/9209/</url>
    
    <content type="html"><![CDATA[<p>📝索引维护::</p><!-- basicblock-end --><p>B+树为了维护索引有序性，如果待插入记录所在的数据页已经满了，则可能造成“页分裂”<br>（申请一个新的数据页，然后将部分数据 挪过去）</p><p>页分裂的缺点：</p><ol><li>影响系统性能</li><li>影响数据页的利用率</li><li>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</li><li>所以，应该尽量使用 自增主键，减少空间存储消耗。（但是，事无绝对，只是大多情况使用自增主键，下面也有特例）</li></ol><p>适合用业务字段 直接做主键，而不是使用 自增主键的场景：（特例）</p><ol><li>只有一个索引</li><li>该索引必须是唯一索引</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 索引</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>索引下推</title>
    <link href="/posts/49591/"/>
    <url>/posts/49591/</url>
    
    <content type="html"><![CDATA[<p>📝索引下推::</p><!-- basicblock-end --><h1 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h1><p>索引下推 (Index Condition Pushdown，简称 ICP)，是 MySQL5.6 版本的新特性。</p><p>方法：<strong>即服务层把查询工作下推到引擎层去处理</strong><br>效果：它能减少回表查询次数，提高查询效率，节约 IO 开销。<br>目的: 索引下推的是为了减少回表次数，也就是要减少 IO 操作。</p><p>![[索引下推概念.excalidraw]]</p><h2 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h2><p>对存储引擎来说，<strong>索引下推只适用于二级索引</strong>；</p><p>对于的聚簇索引来说，数据和索引是在一起的，不存在回表这一说。</p><h2 id="2-什么时候不能下推"><a class="markdownIt-Anchor" href="#2-什么时候不能下推"></a> 2 什么时候不能下推</h2><p>引用了子查询的条件不能下推；<br>引用了存储函数的条件不能下推，因为存储引整无法调用存储函数。</p><blockquote><p>[!cite] 索引下推使用条件 (一般都支持): 满足条件自动触发<br>只能用于range、ref、ea_ref、ref_or_null访问方法；<br>只能用于 InnoDB 和 MyISAM 存储引擎及其分区表；</p></blockquote><h1 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h1><p>索引下推<br>那些不符合最左前缀的部分, 会怎么样呢?<br>比如,执行如下语句时候,则存在不符合最左前缀的部分:</p><blockquote><p>![[索引下推.excalidraw]]</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引常见类型</title>
    <link href="/posts/14700/"/>
    <url>/posts/14700/</url>
    
    <content type="html"><![CDATA[<p>📝索引常见类型::</p><!-- basicblock-end --><p>MySQL的索引是在存储引擎层实现的,不同的存储引擎有不同的索引结构,主要包含以下几种:</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><p>上述是MySQL中所支持的所有的索引结构,接下来,我们再来看看不同的存储引擎对于索引结构的支持情况。</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><blockquote><p>[!tip] 注意: 我们平常所说的索引, 如果没有特别指明, 都是指 B+树结构组织的索引。</p></blockquote><blockquote><p>[!tip]-<br>等值查询：<br>二分法（前提是，有序 ＋顺序存储），查询时间复杂度 O (log N)</p><p>区间查询：</p><ol><li>先用二分查找“左边界”（不存在的时，则找第一个比它大的记录）</li><li>然后，再向右扫描，直至 大于右边界</li></ol></blockquote><p>我们可以按照四个角度来分类索引。</p><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li><li>其他索引: [[聚集索引(目录)]], [[非聚集(合)索引]]</li></ul><ol><li>普通索引：最基本的索引，没有任何限制</li><li>唯一索引：与普通索引类似，但索引列的值必须是唯一的，允许空值</li><li>主键索引：一种特殊的唯一索引，一个表只能有一个主键，不允许有空值</li><li>组合索引：在多个字段上创建的索引，只有在查询条件中使用了创建索引的第一个<br>字段，索引才会被使用</li><li>全文索引：主要用来查找文本中的关键字，类似于搜索引擎</li></ol><h1 id="1-数据结构"><a class="markdownIt-Anchor" href="#1-数据结构"></a> 1: 数据结构</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png" alt=""></p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<br><strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><h1 id="2-主键索引与非主键索引"><a class="markdownIt-Anchor" href="#2-主键索引与非主键索引"></a> 2: 主键索引与非主键索引</h1><p>根据叶子节点的内容，索引类型<strong>分为主键索引和非主键索引</strong>：<br>主键索引的叶子节点<strong>存的是整行数据</strong><br>在 InnoDB 里，主键索引也被称为聚簇索引 (clustered index)</p><p>非主键索引的叶子节点<strong>存的是主键的值</strong><br>在 InnoDB 里，非主键索引也被称为二级索引 (secondary index)</p><blockquote><p>[!example]- 主键索引与二级索引的查找过程<br>![[二级索引.excalidraw]]</p></blockquote><h1 id="3-mysql索引主要使用的两种数据结构是什么"><a class="markdownIt-Anchor" href="#3-mysql索引主要使用的两种数据结构是什么"></a> 3: [[MySQL索引主要使用的两种数据结构是什么？]]</h1><h1 id="4-21-mysql中有四种索引类型可以简单说说吗"><a class="markdownIt-Anchor" href="#4-21-mysql中有四种索引类型可以简单说说吗"></a> 4: [[21、MySQL中有四种索引类型，可以简单说说吗？]]</h1><h1 id="5-有序数组"><a class="markdownIt-Anchor" href="#5-有序数组"></a> 5: 有序数组</h1><p>优点：<br>等值查询 和区间查询 性能都挺6（<strong>有序数组 适合 查询</strong>）</p><p>缺点：<br>有序数组不适合频繁 增/删记录的场景（<strong>但是，有序数组不合适增/删</strong>）</p><blockquote><p>[!summary] Note：<br>有序数组只适用于<strong>静态存储引擎</strong>，在等值查询和范围（区间）查询场景中的性能非常优秀</p></blockquote><h1 id="6-二叉搜索树"><a class="markdownIt-Anchor" href="#6-二叉搜索树"></a> 6: 二叉搜索树</h1><p>BST 是为了保留了“有序数组”查询（二分，O (logN)）性能好的优点，同时解决“有序数组”不适合增/删的缺点</p><p>BST 查询的时间复杂度：O(log N)<br>但是，为了维持 O (log (N)）的查询复杂度，就需要保持这棵树是平衡二叉树。（维护 BST 是 AVL 的时间复杂度也是 O (log (N))）</p><p>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。<br>其原因是:  索引不止存在内存中，还要写到磁盘上</p><h1 id="7-n-叉树"><a class="markdownIt-Anchor" href="#7-n-叉树"></a> 7: N 叉树</h1><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块<br>那么，我们就不应该使用二叉树，而是要使用“N 叉”树（N 取决于数据块的大小）<br>即，通过使用N叉树 来降低树的高度，即 减少读取磁盘的次数（IO是很慢的），提高查<br>询效率</p><blockquote><p>[!example]-<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211071640526.png" alt=""></p></blockquote><p>N 叉树特点：<br>折中 考虑了“查询性能”和“读取磁盘的次数”，广泛应用于数据库引擎中<br>MySQL中，索引是在存储引擎层实现的，而且不同存储引擎的索引的工作方式并不一样。<br>而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引目录</title>
    <link href="/posts/6234/"/>
    <url>/posts/6234/</url>
    
    <content type="html"><![CDATA[<p>📝索引目录::</p><!-- basicblock-end --><h1 id="1-什么是索引"><a class="markdownIt-Anchor" href="#1-什么是索引"></a> 1: 什么是索引</h1><p>索引：索引的出现其实就是为了提高数据查询的效率，就像书的目录一样</p><p><strong>MySQL 在查询方面主要就是两种方式：</strong></p><ol><li>全表扫描（一个一个挨个找）</li><li>根据索引检索</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>1、创建索引<br>create index 索引名 on 表名(列名）；<br># 也可以有多个列名构成索引（即，组合索引）<br><br>2、删除索引<br>drop index 索引名 on 表名；<br><br></code></pre></td></tr></tbody></table></figure><p>在 mysql 当中，怎么查看一个 SQL 语句是否使用了索<br>引进行检索？</p><ol><li>在 SQL 语句前，添加 explain 关键字<ol><li>[[explain 案例.excalidraw]]</li></ol></li><li>当 type=ALL 时，表示使用 全表查询（未使用索引）</li><li>当 type=RES 时，表示使用索引</li></ol><p>下图是 MySQL 的结构图，索引和数据就是位于存储引擎中：</p><p><img src="https://myblog-tuchuang.oss-cn-shanghai.aliyuncs.com/1623727651911_20170928110355446.png" alt=""></p><h1 id="2-为什么使用索引"><a class="markdownIt-Anchor" href="#2-为什么使用索引"></a> 2: 为什么使用索引？</h1><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>帮助服务器避免排序和临时表</li><li>将随机IO变为顺序IO。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li></ul><h1 id="3-索引失效的情况"><a class="markdownIt-Anchor" href="#3-索引失效的情况"></a> 3: 索引失效的情况：</h1><ol><li>模糊匹配当中以“％”开头时，索引失效</li><li>OR有一边的条件字段没有索引时，索引失效</li><li>使用复合索引的时候，没有使用左侧的列查找，索引失效</li><li>在where 当中索引列参加了运算，索引失效</li><li>在 where 当中索引列使用了函数，索引失效</li></ol><blockquote><p>[!tip] Note:</p><ol><li>在任何数据库当中主键上都会自动添加索引对象</li><li>在 mysql 当中，一个字段上如果有 unique 约束的话，也会自动创建索引对象</li></ol></blockquote><h1 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4:</h1><h2 id="41-25-什么时候需要建立数据库索引呢"><a class="markdownIt-Anchor" href="#41-25-什么时候需要建立数据库索引呢"></a> 4.1: [[25、什么时候需要建立数据库索引呢？]]</h2><h1 id="5-建立索引注意事项"><a class="markdownIt-Anchor" href="#5-建立索引注意事项"></a> 5: [[建立索引注意事项]]</h1><h1 id="6-索引优化"><a class="markdownIt-Anchor" href="#6-索引优化"></a> 6: 索引优化</h1><ol><li>尽量避免在where字句中对字段进行空值判断，这会导致引擎放弃使用索引，进行全表扫描</li><li>字段值分布很稀少的字段，不适合建立索引</li><li>不要用字符字段做主键</li><li>字符字段只建立前缀索引</li><li>不要用外键和UNIQUE</li><li>使用多列索引时，注意顺序和查询条件保持一致，同时删除不必要的单列索引</li></ol><h1 id="7-索引分类目录"><a class="markdownIt-Anchor" href="#7-索引分类目录"></a> 7: [[索引分类(目录)]]</h1><h1 id="8-innodb-的索引模型"><a class="markdownIt-Anchor" href="#8-innodb-的索引模型"></a> 8: InnoDB 的索引模型：</h1><p>InnoDB 使用了 B+树索引模型，每一个索引在 InnoDB 里面对应一棵 B+树</p><p>![[InnoDB 的索引模型.excalidraw]]</p><h2 id="81-主键查询-vs-普通索引查询"><a class="markdownIt-Anchor" href="#81-主键查询-vs-普通索引查询"></a> 8.1: 主键查询 vs 普通索引查询</h2><h3 id="811-主键查询"><a class="markdownIt-Anchor" href="#811-主键查询"></a> 8.1.1: 主键查询：</h3><p>直接在主键索引所在的 B+ 树中查询，然后直接返回查询到的叶子节点（此时，叶子节点里面就是整行记录）</p><h3 id="812-普通索引查询"><a class="markdownIt-Anchor" href="#812-普通索引查询"></a> 8.1.2: 普通索引查询：</h3><p>首先，在普通索引所在的B+树中，查询到待查询记录的主键；<br>然后，再根据这些查到的主键，执行“主键查询”（即，回表）</p><blockquote><p>[!tip]<br>基于非主键索引的查询需要多扫描一棵索引树。<br>因此，我们在应用中应该尽量使用主键查询。</p></blockquote><h1 id="9-索引维护"><a class="markdownIt-Anchor" href="#9-索引维护"></a> 9: [[索引维护]]</h1><h1 id="10-覆盖索引"><a class="markdownIt-Anchor" href="#10-覆盖索引"></a> 10: [[覆盖索引]]</h1><h1 id="11-最左前缀法则"><a class="markdownIt-Anchor" href="#11-最左前缀法则"></a> 11: [[最左前缀法则]]</h1><h1 id="12-索引的优缺点"><a class="markdownIt-Anchor" href="#12-索引的优缺点"></a> 12: [[索引的优缺点]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 锁</title>
    <link href="/posts/50086/"/>
    <url>/posts/50086/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 锁::</p><!-- basicblock-end --><blockquote><p>[!cite] 场景<br>多个事物在并发情况下会出现一些经典的问题, 如脏读、不可重复读、幻读、丢失更新。为了不同程度的解决这些问题, 出现了[[事务隔离(目录)|四大隔离级别]],锁就是实现各种隔离级别的一种方式。</p></blockquote><p>![[MySQL 锁 思维导图. excalidraw]]</p><blockquote><p>[!tip] Innodb 使⽤表锁还是⾏锁？<br>对于 innodb，绝⼤部分情况应该使⽤⾏锁</p></blockquote><h1 id="1-锁"><a class="markdownIt-Anchor" href="#1-锁"></a> 1 [[锁]]</h1><h1 id="2-锁的种类目录"><a class="markdownIt-Anchor" href="#2-锁的种类目录"></a> 2 [[锁的种类(目录)]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 表连接 与 锁</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 表连接</title>
    <link href="/posts/43588/"/>
    <url>/posts/43588/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 表连接::</p><!-- basicblock-end --><h1 id="前导知识"><a class="markdownIt-Anchor" href="#前导知识"></a> 前导知识</h1><h2 id="1-连接"><a class="markdownIt-Anchor" href="#1-连接"></a> 1 连接</h2><p>将各个表中的记录都取出来进行依次匹配，将匹配后的结果发给客户端</p><h2 id="2-笛卡尔积"><a class="markdownIt-Anchor" href="#2-笛卡尔积"></a> 2 笛卡尔积</h2><p>连接查询的结果中包含一个表的每一条记录与另一个表中每一条记录的组合，这样的查询结果就是笛卡尔积<br>比如表a有5条记录；表b有6条记录；a和b的笛卡尔积就是30</p><h1 id="连接过程"><a class="markdownIt-Anchor" href="#连接过程"></a> 连接过程</h1><p>1、确定第一个需要查询的表，此表为驱动表</p><p>2、从驱动表中取每一条符合搜索条件的记录，到接下来的表中查找匹配的记录；<br>驱动表之后的那个表就叫被驱动表</p><p>只需要访问驱动表一次，可能会多次访问被驱动表<br>每获得一条满足条件的驱动表记录，马上到被驱动表中寻找匹配的记录</p><h1 id="内外连接"><a class="markdownIt-Anchor" href="#内外连接"></a> 内外连接</h1><p>[[内连接]]. [[外连接]]</p><h2 id="1-内连接"><a class="markdownIt-Anchor" href="#1-内连接"></a> 1 内连接</h2><p>驱动表中的记录在被驱动表中找不到匹配的记录，那么驱动表的这条记录不会加入到最后的<br>结果中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from 驱动表， 被驱动表；<br>select * from 驱动表 join 被驱动表；<br>select * from 驱动表 inner join 被驱动表；<br>select * from 驱动表 cross join 被驱动表；<br></code></pre></td></tr></tbody></table></figure><h2 id="2-外连接"><a class="markdownIt-Anchor" href="#2-外连接"></a> 2 外连接</h2><p>驱动表中的记录在被驱动表中找不到匹配的记录，也仍需要加入到最后结果中</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>左外连接：语句左侧的表为驱动表<br>select * from 驱动表 left join 被驱动表 on 连接条件；<br><br>右外连接：语句右侧的表为驱动表<br>select * from 被驱动表 right join 驱动表 on 连接条件；<br><br></code></pre></td></tr></tbody></table></figure><p><strong>对于内连接，驱动表和被驱动表的顺序可以更换；对于外连接，这个顺序不能随意更换</strong></p><h2 id="3-过滤条件"><a class="markdownIt-Anchor" href="#3-过滤条件"></a> 3 过滤条件：</h2><p><strong>where:</strong><br>不论内外连接，只要是不符合 where 子句的记录都不会加入到最后的结果中</p><p><strong>on:</strong><br>在内连接中与where等价；<br>在外连接中，如果驱动表中的记录在被驱动表中没有记录可以匹配，该驱动表记录仍会加入到结果中，对应的被驱动表字段以 null 填充</p><h1 id="嵌套循环连接"><a class="markdownIt-Anchor" href="#嵌套循环连接"></a> 嵌套循环连接</h1><p>如果有3个表进行连接，那么表1和表2完成连接后的结果作为驱动表，将表3作为被驱动表<br>进行连接查询</p><p>减少被驱动表的访问次数</p><h1 id="使用索引"><a class="markdownIt-Anchor" href="#使用索引"></a> 使用索引</h1><p>在根据驱动表的一条记录去被驱动表中查询时，相当于确定搜索条件的单表查询，可以使用索引优化单表查询</p><p>在被驱动表上使用二级索引进行查询时，可能连接查询的变量和过滤条件都是二级索引的部分列，可以不用回表直接覆盖索引，所以最好不要用<code>*</code>作为查询列表，而是使用真正需要查询的列</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 表连接 与 锁</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 基础</title>
    <link href="/posts/64803/"/>
    <url>/posts/64803/</url>
    
    <content type="html"><![CDATA[<p>📝MySQL 基础::</p><!-- basicblock-end --><h1 id="1-数据库中的键"><a class="markdownIt-Anchor" href="#1-数据库中的键"></a> 1: 数据库中的键</h1><p>[[27、数据库中的主键, 超键, 候选键, 外键(目录)]]</p><h1 id="2-主键-外键-索引的区别"><a class="markdownIt-Anchor" href="#2-主键-外键-索引的区别"></a> 2: 主键、外键、索引的区别</h1><p>主键：唯一标识一条记录，不允许重复，不允许为空<br>用来保存数据的完整性</p><p>外键：外键表示另一张表的主键，允许重复，可以是空值<br>主要用于和其它表建立联系<br>索引：没有重复值，但可以有一个空值<br>为了提高查询排序的速度</p><h1 id="3-表的优化"><a class="markdownIt-Anchor" href="#3-表的优化"></a> 3: 表的优化</h1><p>在建表之初就需要考虑拆分逻辑<br>字段优化：</p><ol><li>尽量使用 tinyint，smallint，mediumint 替代 int 类型，如果是非负则加上<br>unsigned</li><li>varchar的长度只分配真正需要的空间</li><li>尽量使用整数或者枚举替代字符串类型</li><li>时间类型尽量使用timestamp而非datetime</li><li>单表不要放太多字段</li><li>尽量少使用null，很难查询优化而且占用额外索引空间</li></ol><h1 id="4-慢查询"><a class="markdownIt-Anchor" href="#4-慢查询"></a> 4: 慢查询</h1><h2 id="41-基础"><a class="markdownIt-Anchor" href="#41-基础"></a> 4.1: 基础：</h2><p>(1) 设置指定超时时间, 超过这个时间的 sql 语句被称为慢查询<br>(2) long_query_time: 默认 10 秒</p><h2 id="42-优化"><a class="markdownIt-Anchor" href="#42-优化"></a> 4.2: 优化</h2><p>(1) 运行语句, 找到慢查询的 sql<br>(2) 查询区分度最高的字段<br>(3) explain: 显示 mysql 如何使用索引来处理 select 语句以及连接表, 可以帮助选择更好的索引、写出更优化的查询语句<br>(4) order by limit 形式的 sql 语句, 让排序的表优先查<br>(5) 考虑建立索引原则<br>(6) 了解业务使用场景</p><h1 id="5-mysql-与-mongodb-的区别海量数据的存储"><a class="markdownIt-Anchor" href="#5-mysql-与-mongodb-的区别海量数据的存储"></a> 5: MySQL 与 MongoDB 的区别，海量数据的存储</h1><h2 id="51-数据库模型"><a class="markdownIt-Anchor" href="#51-数据库模型"></a> 5.1: 数据库模型</h2><p>MySQL：关系型<br>MongoDB： 非关系型</p><h2 id="52-存储方式"><a class="markdownIt-Anchor" href="#52-存储方式"></a> 5.2: 存储方式</h2><p>MySQL：不同引擎有不同的存储方式<br>MongoDB：虚拟内存+持久化</p><h2 id="53-查询语句"><a class="markdownIt-Anchor" href="#53-查询语句"></a> 5.3: 查询语句</h2><p>MySQL：sql语句<br>MongoDB：使用MongoDB自己的查询方式</p><h2 id="54-常见架构特点"><a class="markdownIt-Anchor" href="#54-常见架构特点"></a> 5.4: 常见架构特点</h2><p>MySQL：单点、Master-Slave, MHA， Cluster<br>MongoDB： 通过副本集与分片来实现高可用</p><h2 id="55-数据处理方式"><a class="markdownIt-Anchor" href="#55-数据处理方式"></a> 5.5: 数据处理方式</h2><p>MySQL：不同引擎有不同处理特点<br>MongoDB：基于内存，将热数据存储在物理内存中，从而达到高速读写的目的</p><h2 id="56-海量数据的存储"><a class="markdownIt-Anchor" href="#56-海量数据的存储"></a> 5.6: 海量数据的存储</h2><p>MySQL效率相对较低，但是MongoDB不支持事务</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>carl</category>
      
      <category>MySQL 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>完美转发</title>
    <link href="/posts/50075/"/>
    <url>/posts/50075/</url>
    
    <content type="html"><![CDATA[<p>📝完美转发::<a href="https://www.bilibili.com/video/BV1D84y1z7kT?p=3&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++11完美转发_哔哩哔哩_bilibili</a></p><!-- basicblock-end --><blockquote><p>[!summary]<br>实现写一个接受任意实参的函数模板, 并转发到其它函数, 目标函数会收到与转发函数完全相同的实参, 通过 std:: forward () 实现<br>在函数模板中，可以将参数“完美”的转发给其它函数。所谓完美，即不仅能准确的转发参数的值，还能<strong>保证被转发参数的左、右值属性不变</strong>。</p></blockquote><p>C++11 标准引入了右值引用和移动语义，所以，能否实现完美转发，决定了该参数在传递过程使用的是拷贝语义还是移动语义。</p><ul><li>tip 如果能实现完美转发, 那么 , 参数在传递的过程中就可以使用移动语义</li></ul><p>为了支持完美转发，C++11 提供了以下方案：</p><p>1）如果模板中（包括类模板和函数模板）函数形参的书写成为 <code>T&amp;&amp;</code> 参数名，<br>那么，函数既可以接受左值引用，又可以接受右值引用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">格式<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TT&gt;<span class="hljs-comment">// 1️⃣创建一个模板函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TT&amp;&amp; num)</span><span class="hljs-comment">// 2️⃣用两个&amp;&amp;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">注意必须是 TT,用 <span class="hljs-type">int</span> &amp;&amp; num 则不行</span><br><span class="hljs-function"></span><br></code></pre></td></tr></tbody></table></figure><p>2）提供了模板函数 <code>std::forward&lt;T&gt;</code> (参数) ，用于转发参数，<br>如果参数是一个右值，转发之后仍是右值引用；<br>如果参数是一个左值，转发之后仍是左值引用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; num)</span> </span>{        <span class="hljs-comment">// 如果参数是左值，调用此函数。</span><br>    cout &lt;&lt; <span class="hljs-string">"参数是左值="</span> &lt;&lt; num &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; num)</span> </span>{     <span class="hljs-comment">// 如果参数是右值，调用此函数。</span><br>    cout &lt;&lt; <span class="hljs-string">"参数是右值="</span> &lt;&lt; num &lt;&lt; endl;<br>}<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> TT&gt;<span class="hljs-number">1</span>️⃣<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(TT&amp;&amp; num)</span><span class="hljs-comment">// 2️⃣</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">func1</span>(forward&lt;TT&gt;(num));<span class="hljs-comment">// 3️⃣</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">func</span>(num);       <span class="hljs-comment">// 参数是左值。</span><br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">8</span>);       <span class="hljs-comment">// 参数是右值。</span><br>}<br><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动语义</title>
    <link href="/posts/28000/"/>
    <url>/posts/28000/</url>
    
    <content type="html"><![CDATA[<p>📝移动语义::</p><!-- basicblock-end --><blockquote><p>[!tip]<br>浅拷贝: a 和 b 的指针指向了同一块内存, 就是浅拷贝, ;</p><p>深拷贝: 深拷贝就是再拷贝对象时, 如果被拷贝对象内部还有指针引用指向其它资源, 自己需要重新开辟一块新内存存储资源<br>[[拷贝构造 &amp; 拷贝赋值.excalidraw]]</p></blockquote><p>如果一个对象中有堆区资源，需要编写拷贝构造函数和赋值函数，实现深拷贝。<br>深拷贝把对象中的堆区资源复制了一份，<br>如果源对象（被拷贝的对象）是临时对象，拷贝完就没什么用了，这样会造成没有意义的资源申请和释放操作。<br>如果能够直接使用源对象拥有的资源，可以节省资源申请和释放的时间。<br>C++11新增加的移动语义就能够做到这一点。</p><p>可以理解为转移所有权, 对于移动语义, 类似于转让或者资源窃取的意思, 对于那块资源, 转为自己所拥有, 别人不再拥有也不会再使用。</p><p>通过移动构造函数使用移动语义, 也就是 std:: move; <strong>移动语义仅针对于那些实现了移动构造函数的类的对象</strong>,<br>对于那种基本类型 int、float 等没有任何优化作用, 还是会拷贝, 因为它们实现没有对应的移动构造函数</p><blockquote><p>[!summary] 注意<br>1）对于一个左值，会调用拷贝构造函数，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？<br>C++11 为了解决这个问题，提供了 <strong>std:move () 方法来将左值转义为右值</strong>，从而方便使用移动语义。它其实就是告诉编译器，虽然我是一个左值，但不要对我用拷贝构造函数，用移动构造函数吧。<br>左值对象被转移资源后，不会立刻析构，只有在离开自己的作用域的时候才会析构，如果继续使用左值中的资源，可能会发生意想不到的错误。</p><p>2）如果没有提供移动构造/赋值函数，只提供了拷贝构造/赋值函数，编译器找不到移动构造/赋值函数就去寻找拷贝构造/赋值函数。</p><p>3）C++11 中的所有容器都实现了移动语义，避免对含有资源的对象发生无谓的拷贝。</p><p>4）移动语义对于拥有资源（如内存、文件句柄）对象有效，如果是基本类型，使用移动语义没有意义。</p></blockquote><blockquote><p>[!question]<br>std:: move 的语法::   #疑问</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;移动构造函数的语法：<br>&gt;类名 (类名&amp;&amp; 源对象）{.....}<br>&gt;移动赋值函数的语法：<br>&gt;类名&amp; <span class="hljs-keyword">operator</span>=(类名&amp;＆ 源对象）{.....}<br></code></pre></td></tr></tbody></table></figure></blockquote><p>![[左右值引用 2022-10-29 17.36.40.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>返回值</title>
    <link href="/posts/32286/"/>
    <url>/posts/32286/</url>
    
    <content type="html"><![CDATA[<p>📝返回值::</p><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>res = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 先赋值</span><br><span class="hljs-keyword">if</span>函数中改变 res 值<br><span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 最后直接返回 res, 如果改变了最好, 没改变就直接返回了-1</span><br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>09. 用两个栈实现队列</title>
    <link href="/posts/28644/"/>
    <url>/posts/28644/</url>
    
    <content type="html"><![CDATA[<p>📝09. 用两个栈实现队列::</p><!-- basicblock-end --><h1 id="一-题目描述"><a class="markdownIt-Anchor" href="#一-题目描述"></a> 一、题目描述</h1><p><strong>用两个栈实现一个队列</strong>。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 <code>-1</code> )</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">"CQueue"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"deleteHead"</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br>输出：[null,null,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">"CQueue"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"appendTail"</span>,<span class="hljs-string">"deleteHead"</span>,<span class="hljs-string">"deleteHead"</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br>输出：[null,<span class="hljs-number">-1</span>,null,null,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ul><li>push 操作: 直接加入添加栈</li><li>delete 操作:<ul><li>把添加栈中的元素反向加入删除栈</li><li>删除栈顶元素</li><li>在把删除栈中的元素反向加入添加栈<br>‌‌‌　　![[09. 用两个栈实现队列 2022-11-07 11.19.22.excalidraw]]</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> {<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stAdd;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stDel;<br><br>    <span class="hljs-built_in">CQueue</span>() { <span class="hljs-comment">// ❓这个函数是干嘛的, 不懂, 💡没有它也可以通过</span><br>        <span class="hljs-keyword">while</span>(!stAdd.<span class="hljs-built_in">empty</span>()){<br>            stAdd.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-keyword">while</span>(!stDel.<span class="hljs-built_in">empty</span>()){<br>            stDel.<span class="hljs-built_in">pop</span>();<br>        }<br><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>{<br>        stAdd.<span class="hljs-built_in">push</span>(value);<br><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-comment">// 把添加栈反向加入删除栈</span><br>        <span class="hljs-keyword">while</span>(!stAdd.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> val = stAdd.<span class="hljs-built_in">top</span>();stAdd.<span class="hljs-built_in">pop</span>();<br>            stDel.<span class="hljs-built_in">push</span>(val);<br>        }<br>        <span class="hljs-comment">// 删除元素</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(!stDel.<span class="hljs-built_in">empty</span>()){<br>        <span class="hljs-comment">// ❗️如果这里用 int res = ....., 就不行, 他会默认是一个临时变量</span><br>        res = stDel.<span class="hljs-built_in">top</span>();stDel.<span class="hljs-built_in">pop</span>(); <br>        }<br><br>        <span class="hljs-comment">// 再把删除栈 放回添加栈</span><br>        <span class="hljs-keyword">while</span>(!stDel.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> val =  stDel.<span class="hljs-built_in">top</span>();stDel.<span class="hljs-built_in">pop</span>();<br>            stAdd.<span class="hljs-built_in">push</span>(val);<br>        }<br>        <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// ❗️❗️不能返回之前返回 res, 不然后边的执行了</span><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>[[返回值]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程切换为何比线程慢</title>
    <link href="/posts/59224/"/>
    <url>/posts/59224/</url>
    
    <content type="html"><![CDATA[<p>📝进程<strong>切换</strong>为何比线程慢::</p><!-- basicblock-end --><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247489156&amp;idx=1&amp;sn=d11a8ec34fcb17b9fb39f3dd9f8b039f&amp;chksm=e959c33cde2e4a2a051edc37642a899181b5d4d11d21773d8fb667a95c599ba0743bde2892b9&amp;scene=178&amp;cur_album_id=2153190488940642309#rd">https://mp.weixin.qq.com/s?__biz=MzI0NDc3ODE5OQ==&amp;mid=2247489156&amp;idx=1&amp;sn=d11a8ec34fcb17b9fb39f3dd9f8b039f&amp;chksm=e959c33cde2e4a2a051edc37642a899181b5d4d11d21773d8fb667a95c599ba0743bde2892b9&amp;scene=178&amp;cur_album_id=2153190488940642309#rd</a></p><blockquote><p>[!cite] 这里的线程肯定指的是同一个进程中的线程。</p></blockquote><p>进程<strong>切换</strong>为何比线程慢</p><p>涉及到虚拟内存的问题，进程切换涉及虚拟地址空间的切换而线程不会。<br>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，所以同一个进程中的线程<strong>进行线程切换</strong>时不涉及虚拟地址空间的转换。</p><p>把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程（至少访问2次内<br>存），因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就<br>是 TLB（快表）。</p><p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后 TLB 就失效了，cache 失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程线程无需切换地址空间，这也就是进程切换要比同进程下线程切换慢的原因。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>操作系统</category>
      
      <category>carl</category>
      
      <category>进程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程的状态</title>
    <link href="/posts/18933/"/>
    <url>/posts/18933/</url>
    
    <content type="html"><![CDATA[<p>📝进程的状态::</p><!-- basicblock-end --><blockquote><p>[!question]<br>进程运行会占用物理内存::   #疑问</p></blockquote><blockquote><p>[!summary] 除了创建和结束和技术的其他状态<br>![[进程状态.excalidraw|1800]]</p></blockquote><h1 id="1-进程状态的切换"><a class="markdownIt-Anchor" href="#1-进程状态的切换"></a> 1 进程状态的切换</h1><p>进程的状态分类：</p><ol><li>就绪状态 (ready) 等待被调度</li><li>运行状态 (running)</li><li>阻塞状态 (waiting)：等待资源</li></ol><p>![[进程状态的切换. excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>操作系统</category>
      
      <category>carl</category>
      
      <category>进程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 计算机硬件组成</title>
    <link href="/posts/18158/"/>
    <url>/posts/18158/</url>
    
    <content type="html"><![CDATA[<p>📝2. 计算机硬件组成:: 太长了, 没看</p><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/277741932b674f558160c0f85e9a0297.png" alt="请添加图片描述"></p><h1 id="1-一计算机层次结构"><a class="markdownIt-Anchor" href="#1-一计算机层次结构"></a> 1 一：计算机层次结构</h1><h2 id="11-1冯诺依曼机特点"><a class="markdownIt-Anchor" href="#11-1冯诺依曼机特点"></a> 1.1 （1）冯诺依曼机特点</h2><p><strong>冯诺依曼机特点如下</strong></p><ol><li>计算机硬件系统由<strong>运算器、存储器、控制器、输入和输出设备</strong>5部分组成</li><li><strong>指令和数据</strong>以同等地位存储在<strong>存储器</strong>，并可按<strong>地址</strong>寻访</li><li>指令由<strong>操作码和地址码</strong>组成，操作码用于表示这是一个<strong>什么类型的操作</strong>，地址码用于表示<strong>操作数在存储器中的存放位置</strong></li><li>指令在存储器内<strong>按顺序存放</strong>（一般情况下是这样的，但在特定条件下也可以进行设定）</li><li><strong>早期的冯诺依曼机器以运算器为中心</strong>，输入输出设备通过运算器与存储器传送数据</li></ol><p><img src="https://img-blog.csdnimg.cn/2021071021272932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgzMDM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>上图中，<strong>实线是数据线，虚线是控制线</strong>（双向）</li></ul><p><strong>冯诺依曼机缺陷（早期）</strong></p><p>在控制器的指挥下，输入和输出设备输入一些数据交给运算器进行运算，如果产生中间结果，就会传送给存储器，计算完成后最终结果会给输出设备。<strong>可以发现这种层次结构容易受到输入和输出设备的牵制，因为他们的速度相较于运算器太慢了（短板效应）</strong></p><h2 id="12-2现代计算机的组织结构"><a class="markdownIt-Anchor" href="#12-2现代计算机的组织结构"></a> 1.2 （2）现代计算机的组织结构</h2><p>为了解决I/O设备的速度和CPU速度差异悬殊的问题，<strong>现如今的计算机则采用以存储器为中心的计算机组织结构</strong>，这种结果使I/O操作尽可能绕过CPU，直接<strong>在I/O设备和存储器之间完成</strong>，以提高系统的整体运行效率</p><p><img src="https://img-blog.csdnimg.cn/202107102132256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MTgzMDM0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>操作系统</category>
      
      <category>王道操作系统</category>
      
      <category>1. 计算机概述</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进程的基础知识</title>
    <link href="/posts/37302/"/>
    <url>/posts/37302/</url>
    
    <content type="html"><![CDATA[<p>📝进程的基础知识::</p><!-- basicblock-end --><h1 id="1-进程的概念"><a class="markdownIt-Anchor" href="#1-进程的概念"></a> 1 进程的概念</h1><p>我们编译的代码可执行文件只是储存在硬盘的静态文件，运行时被加载到内存，CPU 执行内存中指令，这个运行的程序被称为进程。</p><p>进程是对运行时程序的封装，操作系统进行资源调度和分配的<strong>基本单位</strong>。</p><h1 id="2-进程的实现"><a class="markdownIt-Anchor" href="#2-进程的实现"></a> 2 进程的实现</h1><blockquote><p>[!question]<br>中断发生后操作系统底层的工作步骤::   #疑问</p></blockquote><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li>汇编语言过程保存寄存器值</li><li>汇编语言过程设置新的堆栈</li><li>C中断服务例程运行（典型地读和缓冲输入）</li><li>调度程序决定下一个将运行的进程</li><li>C 过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ol><p><strong>进程表</strong>：<br>为了实现进程模型，操作系统维护着一张表格(一个结构数组)，即进程表。<br>每个进程占有一个进程表项。（有些著作称这些为进程控制块, 💡应该说的是 PCB）</p><p>该表项包含了一个进程状态的重要信息<br>包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号的调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，<strong>从而保证该进程随后能再次启动，就像从未中断过一样</strong></p><h1 id="3-并发与并行"><a class="markdownIt-Anchor" href="#3-并发与并行"></a> 3 并发与并行</h1><p>(1) 单个核心在很短时间内分别执行多个进程, 称为并发<br>(2) 多个核心同时执行多个进程称为并行<br>(3)对于并发来说,CPU需要从一个进程切换到另一个进程,这个过程需要保存进程的状态信息</p><h1 id="4-进程的状态"><a class="markdownIt-Anchor" href="#4-进程的状态"></a> 4 [[进程的状态]]</h1><h1 id="5-进程控制块-pcb"><a class="markdownIt-Anchor" href="#5-进程控制块-pcb"></a> 5 进程控制块 (PCB)</h1><p>操作系统对进程的感知，是通过进程控制块PCB数据结构来描述的。它是进程存在的唯一标识，其包括以下信息：</p><ol><li>进程描述信息：进程标识符、用户标识符等；</li><li>进程控制和管理信息：进程状态，进程优先级等；</li><li>进程资源分配清单：虚拟内存地址空间信息，打开文件列表，IO设备信息等；</li><li>CPU相关信息：当进程切换时，CPU寄存器的值都被保存在相应PCB中，以便CPU重新执行该进程时能从断点处继续执行；</li></ol><p>PCB通过链表形式组织起来，比如有就绪队列、阻塞队列等，方便增删，方便进程管理。</p><p>![[文件描述符.excalidraw]]</p><h1 id="6-进程切换为何比线程慢"><a class="markdownIt-Anchor" href="#6-进程切换为何比线程慢"></a> 6 [[进程切换为何比线程慢]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>操作系统</category>
      
      <category>carl</category>
      
      <category>进程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统目录</title>
    <link href="/posts/44040/"/>
    <url>/posts/44040/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是操作系统操作系统-operating-system"><a class="markdownIt-Anchor" href="#1-什么是操作系统操作系统-operating-system"></a> 1: 什么是操作系统操作系统 (Operating System),</h1><blockquote><p>[!summary] 一堆废话</p></blockquote><p>介于硬件资源和应用程序之间的一个系统软件</p><p>如果将它理解为“掌控计算机的系统”是否更能精确的描述 OS 所做的事情呢?</p><p>如果要更深入的掌握这个问题, 可以问一问: 如果没有了操作系统, 你使用的 PC 机还能干什么? 或者说, 你能够使用你的 PC 机做什么呢?</p><h1 id="2-操作系统的功能"><a class="markdownIt-Anchor" href="#2-操作系统的功能"></a> 2: 操作系统的功能</h1><p>操作系统位于硬件资源之上, 管理硬件资源; 应用程序之下, 为应用程序提供服务, 同时管理应用程序</p><h2 id="21-资源分配-资源回收"><a class="markdownIt-Anchor" href="#21-资源分配-资源回收"></a> 2.1: 资源分配, 资源回收</h2><p>计算机必要重要的硬件资源无非就是 CPU、内存、硬盘、I/O 设备。<br>而这些资源总是有限的, 因此需要有效管理, 资源管理最终只有两个问题: <strong>资源分配、资源回收</strong>。</p><p><strong>资源分配</strong>: 体现在 CPU 上, 比如进程调度, 多个进程同时请求 CPU 下, 应该给哪一个进程呢? 再比如内存分配, 内存不够了怎么办?A 进程非法访问了 B 进程的内存地址怎么办? 内存内、外碎片问题等。</p><p><strong>资源回收</strong>: 考虑内存回收后的合并等等。</p><h2 id="22-为应用程序提供服务"><a class="markdownIt-Anchor" href="#22-为应用程序提供服务"></a> 2.2: 为应用程序提供服务</h2><p>操作系统将硬件资源的操作封装起来,提供相对统一的接又(系统调用)供开发者调用。<br>如果没有操作系统,应用程序将直接面对硬件,除去给开发者带来的编程困难不说,直接访问硬件,使用不当极有可能直接损坏硬件资源。</p><h2 id="23-管理应用程序"><a class="markdownIt-Anchor" href="#23-管理应用程序"></a> 2.3: 管理应用程序</h2><p>即控制进程的生命周期:进程开始时的环境配置和资源分配、进程结束后的资源回收、进程调度等。</p><h2 id="24-操作系统内核的功能"><a class="markdownIt-Anchor" href="#24-操作系统内核的功能"></a> 2.4: 操作系统内核的功能</h2><ol><li>进程调度能力: 管理进程、线程, 决定哪个进程、线程使用 CPU。</li><li>内存管理能力: 决定内存的分配和回收。</li><li>硬件通信能力: 管理硬件, 为进程和硬件之间提供通信</li><li>系统调用能力: 应用程序进行更高限权运行的服务, 需要系统调用, 用户程序和操作系统之间的接口。</li></ol><blockquote><p>[!tip] 健壮性, 又称鲁棒性, 即使很粗鲁的对待程序, 它还是可以运行得很棒!</p></blockquote><h1 id="3-操作系统的角色"><a class="markdownIt-Anchor" href="#3-操作系统的角色"></a> 3: 操作系统的角色</h1><blockquote><p>[!summary] 魔术师与管理者</p></blockquote><p>1、管理者<br>主要分为: CPU 管理、内存管理、外存管理、IO 管理; 以及自己的健壮性和安全性管理。</p><p>2、魔术师:<br>比如操作系统会让每个进程都觉得自己独占 CPU、独占整片物理内存, 而实际上每个进程都只是在某一时间段内占用 CPU, 仅仅只是占用实际一点点物理内存。</p><h1 id="4-用户程序与操作系统的关系"><a class="markdownIt-Anchor" href="#4-用户程序与操作系统的关系"></a> 4: 用户程序与操作系统的关系</h1><blockquote><p>[!summary] <strong>相互调用</strong></p></blockquote><p>1、操作系统的角度</p><p>计算机启动后启动的第一个软件就是操作系统, 随后启动的所有进程都运行在操作系统之上, 使用操作系统提供的服务, 同时被操作系统监控, 进程结束后也由操作系统回收。</p><p>2、进程角度<br>调用操作系统提供的服务,实现自己的功能。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>操作系统</category>
      
      <category>carl</category>
      
      <category>操作系统基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>41-50</title>
    <link href="/posts/30009/"/>
    <url>/posts/30009/</url>
    
    <content type="html"><![CDATA[<p>📝41-50::</p><!-- basicblock-end --><h1 id="1-条款-41-理解-ptr-funmem-fun-和-mem-fun-ref-的来由"><a class="markdownIt-Anchor" href="#1-条款-41-理解-ptr-funmem-fun-和-mem-fun-ref-的来由"></a> 1 条款 41: 理解 ptr-fun,mem-fun 和 mem-fun-ref 的来由</h1><h2 id="11-知识点-1-理解他们的由来"><a class="markdownIt-Anchor" href="#11-知识点-1-理解他们的由来"></a> 1.1 知识点 1: 理解他们的由来</h2><p>这几个完全是用来掩盖一个C++在调用一个函数的时候语法不一致的问题的<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051619451.png" alt=""></p><p>一般而言，我们的 STL 都接受第一种形式的调用，为了满足下面两种形式，可以使用 mem-fun 或者 mem-fun-ref，这两个是针对无参函数的调用的（即 f 须是没有参数的）</p><h2 id="12-知识点-2c11-的形式"><a class="markdownIt-Anchor" href="#12-知识点-2c11-的形式"></a> 1.2 知识点 2:C++11 的形式</h2><p>C++11中,mem-fun和mem-fun-ref变成了历史包袱,更好的是用mem-fn。<br>但是bind他不香嘛为啥不用他。。有着相同的功效还没有参数的限制。</p><h1 id="2-条款-42-确保-lesst-与-operator-具有相同的意思"><a class="markdownIt-Anchor" href="#2-条款-42-确保-lesst-与-operator-具有相同的意思"></a> 2 条款 42: 确保 <code>less&lt;T&gt;</code> 与 <code>operator&lt;</code> 具有相同的意思</h1><h2 id="21-知识点-1-less-与的关系"><a class="markdownIt-Anchor" href="#21-知识点-1-less-与的关系"></a> 2.1 知识点 1: less 与&lt;的关系</h2><p>operator&lt;不仅仅是 less 的默认实现方式, 也是程序员期望 less 做的事情, 让 less 不调用 operator&lt;而去做别的事情是不好的</p><p>对于multiset类型的可以考虑定义一个函数类,直接替换默认比较方式less,而不是使用模板特例化去实现<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051622258.png" alt=""></p><h1 id="3-条款-43-算法的调用优先于手写的循环"><a class="markdownIt-Anchor" href="#3-条款-43-算法的调用优先于手写的循环"></a> 3 条款 43: 算法的调用优先于手写的循环</h1><h2 id="31-知识点-1-算法的调用优先于手写循环的原因"><a class="markdownIt-Anchor" href="#31-知识点-1-算法的调用优先于手写循环的原因"></a> 3.1 知识点 1: 算法的调用优先于手写循环的原因</h2><p>效率: 算法通常比程序员自己写的循环效率更高<br>正确性: 自己写的算法更加容易出错 (比如迭代器这块)<br>可维护性:使用算法的代码通常比手写循环的代码更加的简洁明了</p><h1 id="4-条款-44-容器的成员函数优先于同名的算法"><a class="markdownIt-Anchor" href="#4-条款-44-容器的成员函数优先于同名的算法"></a> 4 条款 44: 容器的成员函数优先于同名的算法</h1><blockquote><p>[!summary] 原因<br>首先, 成员函数的行为与关联容器的其他成员函数能够保持更好的一致性。</p><p>相等性和等价性的区别, 算法一般关注于相等性, 而容器函数一般是等价性</p><p>成员函数的性能更加卓越,毕竟自己人才懂自己人</p></blockquote><h1 id="5-条款45正确区分countfind等算法"><a class="markdownIt-Anchor" href="#5-条款45正确区分countfind等算法"></a> 5 条款45:正确区分count,find等算法</h1><p>![[41-50 2022-11-05 16.24.14.excalidraw]]</p><h1 id="6-条款-46考虑使用函数对象而不是函数作为-stl-算法的参数"><a class="markdownIt-Anchor" href="#6-条款-46考虑使用函数对象而不是函数作为-stl-算法的参数"></a> 6 条款 46：考虑使用函数对象而不是函数作为 STL 算法的参数</h1><h2 id="61-知识点1为什么要考虑使用函数对象而不是函数本身作为stl算法的参数"><a class="markdownIt-Anchor" href="#61-知识点1为什么要考虑使用函数对象而不是函数本身作为stl算法的参数"></a> 6.1 知识点1：为什么要考虑使用函数对象而不是函数本身作为STL算法的参数</h2><h3 id="611-原因1函数对象与内联性"><a class="markdownIt-Anchor" href="#611-原因1函数对象与内联性"></a> 6.1.1 原因1：函数对象与内联性</h3><p>定义在class内部的函数是会被优化成inline的，然而在外部的函数使用inline之后编译器只是针对性的，不一定会去优化。</p><h3 id="612-原因2调用函数名字作为函数背后的故事"><a class="markdownIt-Anchor" href="#612-原因2调用函数名字作为函数背后的故事"></a> 6.1.2 原因2：调用函数名字作为函数背后的故事</h3><p>每次我们调用一个函数名字作为函数，背后都是传递一个函数的指针，这个指针去调用函数，相当于一次间接的调用，这种调用很难进行内联优化</p><h3 id="613-原因-3不一定正确的算法调用"><a class="markdownIt-Anchor" href="#613-原因-3不一定正确的算法调用"></a> 6.1.3 原因 3：不一定正确的算法调用</h3><p>直接的去调用函数的名字，可能会导致因为无法进行隐式转换/类型不匹配等原因导致 jj</p><p>所以我们应该多使用函数对象而不是函数本身作为STL算法的参数，使用函数对象更加安全且快速</p><h1 id="7-条款-47避免产生直写型代码"><a class="markdownIt-Anchor" href="#7-条款-47避免产生直写型代码"></a> 7 条款 47：避免产生”直写型”代码</h1><p>知识点1：不要嵌套太多代码，可能会导致很难理解<br>不要嵌套过于多的函数，这样可能导致难理解的同时还会难以维护<br>代码的可读性是非常重要的，有了可读性的代码才能维护<br>对于嵌套较多且难理解的代码可以选择加上一些注释</p><h1 id="8-条款-48总是include-正确的头文件"><a class="markdownIt-Anchor" href="#8-条款-48总是include-正确的头文件"></a> 8 条款 48：总是#include 正确的头文件</h1><p>几乎所有的标准 STL 容器都被声明在与之同名的头文件中，</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">比如 <br>vector 被声明在&lt;vector&gt;中，<br>list 被声明在&lt;list&gt;中，等等。<br><br>但是&lt;set&gt;和＜map＞是个例外，<br>    &lt;set＞中声明了 set 和 multiset，<br>    ＜map&gt;中声明了 map 和 multimap。<br></code></pre></td></tr></tbody></table></figure><p>除了 4 个 STL 算法以外，其他所有的算法都被声明在＜algorithm&gt;中，<br>这 4 个算法是</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">accumulate（参见第 <span class="hljs-number">37</span> 条）、<br>inner_product.adjacent <br>difference<br>partialsum，<br>    它们被声明在头文件&lt;numeric&gt;中。<br></code></pre></td></tr></tbody></table></figure><p>特殊类型的迭代器，包括 istream iterator 和 istreambuf_iterator （见第 29 条），被声明在 <code>&lt;iterator&gt;</code> 中。</p><p>标准的函数子 (比如 <code>less&lt;T&gt;</code>) 和西数子配接器（比如 not、bind）被声明在头文件 <code>&lt;functional&gt;</code> 中。</p><h1 id="9-条款-49学会分析-stl-相关编译器的诊断信息"><a class="markdownIt-Anchor" href="#9-条款-49学会分析-stl-相关编译器的诊断信息"></a> 9 条款 49：学会分析 STL 相关编译器的诊断信息</h1><ul><li>如果你看见 basic-string，可以把他换成 string</li><li>对于 std：：xxx 这种类型为 st/内部模板，可以统一的把&lt;&gt;里面的内容替换为 something</li><li>如果你错误的使用了iterator，那么编译器诊断类型中往往包括指针类型</li><li>如果诊断信息中提到了back-insert/front-insert/insert iterator，那么你一定是错误的调用了他们</li><li>如果诊断信息中提到了bind，那么就是错误的调用了它</li><li>输出迭代器以及由哪些inserter函数返回的迭代器在使用的时候犯了错误，那么就是可以看到与赋值操作符有关的错误内容</li><li>如果错误消息来自于某一个 STL 算法的实现，那么大概率就是在调用算法的时候使用了错误的类型</li></ul><h1 id="10-条款-50熟悉与-stl-相关的-web-站点"><a class="markdownIt-Anchor" href="#10-条款-50熟悉与-stl-相关的-web-站点"></a> 10 条款 50：熟悉与 STL 相关的 web 站点</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>31：了解各种与排序有关的选择</title>
    <link href="/posts/49127/"/>
    <url>/posts/49127/</url>
    
    <content type="html"><![CDATA[<p>📝31：了解各种与排序有关的选择::</p><!-- basicblock-end --><h1 id="1-种类"><a class="markdownIt-Anchor" href="#1-种类"></a> 1:  种类</h1><h2 id="11-知识点-1sort-算法和-listsort"><a class="markdownIt-Anchor" href="#11-知识点-1sort-算法和-listsort"></a> 1.1:  知识点 1：Sort 算法和 list::sort</h2><p>sort 算法安照一定要求对元素进行排序，要求排序的类满足<strong>严格弱序列</strong><br>list:: sort 是一个稳定的算法（相当于链表版 stable-sort)</p><h2 id="12-知识点-2partial-一-sort-算法"><a class="markdownIt-Anchor" href="#12-知识点-2partial-一-sort-算法"></a> 1.2:  知识点 2：partial 一 sort 算法</h2><p>这是一个对部分元素进行排序的功能，将所有元素中最符合要求的部分按照排序放在最前面</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051545038.png" alt=""></p><h2 id="13-知识点-3nth-element-算法"><a class="markdownIt-Anchor" href="#13-知识点-3nth-element-算法"></a> 1.3:  知识点 3：nth-element 算法</h2><p>它可以对部分的元素进行排列，把符合要求的元素放在前面，但是不进行排序<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051546133.png" alt=""></p><p>它也可以用来找一个区间的中间值，或者某个特定百分比的值</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051546414.png" alt=""></p><h2 id="14-知识点-4-partition-算法"><a class="markdownIt-Anchor" href="#14-知识点-4-partition-算法"></a> 1.4:  知识点 4: partition 算法</h2><p>它可以简单的进行交换，将好的放在起始迭代器和自义迭代器中间，不好的放在自定义迭代器和结束迭代器之间</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051548866.png" alt=""></p><p>与 sort. stable_ sort、partial_ sort 和 nth_element 不同的是，partition 和 stable_partition 只要求双向迭代器就能完成工作。所以，对于所有的标准序列容器，你都可以使用 partition 或者 stable_partition。</p><h2 id="15-知识点-5-stable-类算法"><a class="markdownIt-Anchor" href="#15-知识点-5-stable-类算法"></a> 1.5:  知识点 5: stable 类算法</h2><p>可以有 stable 形式的算法有: sort,partition 等<br>stable 算法和非 stable 算法的主要区别是, 对于两个相同的变量, 可以保证他们的相对位置不改变, 但是非 stable 算法就不一定了</p><h1 id="2-知识点-6-算法选择"><a class="markdownIt-Anchor" href="#2-知识点-6-算法选择"></a> 2:  知识点 6: 算法选择</h1><p>如果需要对 vector、string、deque 或者数组中的元素执行一次完全排序, 那么可以使用 sort 或者 stable_sort。</p><p>如果有一个 vector、string、deque 或者数组, 并且只需要对等价性最前面的 n 个元素进行排序, 那么可以使用 partial_sort。</p><p>如果有一个 vector、string、deque 或者数组, 并且需要找到第 n 个位置上的元素, 或者, 需要找到等价性最前面的 n 个元素但又不必对这 n 个元素进行排序, 那么,nth_element 正是你所需要的函数。</p><p>如果需要将一个标准序列容器中的元素按照是否满足某个特定的条件区分开来, 那么,partition 和 stable_partition 可能正是你所需要的。</p><p>如果你的数据在一个 list 中, 那么你仍然可以直接调用 partition,stable_partition 算法; 可以用 list:: sort 来替代 sort 和 stable_sort 算法。但是, 如果你需要获得 partial_sort 或 nth_element 算法的效果, 那么, 正如前面我所提到的那样, 你可以有一些间接的途径来完成这项任务。</p><p>除此以外,你可以通过使用标准的关联容器来保证容器中的元素始终保持特定的顺序,也可以考虑使用标准的非STL容器priority_queue,它总是保持其元素的顺序关系</p><h1 id="3-知识点-7-算法时间长短"><a class="markdownIt-Anchor" href="#3-知识点-7-算法时间长短"></a> 3:  知识点 7: 算法时间长短</h1><p>首先, 算法的选择更多的应该基于你需要完成的功能, 而不是算法的性能, 最好使用能恰好完成你的功能的算法<br>1.partition<br>2.stable_partition<br>3.nth_element<br>4.partial_sort<br>5.sort<br>6.stable_sort</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>31-40</title>
    <link href="/posts/9613/"/>
    <url>/posts/9613/</url>
    
    <content type="html"><![CDATA[<p>📝31-40::</p><!-- basicblock-end --><h1 id="1-条款-31了解各种与排序有关的选择"><a class="markdownIt-Anchor" href="#1-条款-31了解各种与排序有关的选择"></a> 1 条款 [[31：了解各种与排序有关的选择]]</h1><h1 id="2-条款-32-如果确实需要删除元素-需要在-remove-这一类算法之后调用-erase"><a class="markdownIt-Anchor" href="#2-条款-32-如果确实需要删除元素-需要在-remove-这一类算法之后调用-erase"></a> 2 条款 32: 如果确实需要删除元素, 需要在 remove 这一类算法之后调用 erase</h1><h2 id="21-知识点-1-对于绝大部分容器-remove-不是真正意义上的删除-他做不到"><a class="markdownIt-Anchor" href="#21-知识点-1-对于绝大部分容器-remove-不是真正意义上的删除-他做不到"></a> 2.1 知识点 1: 对于绝大部分容器 remove 不是真正意义上的删除, 他做不到</h2><p>remove不是真正意义上的删除,他做不到,虽然他确实移除了元素,但是容器的大小是没有改变的。<br>如果按照我们希望的, 在删除的时候改变容器的大小, 需要配合着 erase 一起调用<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051552585.png" alt=""></p><h2 id="22-知识点-2list-remove-是真正意义上的删除"><a class="markdownIt-Anchor" href="#22-知识点-2list-remove-是真正意义上的删除"></a> 2.2 知识点 2:list:: remove 是真正意义上的删除</h2><p>list 的 remove 是一个名为 remove 且确实删除了容器中元素的函数, 他也更高效</p><h1 id="3-条款-33-对包含指针的容器使用-remove-这一类算法时候要特别小心"><a class="markdownIt-Anchor" href="#3-条款-33-对包含指针的容器使用-remove-这一类算法时候要特别小心"></a> 3 条款 33: 对包含指针的容器使用 remove 这一类算法时候要特别小心</h1><h2 id="31-知识点-1-remove-算法对于指针使用可能会导致资源泄露"><a class="markdownIt-Anchor" href="#31-知识点-1-remove-算法对于指针使用可能会导致资源泄露"></a> 3.1 知识点 1: remove 算法对于指针使用可能会导致资源泄露</h2><p>对于一个储存了容器的指针来讲,remove 算法 remove 是容器里面指针本身, 而不是指针指向的资源, 如果直接调用 remove 就会导致资源泄露<br>解决的方法是使用 share-ptr,share-ptr 会正常的释放资源, 保证不泄露</p><h1 id="4-条款-34-了解那些算法要求使用排序区间作为参数"><a class="markdownIt-Anchor" href="#4-条款-34-了解那些算法要求使用排序区间作为参数"></a> 4 条款 34: 了解那些算法要求使用排序区间作为参数</h1><h2 id="41-知识点-1-需要排序区间的算法"><a class="markdownIt-Anchor" href="#41-知识点-1-需要排序区间的算法"></a> 4.1 知识点 1: 需要排序区间的算法</h2><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051555352.png" alt=""></p><p>所谓需要排序区间的算法, 就是指的需要进行操作的区间对应必须是有序的 (有 operator&lt;) 的, 并且有排序标准, 否则效率大大降低</p><p>所有的算法一般需要随机访问迭代器, 如果是低级的迭代器可能效率大大降低或者无法运行</p><pre><code class="hljs">注: unique 和 unique-copy 的操作和 remove 差不多, 所以如果用来排序指针需要谨慎小心</code></pre><h1 id="5-条款-35-通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较"><a class="markdownIt-Anchor" href="#5-条款-35-通过-mismatch-或-lexicographical-compare-实现简单的忽略大小写的字符串比较"></a> 5 条款 35: 通过 mismatch 或 lexicographical-compare 实现简单的忽略大小写的字符串比较</h1><p>对于实现字符串的比较, 有两种常见的实现方式</p><p>知识点 1: mismatch<br>mismatch算法接受两个迭代器, 然后返回第一个字符不相同的位置</p><p>知识点 2: lexicographical-compare<br>这个算法是一个缩写版本stl算法,他可以与任何类型的值的区间一起工作</p><h1 id="6-条款-36-理解-copy-if-算法的实现"><a class="markdownIt-Anchor" href="#6-条款-36-理解-copy-if-算法的实现"></a> 6 条款 36: 理解 copy-if 算法的实现</h1><p>在C++11中,copy-if算法在algorithm库里可以找到了</p><h1 id="7-条款-37-使用-accumulate-或者-for-each-进行区间统计"><a class="markdownIt-Anchor" href="#7-条款-37-使用-accumulate-或者-for-each-进行区间统计"></a> 7 条款 37: 使用 accumulate 或者 for-each 进行区间统计</h1><h2 id="71-知识点-1-accumulate-的使用"><a class="markdownIt-Anchor" href="#71-知识点-1-accumulate-的使用"></a> 7.1 知识点 1: accumulate 的使用</h2><p>accumulate定义在numeric中,它可以用来计算两个区间中的和</p><p>![[accumulate的使用.excalidraw]]</p><h2 id="72-知识点-2for-each-的使用"><a class="markdownIt-Anchor" href="#72-知识点-2for-each-的使用"></a> 7.2 知识点 2：for-each 的使用</h2><p>foreach 也带两个参数：一个是区间，另一个是函数（通常是函数对象）一一对区间中的每个元素都要调用这个函数，但是，传给 for_each 的这个函数只接收一个实参（即当前的区间元素）；for_each 执行完毕后会返回它的函数（实际上，它返回的是这个函数的一份拷贝，<br>![[for-each. excalidraw]]</p><h1 id="8-条款-38遵循按值传递的原则来设计函数子类"><a class="markdownIt-Anchor" href="#8-条款-38遵循按值传递的原则来设计函数子类"></a> 8 条款 38：遵循按值传递的原则来设计函数子类</h1><h2 id="81-知识点-1传递函数子"><a class="markdownIt-Anchor" href="#81-知识点-1传递函数子"></a> 8.1 知识点 1：传递函数子</h2><p>无论是 C 还是 C++，都不允许将一个函数作为参数传递给另一个函数，当然也大概率不会把一个函数的引用传递给其他函数，我们一般都是使用函数的指针去传递</p><p>为了能让函数对象很大或者大概率的保留多态性，也能按照按值传递的习惯，我们也就可以将所需的数据和虛函数从函数子类中分离出来，放到一个新的类中；<br>然后在函数子类中包含一个指针，指向这个新类的对象。例如，如果你希望创建一个包含大量数据井且使用了多态性的函数<br>‌‌‌　　![[31-40 2022-11-05 16.07.46.excalidraw]]</p><h1 id="9-条款-39-确保判别式是纯函数"><a class="markdownIt-Anchor" href="#9-条款-39-确保判别式是纯函数"></a> 9 条款 39: 确保判别式是纯函数</h1><h2 id="91-知识点-1-理解题目对应的定义"><a class="markdownIt-Anchor" href="#91-知识点-1-理解题目对应的定义"></a> 9.1 知识点 1: 理解题目对应的定义</h2><ul><li>判别式: 一个判别式是一个返回值为 bool 类型的/可以隐式转换为 bool 类型的函数。</li><li>纯函数: 一个纯函数是指返回值仅仅依赖其参数的函数, 只有当函数值发生变化的时候, 对应的返回值参能发生变化<ul><li>对于纯函数, 其参数必须是 const, 对应的函数也需要是 const 的</li></ul></li><li>判别式类: 判别式类是一个函数子类, 他的 operator () 函数是一个判别式,STL 能接受判别式的地方, 也能接收判别式类</li></ul><h1 id="条款-40-若一个类是函数子-则应使它可配接-c11-已经废弃-条款"><a class="markdownIt-Anchor" href="#条款-40-若一个类是函数子-则应使它可配接-c11-已经废弃-条款"></a> 条款 40: 若一个类是函数子, 则应使它可配接 (C++11 已经废弃) 条款</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21-30</title>
    <link href="/posts/54710/"/>
    <url>/posts/54710/</url>
    
    <content type="html"><![CDATA[<p>📝21-30::</p><!-- basicblock-end --><h1 id="1-条款-21总是让比较函数在等值情况下返回-false"><a class="markdownIt-Anchor" href="#1-条款-21总是让比较函数在等值情况下返回-false"></a> 1 条款 21：总是让比较函数在等值情况下返回 false</h1><h2 id="11-知识点1严格的弱序化"><a class="markdownIt-Anchor" href="#11-知识点1严格的弱序化"></a> 1.1 知识点1：严格的弱序化</h2><p>在关联容器中，我们需要一个严格的弱序化的比较，<br>即我们应该主动用＜或&gt;<strong>而不是</strong>＜=或＞=<br>如果使用＜=或＞=我们就会破坏关联容器，<br>包括其对应可使用的算法也一样会失效</p><h1 id="2-条款-22切勿直接修改-set-或-multiset-中的键"><a class="markdownIt-Anchor" href="#2-条款-22切勿直接修改-set-或-multiset-中的键"></a> 2 条款 22：切勿直接修改 set 或 multiset 中的键</h1><h2 id="21-知识点1对于map和mutimap"><a class="markdownIt-Anchor" href="#21-知识点1对于map和mutimap"></a> 2.1 知识点1：对于map和mutimap</h2><p>对于 <code>map</code> 和 <code>mutimap</code>，这两个的元素类型是 <code>pair&lt;const K,V&gt;</code>所以他们的键是不可以修改的</p><h2 id="22-知识点2对于set和mutiset"><a class="markdownIt-Anchor" href="#22-知识点2对于set和mutiset"></a> 2.2 知识点2：对于set和mutiset</h2><ul><li>对于 set 和 mutiset，这两个键对于某些 STL 标准是可以被修改的，会导致代码不通用, 也就意味着代码可能具有不可移植性，</li><li>所以如果要有可移植性可以考虑这样两种方法<ul><li>使用 const-cast (而不是 static-cast，其转换的为副本）做一次去除 const 的类型转换，然后修改 key</li><li>擦去再添加方法：<ul><li>找到合适的元素</li><li>对元素做一份拷贝</li><li>修改该拷贝</li><li>删除该元素</li><li>重新插入元素</li></ul></li></ul></li></ul><h1 id="3-条款-23考虑用排序的-vector-替代关联容器"><a class="markdownIt-Anchor" href="#3-条款-23考虑用排序的-vector-替代关联容器"></a> 3 条款 23：考虑用排序的 vector 替代关联容器</h1><h2 id="31-知识点1程序使用数据结构的三个阶段"><a class="markdownIt-Anchor" href="#31-知识点1程序使用数据结构的三个阶段"></a> 3.1 知识点1：程序使用数据结构的三个阶段</h2><ul><li>设置阶段：创建一个新的数据结构，插入大量元素，基本都是删除或者插入操作</li><li>查找阶段：查询该数据结构以找到特定的信息，这个阶段基本都是查找操作，没有或很少有插入或者删除操作</li><li>重组阶段：改变该数据结构的内容，或许是删除所有的当前数据，再插入新的数据</li></ul><h2 id="32-知识点2什么时候考虑用排序的vector代替关联容器"><a class="markdownIt-Anchor" href="#32-知识点2什么时候考虑用排序的vector代替关联容器"></a> 3.2 知识点2：什么时候考虑用排序的vector代替关联容器</h2><p>查找操作几乎从不跟插入和删除操作混在一起的时候，在考虑使用排序vector</p><h1 id="4-条款-24当效率至关重要的时候请在-map-operator-与-map-insert-之间做出选择"><a class="markdownIt-Anchor" href="#4-条款-24当效率至关重要的时候请在-map-operator-与-map-insert-之间做出选择"></a> 4 条款 24：当效率至关重要的时候，请在 map： ： operator 【】 与 map： insert 之间做出选择</h1><p>对于 map，当你在插入一个数据的时候，选择 insert，因为这样的话可以减少一个临时对象的构造节约时间</p><p>对于map，当你在更新一个数据的时候，选择opeartor【】，因为这样可以直接修改数据，减少查找所消耗的时间</p><h1 id="5-条款-25熟悉非标准的散列容器"><a class="markdownIt-Anchor" href="#5-条款-25熟悉非标准的散列容器"></a> 5 条款 25：熟悉非标准的散列容器</h1><p>注：C++11中已经提供了unorder系列作为替代，其实现和原先的hash基本一致<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211042203534.png" alt="|500"></p><h1 id="6-没有条款-26-啊-阿鹿没写"><a class="markdownIt-Anchor" href="#6-没有条款-26-啊-阿鹿没写"></a> 6 没有条款 26 啊,  阿鹿没写</h1><h1 id="7-条款-27使用-distance-和-advance-将容器的-const-iterator-转换为-iterator"><a class="markdownIt-Anchor" href="#7-条款-27使用-distance-和-advance-将容器的-const-iterator-转换为-iterator"></a> 7 条款 27：使用 distance 和 advance 将容器的 const-iterator 转换为 iterator</h1><blockquote><p>[!question] : : #疑问<br>![[21- 2022-11-04 22.05.37.excalidraw]]</p></blockquote><h1 id="8-条款-28正确理解由-reverse-iterator-的-base-成员函数所产生的-iterator-的用法"><a class="markdownIt-Anchor" href="#8-条款-28正确理解由-reverse-iterator-的-base-成员函数所产生的-iterator-的用法"></a> 8 条款 28：正确理解由 reverse-iterator 的 base ()成员函数所产生的 iterator 的用法</h1><h2 id="81-知识点1reverse-iterator的base函数获得的迭代器的位置关系"><a class="markdownIt-Anchor" href="#81-知识点1reverse-iterator的base函数获得的迭代器的位置关系"></a> 8.1 知识点1:reverse-iterator的base函数获得的迭代器的位置关系</h2><p>存在向右偏移一格的距离</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051536267.png" alt="|600"></p><p>知识点 2：insert 操作<br>如果要在一个 reverse-iterator ri 指定位置进行插入新的元素，那么只需要在 ri.base ()= i 位置处直接插入，对于插入而言是等价的</p><p>知识点 3：erase 操作</p><p>如果要在 reverse-iterator ri 指定一个位置删除要给元素，那么就是需要在+＋ri 后在进行 base 转换最后删除<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051541622.png" alt=""></p><h1 id="9-条款-29对于逐个字符的输入请考虑使用-istreambuf-iterator"><a class="markdownIt-Anchor" href="#9-条款-29对于逐个字符的输入请考虑使用-istreambuf-iterator"></a> 9 条款 29：对于逐个字符的输入请考虑使用 istreambuf-iterator</h1><h2 id="91-知识点-1为什么不使用-istream-iterator"><a class="markdownIt-Anchor" href="#91-知识点-1为什么不使用-istream-iterator"></a> 9.1 知识点 1：为什么不使用 istream-iterator?</h2><p>![[为什么不使用istream-iterator?.excalidraw]]</p><h1 id="10-条款-30确定目标区间足够大"><a class="markdownIt-Anchor" href="#10-条款-30确定目标区间足够大"></a> 10 条款 30：确定目标区间足够大</h1><h2 id="101-知识点1必须在目标区间內有足够大的已经实例化的空对象来存放数值"><a class="markdownIt-Anchor" href="#101-知识点1必须在目标区间內有足够大的已经实例化的空对象来存放数值"></a> 10.1 知识点1：必须在目标区间內有足够大的，已经“实例化”的“空对象"来存放数值</h2><p>无论如何，如果使用的算法需要指定一个目标区间，那么必须确保这个目标区间足够大，或者随着算法的运行而增大。<br>要在算法执行的过程中增大目标区间，需要使用插入型迭代器。inserter 等</p><p>情景1：使用transform算法移动元素，这个算法必须保证result容器是有己经分配的空间，否则就会出错</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211051542518.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>string</title>
    <link href="/posts/58910/"/>
    <url>/posts/58910/</url>
    
    <content type="html"><![CDATA[<p>📝string::</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12-20</title>
    <link href="/posts/503/"/>
    <url>/posts/503/</url>
    
    <content type="html"><![CDATA[<p>📝12-20::</p><!-- basicblock-end --><h1 id="1-条款-12切勿对-stl-容器的线程安全性有不切实际的依赖"><a class="markdownIt-Anchor" href="#1-条款-12切勿对-stl-容器的线程安全性有不切实际的依赖"></a> 1 条款 12：切勿对 STL 容器的线程安全性有不切实际的依赖</h1><p>为了速度 STL 不支持完整的线程安全性</p><h2 id="11-知识点-1stl-的线程安全的要求"><a class="markdownIt-Anchor" href="#11-知识点-1stl-的线程安全的要求"></a> 1.1 知识点 1：STL 的线程安全的要求</h2><p>对于一个STL多个线程的读是安全的<br>对于一个 STL多个线程对不同容器做写入操作是安全的</p><h2 id="12-知识点-2实现-stl-线程安全的可能行为"><a class="markdownIt-Anchor" href="#12-知识点-2实现-stl-线程安全的可能行为"></a> 1.2 知识点 2：实现 STL 线程安全的可能行为</h2><p>![[实现 STL 线程安全.excalidraw]]</p><h1 id="2-条款-13vector-和-string-优先于动态分配的数组"><a class="markdownIt-Anchor" href="#2-条款-13vector-和-string-优先于动态分配的数组"></a> 2 条款 13：vector 和 string 优先于动态分配的数组</h1><h2 id="21-知识点-1当你使用-new-进行内存分配的时候必须承担的责任"><a class="markdownIt-Anchor" href="#21-知识点-1当你使用-new-进行内存分配的时候必须承担的责任"></a> 2.1 知识点 1：当你使用 new 进行内存分配的时候必须承担的责任：</h2><ul><li>确保以后会有人用 delete 来删除所有分配的内存如果没有后面的 delete那么你的 new 将会导致一个资源泄露</li><li>确保使用正确的 delete 形式对于一个使用 delete对于多个使用 delete[]</li><li>确保只能 delete 一次</li></ul><h2 id="22-知识点-2代替数组"><a class="markdownIt-Anchor" href="#22-知识点-2代替数组"></a> 2.2 知识点 2：代替数组</h2><p>一般就是用 vector 代替常见数组<br>如果你的 string 是引用计数的那么可以考虑使用 <code>vector&lt;char&gt;</code>代替 string因为 vector 不允许引用计数</p><blockquote><p>[!question]<br>什么是引用计数::   #疑问</p></blockquote><h1 id="3-条款-14使用-reserve-来避免不必要的重新分配"><a class="markdownIt-Anchor" href="#3-条款-14使用-reserve-来避免不必要的重新分配"></a> 3 条款 14：使用 reserve 来避免不必要的重新分配</h1><h2 id="31-知识点1vector和string自动加大的原理和作用"><a class="markdownIt-Anchor" href="#31-知识点1vector和string自动加大的原理和作用"></a> 3.1 知识点1：vector和string自动加大的原理和作用</h2><p>[[vector (🗃)#2 原理 (扩容过程)]]</p><h2 id="32-知识点-2明确-vector-和-string-都提供以下几个函数"><a class="markdownIt-Anchor" href="#32-知识点-2明确-vector-和-string-都提供以下几个函数"></a> 3.2 知识点 2：明确 vector 和 string 都提供以下几个函数</h2><p>[[vector API]]</p><h2 id="33-知识点-3如何避免-vector-string-被频繁重复的分配"><a class="markdownIt-Anchor" href="#33-知识点-3如何避免-vector-string-被频繁重复的分配"></a> 3.3 知识点 3：如何避免 vector， string 被频繁重复的分配</h2><p>尽可能不要一个一个 insert 进去，那样会导致 vector 被频繁的重新分配内存</p><p>在已知大小的情况下，调用 reserve () 重新提前分配好</p><p>先预留足够大的空间，然后加入数据，加入完成后去除多余容量，<strong>方法见 17 条</strong></p><h1 id="4-条款-15注意-string-实现的多样性"><a class="markdownIt-Anchor" href="#4-条款-15注意-string-实现的多样性"></a> 4 条款 15：注意 string 实现的多样性</h1><p>前言：在 STL 标准库中，string 的大小是多样性的，如果使用 sizeof (string）他的结果可能和指针一样为 <code>1</code>，或者是 <code>7</code>，这和 STL 的实现有关系</p><h2 id="41-知识点1string的基本特征"><a class="markdownIt-Anchor" href="#41-知识点1string的基本特征"></a> 4.1 知识点1：[[string]]的基本特征</h2><p>每个 string 都包括以下信息<br>size，包含字符的个数<br>capacity, string 的容量<br>value, string 的值<br>可能还包含<br>string 分配子的一份拷贝<br>string 对值的引用计数 (这个只是在建立在引用计数基础上的 string 才有的）</p><h2 id="42-知识点2string的重要特性"><a class="markdownIt-Anchor" href="#42-知识点2string的重要特性"></a> 4.2 知识点2：string的重要特性</h2><p>string 的值可能会被引用计数，也可能不会，如果一旦引用，那么他的值的大小会扩大。</p><p>sizeof (string) 的大小可以是 sizeof (char*）的 1 到 7 倍</p><p>创建一个新的字符串值可能需要 0 次，1 次，或两次的动态分配内存</p><p>string 可能支持，也可能不支持针对单个对象的分配子</p><p>不同的实现对字符内存的最小分配单位有着不同的策略</p><h1 id="5-条款-16了解如何把-vector-和-string-数据传递给旧的-api"><a class="markdownIt-Anchor" href="#5-条款-16了解如何把-vector-和-string-数据传递给旧的-api"></a> 5 条款 16：了解如何把 vector 和 string 数据传递给旧的 API</h1><h1 id="6-条款-17使用-swap-技巧去除多余的变量"><a class="markdownIt-Anchor" href="#6-条款-17使用-swap-技巧去除多余的变量"></a> 6 条款 17：使用 swap 技巧去除多余的变量</h1><p>备注：虽然 C++11 中的 vector 有 shrink-to-fit 成员函数，但是呢这个函数只是一个请求，随着 STL 实现的方式不同，使用后 capicity 可能还是大于 size，swap 则是一种相对强硬的手段，用来去除多余的容量，但是也有可能失败</p><h2 id="61-知识点1使用swap去除多余的容量"><a class="markdownIt-Anchor" href="#61-知识点1使用swap去除多余的容量"></a> 6.1 知识点1：使用swap去除多余的容量</h2><blockquote><p>[!question]<br>![[swap 技巧去除多余的变量.excalidraw]]::   #疑问</p></blockquote><h1 id="7-条款-18避免使用-vectorbool"><a class="markdownIt-Anchor" href="#7-条款-18避免使用-vectorbool"></a> 7 条款 18：避免使用 <code>vector&lt;bool&gt;</code></h1><p>作为一个 STL 容器，<code>vector&lt;bool&gt;</code> 只有两点不对：<br>他不是一个 STL 容器，<br>其次他不能储存 bool</p><p>如果需要使用类似的结构，使用 <code>deque&lt;bool＞</code>或者 <code>bitset</code> 是更好的选择</p><h1 id="8-条款-19理解相等和等价之间的区别"><a class="markdownIt-Anchor" href="#8-条款-19理解相等和等价之间的区别"></a> 8 条款 19：理解相等和等价之间的区别</h1><h2 id="81-知识点1相等与等价的字面区别"><a class="markdownIt-Anchor" href="#81-知识点1相等与等价的字面区别"></a> 8.1 知识点1：相等与等价的字面区别</h2><p>相等，一般是调用 <code>operator == 判断</code>，代表两者完全相同，<br>等价，在一定的规则下，两者所内涵的区别可以忽略不计，代表等价，一般都会采用 operator&lt;去组织 (💡确实是这样写的)</p><h2 id="82-知识点2相等和等价使用时候的区别"><a class="markdownIt-Anchor" href="#82-知识点2相等和等价使用时候的区别"></a> 8.2 知识点2：相等和等价使用时候的区别</h2><p>比较典型的例子就是 find 和关联容器的 find，<br>对于泛型算法的 find，一般都是以相等去组织，<br>但是关联容器的 find 可能会用等价去组织，</p><p>‌‌‌　　因此对于这种情况下，一般使用成员函数会更好，否则可能导致查找失败致查找失败致查找失败致查找失败致查找失败</p><h1 id="9-条款-20为包含指针的关联容器指定比较类型"><a class="markdownIt-Anchor" href="#9-条款-20为包含指针的关联容器指定比较类型"></a> 9 条款 20：为包含指针的关联容器指定比较类型</h1><h2 id="91-知识点-1明确关联容器里的内容"><a class="markdownIt-Anchor" href="#91-知识点-1明确关联容器里的内容"></a> 9.1 知识点 1：明确关联容器＜＞里的内容</h2><h2 id="92-知识点2保存在指针里面的关联容器"><a class="markdownIt-Anchor" href="#92-知识点2保存在指针里面的关联容器"></a> 9.2 知识点2：保存在指针里面的关联容器</h2><blockquote><p>[!question]<br>![[条款20：为包含指针的关联容器指定比较类型.excalidraw]]::   #疑问</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最左前缀法则</title>
    <link href="/posts/17528/"/>
    <url>/posts/17528/</url>
    
    <content type="html"><![CDATA[<p>📝最左前缀法则::</p><!-- basicblock-end --><h1 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h1><blockquote><p>[!example] 案例</p><p>场景：当单独为一个不频繁的请求创建索引时，会造成空间浪费；但是，如果直接让它走全表查询 (一个一个找)，那效率也太低了吧？此时，应该怎么做？</p></blockquote><p>答：B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</p><h1 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h1><p>‌‌‌</p><h2 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1 ‌‌‌</h2><blockquote><p>[!question]<br>![[最左前缀法则 2022-11-07 17.41.36.excalidraw]]::   #疑问</p></blockquote><blockquote><p>[!tip] Note：<br>考虑到“最左前缀原则”，可以通过调整组合索引中的字段顺序，可以少维护一个索<br>引</p></blockquote><p>那些不符合最左前缀的部分, 会怎么样呢?<br>比如, 执行如下语句时候, 则存在不符合最左前缀的部分怎么办</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from tuser<br>where name like '张 %'<br>and age=10<br>and ismale=1;<br></code></pre></td></tr></tbody></table></figure><p>使用:  [[索引下推]]</p><h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h2><p>主要针对联合索引<br>如果索引关联了多列（联合索引），要遵守最左前缀法则，</p><blockquote><p>[!summary]<br>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p></blockquote><p>‌‌‌‌ ![[最左前缀法则.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>explain</title>
    <link href="/posts/34718/"/>
    <url>/posts/34718/</url>
    
    <content type="html"><![CDATA[<p>📝explain::</p><!-- basicblock-end --><h1 id="1-语法"><a class="markdownIt-Anchor" href="#1-语法"></a> 1 语法</h1><blockquote><p>[!summary] 它最重要</p></blockquote><p><strong>explain</strong> 或者 desc 命令获取 :</p><ul><li>mysql 如何执行 select 语句的信息,</li><li>是否用到索引</li><li>select 语句执行过程中表如何连接</li><li>以及连接的顺序。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- 直接在select语句之前加上关键字 explain / desc <br>explain   select   字段列表   from   表名   where  条件<br><br></code></pre></td></tr></tbody></table></figure><p>![[explain 语法.excalidraw]]</p><h1 id="2-explain-案例"><a class="markdownIt-Anchor" href="#2-explain-案例"></a> 2 explain 案例</h1><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id 相同，执行顺序从上到下；id 不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</li><li>tip type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>tip possible_key：可能应用在这张表上的索引，一个或多个</li><li>tip Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>tip Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><p>![[explain 案例.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL 性能分析</title>
    <link href="/posts/37527/"/>
    <url>/posts/37527/</url>
    
    <content type="html"><![CDATA[<p>📝SQL 性能分析::</p><!-- basicblock-end --><p>主要优化索引</p><h1 id="1-sql-执行频率"><a class="markdownIt-Anchor" href="#1-sql-执行频率"></a> 1 SQL 执行频率</h1><p>MySQL 客户端连接成功后, 通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令, 可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>-- session 是查看当前会话 ; -- global 是查询全局数据 ; <br>show  global status like  'com_______'; <br># like: 模糊匹配<br># com 后边是下划线: 一个下划线代表一个字符<br><br><br></code></pre></td></tr></tbody></table></figure><p>![[SQL 执行频率.excalidraw]]</p><p>通过上述指令, 我们可以查看到当前数据库到底是以查询为主, 还是以增删改为主, 从而为数据库优化提供参考依据。如果是以增删改为主, 我们可以考虑不对其进行索引的优化。如果是以查询为主, 那么就要考虑对数据库的索引进行优化了。</p><p>那么通过查询 SQL 的执行频次, 我们就能够知道当前数据库到底是增删改为主, 还是查询为主。<br>那假如说是以查询为主,<strong>我们又该如何定位针对于那些查询语句进行优化呢</strong>? 次数我们可以借助于慢查询日志。<br>接下来,我们就来介绍一下MySQL中的慢查询日志。</p><h1 id="2-慢查询"><a class="markdownIt-Anchor" href="#2-慢查询"></a> 2 慢查询</h1><p>慢查询日志记录了所有执行时间超过指定参数 (long_query_time, 单位: 秒, 默认 10 秒) 的所有 SQL 语句的日志。<br>MySQL 的慢查询日志默认没有开启, 我们可以查看一下系统变量 slow_query_log。</p><p>![[慢查询日志.excalidraw]]</p><h1 id="3-profile-详情"><a class="markdownIt-Anchor" href="#3-profile-详情"></a> 3 profile 详情</h1><p>比如慢查询到 2s 之后才能查询出来, 如果有一些简单的语句达到了 1.9s, 这种就没办法用慢查询. 要用 profile</p><p>‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　‌‌‌　　![[profile 详情.excalidraw]]</p><h1 id="4-explain"><a class="markdownIt-Anchor" href="#4-explain"></a> 4 [[explain]]</h1><ul><li>cite 最重要</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>07. 重建二叉树</title>
    <link href="/posts/17164/"/>
    <url>/posts/17164/</url>
    
    <content type="html"><![CDATA[<p>📝07. 重建二叉树:: 注意一个下标值需要+1<br><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树 - 力扣（LeetCode）</a></p><!-- basicblock-end --><p>[[18. 从中序与后序遍历序列构造二叉树|18. 从中序与后序遍历序列构造二叉树]]</p><p>![[07. 重建二叉树 2022-11-07 09.45.51.excalidraw]]</p><p>通过: 重点看递归方面的参数设置</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> prel, <span class="hljs-type">int</span> prer, <span class="hljs-type">int</span> inl, <span class="hljs-type">int</span> inr)</span> </span>{<br>        <span class="hljs-keyword">if</span>(prel &gt; prer) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 判断范围是否可行</span><br><br>        <span class="hljs-comment">// 找根节点</span><br>        <span class="hljs-type">int</span> rootVal = preorder[prel];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br>        <span class="hljs-comment">// 通过根节点找中序的左子树, 右子树</span><br>        <span class="hljs-type">int</span> i = inl;<br>        <span class="hljs-keyword">for</span>(; i &lt; inorder.<span class="hljs-built_in">size</span>() ;i++){ <span class="hljs-comment">// ❗️从 inl 开始找根节点, 而不是从下标 0; </span><br>            <span class="hljs-keyword">if</span>(inorder[i] == rootVal) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-type">int</span> count = i - inl;<br>        root-&gt;left = <span class="hljs-built_in">buildTree</span>(preorder, inorder, prel+<span class="hljs-number">1</span>, prel+count, inl, inl + count <span class="hljs-number">-1</span>);  <span class="hljs-comment">// ❗️inl + count - 1: 要减 1 哦</span><br>        root-&gt;right = <span class="hljs-built_in">buildTree</span>(preorder, inorder, prel+count+<span class="hljs-number">1</span>, prer, inl + count + <span class="hljs-number">1</span>, inr);<span class="hljs-comment">// ❗️inl + count + 1: 要加 1 哦</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br><br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>{<br>        <span class="hljs-type">int</span> r = inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// prer 与 inr 都是一样的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(preorder, inorder, <span class="hljs-number">0</span>, r, <span class="hljs-number">0</span>, r);<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector API</title>
    <link href="/posts/10899/"/>
    <url>/posts/10899/</url>
    
    <content type="html"><![CDATA[<p>📝vector API::</p><!-- basicblock-end --><h1 id="1-初始化"><a class="markdownIt-Anchor" href="#1-初始化"></a> 1: 初始化</h1><p><strong>一维数组的初始化</strong><br>vector的长度不能是变量,必须是常量</p><ol><li><code>vector&lt;int&gt; a(10)</code>; 默认是0</li><li><code>vector&lt;int&gt; a(10,1)</code>;(10个变量每个为1)</li><li><code>vector&lt;int&gt; a(b)</code>; //用b向量来创建a向量，整体复制性赋值</li><li><code>vector&lt;int&gt; a(b.begin(),b.begin+3)</code>; //定义了a值为b中第0个到第2个（共3个）元素</li><li>int b[7]={1,2,3,4,5,9,8}; <code>vector&lt;int&gt; a(b,b+7);</code> //从数组中获得初值</li></ol><p><strong>二维数组的初始化</strong><br>初始化为0，0可变其他数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; vec(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (col,<span class="hljs-number">0</span>));<br><br></code></pre></td></tr></tbody></table></figure><p><code>{{1, 2, 3}, {3, 4, 5}......}</code> : 这种类型的也是二维数组 ^1wjjr0</p><p>返回值和使用时：必须用 dp[ i ]，不能用dp(i)</p><p><strong>强转 vector 类型</strong><code>return vector&lt;int&gt;(result_set.begin(), result_set.end());</code>[^2]</p><h1 id="2-push_back"><a class="markdownIt-Anchor" href="#2-push_back"></a> 2: push_back</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}); = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, 还可以往里再加}`<br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-size-resize"><a class="markdownIt-Anchor" href="#3-size-resize"></a> 3: size () &amp;&amp; resize ()</h1><h2 id="31-size"><a class="markdownIt-Anchor" href="#31-size"></a> 3.1: size（）：</h2><p>告诉你容器中有多少个元素<br>但是不会告诉你为了包含这些数据所分配的内存</p><h2 id="32-resize"><a class="markdownIt-Anchor" href="#32-resize"></a> 3.2: resize（）</h2><blockquote><p>[!summary]  <code>&gt;</code>容量就扩容在赋值,  <code>&lt;</code> 容量就直接赋值<br><strong>改变当前容器内含有元素的数量 size (), 而不是容器的容量</strong></p></blockquote><ul><li><p>如果 n <code>大于</code> 容器中元素总数, 小于目前的 capacity：</p><ul><li>通过构造函数将新的元素添加到容器未尾</li></ul></li><li><p>n大于capacity</p><ul><li>重新分配内存, 在赋值</li></ul></li><li><p>n<code>小于</code>容器中元素的总数</p><ul><li>将容器尾部的元素析构</li></ul></li><li><p>example</p></li></ul><ol><li>当 resize (len) 中 len&gt;v.capacity(), 则数组中的 size 和 capacity 均设置为 len</li><li>当 resize (len) 中 len&lt;=v.capacity(), 则数组中的 size 设置为 len, 而 capacity 不变；</li></ol><h1 id="4-reserve"><a class="markdownIt-Anchor" href="#4-reserve"></a> 4: reserve ():</h1><p>强迫容器把他的<strong>容量</strong>变到至少是n，n不小于当前的大小，这通常会导致重新分配</p><ol><li>如果 reserve (len) 的值&gt;当前的 capacity (), 那么会重新分配一块能存 len 个对象的空间，然后把之前的对象通过 copy construtor 复制过来，销毁之前的内存；<ul><li>tip 就是扩容的过程</li></ul></li><li>当 reservel (len) 中 len&lt;=当前的 capacity(), 则数组中的 capacity 不变，size 不变，即不对容器做任何改变。</li></ol><h1 id="5-reverse-vecbegin-vec-end"><a class="markdownIt-Anchor" href="#5-reverse-vecbegin-vec-end"></a> 5: reverse (vec.begin (), vec. end () )</h1><p>反转 vec</p><p>capacity(）：告诉你容器中利用己经分配的内存可以容纳多少个元素这个是容器能容纳的容器元素总数要知道<br>用capacity-size</p><p>reserve():强迫容器把他的容量变到至少是n不小于当前的大小这通常会导致重新分配</p><h1 id="6-begin-end-front-back的区别"><a class="markdownIt-Anchor" href="#6-begin-end-front-back的区别"></a> 6: begin()、end()、front()、back()的区别</h1><h2 id="61-front-back-的使用"><a class="markdownIt-Anchor" href="#61-front-back-的使用"></a> 6.1: front( )，back( )的使用</h2><p><code>arr.front();</code>返回的是第一个元素的引用。<br><code>arr.back();</code>返回的的是最后一个元素的引用。</p><p>如果定义<code>int c = a.back()</code>，c并不是一个引用，操作b不会对a中的最后一个元素造成影响。<br>若定义<code>int &amp;b=a.front();</code>，则对b的操作会影响a中第一个元素。</p><h2 id="62-begin-end-的使用"><a class="markdownIt-Anchor" href="#62-begin-end-的使用"></a> 6.2: begin( )，end( )的使用</h2><p>返回的是迭代器, 而不是元素</p><h3 id="621-begin函数原型"><a class="markdownIt-Anchor" href="#621-begin函数原型"></a> 6.2.1: begin函数原型:</h3><p><code>iterator begin();</code><br><code>const_iterator begin();</code></p><p>功能：<br>返回一个当前vector容器中起始元素的<a href="https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&amp;spm=1001.2101.3001.7020">迭代器</a>。<br><strong>从后向前遍历</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;::iterator itr2 = arr.end()<span class="hljs-number">-1</span>;<span class="hljs-comment">//arr.end()是指向末尾的指针，arr.end()-1才指向最后一个元素</span><br><span class="hljs-type">int</span> len2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (itr2 != arr.begin())<br>{<br><span class="hljs-comment">//do something</span><br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="622-end函数原型"><a class="markdownIt-Anchor" href="#622-end函数原型"></a> 6.2.2: end函数原型：</h3><p><code>iterator end();</code><br><code>const_iterator end();</code><br>功能：<br>返回一个当前vector容器中末尾元素的迭代器。</p><p><strong>从前向后遍历</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;::iterator itr1 = arr.begin();<br><span class="hljs-keyword">while</span> (itr1 != arr.end())<br>{<br><span class="hljs-comment">//do something</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="7-vector删除操作"><a class="markdownIt-Anchor" href="#7-vector删除操作"></a> 7: [[vector删除操作]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/43124/"/>
    <url>/posts/43124/</url>
    
    <content type="html"><![CDATA[<p>📝遍历链表::</p><!-- basicblock-end --><p>遍历链表</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* cur = head;<br><span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span>){<br>    cur = cur-&gt;next;<br>    中间可以加其他操作<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>06. 从尾到头打印链表</title>
    <link href="/posts/28723/"/>
    <url>/posts/28723/</url>
    
    <content type="html"><![CDATA[<p>📝06. 从尾到头打印链表::<a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode）</a></p><!-- basicblock-end --><ul><li>遍历链表, 向 vector 中添加链表元素</li><li>反转 vector , reverse (res.begin(), res. end())</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span>){<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>[[遍历链表]]</p><p>[[vector (🗃)]]</p><p>[[4. 反转链表]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组扩容</title>
    <link href="/posts/29767/"/>
    <url>/posts/29767/</url>
    
    <content type="html"><![CDATA[<p>📝数组扩容:: 先扩容, 在用双指针</p><!-- basicblock-end --><p>![[双指针法.excalidraw]]</p><ol><li>首先扩充数组到每个空格替换成"%20"之后的大小。</li><li>快指针指向新长度的末尾，慢指针指向旧长度的末尾。然后从后向前替换空格，<ol><li>如果从前往后填充, 就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。<br>演示过程如下</li></ol></li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1go6qmevhgpg20du09m4qp.gif" alt="替换空格"></p><p><strong>其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。</strong><br>这么做有两个好处：</p><ol><li>不用申请新数组。</li><li>从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。<br>双指针法:  用第一个指针新数组的新元素, 第二个指针在新数组中赋值</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>索引使用</title>
    <link href="/posts/20779/"/>
    <url>/posts/20779/</url>
    
    <content type="html"><![CDATA[<p>📝索引使用::</p><!-- basicblock-end --><h1 id="1-验证索引效率"><a class="markdownIt-Anchor" href="#1-验证索引效率"></a> 1 验证索引效率</h1><blockquote><p>[!example]-  一句话: 采用索引之后效率非常高<br>‌‌‌　　‌‌‌　　![[验证索引效率.excalidraw]]</p></blockquote><h1 id="2-最左前缀法则"><a class="markdownIt-Anchor" href="#2-最左前缀法则"></a> 2 [[最左前缀法则]]</h1><h1 id="3-范围查询"><a class="markdownIt-Anchor" href="#3-范围查询"></a> 3 范围查询</h1><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。<br>可以用&gt;=或者&lt;=来规避索引失效问题。(业务允许的情况下尽量用)</p><blockquote><p>[!example]<br>![[范围查询.excalidraw]]</p></blockquote><h1 id="4-索引失效情况"><a class="markdownIt-Anchor" href="#4-索引失效情况"></a> 4 索引失效情况</h1><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h1 id="5-sql-提示"><a class="markdownIt-Anchor" href="#5-sql-提示"></a> 5 SQL 提示</h1><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession="软件工程";</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession="软件工程";</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h1 id="6-覆盖索引回表查询"><a class="markdownIt-Anchor" href="#6-覆盖索引回表查询"></a> 6 覆盖索引&amp;回表查询</h1><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name='xxx';</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username='itcast';</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h1 id="7-前缀索引"><a class="markdownIt-Anchor" href="#7-前缀索引"></a> 7 前缀索引</h1><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(distinct email) / count(*) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;<br></code></pre></td></tr></tbody></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h1 id="8-单列索引联合索引"><a class="markdownIt-Anchor" href="#8-单列索引联合索引"></a> 8 单列索引&amp;联合索引</h1><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code><br>这句只会用到phone索引字段</p><h3 id="01-注意事项"><a class="markdownIt-Anchor" href="#01-注意事项"></a> 0.1 注意事项</h3><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引语法</title>
    <link href="/posts/1821/"/>
    <url>/posts/1821/</url>
    
    <content type="html"><![CDATA[<p>📝索引语法::<br>2022/11/3 : 第一次创建</p><!-- basicblock-end --><h1 id="1-语法"><a class="markdownIt-Anchor" href="#1-语法"></a> 1 语法</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">创建索引：<br>create [ unique | fulltext ] index index_name on table_name (index_col_name, ...);<br>如果不加 create 后面不加索引类型参数，则创建的是常规索引<br><br>查看索引：<br>show index from table_name;<br><br>删除索引：<br>drop index index_name on table_name;<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例：</h1><p>数据准备: <a href="marginnote3app://note/4BC4F6F5-05D4-4A1E-BC6D-0F36FAE694F1">margin: 索引语法</a><br>‌‌‌　　‌‌‌　　‌‌‌　　![[索引案例.excalidraw]]</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 普通索引<br>    -- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>-- 唯一索引<br>    -- phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>-- 联合索引<br>    -- 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br><br>-- 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br><br><br>-- 完成上述的需求之后, 我们再查看 tb_user 表的所有的索引数据。<br>show index from tb_user;<br><br>-- 删除索引<br>drop index idx_user_email on tb_user;<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试笔记 2</title>
    <link href="/posts/36237/"/>
    <url>/posts/36237/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsItzOYiu5QGN4A1gc3grjs"  --> <p>📝测试笔记 2::<br>2022/11/3: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符</title>
    <link href="/posts/4075/"/>
    <url>/posts/4075/</url>
    
    <content type="html"><![CDATA[<p>📝运算符::<br>2022/11/3: 第一次创建</p><!-- basicblock-end --><h1 id="1-左移运算符"><a class="markdownIt-Anchor" href="#1-左移运算符"></a> 1: 左移运算符（&lt;&lt;）</h1><p>若左移时舍弃的高位不包含1，则每左移一位，<strong>相当于该数乘以2</strong>。</p><blockquote><p>[!example]- 定义：<br>将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。<br>设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。</p></blockquote><h1 id="2-右移运算符"><a class="markdownIt-Anchor" href="#2-右移运算符"></a> 2: 右移运算符（&gt;&gt;）</h1><p>操作数每右移一位，<strong>相当于该数除以 2</strong>。</p><blockquote><p>[!summary] 两者等价<br>l + (r - l) /2 : 还是用这个吧<br>l + (r - l ) &gt;&gt;2</p></blockquote><p><strong><code>n &gt;&gt;= 1</code> ：</strong> 将二进制数字 n 无符号右移一位</p><blockquote><p>[!example]- 定义：<br>将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。<br>例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。<br>操作数每右移一位，相当于该数除以2。</p></blockquote><h1 id="3-数组类"><a class="markdownIt-Anchor" href="#3-数组类"></a> 3: 数组类</h1><p>运算符::<br>[ ] : 下标运算       eg:  arr[5]<br>{}  :  数组初始化  eg: int a[3] 二 {1,2,3}</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>矩阵的性质</title>
    <link href="/posts/62366/"/>
    <url>/posts/62366/</url>
    
    <content type="html"><![CDATA[<p>📝矩阵的性质::<br>2022/11/3: 第一次创建</p><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br>二维数组[行][列] <br>matrix[A][B]<br><br><br>一行有多少个: matrix.<span class="hljs-built_in">size</span>()<br>一列有多少个: matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br><br><br><br></code></pre></td></tr></tbody></table></figure><p>对于一个二维数组 <code>matrix</code>，<br><code>matrix.size()</code> 返回的是该二维数组中包含的一维数组的个数，即行数。<br>而 <code>matrix[0].size()</code> 返回的是该二维数组中第一个一维数组的长度，即列数。</p><p>![[二维数组.excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/posts/44464/"/>
    <url>/posts/44464/</url>
    
    <content type="html"><![CDATA[<p>有序查找一般考虑二分查找:</p><blockquote><p>[!tip]<br>由于矩阵 matrix 中每一行的元素都是升序排列的，因此我们可以对每一行都使用一次二分查找，判断 target 是否在该行中，从而判断 target 是否出现。</p></blockquote><p>[[二维数组 或 矩阵]]<br>[[运算符]]</p><p>![[二分查找法.excalidraw]]</p><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(nlog⁡m)。对一行使用二分查找的时间复杂度为 O(log⁡m)，最多需要进行 nn 次二分查找。</p></li><li><p>空间复杂度：O(1)</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>() || matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// ❗️必须提前判断: 矩阵为空或者矩阵第一行为空, 如果为空了下边就没有意义了</span><br>        <span class="hljs-type">int</span> x = matrix.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取列个数</span><br>        <span class="hljs-type">int</span> y = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取行个数</span><br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x;i++){<br>            <span class="hljs-comment">// 在每一行中用二分查找</span><br>            <span class="hljs-keyword">if</span>(target &gt;= matrix[i][<span class="hljs-number">0</span>] &amp;&amp;  target &lt;= matrix[i][y<span class="hljs-number">-1</span>]){<br>                <span class="hljs-comment">// 左闭右闭类型</span><br>                <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; <span class="hljs-type">int</span> r = y <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">while</span>(l &lt;= r){<br>                    <span class="hljs-type">int</span> mid = l + (r - l)/<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span>(target &lt; matrix[i][mid]) r = mid - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( target &gt; matrix[i][mid])l = mid + <span class="hljs-number">1</span> ;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                }<br><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt; matrix[i][<span class="hljs-number">0</span>]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 剪枝</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsk8Bm3Ujp87XnoSGobangc"  --> <p>📝剑指 Offer 04. 二维数组中的查找::<br>2022/11/3: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引分类</title>
    <link href="/posts/17909/"/>
    <url>/posts/17909/</url>
    
    <content type="html"><![CDATA[<p>📝索引分类::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end --><h1 id="1-总分类"><a class="markdownIt-Anchor" href="#1-总分类"></a> 1: 总分类</h1><p>在 MySQL 数据库, 将索引的具体类型主要分为以下几类:<br>主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h1 id="2-innodb-中的分类"><a class="markdownIt-Anchor" href="#2-innodb-中的分类"></a> 2: InnoDB 中的分类</h1><p>存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引<br>![[二级索引.excalidraw]]</li></ul><h1 id="3-思考题"><a class="markdownIt-Anchor" href="#3-思考题"></a> 3: 思考题</h1><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 10;<br>select * from user where name = 'Arm';<br>-- 备注：id为主键，name字段创建的有索引<br></code></pre></td></tr></tbody></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>![[一张表能存多少数据.excalidraw]]</p><p>另外，如果有上亿的数据，那么就要考虑分表，涉及运维篇知识。title: 索引分类</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hash 索引</title>
    <link href="/posts/35172/"/>
    <url>/posts/35172/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!example]-<br>‌‌‌ ![[Hash 索引.excalidraw|1000]]</p></blockquote><h1 id="使用-key-value-对存储数据"><a class="markdownIt-Anchor" href="#使用-key-value-对存储数据"></a> 使用 key-value 对，存储数据</h1><p>但是，可能存在hash 冲突（多个 value 对应同一个 key)<br>拉链法:  解决 hash 冲突的方法之一<br>适用情景：只有等值查询，如Mencached、 NoSQL</p><h1 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h1><h2 id="1-优点"><a class="markdownIt-Anchor" href="#1-优点"></a> 1 优点：</h2><ul><li>key 无序，插入数据时无需维护顺序（直接在最后一个元索后追加，即可），</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引<ul><li>一次索引: 不发生哈希碰撞的情况下</li></ul></li></ul><h2 id="2-缺点"><a class="markdownIt-Anchor" href="#2-缺点"></a> 2 缺点：</h2><ul><li>因为不是有序的，所以哈希索引做区间查询的速度是很慢</li><li>Hash 索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li></ul><blockquote><p>[!tip] Note:<br>哈希表适用于只有等值查询的场景，而不适用频繁 区间查找</p></blockquote><h2 id="3-存储引擎支持"><a class="markdownIt-Anchor" href="#3-存储引擎支持"></a> 3 存储引擎支持：</h2><ul><li>Memory</li><li>InnoDB: 具有自适应 hash 功能，hash 索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsmQeGHrMCs2Q4l8gd87qVd" --> <p>📝Hash 索引::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>B-Tree</title>
    <link href="/posts/29945/"/>
    <url>/posts/29945/</url>
    
    <content type="html"><![CDATA[<p>📝B-Tree::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end --><blockquote><p>[!note]- MySQL 为什么不选二叉树.<br>大数据量情况下, 层级较深, 检索速度慢。<br>孩子太少了, 效率不高<br>![[MySQL 为什么不选二叉树.excalidraw]]</p></blockquote><h1 id="1-b-tree"><a class="markdownIt-Anchor" href="#1-b-tree"></a> 1: B-Tree</h1><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）<br>![[B-Tree .excalidraw]]</p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h2 id="11-btree"><a class="markdownIt-Anchor" href="#11-btree"></a> 1.1: B+Tree</h2><p>B+Tree是B-Tree的变种,我们以一颗最大度数(max-degree)为4(4阶)的b+tree为例,来看一下其结构示意图:</p><p>![[B+Tree .excalidraw]]<br>gif<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211022126176.gif" alt=""></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li><li>非叶子节点仅仅起到索引数据作用,具体的数据都是在叶子节点存放的。</li><li></li><li></li></ul><h2 id="对于-b-tree无论是叶子节点还是非叶子节点都会保存数据这样导致一页中存储的键值减少指针也跟着减少要同样保存大量数据只能增加树的高度导致性能降低"><a class="markdownIt-Anchor" href="#对于-b-tree无论是叶子节点还是非叶子节点都会保存数据这样导致一页中存储的键值减少指针也跟着减少要同样保存大量数据只能增加树的高度导致性能降低"></a> 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</h2><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带<strong>有顺序指针的 B+Tree，提高区间访问的性能。</strong></p><p>![[MySQL B+Tree .excalidraw]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 索引</title>
    <link href="/posts/6862/"/>
    <url>/posts/6862/</url>
    
    <content type="html"><![CDATA[<p>📝2. 索引::<br>2022/11/3 : 第一次创建</p><!-- basicblock-end --><h1 id="1-索引介绍"><a class="markdownIt-Anchor" href="#1-索引介绍"></a> 1: 索引介绍</h1><p>索引是帮助 MySQL <strong>高效获取数据的数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><blockquote><p>[!example]-<br>![[索引介绍.excalidraw]]</p></blockquote><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h1 id="2-3-source_postscodemysql进阶篇索引分类"><a class="markdownIt-Anchor" href="#2-3-source_postscodemysql进阶篇索引分类"></a> 2: 3: [[source/_posts/👨🏻‍💻code/MySQL/进阶篇/索引分类]]</h1><h1 id="3-索引语法"><a class="markdownIt-Anchor" href="#3-索引语法"></a> 3: [[索引语法]]</h1><h1 id="4-sql-性能分析"><a class="markdownIt-Anchor" href="#4-sql-性能分析"></a> 4: [[SQL 性能分析]]</h1><h1 id="5-索引使用规则"><a class="markdownIt-Anchor" href="#5-索引使用规则"></a> 5: 索引使用规则</h1><h2 id="51-索引使用"><a class="markdownIt-Anchor" href="#51-索引使用"></a> 5.1: [[索引使用]]</h2><h1 id="6-设计原则"><a class="markdownIt-Anchor" href="#6-设计原则"></a> 6: 设计原则</h1><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Memory</title>
    <link href="/posts/9867/"/>
    <url>/posts/9867/</url>
    
    <content type="html"><![CDATA[<p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsApFba7Ev0BNXKZHLPMxac" --> <p>📝Memory::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MyISAM</title>
    <link href="/posts/16261/"/>
    <url>/posts/16261/</url>
    
    <content type="html"><![CDATA[<p>MyISAM 是 MySQL 早期的默认存储引擎。</p><h1 id="1-特点"><a class="markdownIt-Anchor" href="#1-特点"></a> 1 特点：</h1><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><h1 id="2-文件格式"><a class="markdownIt-Anchor" href="#2-文件格式"></a> 2 文件格式：</h1><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211022014432.png" alt="|400"></p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs1N92I7P0MJn99gzw685QY" --> <p>📝MyISAM::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1 定义</title>
    <link href="/posts/21625/"/>
    <url>/posts/21625/</url>
    
    <content type="html"><![CDATA[<p>📝InnoDB::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end --><p><img src="" alt="Uploading file...myken"></p><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1: 定义</h1><p>InnoDB 是一种兼顾高<strong>可靠性和高性能</strong>的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><h1 id="2-文件存储"><a class="markdownIt-Anchor" href="#2-文件存储"></a> 2: 文件存储</h1><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>![[innobd 的参数excalidraw]]</p><h1 id="3-innodb-逻辑存储结构"><a class="markdownIt-Anchor" href="#3-innodb-逻辑存储结构"></a> 3: [[InnoDB 逻辑存储结构：]]</h1><h1 id="4-innodb-架构"><a class="markdownIt-Anchor" href="#4-innodb-架构"></a> 4: [[InnoDB 架构]]</h1><h1 id="5-mvcc"><a class="markdownIt-Anchor" href="#5-mvcc"></a> 5: [[MVCC]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自连接</title>
    <link href="/posts/49029/"/>
    <url>/posts/49029/</url>
    
    <content type="html"><![CDATA[<h1 id="1-自连接查询"><a class="markdownIt-Anchor" href="#1-自连接查询"></a> 1 自连接查询</h1><p>自连接查询,顾名思义,就是自己连接自己,也就是把一张表连接查询多次。</p><p>语法</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">SELECT  字段列表   FROM   表A   别名A   JOIN  表A    别名B   ON  条件 ... ;<br></code></pre></td></tr></tbody></table></figure><p>而对于自连接查询,可以是内连接查询,也可以是外连接查询。</p><blockquote><p>[!example]<br>![[自连接案例.excalidraw]]</p></blockquote><blockquote><p>[!tip]  注意事项:<br>在自连接查询中,必须要为表起别名,要不然我们不清楚所指定的条件、返回的字段,到底是哪一张表的字段。</p></blockquote><h1 id="2-联合查询"><a class="markdownIt-Anchor" href="#2-联合查询"></a> 2 联合查询</h1><p>对于union查询,就是把多次查询的结果合并起来,形成一个新的查询结果集。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select  字段列表   from   表a  ...  <br>union [ all ] <br>select  字段列表  from   表b  ....;<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!tip]<br>对于联合查询的多张表的列数必须保持一致,字段类型也需要保持一致。<br>union all 会将全部的数据直接合并在一起,union 会对合并之后的数据去重。<br>如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union al1联合查询时，将会报错。</p></blockquote><blockquote><p>[!example]<br>![[5. 多表查询 2022-10-09 20.42.15.excalidraw]]</p></blockquote><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObschKinjwPZuMeqqy5Mq0Aj" --> <p>📝自连接::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子查询简介</title>
    <link href="/posts/40156/"/>
    <url>/posts/40156/</url>
    
    <content type="html"><![CDATA[<p>📝子查询简介::</p><!-- basicblock-end --><blockquote><p>[!summary] 子查询是嵌套查询<br>在⼀个查询语句中的某个位置可以出现另⼀个查询语句，这另⼀个查询就叫⼦查询</p></blockquote><p>SQL语句中嵌套SELECT语句,称为嵌套查询,又称子查询。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select  *  from   t1   where  column1 =  ( select  column1  from  t2 );<br></code></pre></td></tr></tbody></table></figure><p>子查询外部的语句可以是insert / update / delete / select 的任何一个</p><blockquote><p>[!summary] 分类<br>根据<strong>子查询位置</strong>, 分为:<br>A. WHERE之后<br>B. FROM之后<br>C. SELECT 之后</p></blockquote><p>根据<strong>子查询结果</strong>不同,分为:<br>A. 标量子查询(子查询结果为单个值)<br>B. 列子查询(子查询结果为一列)<br>C. 行子查询(子查询结果为一行)<br>D. 表子查询 (子查询结果为多行多列)</p><blockquote><p>下边黑马的例子可以不看了, 只看总结版</p></blockquote><h1 id="1-根据子查询位置"><a class="markdownIt-Anchor" href="#1-根据子查询位置"></a> 1: 根据子查询位置</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- 在 select⼦句中<br><br>select (select m1 from t1 limit 1);<br><br>-- 在from⼦句中<br>select m, n from (select ...);<br>将这种⼦查询的结果当做⼀个表，在 from⼦句中的⼦查询称为派⽣表<br><br><br>-- 在 where 或 on⼦句中<br>select * from t1 where m1 in (select ...);<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-根据子查询结果不同"><a class="markdownIt-Anchor" href="#2-根据子查询结果不同"></a> 2: 根据子查询结果不同</h1><h2 id="21-标量子查询"><a class="markdownIt-Anchor" href="#21-标量子查询"></a> 2.1: 标量子查询</h2><blockquote><p>[!summary] 只返回⼀个单⼀值<br>子查询返回的结果是<strong>单个值</strong>(数字、字符串、日期等),最简单的形式,这种子查询称为标量子查询。<br>常用的操作符:=  &lt;&gt;  &gt;   &gt;=   &lt;  &lt;=</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select (select m1 from t1 limit 1);<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]- 简单了解</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- A. 查询 "销售部" 的所有员工信息<br>完成这个需求时,我们可以将需求分解为两步: <br><br>1. 查询 "销售部" 部门ID<br>select id from dept where name = '销售部';<br><br>2. 根据 "销售部" 部门ID, 查询员工信息<br>select * from emp where dept_id = (select id from dept where name = '销售部');<br><br>-- B. 查询在 "方东白" 入职之后的员工信息<br>完成这个需求时,我们可以将需求分解为两步: <br><br>1. 查询 方东白 的入职日期<br>select entrydate from emp where name = '方东白'; <br><br>1. 查询指定入职日期之后入职的员工信息<br>select * from emp where entrydate &gt; (select entrydate from emp where name = '方东白');<br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="22-列子查询"><a class="markdownIt-Anchor" href="#22-列子查询"></a> 2.2: 列子查询</h2><blockquote><p>[!summary]- 返回⼀个列的数据，可能包含多条纪录<br>子查询返回的结果是一列(可以是多行),这种子查询称为列子查询。<br>常用的操作符:IN 、NOT IN 、 ANY 、SOME 、 ALL</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from t1 where m1 in (select m2 from t2);<br></code></pre></td></tr></tbody></table></figure><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部和市场部的所有员工信息<br>1. 查询 "销售部" 和 "市场部" 的部门ID<br>2. 根据部门ID, 查询员工信息<br><br>select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');<br><br>-- 查询比财务部所有人工资都高的员工信息<br>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部'));<br><br>-- 查询比研发部任意一人工资高的员工信息<br>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部'));<br></code></pre></td></tr></tbody></table></figure><h2 id="23-行子查询"><a class="markdownIt-Anchor" href="#23-行子查询"></a> 2.3: 行子查询</h2><blockquote><p>[!question] 返回⼀条记录，需要包含多个列<br>返回的结果是一行（可以是多列）。<br>常用操作符：=, &lt;, &gt;, IN, NOT IN</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from t1 where (m1, n1) = (select m2, n2 from t2 limit 1);<br>使⽤limit 1 保证⼦查询的结果只有⼀条记录<br><br></code></pre></td></tr></tbody></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与'张无忌'的薪资及直属领导 相同的员工信息<br>1. 查询 "张无忌" 的薪资及直属领导<br>2. 查询与 "张无忌" 的薪资及直属领导相同的员工信息 ;<br><br>select salary, managerid from emp where name = '张无忌';<br>select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');<br><br><br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="24-表子查询"><a class="markdownIt-Anchor" href="#24-表子查询"></a> 2.4: 表子查询</h2><p>返回的结果是多行多列<br>常用操作符：IN</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from t1 where (m1, n1) = (select m2, n2 from t2);<br></code></pre></td></tr></tbody></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mysql">A. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息<br>1. 查询 "鹿杖客" , "宋远桥" 的职位和薪资<br>2. 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息<br><br><br>select job, salary from emp where name = '鹿杖客' or name = '宋远桥';<br>select * from emp where (job,salary) in ( select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );<br><br><br><br>B. 查询入职日期是 "2006-01-01" 之后的员工信息 , 及其部门信息<br>分解为两步执行: <br>1. 入职日期是 "2006-01-01" 之后的员工信息<br>2. 查询这部分员工, 对应的部门信息;<br>select * from emp where entrydate &gt; '2006-01-01';<br>select e.*, d.* from (select * from emp where entrydate &gt; '2006-01-01') e left join dept d on e.dept_id = d.id ;<br><br><br><br><br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-按外层查询关系分类"><a class="markdownIt-Anchor" href="#3-按外层查询关系分类"></a> 3: 按外层查询关系分类</h1><h2 id="31-不相关子查询"><a class="markdownIt-Anchor" href="#31-不相关子查询"></a> 3.1: 不相关⼦查询</h2><p>⼦查询可以单独运⾏出结果，不依赖于外层查询的值上⾯都是例⼦</p><h2 id="32-相关子查询"><a class="markdownIt-Anchor" href="#32-相关子查询"></a> 3.2: 相关⼦查询</h2><p>⼦查询的执⾏需要依赖于外层 (💡外表) 查询的值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select * from t1 where m1 in (select m2 from t2 where n1 = n2);<br></code></pre></td></tr></tbody></table></figure><h1 id="4-子查询的注意事项"><a class="markdownIt-Anchor" href="#4-子查询的注意事项"></a> 4: ⼦查询的注意事项：</h1><ol><li><p>必须⽤⼩括号括起来</p></li><li><p>select⼦句中的⼦查询必须是标量⼦查询</p></li><li><p>要想得到标量⼦查询/⾏⼦查询，应该使⽤limit 1</p></li><li><p>对于[not] in/any/som/all⼦查询来说，⼦查询不允许出现limit</p></li><li><p>⼦查询中不必使⽤order by：⼦查询相当于⼀个集合，集合没必要排序</p></li><li><p>⼦查询中不必使⽤distinct，因为集合也不需要去重</p></li><li><p>⼦查询中没有聚集函数以及having⼦句时，不必使⽤group by⼦句</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>外连接</title>
    <link href="/posts/8547/"/>
    <url>/posts/8547/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">- 外连接: - 左外连接:查询左表所有数据,以及两张表交集部分数据- 右外连接:查询右表所有数据,以及两张表交集部分数据</code></pre><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210082212714.png" alt="|500"></p><p>外连接分为两种,分别是:左外连接 和 右外连接。<br>1). 左外连接</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select  字段列表   from   表1  left  [ outer ]  join 表2  on  条件 ... ;<br><br>-- 案例查询emp表的所有数据, 和对应的部门信息<br>select e.*, d.name from emp e left join dept d on e.dept_id = d.id;<br></code></pre></td></tr></tbody></table></figure><p><strong>左外连接相当于查询表1(左表)的所有数据</strong>,当然也包含表1和表2交集部分的数据。</p><p>2). 右外连接</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select  字段列表   from   表1  right  [ outer ]  join 表2  on  条件 ... ;<br><br>-- 查询dept表的所有数据, 和对应的员工信息(右外连接)<br>select e.*, d.name from emp e right join dept d on e.dept_id = d.id;<br>select d.*, e.* from dept d left  join emp e on e.dept_id = d.id;<br><br><br></code></pre></td></tr></tbody></table></figure><p><strong>右外连接相当于查询表2(右表)的所有数据</strong>,当然也包含表1和表2交集部分的数据。</p><blockquote><p>[!example]-<br>![[外连接案例.excalidraw]]</p></blockquote><blockquote><p>[!tip]<br>注意事项:  左外连接和右外连接是可以相互替换的,只需要调整在连接查询时SQL中,表结构的先后顺序就可以了。<br>而我们在日常开发使用时,<strong>更偏向于左外连接</strong>。</p></blockquote><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsRG527MJeYFqY12HsANHya" --> <p>📝外连接::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内连接</title>
    <link href="/posts/8644/"/>
    <url>/posts/8644/</url>
    
    <content type="html"><![CDATA[<p>内连接查询的是两张表交集部分的数据</p><p>内连接的语法分为两种: 隐式内连接、显式内连接</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">1). 隐式内连接<br>select  字段列表   from   表1 , 表2   where   条件 ... ;<br><br><br>2). 显式内连接<br>select  字段列表   from   表1  [ inner ]  join 表2  on  连接条件 ... ; -- inner 可以省略<br><br>-- 说明<br>显示内连接: 相当于多了几个关键字显示的说明他们连接了<br>隐式: 只是没有关键字, 也连接了<br><br>-- 💡统一用显式连接, 因为可以和外连接保持一致<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>![[内连接案例.excalidraw]]</p></blockquote><p>多表查询和起别名联立使用<br>表的别名:</p><ol><li>tablea as 别名1 , tableb as 别名2 ;  /💡as 可以省略</li><li>tablea 别名1 , tableb 别名2 ;</li></ol><blockquote><p>[!tip] 一旦为表起了别名,就不能再使用表名来指定对应的字段了,此时只能够使用别名来指定字段。</p></blockquote><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsjVLurQZl5pI3b12jXOmyd" --> <p>📝内连接::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 储存引擎层</title>
    <link href="/posts/8283/"/>
    <url>/posts/8283/</url>
    
    <content type="html"><![CDATA[<p>📝1. 储存引擎层::<br>2022/11/2 : 第一次创建</p><!-- basicblock-end --><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1: 概念</h1><p>^f297bb<br>![[MySQL 整体架构图.excalidraw]]<br>![[储存引擎简介.excalidraw]]</p><h2 id="11-innodb"><a class="markdownIt-Anchor" href="#11-innodb"></a> 1.1: [[InnoDB]]</h2><h2 id="12-myisam"><a class="markdownIt-Anchor" href="#12-myisam"></a> 1.2: [[MyISAM]]</h2><h2 id="13-memory"><a class="markdownIt-Anchor" href="#13-memory"></a> 1.3: [[Memory]]</h2><h1 id="2-存储引擎特点"><a class="markdownIt-Anchor" href="#2-存储引擎特点"></a> 2: 存储引擎特点</h1><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6版本之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><h2 id="21-数据库引擎innodb与myisam的区别"><a class="markdownIt-Anchor" href="#21-数据库引擎innodb与myisam的区别"></a> 2.1: [[数据库引擎InnoDB与MyISAM的区别]]</h2><h1 id="3-存储引擎的选择"><a class="markdownIt-Anchor" href="#3-存储引擎的选择"></a> 3: 存储引擎的选择</h1><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还<strong>可以根据实际情况选择多种存储引擎进行组合</strong>。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>进阶篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>硬度</title>
    <link href="/posts/45930/"/>
    <url>/posts/45930/</url>
    
    <content type="html"><![CDATA[<p>硬度<br>纯铝的测试方法<br>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-27 11.50.29.excalidraw]]</p><p>如图 2-8 所示, 为了保证测试面的一致性与硬度测试的准确性, 本研究统一通过线切割沿着梯度结构纯铜片材中心线切开, 并以中心线处的截面为测试面。由于硬度测试试样尺寸较小, 不便于磨削及抛光, 所以需要将其通过冷镶嵌的方式镶嵌成圆柱试样。</p><p>为了达到硬度测试样表面的镜面效果, 需要将测试试样依次经过 800 目、 1000 目、 1500 目、 2000 目与 3000 目的砂纸进行粗磨及精磨。当使用 3000 目的砂纸精磨至划痕细腻均匀、方向统一以后, 再依次使用 1μm、0.5μm 的金刚石喷雾抛光剂对测试试样进行粗抛光及精抛光。当使用 0.5μm 的金刚石喷雾抛光剂精抛光至镜面效果时, 对试样进行硬度测试。</p><ul><li>question 在硬度测试试样同一厚度层的位置, 随机选取 5 个测试点进行测试, 并最终以其平均值作为该厚度层的硬度值。</li><li>tip 在试样的每个区域选取 5 个点进行测试, 取其平均值作为样品在该区域的最终硬度值。</li></ul><p><a href="marginnote3app://note/8183B536-F0A0-4341-8B80-A508AD8D820D">margin: 纯铝2.5.1 硬度测试</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
      <category>论文学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深度探索 C++对象模型目录</title>
    <link href="/posts/31886/"/>
    <url>/posts/31886/</url>
    
    <content type="html"><![CDATA[<ul><li>1.1：C++对象模型<ul><li>模型简介<ul><li>每一个 class产生出一堆指向 virtual functions 的指针，放在表格之中。这个表格被称为 virtual table（vtbl）。</li><li>每一个 class object被安插一个指针，指向相关的 virtual table。通常这个指针被称为 vptr。vptr 的设定（setting）和重置（resetting）都由每一个 class的 constructor、destructor和 copy assignment运算符自动完成（我将在第5章讨论这个问题）。每一个 class所关联的 type_info object（用以支持 runtime type identification，RTTI）也经由 virtual table被指出来，通常放在表格的第一个 slot。</li></ul></li><li>模型优点和缺点<ul><li>优点：空间和存取时间优秀</li><li>缺点：如果应用程序代码本身未曾改变，但是所用的class object的nonstatic data member有更改就需要重新编译，因为多了一层间接性，就需要符出空间和执行效率的两方面的代价</li></ul></li></ul></li></ul><p>![[深度探索 C++对象模型目录 2022-11-02 09.32.35.excalidraw]]</p><p>![[深度探索 C++对象模型目录 2022-11-02 09.32.35.excalidraw.svg]]</p><ul><li>1.2： 关键词所带来的差异<ul><li>对于C<ins>为了维护和C之间的兼容性，C</ins>为此付出了很多牺牲。<ul><li>对于struct，C++更多的类似于class，而非C中的数据集合体</li><li>部分C中的技巧到了C++中失效的可能性很大，并不建议</li></ul></li><li>struct的一个合理用途便是可以将某个数据做一个简单的封装，达到与C的兼容</li><li>struct并不能兼容template</li></ul></li><li>1.3：对象的差异<ul><li>C++程序设计模型直接支持三种程序设计范式</li><li>C++通过三种方式支持多态<ul><li>经由一组隐式的转化操作，把一个derived class的指针转化为一个指向base type指针的操作</li><li>经由virtual function 机制</li><li>经由dynamic -case的typeid运算符</li><li>多态的主要用途就是经过一个共同的接口来影响类型的封装，这个接口通常被定义在抽象的base class中</li></ul></li><li>class object 的所需内存大小<ul><li>其nonstatic data members的总和大小</li><li>加上任何由于译注的需求而填补上去的空间（可能存在于members边界，也可能存在于集合体边界）<ul><li>译注：将数值调整到某个数的倍数，32位上通常为4，使得bus的运输量达到最高效率</li><li>这里的译注从某种角度上就是内存对齐，让cpu的命中率更高？</li></ul></li><li>加上为了支持virtual而由内部产生的任何额外负担</li></ul></li><li>指向一个<code>array&lt;string&gt;</code>的指针和一个指向证书的指针的不同<ul><li>一个指向正数1000的整数指针，int大小为16bits，会占掉1000-1003这块空间</li><li>string则是8个</li></ul></li></ul></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsQjaSTVgQMLRproIdZKUtM"  --> <p>📝深度探索 C++对象模型目录::<br>2022/11/2: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
      <category>深度探索 C++对象模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/7/"/>
    <url>/posts/7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>无法修改是因为, 文档被 typor 锁定了</p></blockquote><h1 id="1-variadic-template"><a class="markdownIt-Anchor" href="#1-variadic-template"></a> 1 Variadic Template</h1><ul><li>数量不定的模板参数：这个东西是C++11一个非常意思的东西，他可以接受任意个参数，然后输出出来</li><li>使用的时候也是需要注意，对于一个数量不定的模板参数，记得需要一个同名的函数来对最后一个进行“垫底”的操作</li><li>一般来讲，有参数的比无参数的更加特化一点，无参数的更加泛化</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-comment">//这里为空，作为最后的一个垫底操作</span><br>}<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span>... Types&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; firstargs,<span class="hljs-type">const</span> Types&amp; ...args)</span></span>{<br>cout&lt;&lt;firstargs&lt;&lt;endl;<br>    <span class="hljs-built_in">print</span>(args...);<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-initializer-list"><a class="markdownIt-Anchor" href="#2-initializer-list"></a> 2 Initializer-list</h1><p>Initializer-list的使用</p><ul><li>对于何时使用initializer-list，一般情况下，我们在使用{}时候，如果构造函数有接受一个initializer-list，那么整个{}里面的内容就会被打包进去，然后传递给函数进行调用</li><li>{}就会构造出一个array&lt;T,N&gt;,然后传入进去</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; val)</span></span>{<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p=val.<span class="hljs-built_in">begin</span>();p!=val.<span class="hljs-built_in">end</span>();p++){<br>std::cout&lt;&lt;*p&lt;&lt;std::endl;<br>}<br>}<br></code></pre></td></tr></tbody></table></figure><p>Initializer-list与初始化</p><ul><li>对于初始化，使用{}可以达到合适的初始化目标</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> j{}<span class="hljs-comment">//j=0;</span><br><span class="hljs-type">int</span> j<span class="hljs-comment">//undefine</span><br><span class="hljs-type">int</span> *p{}<span class="hljs-comment">//p=nullptr</span><br><span class="hljs-type">int</span> *p<span class="hljs-comment">//undefine</span><br></code></pre></td></tr></tbody></table></figure><ul><li>initializer-list对于隐式转换会报错/warning</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> j{<span class="hljs-number">5.0</span>}<span class="hljs-comment">//error</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>initializer-list的初始化与拷贝</p><p>对于其初始化，我们一般需要知道，其内部只是存储了一个指向第一个元素的指针指针和对应的函数</p><p>所以如果我们拷贝他。其并不会把元素全部都复制一份，而是复制了其对应的指针。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//内部储存数据</span><br>iterator array<span class="hljs-comment">//指向头部</span><br>size_type len<span class="hljs-comment">//表示长度</span><br></code></pre></td></tr></tbody></table></figure></li></ul><p>Initializer-list对标准库的影响</p><ul><li>标准库很多都使用了initializer-list，在C++11中，利用这个特性，我们可以将“一包”东西进行统一的操作，而不是单一单一一个一个来</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> c=<span class="hljs-built_in">max</span>({<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>});<span class="hljs-comment">//寻找三个值中最大的</span><br>vector&lt;<span class="hljs-type">int</span>&gt; a{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>};<span class="hljs-comment">//初始化</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ax</span><span class="hljs-params">({<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>})</span></span>;<span class="hljs-comment">//初始化</span><br>ax.<span class="hljs-built_in">insert</span>(ax.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>,{<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>});<span class="hljs-comment">//一次性插入多个元素</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-explicit"><a class="markdownIt-Anchor" href="#3-explicit"></a> 3 explicit</h1><p>explicit它可以保证：不让编译器做隐式的类型转换</p><p>C++11的explict可以使用在传入多个参数的explicit上了</p><h1 id="4-defaultdelete"><a class="markdownIt-Anchor" href="#4-defaultdelete"></a> 4 =default，=delete</h1><p>=delete可以用在任意函数身上</p><p>=default则不能</p><p>拷贝构造，移动构造以及对应的operator=只能有一份，所以不能在设定自己的函数之后再来一份default</p><p>一般情况下，如果成员有指针类型，那么一般都要自己定义，否则使用default版本就可以了</p><h1 id="5-alias-templatetype-alias"><a class="markdownIt-Anchor" href="#5-alias-templatetype-alias"></a> 5 Alias Template,type alias</h1><p>using关键字代表别名，在cpp11中，using的功能更加强大</p><ul><li>using的命名效果甚至可以在template中使用，完美的进行调用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> Vec＝std::vector&lt;T,mymalloc&lt;T&gt;&gt;;<br>Vec&lt;<span class="hljs-type">int</span>&gt; an<br><span class="hljs-comment">//这样可以成功的调用std::vector&lt;int,mymalloc&lt;int&gt;&gt;</span><br><span class="hljs-comment">//define和typedef都达不到对应的效果</span><br></code></pre></td></tr></tbody></table></figure><ul><li>但是这种方法到局限就是，没有办法进行偏特化和全特化</li></ul><p>using关键字还有一个作用就是作为类型别名</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<span class="hljs-comment">//C语言就有的用法</span><br><span class="hljs-keyword">using</span> func=<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);<span class="hljs-comment">//C++的用法，更加直观</span><br><span class="hljs-comment">//两者作用相同</span><br></code></pre></td></tr></tbody></table></figure><p>using常用的几种方式</p><ul><li>using namespace std； using std：：cout</li><li>using class：：member；//明确表明我需要使用那个函数（重载的时候可能会用到之类的）</li><li>type alias，alias template</li></ul><p>using关键字总的来说就是能记录某一个状态</p><ul><li>记录vector的状态：（Vec）的例子，可以完美记录vector需要调用的函数，以及对应的默认函数</li><li>记录一个名字：也就是作为类型别名</li></ul><h1 id="6-template-template-paramber"><a class="markdownIt-Anchor" href="#6-template-template-paramber"></a> 6 Template template paramber</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>,T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">container</span>&gt;<br></code></pre></td></tr></tbody></table></figure><h1 id="7-noexpect"><a class="markdownIt-Anchor" href="#7-noexpect"></a> 7 noexpect</h1><p>定义：保证函数不会丢出异常</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>noexpect</span>;<span class="hljs-comment">//无论如何，函数都不能丢出异常</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span><span class="hljs-title">noexpect</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<span class="hljs-comment">//在某种条件下，函数不会丢出异常</span><br></code></pre></td></tr></tbody></table></figure><p>在使用move语义的时候，记得函数一定不能抛出异常，并且后面加上noexpect</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">mystring</span>(string &amp;&amp;s)noexpect....<br></code></pre></td></tr></tbody></table></figure><h1 id="8-overridefinal"><a class="markdownIt-Anchor" href="#8-overridefinal"></a> 8 override，final</h1><ul><li>override检验是否是原来的函数重载</li><li>final有两个地方<ul><li>阻止子类继承父类的class</li><li>阻止子类继承父类的virtual function</li></ul></li></ul><h1 id="9-decltype"><a class="markdownIt-Anchor" href="#9-decltype"></a> 9 decltype</h1><p>decltype的三种使用方法</p><ul><li>用来声告一个return type</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> Q&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T x,Q y)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ul><li>适用于模板元编程</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string,<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-keyword">decltype</span>(a)::value_type elem;<span class="hljs-comment">//</span><br></code></pre></td></tr></tbody></table></figure><ul><li>传递一个由lambda对象返回的返回值的类型</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> cmp=[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b){<br><span class="hljs-keyword">return</span> a&gt;b;<br>}<br><span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(cmp)</span>&gt; <span class="hljs-title">xx</span><span class="hljs-params">(cmp)</span></span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="10-lambdas"><a class="markdownIt-Anchor" href="#10-lambdas"></a> 10 Lambdas</h1><p>C++ 11允许通过lambda定义一个inline function或功能单元， 他可以被用在local object或者parameter</p><p>lambdas本身就是一个对象，如果要直接调用他，需要加一个括号</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">[]{<br>   std::cout&lt;&lt;<span class="hljs-string">"hello"</span><br>}<br><span class="hljs-comment">//以上这个不能直接调用，如果需要直接调用的话需要按照下面这样写</span><br>[]{<br>   std::cout&lt;&lt;<span class="hljs-string">"hello"</span><br>}();<span class="hljs-comment">//注意这个括号，使用括号能够进行调用</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">auto</span> I=[]{<br>   std::cout&lt;&lt;<span class="hljs-string">"hello"</span><br>}<br><span class="hljs-built_in">I</span>();<span class="hljs-comment">//发生调用</span><br><br></code></pre></td></tr></tbody></table></figure><p>lambda格式回顾</p><figure class="highlight elm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elm">[]()mutable throwspec-&gt;rec<span class="hljs-keyword">type</span>{}<br>/*<br>[] 捕获外部的非static objects<br>() 参数（行为像函数）<br><span class="hljs-title">mutable</span> 可以改动[]里面的数据<br><span class="hljs-title">throwspec</span> 丢出异常<br><span class="hljs-title">rettype</span> 描述返回lambda的返回类型<br>如果mutable throwspec，ret<span class="hljs-keyword">type</span>都没有，则可以不写括号，否则不可以<br>*/<br></code></pre></td></tr></tbody></table></figure><p>[]的特别注意</p><ul><li>[]可以取用外部的变量</li><li>[=]代表pass by value</li><li>[&amp;]代表pass by reference</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> y=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> x=[x,&amp;y]<span class="hljs-comment">//代表y是reference，x是value</span><br><span class="hljs-keyword">auto</span> y=[=,&amp;y]<span class="hljs-comment">//除了y是reference，其他的所有变量都以reference进行传递</span><br><br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span><br><span class="hljs-keyword">auto</span> f=[a]()<span class="hljs-keyword">mutable</span>{<br>    a++;<br>}<br>a=<span class="hljs-number">42</span>;<br><span class="hljs-comment">//但是在调用f完成的时候，a是1，因为a记录的是当时的值</span><br><br><span class="hljs-type">int</span> a=<span class="hljs-number">0</span><br><span class="hljs-keyword">auto</span> f=[&amp;a]()<span class="hljs-keyword">mutable</span>{<br>    a++;<br>}<br>a=<span class="hljs-number">42</span>;<br><span class="hljs-comment">//但是在调用f完成的时候，a是43，因为a记录的是当时的变量的引用</span><br></code></pre></td></tr></tbody></table></figure><p>lambda与stl使用的时候的特别注意</p><ul><li>lambda在与stl库搭配使用的时候，因为lambda没有默认构造函数，没有assignment operator 所以当lambda作为比较函数的时候需要特别注意</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> cmp=[](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b){<span class="hljs-keyword">return</span> a&gt;b;};<br><span class="hljs-function">std::set&lt;<span class="hljs-type">int</span>,<span class="hljs-title">decltype</span><span class="hljs-params">(cmp)</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(cmp)</span></span>;<span class="hljs-comment">//注意这里必须要放cmp，否则就会调用默认的构造函数</span><br></code></pre></td></tr></tbody></table></figure><h1 id="11-rvalue-referencesperfect-forwarding"><a class="markdownIt-Anchor" href="#11-rvalue-referencesperfect-forwarding"></a> 11 Rvalue references，perfect forwarding</h1><p>右值引用就是他做了一个“偷”的动作，将值直接移动，而不是使用一个allocator进行分配然后赋予</p><p>左值只能出现在左边，而右值只能出现在右边</p><p>所有被“偷”的左值，都必须确保后面不再被使用</p><p>copy作一个深拷贝，move则是一个浅拷贝</p><p>对于浅拷贝和深拷贝没有区别的操作，则是否move就是没有区别的。</p><p>move在deque和vector影响最为巨大，其他的则不一定</p><p>move只是交换对应类的指针，如果没有指针，那么效率lei’s</p><p><strong>写移动类函数的三个操作</strong></p><ul><li>传入函数使用 &amp;&amp; ，然后可以使用初始化队列进行构造</li><li>将对应的值设为0</li><li>将其带有的指针设为null（原因：必须设为null，否则会在临时对象调用析构函数的的时候将本来不能析构调的资源析构，导致空悬指针）</li></ul><h1 id="12-hashtable"><a class="markdownIt-Anchor" href="#12-hashtable"></a> 12 hashtable</h1><ul><li><p>hashtable对于C++中unordered的容器，</p></li><li><p>他的基本原理是使用一个可以增长的buckets，每一个bucket是一个指针，指向一个对应的单向链表</p></li><li><p>当元素个数大于buckets个数的时候，buckets的个数会增长到原来的两倍左右，但是是一个素数，然后重新将元素放入</p></li><li><p>如何编写一个万用的hash function：30，25：32</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7-11</title>
    <link href="/posts/63884/"/>
    <url>/posts/63884/</url>
    
    <content type="html"><![CDATA[<h1 id="1-条款-7如果容器中包含了通过-new-操作创建的指针切记在容器对象析构前将指针-delete-掉"><a class="markdownIt-Anchor" href="#1-条款-7如果容器中包含了通过-new-操作创建的指针切记在容器对象析构前将指针-delete-掉"></a> 1 条款 7：如果容器中包含了通过 new 操作创建的指针，切记在容器对象析构前将指针 delete 掉</h1><h2 id="11-知识点-1delete-指针"><a class="markdownIt-Anchor" href="#11-知识点-1delete-指针"></a> 1.1 知识点 1：delete 指针</h2><p>虽然说容器在销毁的时候会对每一个对象进行delete，但是指针不是所谓的“对象”没有析构函数，所以不会做任何事情。如果不对指针进行<br>delete 就会导致资源泄露</p><ul><li><p>解决方法1：在销毁容器之前，使用for循环挨个delete指针</p></li><li><p>解决方法2：编写一个template函数，用来挨个删除，这种方法是类型安全的而不是异常安全的，当有资源泄露的时候还是会出现错误</p><ul><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211012205070.png" alt="|700"></li></ul></li><li><p><strong>解决办法 3：使用智能指针，确保资源不泄露</strong></p></li></ul><h1 id="2-条款-8切勿创建包含-auto-ptr-的对象对于-c11-过时"><a class="markdownIt-Anchor" href="#2-条款-8切勿创建包含-auto-ptr-的对象对于-c11-过时"></a> 2 条款 8：切勿创建包含 auto-ptr 的对象（对于 C++11 过时）</h1><h1 id="3-条款9慎重选择刪除元素的方法"><a class="markdownIt-Anchor" href="#3-条款9慎重选择刪除元素的方法"></a> 3 条款9：慎重选择刪除元素的方法</h1><h2 id="31-知识点-1删除容器对象选择的方法"><a class="markdownIt-Anchor" href="#31-知识点-1删除容器对象选择的方法"></a> 3.1 知识点 1：删除容器对象选择的方法</h2><!-- basicblock-start oid="ObsXkfHY4JDTzAkO7ODfN1Q6" --><p>![[7-10 2022-11-01 22.07.08.excalidraw]]::  ❓ #疑问</p><!-- basicblock-end --><h1 id="4-条款10了解分配子allocator的约定和限制"><a class="markdownIt-Anchor" href="#4-条款10了解分配子allocator的约定和限制"></a> 4 条款10：了解分配子allocator的约定和限制</h1><blockquote><p>快下班了, 没仔细看, 晚上还要打电话: <a href="marginnote3app://note/74C153BA-1566-4B11-9E7F-EC58B9603992">margin: 条款10</a></p></blockquote><p>[[static 关键字|static 关键字]]</p><blockquote><p>[!question]</p></blockquote><h2 id="41-下边都不懂-疑问"><a class="markdownIt-Anchor" href="#41-下边都不懂-疑问"></a> 4.1 下边都不懂::   #疑问</h2><ul><li>确保你的分配子是一个模板，模板参 T 代表你为他分配内存的对象的类型</li></ul><h2 id="42"><a class="markdownIt-Anchor" href="#42"></a> 4.2</h2><ul><li><p>提供类型定义 pointer 和 reference，但是始终让 pointer 为 <code>T*</code>，reference 为 <code>T&amp;</code>，这是标准库所规定的</p></li><li><p>千万不要让你的分配子拥有随对象而不同的状态，通常分配子不应该有非静态类型的数据成员，因为 STL 实现假定同一类型的分配子是等价的</p></li><li><p>传给 allocator 成员函数的是那些要求内存对象的个数，而不是所需要的字节数，同时要记住，这些函数返回 <code>T*</code> 指针（(通过 pointer 类型定义，即使尚未有 T 对象被构造出来</p></li><li><p>通过嵌套的rebind模板，因为标准容器依靠模板取得类的成员的类型来分配内存</p></li></ul><h1 id="5-条款-11理解自定义分配子的合理用法"><a class="markdownIt-Anchor" href="#5-条款-11理解自定义分配子的合理用法"></a> 5 条款 11：理解自定义分配子的合理用法</h1><p>知识点 1：自定义分配子的合适场景</p><ul><li><p>在 <code>alloctor&lt;T&gt;</code> 是线程安全的，你想使用一个单线程的 alloctor，那么就可以考虑定制</p></li><li><p>想建立一个与共享内存相对应的特殊的堆，然后在这块内存中放一个或者多个容器，让其他的进程可以共享这些容器</p></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsIYSf9LLVGK1CFWpN0xqFB"  --> <p>📝7-11::<br>2022/11/1: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3 - 6</title>
    <link href="/posts/6919/"/>
    <url>/posts/6919/</url>
    
    <content type="html"><![CDATA[<h1 id="1-确保容器中的对象拷贝正确且高效"><a class="markdownIt-Anchor" href="#1-确保容器中的对象拷贝正确且高效"></a> 1 确保容器中的对象拷贝正确且高效</h1><h2 id="11-知识点-1拷贝对象时-stl-的工作方式"><a class="markdownIt-Anchor" href="#11-知识点-1拷贝对象时-stl-的工作方式"></a> 1.1 知识点 1：拷贝对象时 STL 的工作方式</h2><p>首先我们可以认为，STL 的工作方式为拷贝（但是在 C<ins>11 中，这种工作方式需要再加上一个，移动）<br>在 C</ins>11 中，对于一个左值，我们依然会调用拷贝构造函数进行创建，<br>但是对于一个临时创建出来的变量或者纯右值就会调用<strong>移动构造函数</strong><br>![[3. 确保容器中的对象拷贝正确且高效 2022-11-01 21.33.12.excalidraw]]</p><h2 id="12-知识点-2了解基类的容器不能承载继承类"><a class="markdownIt-Anchor" href="#12-知识点-2了解基类的容器不能承载继承类"></a> 1.2 知识点 2：了解基类的容器不能承载继承类</h2><p>因为上面的原因可以看的出来，基类的容器是无法装在继承类的，如果装载了继承类那么原来继承类的数据就面临丢失的风险。因为调用的是基类的拷贝构造函数。<br><strong>如果希望插入后的对象依然表现的像派生类对象一样那么可以考虑使用指针或者智能指针</strong>，这样有两个好处</p><p>拷贝指针的速度非常快：可以快速的通过指针去排序，而不用调用一大堆的拷贝构造函数等等拖慢速度</p><p>保留对象的“继承性”通过动态鄉定，指针可以让其调用virtual函数，从而完整的保留派生类及其特性</p><h1 id="2-条款-4调用-empty-而不是检查-size-是否为-0"><a class="markdownIt-Anchor" href="#2-条款-4调用-empty-而不是检查-size-是否为-0"></a> 2 条款 4：调用 empty 而不是检查 size 是否为 0</h1><p>原因：empty在大多数标准容器都是常数时间操作，而对于一些list的实现，size会耗费线性时间（主要是list)</p><h1 id="3-条款5区间成员函数优先于与之对应的单元素成员函数"><a class="markdownIt-Anchor" href="#3-条款5区间成员函数优先于与之对应的单元素成员函数"></a> 3 条款5：区间成员函数优先于与之对应的单元素成员函数</h1><h2 id="31-知识点-1优先考虑区间成员函数-说的应该是本身的函数吧"><a class="markdownIt-Anchor" href="#31-知识点-1优先考虑区间成员函数-说的应该是本身的函数吧"></a> 3.1 知识点 1：优先考虑区间成员函数 (❓说的应该是本身的函数吧)</h2><ul><li>区间成员函数的定义：使用两个迭代器作为参数传入的函数</li><li>使用区间成员函数的好处<ul><li>使得代码更加容易被理解，copy函数总比使用for循环好理解的多</li><li>使用合适的区间成员函数可以大幅减少完成工作的时间。提升效率</li><li>使用区间成员函数的效率，最差为和for循环一样，比如说对istream使用的时候2者相同，但大多数比这个好</li></ul></li></ul><h2 id="32-知识点-2使用区间成员函数的时候优先考虑非泛型函数"><a class="markdownIt-Anchor" href="#32-知识点-2使用区间成员函数的时候优先考虑非泛型函数"></a> 3.2 知识点 2：使用区间成员函数的时候，优先考虑非泛型函数</h2><ul><li>所有的标准容器都提供了以下几个构造函数</li><li>区间创建函数</li><li>区间插入函数insert</li><li>区间删除函数erase</li><li>区间赋值函数assign</li><li>可以考虑优先选用stl自带的函数，毕竟大多数时候自己人更懂自己人，效率更高速度更快</li></ul><!-- basicblock-start oid="ObsX6etbGlWFX1CmiDr8IoTr" --><h1 id="4-条款-6当心-c编译器最烦人的分析机制情景-疑问"><a class="markdownIt-Anchor" href="#4-条款-6当心-c编译器最烦人的分析机制情景-疑问"></a> 4 条款 6：当心 C++编译器最烦人的分析机制情景::  ❓ #疑问</h1><!-- basicblock-end --><p>![[3. 确保容器中的对象拷贝正确且高效 2022-11-01 21.51.48.excalidraw]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs5fZhWJNGQM2nuIT2vTSK5" --> <p>📝3 - 6::<br>2022/11/1 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 不要试图编写独立于容器类型的代码</title>
    <link href="/posts/4728/"/>
    <url>/posts/4728/</url>
    
    <content type="html"><![CDATA[<p>📝2. 不要试图编写独立于容器类型的代码::<br>2022/11/1: 第一次创建</p><!-- basicblock-end --><h1 id="1-知识点-1容器是泛化的但是不能泛化容器"><a class="markdownIt-Anchor" href="#1-知识点-1容器是泛化的但是不能泛化容器"></a> 1 知识点 1：容器是泛化的，但是不能泛化容器</h1><blockquote><p>[!summary] 不要自己创造容器<br>STL 容器是以泛化为基础的，每一个容器都有着对应独特的数据结构与算法<br>我们不能尝试泛化容器，创造出一个可以任意使用的容器，那种容器不好用，因为他只能使用所有容器的交集部分，这可提供的操作就已经很少了</p></blockquote><h1 id="2-如识点-2封装容器让容器的类型转换变得容易"><a class="markdownIt-Anchor" href="#2-如识点-2封装容器让容器的类型转换变得容易"></a> 2 如识点 2：封装容器，让容器的类型转换变得容易</h1><p>前言：很多时候我们可能会发现一种其他的容器类型比现在用的容器类型好很多，但是更改所有的容器名称非常麻烦，这个时候我们需要通过封装让容器的转换变得容易</p><blockquote><p>[!question] 到底怎么弄的呢<br>我们可以使用类型定义进行封装 (typedef)<br>通过类型定义这样的封装，虽然仅仅是名字上的，但是如果改变容器，那么后续操作起来会非常方便::   #疑问</p></blockquote><p>![[2. 不要试图编写独立于容器类型的代码 2022-11-01 20.58.14.excalidraw]]</p><h1 id="3-知识点-3"><a class="markdownIt-Anchor" href="#3-知识点-3"></a> 3 知识点 3：</h1><p>再进一步封装容器如果要想減少在替换容器类型时所需要修改的代码，那么就可以考虑把容器隐藏到一个类中去，</p><p>并尽量减少那些通过类接口 (而使外部) 可见的，与容器相关的信息</p><p>这么做的好处就是，将容器隐藏于类中并且开放一些接口，当在更换容器的时候，只需要更改该类开放的接口就行，不需要代码全局搜泰去修改直接使用该容器及其成员函数的地方，工作量会減少很多</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务隔离(目录)</title>
    <link href="/posts/58268/"/>
    <url>/posts/58268/</url>
    
    <content type="html"><![CDATA[<p>📝事务隔离(目录)::</p><!-- basicblock-end --><h1 id="1-事务并发问题"><a class="markdownIt-Anchor" href="#1-事务并发问题"></a> 1: [[事务并发问题]]</h1><h1 id="2-事务隔离级别-解决事务并发问题"><a class="markdownIt-Anchor" href="#2-事务隔离级别-解决事务并发问题"></a> 2: [[事务隔离级别 (解决事务并发问题)]]</h1><h1 id="3-数据库对隔离级别的实现"><a class="markdownIt-Anchor" href="#3-数据库对隔离级别的实现"></a> 3: 数据库对隔离级别的实现</h1><p>DB 会创建⼀个视图<br>未提交读： 直接返回记录上的最新值，没有视图概念<br>提交读： 视图在每个 SQL 语句开始执⾏的时候创建的。<br>可重复读：视图在事务启动时创建，整个事务存在期间都⽤这个视图。<br>可串⾏化读： 直接⽤加锁的⽅式来避免并⾏访问</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务目录</title>
    <link href="/posts/19535/"/>
    <url>/posts/19535/</url>
    
    <content type="html"><![CDATA[<p>📝事务目录::</p><!-- basicblock-end --><h1 id="1-事务简介"><a class="markdownIt-Anchor" href="#1-事务简介"></a> 1: 事务简介</h1><h2 id="11-事务的四大特性-acid目录"><a class="markdownIt-Anchor" href="#11-事务的四大特性-acid目录"></a> 1.1: [[事务的四大特性  ACID(目录)]]</h2><blockquote><p>[!tip]<br>注意: 默认 MySQL 的事务是自动提交的, 也就是说, 当执行完一条 [[DML]] 语句时,MySQL 会立即隐式的提交事务。</p></blockquote><h1 id="2-事务操作"><a class="markdownIt-Anchor" href="#2-事务操作"></a> 2: [[事务操作]]</h1><h1 id="3-事务隔离目录"><a class="markdownIt-Anchor" href="#3-事务隔离目录"></a> 3: [[事务隔离(目录)]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多表查询的分类</title>
    <link href="/posts/52518/"/>
    <url>/posts/52518/</url>
    
    <content type="html"><![CDATA[<h1 id="1-多表查询的分类"><a class="markdownIt-Anchor" href="#1-多表查询的分类"></a> 1 多表查询的分类</h1><ul><li>连接查询<ul><li>内连接:相当于查询A、B交集部分数据</li><li>外连接:<ul><li>左外连接:查询左表所有数据,以及两张表交集部分数据</li><li>右外连接:查询右表所有数据,以及两张表交集部分数据</li></ul></li><li>自连接:当前表与自身的连接查询,自连接必须使用表别名</li></ul></li><li>子查询</li></ul><h2 id="11-内连接"><a class="markdownIt-Anchor" href="#11-内连接"></a> 1.1 [[内连接]]</h2><h2 id="12-外连接"><a class="markdownIt-Anchor" href="#12-外连接"></a> 1.2 [[外连接]]</h2><h2 id="13-自连接"><a class="markdownIt-Anchor" href="#13-自连接"></a> 1.3 [[自连接]]</h2><h2 id="14-子查询简介"><a class="markdownIt-Anchor" href="#14-子查询简介"></a> 1.4 [[子查询简介]]</h2><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs7UnOFT70mUEXOCMQh2CbO"  --> <p>📝多表查询的分类::<br>2022/11/1: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 慎重选择容器类型</title>
    <link href="/posts/35660/"/>
    <url>/posts/35660/</url>
    
    <content type="html"><![CDATA[<p>📝1. 慎重选择容器类型::</p><!-- basicblock-end --><h1 id="1-条款-1-慎重选择容器类型"><a class="markdownIt-Anchor" href="#1-条款-1-慎重选择容器类型"></a> 1 条款 1: 慎重选择容器类型</h1><h2 id="11-知识点-1-stl-容器的类型"><a class="markdownIt-Anchor" href="#11-知识点-1-stl-容器的类型"></a> 1.1 知识点 1: STL 容器的类型</h2><ul><li>标准 STL <strong>序列容器</strong>:<ul><li>array</li><li>string</li><li>vector<ul><li><code>vector&lt;char&gt;</code> 可作为 string 的替代, <code>vector&lt;int&gt;同理</code></li><li>question vector 作为标准关联容器的替代。</li></ul></li><li>list<ul><li>forward-list (单项列表)</li></ul></li><li>deque</li></ul></li><li>标准 STL 关联容器: set mutiset map mutimap</li><li>几种标准的非STL容器<ul><li>非标准序列容器: rope, 本质上是一个重型 string</li><li>非标准关联容器: hash-set,hash-mutiset ,hash-map,hash-mutimap</li></ul></li></ul><p>#疑问</p><h2 id="12-知识点2关于容器选择的考虑点"><a class="markdownIt-Anchor" href="#12-知识点2关于容器选择的考虑点"></a> 1.2 知识点2:关于容器选择的考虑点</h2><h3 id="121"><a class="markdownIt-Anchor" href="#121"></a> 1.2.1</h3><ul><li>是否需要在容器的任意位置插入元素？是：选<strong>序列容器而</strong>不是关联容器</li></ul><h3 id="122"><a class="markdownIt-Anchor" href="#122"></a> 1.2.2</h3><ul><li>是否关系容器的排序？是：考虑哈希容器</li></ul><h3 id="123"><a class="markdownIt-Anchor" href="#123"></a> 1.2.3</h3><ul><li>容器是否必须是 C++标准库的一部分？是：排除哈希容器，rope 等非标准库容器</li></ul><h3 id="124"><a class="markdownIt-Anchor" href="#124"></a> 1.2.4</h3><ul><li>需要何种类型的迭代器？<ul><li>随机：从 vector string deque 中选择</li><li>双向：list</li></ul></li></ul><h3 id="125"><a class="markdownIt-Anchor" href="#125"></a> 1.2.5</h3><ul><li>当发生插入或者删除的操作的时候，是否需要避免连续内存的容器？是：避免他<br>就是 STL 序列容器</li></ul><h3 id="126"><a class="markdownIt-Anchor" href="#126"></a> 1.2.6</h3><ul><li>是否介意容器中的引用计数技术？是：避免使用 string, rope</li></ul><h3 id="127"><a class="markdownIt-Anchor" href="#127"></a> 1.2.7</h3><ul><li>对于插入和删除，是否需要回滚的能力吗？是：使用基于节点的容器</li></ul><h3 id="128"><a class="markdownIt-Anchor" href="#128"></a> 1.2.8</h3><ul><li>是否需要让迭代器和指针以及引用变为无效的次数最少吗？是：使用基于节点的容器</li></ul><h3 id="129"><a class="markdownIt-Anchor" href="#129"></a> 1.2.9</h3><ul><li>对于使用 swap 让迭代器指针或引用变为无效，是否重要？是：避免使用 string</li></ul><h3 id="1210"><a class="markdownIt-Anchor" href="#1210"></a> 1.2.10</h3><ul><li>容器的数据布局是否需要和 C 兼容？是：只能用 vector</li></ul><h3 id="1211"><a class="markdownIt-Anchor" href="#1211"></a> 1.2.11</h3><ul><li>元素查找的时候速度是否是关键因素？是：考虑哈希容器</li></ul><h3 id="1212"><a class="markdownIt-Anchor" href="#1212"></a> 1.2.12</h3><p>如果序列容器的迭代器是随机访问类型，而且只要没有删除操作发生，且插入操作只发生在容器的末尾，则指向数据的指针和引用就不会变为无效，这样的容器是否对你有帮助？</p><p>是：考虑deque(deque在重复插入后方元素的时候，迭代器会失效，但是指针和引用不会，<br>- tip deque 是唯一的，迭代器会失效但是指针和引用不会失效的容器</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第3章 异常处理 Exceptions</title>
    <link href="/posts/11196/"/>
    <url>/posts/11196/</url>
    
    <content type="html"><![CDATA[<p>📝第3章 异常处理 Exceptions::</p><!-- basicblock-end --><h1 id="1-9-利用-destructors-避免泄露资源"><a class="markdownIt-Anchor" href="#1-9-利用-destructors-避免泄露资源"></a> 1 9. 利用 destructors 避免泄露资源</h1><p>尽量用析构函数来释放资源</p><p>用对象来管理资源的构造、析构。避免程序在资源声明和释放之间发生异常时，无法释放资源。</p><ol><li><strong>用智能指针来管理类中的指针资源也不错, 这本书有点老了, 现在有了智能指针了</strong></li></ol><h1 id="2-10-在-constructors-内阻止资源泄露resource-leak"><a class="markdownIt-Anchor" href="#2-10-在-constructors-内阻止资源泄露resource-leak"></a> 2 10. 在 constructors 内阻止资源泄露（resource leak)</h1><p>用函数<strong>try语句块来确保构造函数</strong>不抛出异常、用智能指针来管理类中的指针资源避免手动释放。</p><blockquote><p>用 try 语句用的不多</p></blockquote><p>TITLE：在constructors内阻止资源泄露（resource leak)</p><ol><li>注意没有构造完成的对象，是无法被析构的（就是不会调用析构函数）</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><br>Blob&lt;T&gt;::<span class="hljs-built_in">Blob</span>(initializer_list&lt;T&gt; il) <span class="hljs-keyword">try</span>: <span class="hljs-built_in">data</span>(make_shared&lt;vector&lt;T&gt;&gt;(il) {<br><br><span class="hljs-comment">// 函数体</span><br><br>} <span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::bad_alloc &amp;e) { <span class="hljs-built_in">handle_out_of_memory</span>(e); }<br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-12-抛出一个-exceptions-和传递一个参数或调用一个虚函数之间的差异"><a class="markdownIt-Anchor" href="#3-12-抛出一个-exceptions-和传递一个参数或调用一个虚函数之间的差异"></a> 3 12. 抛出一个 exceptions 和传递一个参数或调用一个虚函数之间的差异</h1><p>函数接收实参或对象调用虚函数 和 将对象抛出成为一个exception时的三种不同：</p><ol><li>当对象被当成exception throw时，一定会被复制且以静态类型为本<ol><li>throw Obj 和 throw 的区别：前者抛出Obj的副本，后者抛出其原本。</li><li>捕获异常时<code>catch(Base&amp; ex)</code>，用形参<code>non-const reference</code>可以捕获所有异常（包括<code>const BaseObj</code>)。 但是注意，普通函数<code>func(Base&amp; pram)</code> 的形参<code>param</code>是不能接受<code>底层const</code>的<code>BaseObj</code>实参的。p65页</li></ol></li><li>函数接收实参时允许的类型转换挺多的，exception只允许两种类型转换：<ol><li><code>catch(runtime_error*)</code> 和可以捕获继承架构中的类型转换，比如可以捕获overflow_error类型的异常。p67</li><li>catch(const void*)可以捕获任何指针类型的exception。p67</li></ol></li><li>catch子句是按照出现顺序匹配异常的，而函数是按照形参实参匹配度匹配函数的</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">catch</span>(Base&amp; ex) {<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">throw</span> ex; <span class="hljs-comment">// 如果ex是Drived，抛出的是副本（ex会被复制一次），且类型是其静态类型</span><br>    <span class="hljs-keyword">throw</span>;    <span class="hljs-comment">// 如果ex是Drived，抛出的是原本（没有复制），且类型是Drived   p64</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">C++ 异常处理 | 菜鸟教程</a><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211011139539.png" alt="|600"></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
      <category>More Effective Cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第2章 操作符 Operators</title>
    <link href="/posts/58249/"/>
    <url>/posts/58249/</url>
    
    <content type="html"><![CDATA[<p>📝第2章 操作符 Operators::</p><!-- basicblock-end --><h1 id="1-5-两种可能的类型转换的函数保持警觉"><a class="markdownIt-Anchor" href="#1-5-两种可能的类型转换的函数保持警觉"></a> 1 5. 两种可能的“类型转换的”函数保持警觉</h1><ul><li>单变量 (或其他变量有默认参数）构造函数 ctor：可能触发不必要的隐式转换，所以尽量用 explict 修饰</li><li>隐式类型转换符最好只有 bool 类型，其他类型的用别名函数代替（asDouble）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rational</span>{<br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> number, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>); <span class="hljs-comment">// 💡只有一个形参变量被赋予了初值: 单变量</span><br>    <span class="hljs-comment">// 推荐：exlicit Rational(int number， int denominator = 1);</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 推荐： opeartor asDouble() const;</span><br>};<br><br><span class="hljs-function">Rational <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// 1/2</span><br><span class="hljs-comment">// 没有定义 opeartor&lt;&lt;，为了让&lt;&lt;调用成功而默认执行了 double()</span><br>cout &lt;&lt; r &lt;&lt; endl;   <span class="hljs-comment">// r-&gt;double-&gt; 0.5;</span><br></code></pre></td></tr></tbody></table></figure><h1 id="2-6-increment-和-decrement-的两种类型且尽量用前置来定义后置"><a class="markdownIt-Anchor" href="#2-6-increment-和-decrement-的两种类型且尽量用前置来定义后置"></a> 2 6. increment 和 decrement 的两种类型，且尽量用<strong>前置来定义后置</strong></h1><p>前置++/–, 后置++/-- 问题</p><ol><li>前置返回引用。 UPInt&amp; operator++();</li><li>后装返回常量对象，从而避免使得++++运算符合法化。 const UPInt operator–(int);</li></ol><h1 id="3-7-不要重载-逗号运算符会让用户误以为重载的运算符还保持短路语义"><a class="markdownIt-Anchor" href="#3-7-不要重载-逗号运算符会让用户误以为重载的运算符还保持短路语义"></a> 3 7. <strong>不要重载&amp;&amp;、||、逗号运算符</strong>，会让用户误以为重载的运算符还保持短路语义</h1><p>重载过后不能很好的保持语义</p><h1 id="4-8-不同意义的-new-和-delete-操作符"><a class="markdownIt-Anchor" href="#4-8-不同意义的-new-和-delete-操作符"></a> 4 8. 不同意义的 new 和 delete 操作符</h1><ol><li>new operator通常包含<strong>分配内存+构造对象</strong>的语义，调用operator new() 实现<ol><li>特别的一种new operator，定位new实现【new (targetNeedConstructPtr) Base(ctorParams)】，调用特殊的operator</li></ol></li><li>delete operator操作符也是类似的，有类似的opeator delete来实现</li></ol><blockquote><p>[!tip] 总结：不能改变 new op 和 delete op 的语义，但可以改变其构造的细节。</p></blockquote><p>todo疑问：某种不是new出来的ptr，如sharedMemory，不能用delete和析构释放</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
      <category>More Effective Cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自动操作</title>
    <link href="/posts/3370/"/>
    <url>/posts/3370/</url>
    
    <content type="html"><![CDATA[<ol><li><p>在 启动台 中搜索 自动操作<br><img src="https://bbs-upload.marginnote.cn/original/2X/9/9e681be823e66ecc319bac08f8855cc0dfbcb977.jpeg" alt="image|600"></p></li><li><p>选择新建, 文稿类型选择应用程序</p><p>[<img src="https://bbs-upload.marginnote.cn/optimized/2X/2/2f039b08452916062577a788cdf9a5018e9c7dd8_2_602x500.jpeg" alt="image"></p></li><li><p>在 操作 中搜索 shell ,并选中 shell</p><p>[<img src="https://bbs-upload.marginnote.cn/optimized/2X/9/960963ffe5615e613c59b530119381d7c68f95b0_2_602x500.jpeg" alt="image"></p></li><li><p><code>复制 “DYLD_INSERT_LIBRARIES=~/Documents/mouse3_Release.dylib /Applications/MarginNote\ 3.app/Contents/MacOS/MarginNote\ 3” 到输入框中</code>  [<img src="https://bbs-upload.marginnote.cn/optimized/2X/6/64f62d1c75356d718a9f4b4bd488320d2756aac4_2_690x210.png" alt="image"></p></li></ol><blockquote><p>[!tip]<br>此处的~/Documents 是<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211011037928.png" alt=""></p></blockquote><ol start="5"><li>菜单栏选择 <strong>文件</strong> - <strong>保存</strong> 命名为 <strong>MN</strong> , 保存到 <strong>应用程序</strong> 目录</li><li>以后就可以使用 MN.app 启动程序了</li></ol><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsW3SEIIrOlj2ajB9BaxZIu"  --> <p>📝自动操作::<br>2022/11/1: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>mac</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实验结果分析</title>
    <link href="/posts/11821/"/>
    <url>/posts/11821/</url>
    
    <content type="html"><![CDATA[<p>2022/10/30:<br>![[实验结果分析 2022-10-30 21.56.33.excalidraw|2600]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsN9TkWf8CyhRcCVrjmz3RT"  --> <p>📝实验结果分析::<br>2022/10/30: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第1章 基础议题 Basic</title>
    <link href="/posts/15473/"/>
    <url>/posts/15473/</url>
    
    <content type="html"><![CDATA[<p>📝第1章 基础议题 Basic::</p><!-- basicblock-end --><h1 id="1-1-区别-pointer-和-reference-指针与引用"><a class="markdownIt-Anchor" href="#1-1-区别-pointer-和-reference-指针与引用"></a> 1 1. 区别 Pointer 和 Reference (指针与引用)</h1><ol><li>Pointer：可能会不指向任何对象、可以换绑</li><li>Refer：一定绑定了一个对象、不可以换绑、<ol><li>opertor[] 等操作符通常返回引用: 返回原对象让你去修改</li></ol></li></ol><h1 id="2-2-最好使用-c-转型操作符-强制类型转换"><a class="markdownIt-Anchor" href="#2-2-最好使用-c-转型操作符-强制类型转换"></a> 2 2. 最好使用 C++ 转型操作符 (强制类型转换)</h1><p>不要用 (int) expre 等等形式的，<br>要使用 static_cast、dynamic_cast、const_cast、reinterpret_cast（强转）</p><ol><li>static_cast：类型转换</li><li>const_cast：去除变量底层的常量性</li><li><strong>dynamic_cast：涉及继承体系的指针和引用的转换</strong></li><li>reinterpret_cast：常用于函数指针的转换但不保证转换后能转换回来 p15</li></ol><h1 id="3-3-不用以多态的方法处理数组"><a class="markdownIt-Anchor" href="#3-3-不用以多态的方法处理数组"></a> 3 3. 不用以多态的方法处理数组</h1><ol><li>传入 base 数组或传入 subbase 数组会导致 关于指针的计算表达式 结果出错</li><li>sun 在工程形态上面用的就很少。💡因为实际工程上很难一开始就确定数组的大小</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> Base array[] )</span> </span>{ <span class="hljs-comment">// const SubBase array[]</span><br><br><span class="hljs-comment">// *(array + i); // ptr + sizeOf(Base) , sizeOf(SubBase) 会不一样</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="4-4-非必要不要设定-default-constructor-ctor"><a class="markdownIt-Anchor" href="#4-4-非必要不要设定-default-constructor-ctor"></a> 4 4. 非必要不要设定 default constructor (ctor)</h1><table data-zone-container="*" data-ace-table-col-widths="298;572"><tbody><tr><td contenteditable="false" data-gramm="false"><p>好处​</p></td><td contenteditable="false" data-gramm="false"><p>坏处​</p></td></tr><tr><td contenteditable="false" data-gramm="false"><ol data-origin-start="1" start="1" data-start="1"><li start="1" data-start="1">每个实例化出的对象都是用户要的对象​</li></ol><p>​</p></td><td contenteditable="false" data-gramm="false"><ol data-origin-start="1" start="1" data-start="1"><li start="1" data-start="1">想用 Base 的数组。但是因为无法构造 Base base[]，必须得用 Base* array[]，同时不用了还得手动析构 array 对应的对象​</li></ol><ol start="2" data-start="2"><li start="2" data-start="2">因为可能会调用默认 ctor，有些模板函数如果依赖默认的构造函数就不能用了。p22​</li></ol></td></tr><tr><td colspan="2" contenteditable="false" data-gramm="false"><p>大话孙的实践表明：大多时候还是要默认的构造函数的。​</p></td><td colspan="0" contenteditable="false" data-gramm="false"><p>​</p></td></tr></tbody></table>Operators 操作符]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>Effective C++</category>
      
      <category>More Effective Cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>并发</title>
    <link href="/posts/52510/"/>
    <url>/posts/52510/</url>
    
    <content type="html"><![CDATA[<h1 id="1-stdthread"><a class="markdownIt-Anchor" href="#1-stdthread"></a> 1: std::thread</h1><p>![[并发 2022-10-29 21.08.58.excalidraw]]</p><p>注意:<br>可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detached.</p><blockquote><p>[!note] std:: thread 在使用上容易出错, 即 std:: thread 对象在线程函数运行期问必须是有效的。什么意思呢?<br>![[并发 2022-10-29 21.15.23.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsnytchIGEC10YfxZk04VcH" --><h1 id="2-lock_guard"><a class="markdownIt-Anchor" href="#2-lock_guard"></a> 2: lock_guard::</h1><!-- basicblock-end --><blockquote><p>[!cite]<br>lock guard 是一个互斥量包装程序,<br>它提供了一种方便的 RAII (Resource acquisition is initialization ) 风格的机制来在作用域块的持续时间内拥有一个互斥量。</p></blockquote><p>创建 lockguard 对象时, 它将尝试获取提供给它的互斥锁的所有权。<br>当控制流离开lockguard对象的作用域时, lock_guard析构并释放互斥量。<br>它的特点如下:</p><ol><li>创建即加锁, 作用域结束自动析构并解锁, 无需手工解锁</li><li>不能中途解锁, 必须等作用域结束才解锁</li><li>不能复制</li></ol><!-- basicblock-start oid="ObsAB7Yjv2ipvPHzEQG0BdWw" --><h1 id="3-unique_lock"><a class="markdownIt-Anchor" href="#3-unique_lock"></a> 3: unique_lock::</h1><!-- basicblock-end --><p>![[lock_guard &amp;  unique_lock.excalidraw]]</p><p>unique lock 是一个通用的互斥量锁定包装器, 它允许延迟锁定, 限时深度锁定, 递归锁定, 锁定所有权的转移以及与条件变量一起使用。</p><p><strong>简单地讲,uniquelock 是 lockguard 的升级加强版</strong>,它具有 lock guard 的所有功能,同时又具有其他很多方法, 使用起来更强灵活方便,能够应对更复杂的锁定需要。</p><p>特点如下:</p><ol><li>创建时可以不锁定 (通过指定第二个参数为 std:deferlock), 而在需要时再锁定</li><li>可以随时加锁解锁</li><li>作用域规则同 lock_ grard,析构时自动释放锁</li><li>不可复制,可移动</li><li>条件变量需要该类型的锁作为参数 (此时必须使用 unique_lock)<ol><li>因为这是函数调用, unique_lock 可以提供右值引用, 把参数传递过去</li></ol></li></ol><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsyz7cuYkjWPL44y5SgWO20"  --> <p>📝并发:: <a href="https://www.bilibili.com/video/BV1D5411m73k/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">再谈lock_guard和unique_lock_ev_哔哩哔哩_bilibili</a><br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lambda表达式</title>
    <link href="/posts/40490/"/>
    <url>/posts/40490/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><p>lambda 表达式表示一个可调用的代码单元, 没有命名的内联函数, 不需要函数名因为我们直接 (一次性的) 用它, 不需要其他地方调用它。</p><p>只有调用的时候才会创建函数对象</p><p>![[lambda表达式 2022-10-29 20.15.40.excalidraw]]</p><h1 id="2-lambda-表达式的语法"><a class="markdownIt-Anchor" href="#2-lambda-表达式的语法"></a> 2 lambda 表达式的语法:</h1><p>变量捕获是成就 lambda 卓越的秘方</p><ul><li>[]不捕获任何变量, 这种情况下 lambda 表达式内部不能访问外部的变量</li><li>[=]用值的方式捕获所有变量 (创建时拷贝, 修改对 lambda 内对象无影响)<ul><li>[bar]以值方式捕获 bar; 不捕获其它变量</li><li>[=, &amp;foo]以引用捕获变量 foo 但其余变量都靠值捕获</li></ul></li><li>[&amp;]以引用方式捕获所有变量 (保证 lambda 执行时变量存在)<ul><li>[&amp;, foo]以值捕获 foo 但其余变量都靠引用捕获</li></ul></li><li>[this]捕获所在类的 this 指针</li><li></li></ul><p>![[lambda表达式语法.excalidraw]]</p><h1 id="3-lambda-表达式的特点"><a class="markdownIt-Anchor" href="#3-lambda-表达式的特点"></a> 3 lambda 表达式的特点</h1><p>lambda 最大的一个优势是在使用 STL 中的算法 (algorithms) 库<br>加一个头文件: <code>#include&lt;algorithms&gt;</code></p><!-- basicblock-start oid="ObsTPRYeWGDoLqFDOpyNFKXg" --><blockquote><p>[!question]<br>例如: 数组排序::   #疑问</p></blockquote><!-- basicblock-end --><p>![[lambda表达式 2022-10-29 19.54.39.excalidraw]]</p><p>for_each (num.frist, num.end, function) 函数: 从数第一个元素, 至最后一个元素, 都用 function 函数<br>下面是函数模版<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210292039504.png" alt="|700"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObssYmeweVPeea9Hi7FENITg"  --> <p>📝lambda表达式:: <a href="marginnote3app://note/71C984C7-6EAA-4C45-8F77-C98F0C071A51">margin: lambda表达式</a><br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列表初始化</title>
    <link href="/posts/43212/"/>
    <url>/posts/43212/</url>
    
    <content type="html"><![CDATA[<h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h1><p><strong>采用花括号来进行初始化</strong>称为列表初始化, 无论是初始化对象还是为对象赋新值。<br>C++定义了几种初始化方式, 例如对一个 int 变量 x 初始化为 0:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>; <br><span class="hljs-type">int</span> x={<span class="hljs-number">0</span>}; <br><span class="hljs-type">int</span> x{<span class="hljs-number">0</span>}; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><br><br><br></code></pre></td></tr></tbody></table></figure><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h1><p>用于对内置类型变量时, 如果使用列表初始化, 且初始值存在丢失信息风险时, 编译器会报错。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> d =<span class="hljs-number">3.1415926536</span>; <br><span class="hljs-type">int</span> a= {d}; <span class="hljs-comment">//💡存在丟失信息风险,转换未执行。</span><br><span class="hljs-type">int</span> a = d;  <span class="hljs-comment">//确实丢失信息,转换执行。</span><br><br></code></pre></td></tr></tbody></table></figure><p>补充一个: 列表初始化 (不是新特性)<br>函数特化<br>![[函数特化.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsb9ANO3LKXzFrWSVlzu313"  --> <p>📝列表初始化::<br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>范围 for 循环</title>
    <link href="/posts/20332/"/>
    <url>/posts/20332/</url>
    
    <content type="html"><![CDATA[<p>基于范围的选代写法,for (变量: 对象) 表达式</p><h1 id="1-对基本类型遍历"><a class="markdownIt-Anchor" href="#1-对基本类型遍历"></a> 1 对基本类型遍历</h1><p>对 string 对象的每个字符做一些操作:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">str</span> <span class="hljs-params">(<span class="hljs-string">"some thing"</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) cout&lt;&lt;c&lt;&lt;endl; <span class="hljs-comment">// 对字符串str中的每个字符进行cout操作。</span><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-type">int</span> A[<span class="hljs-number">10</span>] = {<span class="hljs-number">0</span>}<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) { <span class="hljs-comment">// 遍历每一个数值</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-对-vector-进行遍历"><a class="markdownIt-Anchor" href="#2-对-vector-进行遍历"></a> 2 对 vector 进行遍历:</h1><p>vector</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator i = arr.<span class="hljs-built_in">begin</span>(); i != arr.<span class="hljs-built_in">end</span>(); ++i) {<br>cout&lt;&lt;*i&lt;&lt;endl;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>❗️ 有关 vector 容器的数据就不要用这种 for 循环了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">范围<span class="hljs-keyword">for</span>:<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : arr) {<br>cout&lt;&lt;i&lt;&lt;endl;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsFbkquY5DAflujHPGIE08I"  --> <p>📝范围 for 循环::<br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nullptr</title>
    <link href="/posts/1200/"/>
    <url>/posts/1200/</url>
    
    <content type="html"><![CDATA[<p>nullptr 是用来代替 NULL, 一般 C<ins>会把 NULL、0 视为同一种东西, 这取决去编译器如何定义 NULL, 有的定义为 (void*) 0), 有的定义为 0<br>C</ins>不允许直接将 <code>void*</code>隐式转换到其他类型, 在进行 C++重载时会发生混乱</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">char</span> *)</span></span>; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> )</span></span>;<br><br></code></pre></td></tr></tbody></table></figure><p>如果 NULL 被定义为 <code>((void*) 0)</code> 那么当编译 <code>char *ch = NULL</code> 时, NULL 被定义为 0。</p><p>当 foo (NULL) 时, 此时 NULL 为 0, 会去调用 foo (int ), 从而发生混乱<br>为解决这个问题, 从而需要使用 NULL 时, 用 nullptr 代替:<br>C++11 引入 nullptr 关键字来区分 <code>空指针和 0</code>。</p><p>nullptr 的类型为 nullptr_t, <strong>能够转换为任何指针或成员指针的类型,</strong> 也可以进行相等或不等的比较。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZPxVaN0w4RCQPyzPbrDDp"  --> <p>📝nullptr::<br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>左右值引用(目录)</title>
    <link href="/posts/62414/"/>
    <url>/posts/62414/</url>
    
    <content type="html"><![CDATA[<p>📝左右值引用:: <a href="marginnote3app://note/D712A772-10A2-4337-8F11-A8DEB29AA98A">margin: 右值引用</a><br>2022/10/29: 第一次创建</p><!-- basicblock-end --><h1 id="1-左右值的概念"><a class="markdownIt-Anchor" href="#1-左右值的概念"></a> 1: 左右值的概念</h1><p>在C++11中所有的值必属于左值、右值两者之一，<br>右值又可以细分为纯右值、将亡值。</p><blockquote><p>[!note] 如何判断<br>在C++11中可以取地址的、有名字的就是左值，<br>反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</p><blockquote><p>[!example]- 举个例子<br>int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；<br>表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。<br>![[左右值引用 2022-10-29 17.04.42.excalidraw]]</p></blockquote></blockquote><blockquote><p>[!principle] 定义</p><ul><li>左值是指<strong>表达式结束后依然存在的持久化对象</strong>，<ul><li>左值: 可以放在等号左边, 可以取地址并由名字</li></ul></li><li>右值是指<strong>表达式结束后就不再存在的临时对象</strong>。<ul><li>右值: 不可以放在 i 等号左边, 不能取地址, 没有名字</li></ul></li><li></li><li>左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值</li><li>右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</li></ul></blockquote><!-- basicblock-start oid="ObsFxLY3KAnBRIMHjrhVv4x5" --><blockquote><p>[!question]<br><ins>i、–i 是左值, i</ins>、i–是右值<br>字符串字面值"abcd"也是左值, 不是右值<br>::  ❓ #疑问</p></blockquote><!-- basicblock-end --><h2 id="11-右值"><a class="markdownIt-Anchor" href="#11-右值"></a> 1.1: 右值。</h2><p>纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；</p><p>C<ins>11对C</ins>98中的右值进行了扩充。扩展为: 纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。<br>其中</p><h3 id="111-纯右值"><a class="markdownIt-Anchor" href="#111-纯右值"></a> 1.1.1: 纯右值：</h3><p>a）非引用返回的临时变量；<br>b) 运算表达式产生的结果；<br>c）字面常量（C 风格字符串除外，它是地址）。</p><h3 id="112-将亡值"><a class="markdownIt-Anchor" href="#112-将亡值"></a> 1.1.2: 将亡值</h3><p>将亡值可以理解为通过“<strong>盗取</strong>”其他变量内存空间的方式获取到的值。<br>在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。<br>将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），</p><p>与右值引用相关的表达式，<br>例如：将要被移动的对象、T&amp;&amp;函数返回的值、std:move()的返回值、转换成 T&amp;&amp;的类型的转换函数的返回值。</p><blockquote><p>[!tip] 不懂纯右值和将亡值的区别其实没关系，统一看作右值即可，不影响使用。</p></blockquote><h1 id="2-右值引用"><a class="markdownIt-Anchor" href="#2-右值引用"></a> 2: 右值引用</h1><blockquote><p>[!cite]<br>C<ins>98 中的引用很常见，就是给变量取个别名，在C</ins>11中，因为增加了右值引用(rvalue reference)的概念，所以C++98 中的引用都称为了左值引用(lvalue reference)。<br><strong>普通的引用是左值引用</strong></p></blockquote><p>左值引用就是对一个左值进行引用的类型。<br>右值引用就是对一个右值进行引用的类型，<br>事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p><p>右值引用和左值引用都是属于引用类型。<br>无论是声明一个左值引用还是右值引用，都必须立即进行初始化。<br>而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。</p><blockquote><p>[!note]</p><ul><li>左值引用：传统的C++中引用被称为左值引用</li><li>右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，<ul><li>也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</li></ul></li></ul></blockquote><blockquote><p>[!example]- 右值引用就是给右值取个名字。<br>右值有了名字之后，就成了一个普通变量，可以像使用左值一样使用它们: eg: ++, 取址, 加 const 等等</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">语法：数据类型&amp;&amp; 变量名=右值; <span class="hljs-comment">// 相比与引用&amp;, 💡多加一个&amp;即可</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]<br>![[左右值引用 2022-10-29 17.09.39.excalidraw]]</p></blockquote><p><strong>引入右值引用的主要目的是实现移动语义。</strong></p><p>左值引用只能绑定（关联、指向)左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。</p><h2 id="21-右值引用的特点"><a class="markdownIt-Anchor" href="#21-右值引用的特点"></a> 2.1: 右值引用的特点</h2><blockquote><p>[!question]</p></blockquote><ul><li>特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</li><li>特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值</li><li>特点3：T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</li></ul><h2 id="22-例子"><a class="markdownIt-Anchor" href="#22-例子"></a> 2.2: 例子</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>{<br>cout &lt;&lt; t &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a;  <span class="hljs-comment">//b是左值引用</span><br><span class="hljs-type">int</span>&amp; c = <span class="hljs-number">10</span>;  <span class="hljs-comment">//错误，c是左值不能使用右值初始化</span><br><span class="hljs-type">int</span>&amp;&amp; d = <span class="hljs-number">10</span>;  <span class="hljs-comment">//正确，右值引用用右值初始化</span><br><span class="hljs-type">int</span>&amp;&amp; e = a;  <span class="hljs-comment">//错误，e是右值引用不能使用左值初始化</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; f = a; <span class="hljs-comment">//正确，左值常量引用相当于是万能型，可以用左值或者右值初始化</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; g = <span class="hljs-number">10</span>;<span class="hljs-comment">//正确，左值常量引用相当于是万能型，可以用左值或者右值初始化</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; h = <span class="hljs-number">10</span>; <span class="hljs-comment">//正确，右值常引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; aa = h;<span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span>&amp; i = <span class="hljs-built_in">getInt</span>();  <span class="hljs-comment">//错误，i是左值引用不能使用临时变量（右值）初始化</span><br><span class="hljs-type">int</span>&amp;&amp; j = <span class="hljs-built_in">getInt</span>();  <span class="hljs-comment">//正确，函数返回值是右值</span><br><span class="hljs-built_in">fun</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//此时fun函数的参数t是右值</span><br><br><span class="hljs-built_in">fun</span>(a); <span class="hljs-comment">//💡特点 3: 此时fun函数的参数t是左值</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-左值引用"><a class="markdownIt-Anchor" href="#3-左值引用"></a> 3: 左值引用</h1><p>左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。<br>左值引用通常也不能绑定到右值，</p><p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</p><h2 id="31-常量左值引用"><a class="markdownIt-Anchor" href="#31-常量左值引用"></a> 3.1: 常量左值引用</h2><p>但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。<br>不过常量左值所引用的右值在它的“余生”中只能是只读的。<br>相对地，非常量左值只能接受非常量左值对其进行初始化。</p><blockquote><p>[!tip] <strong>常量左值引用</strong> : const T &amp;<br>是个奇葩，它可以算是一个万能的引用类型，<br>它可以绑定<strong>非常量左值</strong>、<strong>常量左值</strong>、<strong>右值</strong>，<br>而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，<br>缺点是，只能读不能改。</p></blockquote><p>![[左右值引用 2022-10-29 17.23.49.excalidraw]]</p><h2 id="32-总结"><a class="markdownIt-Anchor" href="#32-总结"></a> 3.2: 总结</h2><p>总结一下，其中T是一个具体类型：<br>1）左值引用，使用T&amp;，只能绑定左值。<br>2）右值引用，使用T&amp;＆，只能绑定右值。<br>3）已命名的右值引用是左值。<br>4）常量左值，使用 const T &amp;，既可以绑定左值又可以绑定右值。 ^8baw7f</p><h1 id="4-移动语义"><a class="markdownIt-Anchor" href="#4-移动语义"></a> 4: [[移动语义]]</h1><h1 id="5-完美转发"><a class="markdownIt-Anchor" href="#5-完美转发"></a> 5: [[完美转发]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统如何让 CPU 执行程序</title>
    <link href="/posts/211/"/>
    <url>/posts/211/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!summary] 如何让 cpu 执行程序?<br>通过 pc 来实现"取指执行", 每次取指后 pc 自动加一</p></blockquote><blockquote><p>[!summary] cpu 利用率低<br>但是, 此时会引出一个问题, 当只执行一个程序时,cpu 利用率极低, 那么, 如何解决上面这个问题呢?<br>答: 通过在多个程序之间来回交替执行, 即多道批程序处理, 也即“并发”。</p><ul><li>tip (当遇到一个执行时间较长的程序时,cpu 切换执行另一个程序, 等到上一个程序执行完事以后再切换回去)</li></ul></blockquote><blockquote><p>[! tip] <strong>如何做到"并发"呢?</strong></p><ol><li>记录正在执行程序 (即, 进程) 的运行信息<ol><li>(静态程序 (还没有执行的程序) 不用管。这里记录是为了后面当这个程序执行完事后, 再切换回来, 继续之前的部分执行)</li></ol></li><li>修改 PC (将 pc 指针修改为指向新的程序指令的指针)</li></ol></blockquote><blockquote><p>[!tip] 如何记录进程的运行信息<br>答:通过 PCB 记录“进程"的运行信息。</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsngvTc0Cxk3DmlN4umO64F"  --> <p>📝操作系统如何让 CPU 执行程序::<br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个程序从开始运行到结束</title>
    <link href="/posts/19200/"/>
    <url>/posts/19200/</url>
    
    <content type="html"><![CDATA[<h1 id="1-一个程序从开始运行到结束的完整过程"><a class="markdownIt-Anchor" href="#1-一个程序从开始运行到结束的完整过程"></a> 1 一个程序从开始运行到结束的完整过程:</h1><p><strong>预编译+编译+汇编+链接</strong></p><p>![[GCC 编译过程 .excalidraw|2100]]</p><h1 id="2-静态链接和动态链接"><a class="markdownIt-Anchor" href="#2-静态链接和动态链接"></a> 2 ![[静态链接和动态链接]]</h1><h1 id="3-操作系统如何让-cpu-执行程序"><a class="markdownIt-Anchor" href="#3-操作系统如何让-cpu-执行程序"></a> 3 [[操作系统如何让 CPU 执行程序]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsOFch1IJd1NMyRI223HaYU"  --> <p>📝一个程序从开始运行到结束::<br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>智力题</title>
    <link href="/posts/22842/"/>
    <url>/posts/22842/</url>
    
    <content type="html"><![CDATA[<h1 id="1-老鼠与毒药问题"><a class="markdownIt-Anchor" href="#1-老鼠与毒药问题"></a> 1 老鼠与毒药问题</h1><p>有 1000 瓶水, 其中一瓶有毒, 只要老鼠喝下一小口毒水 1 天后就会死亡, 你只有 1 天时间和 10 只老鼠, 如何检验出哪一瓶水有毒?</p><ol><li>2 的每 10 次方对应 10 的每 3 次方, 所以需要 10 只老鼠</li><li>将1~1000号瓶子的编号改成二进制,分别喂给二进制表示中为1的位的老鼠,比如第9瓶水表示为0000001001那么就给倒数第1只和倒数第4只老鼠喂第9瓶水</li><li>第二天死亡的老鼠所组成的二进制数,即表示那瓶毒水的编号</li></ol><h1 id="2-烧绳子"><a class="markdownIt-Anchor" href="#2-烧绳子"></a> 2 烧绳子</h1><p>烧一根绳子需要一个小时, 现有若干条相同的绳子, 问如何计时 15 分钟? (类似双指针)</p><ol><li>点燃绳子 A 的一头, 同时点燃绳子 B 的两头</li><li>绳子 B 烧完的时候绳子 A 还剩一半, 此时点燃绳子 A 的另一头开始计时</li><li>15 分钟绳子 A 烧完</li></ol><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYu6FBe72JSlEuYGEOBeKq"  --> <p>📝智力题::<br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/posts/52561/"/>
    <url>/posts/52561/</url>
    
    <content type="html"><![CDATA[<p>![[网络编程 2022-10-29 15.05.40.excalidraw]]</p><p>![[网络编程 2022-10-29 15.16.16.excalidraw]]</p><h1 id="1-tcpp-网络编程重点知识的小结"><a class="markdownIt-Anchor" href="#1-tcpp-网络编程重点知识的小结"></a> 1: TCP/P 网络编程重点知识的小结</h1><p>形象的记住一些重要的名词</p><p>socket 函数 (安装电话机): 生成套接字<br>bind 函数 (分配电话号码): 给创建好的套接字分配地址信息 (分配 IP 地址和端口号)<br>listen 函数 (连接电话): 把套接字转化为可接收请求连接的状态<br>accept 函数: 受理连接请求</p><h1 id="2-套接字在网络编程中的作用是什么为何称它为套接字"><a class="markdownIt-Anchor" href="#2-套接字在网络编程中的作用是什么为何称它为套接字"></a> 2: 套接字在网络编程中的作用是什么?为何称它为套接字?</h1><p>答: 操作系统会提供 「套接字」(socket) 的部件, 套接字是网络数据传输用的软件设备。因此,「网络编程」也叫「套接字编程」。<br>「套接宇」就是用来连接网络的工具。</p><p><strong>句柄与描述符:</strong><br>文件描述符: 方便称呼操作系统创建的文件或套接字而赋予的数。有时也被成为文件句柄 (句柄-- Windows 中的术语)</p><h2 id="21-面向连接的套接字-sock-stream"><a class="markdownIt-Anchor" href="#21-面向连接的套接字-sock-stream"></a> 2.1: 面向连接的套接字 (SOCK STREAM):</h2><p>例子: 流水线的糖果加工<br>传输特征:</p><ul><li>传输过程中数据不会消失</li><li>按序传输数据</li><li>传输的数据不存在数据边界(read、write函数调用次数并无挨打意义)</li></ul><h2 id="22-面向消息的套接字-sock-dgram"><a class="markdownIt-Anchor" href="#22-面向消息的套接字-sock-dgram"></a> 2.2: 面向消息的套接字 (SOCK DGRAM)</h2><p>摩托车快递传送包裏</p><ol><li>强调快速而非传输顺序</li><li>传输的数据可能丢失也可能销毁</li><li>限制每次传输的数据大小</li><li>传输的数据有数据边界具体参考以下思维导图:<br><a href="marginnote3app://note/440619B0-E26B-4222-A7D5-C1C9FB7A1B94">margin: 具体参考以下思维导图:</a></li></ol><h2 id="23-套接字个数问题"><a class="markdownIt-Anchor" href="#23-套接字个数问题"></a> 2.3: 套接字个数问题:</h2><p>与 TCP 服务器不同,UDP 服务器端和客户端均只需要一个套接字</p><h1 id="3-为何要半关闭"><a class="markdownIt-Anchor" href="#3-为何要半关闭"></a> 3: 为何要半关闭?</h1><p>优雅地断开套接字连接: 半关闭: shutdown 函数</p><p>存在以下集中情况<br>一旦客户端连接到服务器,服务器将约定的文件传输给客户端,客户端收到后发送字符串 「Thank you」 给服务器端。<br>此处「Thank you」的传递是多余的,这只是用来模拟客户端断开连接前还有数据要传输的情况。<br><strong>此时程序的实现难度并不小</strong>, 因为传输文件的服务器端只需连续传输文件数据即可, 而客户端无法知道需要接收数据到何时。客户端也没办法无休止的调用输入函数, 因为这有可能导致程序阻塞。</p><h2 id="31-是否可以让服务器和客户端约定一个代表文件尾的字符"><a class="markdownIt-Anchor" href="#31-是否可以让服务器和客户端约定一个代表文件尾的字符"></a> 3.1: 是否可以让服务器和客户端约定一个代表文件尾的字符?</h2><p>这种方式也有问题, 因为这意味这文件中不能有与约定字符相同的内容。为了解决该问题, 服务端应最后向客户端传递 EOF 表示文件传输结束。客户端通过函数返回值接受 EOF, 这样可以避免与文件内容冲突。那么问题来了, 服务端如何传递 EOF?</p><h2 id="32-断开输出流时向主机传输-eof"><a class="markdownIt-Anchor" href="#32-断开输出流时向主机传输-eof"></a> 3.2: 断开输出流时向主机传输 EOF。</h2><p>当然,调用close 函数的同时关闭 I/O 流,这样也会向对方发送EOF。但此时无法再接受对方传输的数据。<strong>换言之,若调用 close 函数关闭流,就无法接受客户端最后发送的字符串 「Thank you」。</strong><br>这时需要调用 shutdown 函数, 只关闭服务器的输出流。这样既可以发送 EOF, 同时又保留了输入流。下面实现收发文件的服务器端/客户端。</p><p>Time Wait<br>客户端的 Time Wait 状态并不会过多关注<br>与服务器端不同, 客户端每次运行程序事都会动态分配端口号</p><p>并发服务器实现的方式:<br>多进程服务器: 通过创建多个进程提供服务 (不适用)<br>多路复用服务器: 通过捆绑同意管理 I/O 对象提供服务 (常用)<br>多线程服务器: 通过生成与客户端等量的线程提供服务 (常用)</p><h1 id="4-多进程服务器端"><a class="markdownIt-Anchor" href="#4-多进程服务器端"></a> 4: 多进程服务器端:</h1><p>相对于孤儿进程, 僵尸进程对系统带来的影响更大</p><h2 id="41-僵尸进程产生的原因"><a class="markdownIt-Anchor" href="#41-僵尸进程产生的原因"></a> 4.1: 僵尸进程产生的原因:</h2><p>利用如下两个示例展示调用 fork 函数产生子进程的终止方式</p><ol><li>传递参数并调用 exito</li><li>main 函数中执行 return 并返回值</li></ol><p>子进程通过 exit ()传递参数值或者 main 函数返回了值, 但是操作系统没有主动把这些值返回给父进, 导致子进程长时间保持僵尸进程状态。</p><h3 id="411-解决办法"><a class="markdownIt-Anchor" href="#411-解决办法"></a> 4.1.1: 解决办法</h3><p><strong>自行解决:</strong><br>wait ()<br>waitpid ():</p><blockquote><p>[!summary]<br>wait 函数会引起程序阻塞, 还可以考虑调用 waitpid 函数。这是防止僵尸进程的第二种方法, 也是防止阻塞的方法。</p></blockquote><p><strong>请求操作系统协助解决</strong> : 信号<br>signal ()<br>sigaction ()</p><blockquote><p>[!summary]<br>signal 函数在 Unix 系列的不同操作系统可能存在区别, 但 sigaction 函数完全相同<br>下面进程和操作系统的对话可以帮助理解信号处理。</p><ul><li>进程: 操作系统, 如果我之前创建的子进程终止, 就帮我调用 zombie handler 函数。</li><li>操作系统: 好的, 如果你的子进程終止, 我就帮你调用 zombie handler 函数, 但是你先把要函数要执行的语句写好。</li></ul></blockquote><h2 id="42-多进程服务器存在的缺点"><a class="markdownIt-Anchor" href="#42-多进程服务器存在的缺点"></a> 4.2: 多进程服务器存在的缺点</h2><p><strong>进程的缺点可概括为:</strong></p><ol><li>创建进程的过程会带来一定的开销<ul><li>tip 每秒少则 10 次, 多则千次的「上下文切换」是创建进程的最大开销</li></ul></li><li>为了完成进程问数据交换,需要特殊的 IPC技术。</li></ol><p><strong>线程比进程具有如下优点</strong>:</p><ol><li>线程的创建和上下文切换比进程的创建和上下文切换更快</li><li>线程间交换数据无需特殊技术</li></ol><h1 id="5-值得思考的问题"><a class="markdownIt-Anchor" href="#5-值得思考的问题"></a> 5: 值得思考的问题:</h1><ol><li>I/O 复用技术 select、epoll、poll 的区别, 各自的应用场景</li><li>多线程服务器与 I/O 复用技术服务器两者是否可以结合</li></ol><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsEbyBhpEovk8jIv5xxDA7s"  --> <p>📝网络编程:: <a href="marginnote3app://note/E61360B5-45C2-438F-AF97-FE50CE082396">margin: 网络编程</a><br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>非暴力沟通</title>
    <link href="/posts/14103/"/>
    <url>/posts/14103/</url>
    
    <content type="html"><![CDATA[<h1 id="1-沟通过程"><a class="markdownIt-Anchor" href="#1-沟通过程"></a> 1 沟通过程</h1><ul><li>不含感情的描述事实情况·</li><li>说出自己的感受·</li><li>哪些原因导致那样的感受·</li><li>为了改善生活，我的请求是什么</li></ul><blockquote><p>[!example]</p><ul><li>巧义总 (早上/下午/晚上) 好，前几天我去高总办公室交转正报告，他没有明确表示我是否能转正，前天问我领导, 他也没有给我明确答复。现在距离我申请转正都过去了半个多月，且没有一个定论。</li><li>我现在感觉忧虑和着急。</li><li>因为转正的事情一直没确定下来，不知道到底以后是否能继续工作或者不能继续工作，我心里觉得蛮不稳定的，这种情绪最近也一直困扰着我，工作上面也感到很疲惫。如果可以继续留任，那我也可以静下心来的去努力工作。如果是不能继续留任，我自己也好提前做好打算嘛。</li><li>所以我想请问您能不能帮忙看看这个转正流程呢?</li></ul></blockquote><p>1．诚实地表达自己，而不批评、指责<br>（1）观察<br>我所观察（看、听、回忆、想）到的有助于（或无助于）我的福祉的具体行为：<br>“当我（看、听、想到我看到的/听到的）……”</p><p>（2）感受<br>对于这些行为，我有什么样的感受（情感而非思想）：<br>“我感到……”</p><p><strong>（1）下列词语可用来表达我们的需要得到满足时的感受：</strong><br>兴奋 喜悦 欣喜 甜蜜 精力充沛 兴高采烈<br>感激 感动 乐观 自信 振作 振奋 开心<br>高兴 快乐 愉快 幸福 陶醉 满足 欣慰 心旷神怡喜出望外<br>平静 自在 舒适 放松 踏实 安全 温暖 放心 无忧无虑<br><strong>（2）下列词语可用来表达我们的需要没有得到满足时的感受：</strong><br>害怕 担心 焦虑 忧虑 着急 紧张 心神不宁 心烦意乱<br>忧伤 沮丧 灰心 气馁 泄气 绝望 伤感 凄凉 悲伤<br>恼怒 愤怒 烦恼 苦恼 生气 厌烦 不满 不快 不耐烦不高兴<br>震惊 失望 困惑 茫然 寂寞 孤独 郁闷 难过 悲观<br>沉重 麻木 精疲力尽 委靡不振 疲惫不堪 昏昏欲睡无精打采<br>尴尬 惭愧 内疚 妒忌 遗憾 不舒服</p><p>（3）需要<br>什么样的需要或价值（而非偏好或某种具体的行为）导致我那样的感受：<br>“因为我需要/看重……”</p><p>（4）请求<br>清楚地请求（而非命令）那些能丰富我生命的具体行为，<br>“你是否愿意……？”</p><h1 id="2-如何倾听"><a class="markdownIt-Anchor" href="#2-如何倾听"></a> 2 如何倾听</h1><p>关切地倾听他人，而不解读为批评或指责<br>（1）观察<br>你所观察（看、听、回忆、想）到的有助于（或无助于）你的福祉的具体行为：<br>“当你（看、听、想到你看到的/听到的）……”</p><p>（2）感受<br>对于这些行为，你有什么样的感受（是情感而非思想）：<br>“你感到……吗？”</p><p>（3）需要<br>什么样的需要或价值（而非偏好或某种具体的行为）导致你那样的感受：<br>“因为你需要/看重……”</p><p>（4）请求<br>关切地倾听那些能丰富你生命的具体请求，而不解读为命令：<br>“所以，你想……”</p><h1 id="3-表达感激"><a class="markdownIt-Anchor" href="#3-表达感激"></a> 3 表达感激</h1><blockquote><p>[!cite]<br>在赞扬他人时，我们很少揭示内心活动，而把自己放在了裁判的位置。<br>赞扬也常常被人用来实现个人目的</p></blockquote><p>正确的表达感激</p><ul><li>（1）对我们有益的行为；</li><li>（2）我们的哪些需要得到了满足；</li><li>（3）我们的需要得到满足后，我们是什么样的心情。</li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2LQGuoZwcUWiUoFRvhPUb"  --> <p>📝非暴力沟通::<br>2022/10/29: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>📖阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础正则表达式速查表</title>
    <link href="/posts/44463/"/>
    <url>/posts/44463/</url>
    
    <content type="html"><![CDATA[<p>![[基础正则表达式速查表 2022-10-28 16.36.24.excalidraw|2400]]</p><p>![[正则案例.excalidraw]]</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 替换中文字符<br>^[\u4e00-\u9fa5]{<span class="hljs-number">0</span>,<span class="hljs-number">3</span>}\s?\d.<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsdzNYqGcqvdz5zjVQN9tBi"  --> <p>📝基础正则表达式速查表::<br>2022/10/28: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>正则表达式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分组</title>
    <link href="/posts/50718/"/>
    <url>/posts/50718/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分组"><a class="markdownIt-Anchor" href="#1-分组"></a> 1: 分组</h1><p>分组指将匹配的内容，使用 <code>( )</code> 划分成多个组块，分好的组可用于<strong>提取</strong>、反向<strong>引用</strong>以及<strong>替换</strong>操作。<br>你可能会有疑问，<code>()</code>不是用作子表达式么？子表达与分组是共存的，但侧重点不一样：子表达式针对正则的<strong>匹配逻辑</strong>，分组针对<strong>匹配的内容</strong>。</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210281606545.png" alt="|600"></p><h2 id="11-反向引用"><a class="markdownIt-Anchor" href="#11-反向引用"></a> 1.1: 反向引用</h2><p>反向引用指通过 <code>\组号</code> 引用<strong>之前</strong>的分组，可以把分组理解成一个<strong>变量</strong>，在通过变量名 (组号) 引用。它不能引用之后的内容，固作称作反向引用，</p><ul><li>tip 只能从后往前引用<br>比如这样正则是<strong>错误</strong>的：<code>&lt;\1&gt;.*?&lt;\/(h[1-6])&gt;</code></li></ul><p>![[正则表达式字符 2022-10-28 15.57.23.excalidraw|700]]</p><h2 id="12-引用替换"><a class="markdownIt-Anchor" href="#12-引用替换"></a> 1.2: 引用替换</h2><p>替换操作指将正则匹配到的内容，替换成指定字符串，该字符串可通过 <code>$组号</code> 引用组进行拼装。通过 <code>$0</code> 可以引用整个匹配的内容。<br>比如：日期“1960/02/19”被匹配之后 <code>$0</code>表示整个日期，<code>$1、$2、$3</code> 分别表示年月日。请注意反向引用与替换引用的<strong>语法区别</strong>，前者是使用<code>\组号</code>，而替换使用<code>$组号</code>。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210281627267.png" alt=""></p><h3 id="121-大小写转换"><a class="markdownIt-Anchor" href="#121-大小写转换"></a> 1.2.1: 大小写转换</h3><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210281609276.png" alt="|900"></p><h2 id="13-分组的其他引用"><a class="markdownIt-Anchor" href="#13-分组的其他引用"></a> 1.3: 分组的其他引用</h2><p>关于分组还存在一些特殊情况，需要提前了解一下：</p><ol><li><code>(?&lt;名称&gt; )</code>命名分组</li><li><code>(?: )</code> 移除分组</li><li><code>( ( ) )</code>嵌套分组</li><li><code>()+</code>分组使用量词</li></ol><h3 id="131-命名分组"><a class="markdownIt-Anchor" href="#131-命名分组"></a> 1.3.1: 命名分组</h3><p>默认情况下通过<strong>组号</strong>来取值，此外也可以自定义命名组，语法是<code>(?&lt;名称&gt; )</code>，然后在程序中就可以通过<code>&lt;&gt;</code>中的<code>名称</code>来取值。如：<code>&lt;(?&lt;title&gt;h[1-6])&gt;.*?&lt;\/\1&gt;</code> 该表达式就命名了一个<strong>title</strong>的组，在js的结果中就可通过<strong>title</strong>属性取值。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">"&lt;h1&gt;一级标题&lt;/h1&gt;"</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/&lt;(?&lt;title&gt;h[1-6])&gt;.*?&lt;\/\1&gt;/</span>)<br><span class="hljs-comment">// 输出结果如下</span><br><span class="hljs-number">0</span>: <span class="hljs-string">"&lt;h1&gt;一级标题&lt;/h1&gt;"</span><br><span class="hljs-number">1</span>: <span class="hljs-string">"h1"</span><br><span class="hljs-attr">groups</span>:<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">"h1"</span><br><span class="hljs-attr">input</span>: <span class="hljs-string">"&lt;h1&gt;一级标题&lt;/h1&gt;"</span><br><br></code></pre></td></tr></tbody></table></figure><p>注意：这种命名组只能用于在程序中提取操作，不能进行反向引用，也不能用在替换操作中。上例在替换中如果使用 <code>$title</code> 或在反向引用中使用 <code>\title</code> 都是无效的。只能通过组号 <code>\1</code> 进行引用。这也说明命名组后，<strong>组号一样有效</strong>。也正因为这种局限性所以命名组使用的很少。</p><h3 id="132-移除分组"><a class="markdownIt-Anchor" href="#132-移除分组"></a> 1.3.2: 移除分组</h3><p><code>()</code>即用于子表达式，同时也是一个分组。如果只想用作子表达式，而不想用于分组就可以使用<code>(?: )</code>从分组列表中移除。比如<code>(?:\d{4})-(\d{2})-(\d{2})</code> 该表达式只存在两个组，月<code>$1</code>和日<code>$2</code>。</p><p>你可能在想这么做的意义是什么呢？在一些复杂场景中这是有用的,用让组号变得更清晰。</p><h3 id="133-嵌套分组"><a class="markdownIt-Anchor" href="#133-嵌套分组"></a> 1.3.3: 嵌套分组</h3><p>在嵌套分组中组号是如何命名的呢？比如：<code>生日((\d{4})-(\d{2})(\d{2}))</code> 其组号的命名顺序是以<strong>开括号</strong>出现顺序为准。</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210281615739.png" alt="|400"></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-string">"生日2019-09-21"</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/生日((\d{4})-(\d{2})-(\d{2}))/</span>)<br><span class="hljs-comment">// 得出结果如下:</span><br><span class="hljs-number">0</span>: <span class="hljs-string">"生日2019-09-21"</span><br><span class="hljs-number">1</span>: <span class="hljs-string">"2019-09-21"</span><br><span class="hljs-number">2</span>: <span class="hljs-string">"2019"</span><br><span class="hljs-number">3</span>: <span class="hljs-string">"09"</span><br><span class="hljs-number">4</span>: <span class="hljs-string">"21"</span><br></code></pre></td></tr></tbody></table></figure><h3 id="134-分组使用量词"><a class="markdownIt-Anchor" href="#134-分组使用量词"></a> 1.3.4: 分组使用量词</h3><p>同一个分组如果使用了量词，该分组会代表多个值，这时通过<code>$组号</code>去提取值的时候会得到该组最后匹配的值。如<code>(\d)+</code> 匹配12345，通过<code>$1</code>将得到5</p><h2 id="14-练习"><a class="markdownIt-Anchor" href="#14-练习"></a> 1.4: 练习</h2><p>![[分组 2022-10-28 16.20.39.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsanN2Js6NIJPxyYAlEjU3s"  --> <p>📝分组::<br>2022/10/28: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>正则表达式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基础正则表达式速查表</title>
    <link href="/posts/44461/"/>
    <url>/posts/44461/</url>
    
    <content type="html"><![CDATA[<p>![[基础正则表达式速查表 2022-10-28 11.31.39.excalidraw]]</p><h3 id="011-混合字符"><a class="markdownIt-Anchor" href="#011-混合字符"></a> 0.1.1: 混合字符</h3><p>更多正则匹配场景中，是<strong>确定</strong>与<strong>不确定</strong>的字符混合在一起。如要匹配下文中年龄就得这么写<code>\d\d岁</code>：</p><figure class="highlight basic"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> 曾小红，男, 举重运动员，<span class="hljs-number">28</span> 岁，体重 <span class="hljs-number">56</span>KG，身高 <span class="hljs-number">175</span>cm。最好成绩：挺举 <span class="hljs-number">98</span>KG<br></code></pre></td></tr></tbody></table></figure><p>如果要匹配体重得这么写<code>体重\d\dKG</code>，体重与KG是确定的，中间<code>\d\d</code>是不确定的。</p><blockquote><p>小技巧：在编写正则时可以先编写确定部分，然后加入不确定部分，思路一下就清晰了。试试看</p></blockquote><h2 id="02-0-自定义范围字符"><a class="markdownIt-Anchor" href="#02-0-自定义范围字符"></a> 0.2: 0.、自定义范围字符</h2><p>定定义范围指由多个字符，多个范围字符组成的集合，取其中<strong>任意</strong>一个。</p><p>![[正则表达式字符 2022-10-28 11.47.48.excalidraw]]</p><h1 id="1-数量控制"><a class="markdownIt-Anchor" href="#1-数量控制"></a> 1: 数量控制</h1><p>![[正则表达式字符 2022-10-28 15.20.12.excalidraw]]</p><h1 id="2-分组"><a class="markdownIt-Anchor" href="#2-分组"></a> 2: [[分组]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsoR8BEqjg7I8KKZh0ZyB2s"  --> <p>📝基础正则表达式速查表::<br>2022/10/28: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>正则表达式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式规则</title>
    <link href="/posts/5419/"/>
    <url>/posts/5419/</url>
    
    <content type="html"><![CDATA[<p>任意一个字符表示匹配任意对应的字符, 如 a 匹配 a, 7 匹配 7,-匹配-</p><p>[]代表匹配中括号中其中任一宇符, 如[abc]匹配 a 或 b 或 c</p><ul><li>-在中括号里面和外面代表含义不同:</li></ul><ol><li>如果在外时, 就匹配 -</li><li>如果在中括号内 [a-b]表示匹配 26 个小写字母中的任一个<ol><li>[a-ZA-Z]匹配大小写共 52 个字母中任一个</li><li>[0-9]匹配十个数字中任一个:</li></ol></li></ol><p>^在中括号里面和外面含义不同:</p><ol><li>如果在外时, 就表示开头, 如 ^7 [0-9]表示匹配开头是 7 的, 且第二位是任一数字的字符串</li><li>如果在中括号里面, 表示除了这个字符以外的任意字符 (包括数字, 特殊字符),<ol><li>如<code>[^abc]</code>表示匹配出去 abc 之外的其他任一字符</li></ol></li></ol><p>![[正则表达式规则 2022-10-27 21.27.28.excalidraw|700]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsM5DRn6jc0vktHEDBQ8eCS"  --> <p>📝正则表达式规则::<br>2022/10/27: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>正则表达式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类型推导</title>
    <link href="/posts/18982/"/>
    <url>/posts/18982/</url>
    
    <content type="html"><![CDATA[<p>📝类型推导::<br>2022/10/27: 第一次创建</p><!-- basicblock-end --><h1 id="1-auto"><a class="markdownIt-Anchor" href="#1-auto"></a> 1: auto:</h1><p>auto 可以让编译器在编译期就推导出变量的类型</p><ul><li>auto 的使用必须马上初始化, 否则无法推导出类型</li><li>auto 在一行定义多个变量时, 各个变量的推导不能产生二义性, 否则编译失败<ul><li>❓什么是二义性: ✅应该是: 不能是两种类型</li></ul></li><li>auto 不能用作函数参数</li><li>在类中 auto 不能用作非静态成员变量</li><li>auto 不能定义数组, 可以定义指针</li><li>auto 无法推导出模板参数</li><li>在不声明为引用或指针时,auto 会忽略等号右边的引用类型和 cv 限定</li><li>在声明为引用或者指针时,auto 会保留等号右边的引用和 cv 属性</li></ul><h1 id="2-decltype"><a class="markdownIt-Anchor" href="#2-decltype"></a> 2: decltype</h1><p>decltype 则用于推导表达式类型, 这里只用于编译器分析表达式的类型, 表达式实际不会进行运算<br>decltype 不会像 auto 一样忽略引用和 cv 属性,decltype 会保留表达式的引用和 cv 属性</p><p>对于 decltype (exp) 有:</p><ol><li>exp是表达式,decltype(exp)和exp类型相同</li><li>exp是函数调用,decltype(exp)和函数返回值类型相同</li><li>其它情况,若exp是左值,decltype(exp)是exp类型的左值引用</li></ol><blockquote><p>[[左右值引用(目录)]]</p></blockquote><!-- basicblock-start oid="Obsde6bUem6qaFiPGkPqXcud" --><h1 id="3-auto和decltype的配合使用-疑问"><a class="markdownIt-Anchor" href="#3-auto和decltype的配合使用-疑问"></a> 3: auto和decltype的配合使用::  ❓ #疑问</h1><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> I, <span class="hljs-keyword">typename</span> U&gt; </span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(I t,U u)</span> -&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(t + u)</span></span>{ <br>    <span class="hljs-keyword">return</span> t +a; <br>}<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 11 新特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云盘秒传的原理</title>
    <link href="/posts/59172/"/>
    <url>/posts/59172/</url>
    
    <content type="html"><![CDATA[<p>上传大文件时，会对文件进行比对操作，这里的对比操作其实: 就是将我们要上传的文件进行"哈希值"的计算，跟百度的"哈希值"数据库中的文件进行匹配操作。</p><p>如果发现两者的"哈希值"相同，那么，将已存在于百度数据库里面的文件对应的文件链接到我们对应的帐号里，做一个关联就可以，</p><p>其实并没有对本地文件进行上传，所以我们也就看到了秒传的效果。</p><blockquote><p>[!summary]<br>百度网盘将我们要上传的文件与它数据库中的文件进行哈希值匹配, 如果匹配上了就做一个关联操作, 其实并没有对本地文件进行上传</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsjIzOb9rzg3wtAwNXWmAvJ"  --> <p>📝云盘秒传的原理::<br>2022/10/27: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/posts/227/"/>
    <url>/posts/227/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是线程池"><a class="markdownIt-Anchor" href="#1-什么是线程池"></a> 1 什么是线程池</h1><p>1、对网络服务器，单位时间内必须处理数目巨大的连接请求，但是处理时间却是比较短的，<strong>系统不断的启动和关闭新线程，成本高，会消耗系统资源</strong>，以及带来切换线程的危险，从而可能导致系统资源的崩溃。这时我们可以使用线程池。</p><p>2、线程池是服务器预先创建的一组空闲线程，它们的集合称为线程池；这些线程都是处于阻塞状态，这些线程只占一点内存，不占用 CPU。</p><p>3、任务到来的时候，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。<strong>减少创建和销毁对象的次数</strong>，提高程序的运行效率。</p><p>![[线程池 2022-10-27 20.15.42.excalidraw]]</p><p><strong>应用范围：</strong></p><ol><li>需要大量的线程来完成任务，且完成任务的时间比较短，不适合具有可能会长时间运行（并因此阻塞其他任务） 的任务。</li><li>对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。</li></ol><h1 id="2-线程池线程数量"><a class="markdownIt-Anchor" href="#2-线程池线程数量"></a> 2 线程池线程数量</h1><h2 id="21-cpu-计算-密集型任务"><a class="markdownIt-Anchor" href="#21-cpu-计算-密集型任务"></a> 2.1 CPU (计算) 密集型任务：</h2><p>将线程数设置为 N (CPU 核心数)+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响</p><h2 id="22-io-密集型任务"><a class="markdownIt-Anchor" href="#22-io-密集型任务"></a> 2.2 IO 密集型任务：</h2><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在/○密集型任务的应用中，可以多配置一些线程，具体的计算方法是 2N。</p><h1 id="3-主进程的工作步骤"><a class="markdownIt-Anchor" href="#3-主进程的工作步骤"></a> 3 主进程的工作步骤</h1><ol><li>打开熟知端口（端口号为 21），使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程来处理客户进程发来的请求。<ol><li>从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li></ol></li><li>回到等待状态，继续接受其他客户进程发来的请求。<ol><li>主进程和从属进程的处理是并发地进行。</li></ol></li></ol><h1 id="4-ftp-工作流程"><a class="markdownIt-Anchor" href="#4-ftp-工作流程"></a> 4 FTP 工作流程</h1><p>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的传输服务。<br>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</p><p>FTP 使用客户服务器方式，一个 FTP 服务器进程可同时为多个客户进程提供服务。</p><p>FTP 的服务器进程由两大部分组成：</p><ul><li>一个主进程，负责接受新的请求；</li><li>另外有若干个从属进程，负责处理单个请求。</li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs5LZSKbJTfruxJt2sCQocx"  --> <p>📝线程池::<br>2022/10/27: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态链接和动态链接</title>
    <link href="/posts/18661/"/>
    <url>/posts/18661/</url>
    
    <content type="html"><![CDATA[<h1 id="1-静态链接"><a class="markdownIt-Anchor" href="#1-静态链接"></a> 1 静态链接</h1><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，<br>链接器从库中复制这些函数和数据并把它们和应用程序的其它模块<strong>组合</strong>起来创建最终的可执行文件。</p><blockquote><p>[!tip]<br>1、空间浪费： 因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；<br>2、更新困难： 每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。<br>3、运行速度快： 但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p></blockquote><h1 id="2-动态链接"><a class="markdownIt-Anchor" href="#2-动态链接"></a> 2 动态链接</h1><blockquote><p>[!summary]<br>动态链接: 把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，<br>静态链接: 把所有程序模块都组合成一个单独的可执行文件。</p></blockquote><blockquote><p>[!tip]<br>1、共享库： 就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本。<br>2、更新方便： 更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。<br>3、性能损耗： 因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObslPvHPMQ7DILkNMz6DRP88"  --> <p>📝静态链接和动态链接::<br>2022/10/27: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unicode编码与ASCII编码</title>
    <link href="/posts/5202/"/>
    <url>/posts/5202/</url>
    
    <content type="html"><![CDATA[<p>首先，计算机中基本存储单位为字节，一个字节能表示字符范围 0~255。如果将我们理解的文字视为多个字符构成的话，那么一个字节是肯定不够的。所以需要使用多个字节表示一个字符，然后再经过翻译转化成计算机理解的内容。翻译过程就是编码的工作。</p><h1 id="1-ascii-码"><a class="markdownIt-Anchor" href="#1-ascii-码"></a> 1 ASCII 码</h1><p>128 个，包含了英文字母的大小写以及一些其他控制符。一个字节就能表示所有。英语使用 ASC 就够了，但是对于其他语言来说，明显不够用。所以还有譬如 Unicode、GBK 等编码格式</p><h1 id="2-unicode"><a class="markdownIt-Anchor" href="#2-unicode"></a> 2 Unicode</h1><p>一种超语言字典，使得世界上所有语言符号都能够独一无二的表示。但也只定义了符号的二进制表示，没有规定如何存储。UTF-16 和 UTF-8 是基于 Unicode 的具体存储方式。</p><h2 id="21-utf-16"><a class="markdownIt-Anchor" href="#21-utf-16"></a> 2.1 UTF-16</h2><p>采用的是<strong>定长</strong>的编码形式，<strong>网络传输中每次传输 16 位</strong>。对于字符的转换操作方便，Java 的中字符在内存中存储格式好像就是 UTF-16。</p><h2 id="22-utf-8"><a class="markdownIt-Anchor" href="#22-utf-8"></a> 2.2 UTF-8</h2><p>采用的是<strong>变长</strong>的编码形式，<strong>网络传输中每次传输 8 位</strong>。根据不同的字符而变化字节的长度。同时规定一些规则，来支持其变长的特性。</p><h2 id="23-小总结"><a class="markdownIt-Anchor" href="#23-小总结"></a> 2.3 小总结</h2><p>UTF-16 因为其定长的编码形式，编码效率高，字符到字节之间的转换简单，字符的操作更加方便，所以适合在磁盘和内存之间使用，实现字节和字符之间的快速切换。<br>UTF-8 基于其本身的特性更适合网络的传输，譬如网络带宽有限以及传输的字节流容易有损坏。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObscXgTZaDOFHtXttLjn7hxf"  --> <p>📝Unicode编码与ASCII编码::<br>2022/10/27: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>编程常识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>05. 替换空格</title>
    <link href="/posts/31884/"/>
    <url>/posts/31884/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格 - 力扣（LeetCode）</a></p><h1 id="1-暴力解法"><a class="markdownIt-Anchor" href="#1-暴力解法"></a> 1 暴力解法</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>{<br>        string ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(s[i] != <span class="hljs-string">' '</span>) ans += s[i];<br>            <span class="hljs-keyword">else</span> ans += <span class="hljs-string">"%20"</span>;<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>暴力解法的复杂度与双指针解法的复杂度有什么不同 #疑问<br>时间复杂度 O (n) : ❓string 的添加操作是 O (n) 吗<br>空间复杂度 O (n): 如果 s 有 n 个字符, 相应的的 ans 也得有 n 个字符</p><h1 id="2-双指针"><a class="markdownIt-Anchor" href="#2-双指针"></a> 2 双指针</h1><p>思路大概是：扩充原字符串 + 双指针</p><p>可以时间复杂度为 O (n) 的前提下，<br>可以将空间复杂度降到 O (1) : 只是扩充了 s 的字符长度, s 的字符长度总是有限的, 所以是 O (1)</p><p>[[3. 替换空格]]<br>![[双指针法.excalidraw]]</p><ol><li>先扩容</li><li>快指针指向新数组, 慢指针指向老数组</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> spaceNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s){<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">' '</span>) spaceNum++;<br>        }<br>        <span class="hljs-type">int</span> slow = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * spaceNum);<br>        <span class="hljs-type">int</span> fast = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">for</span>(; slow &gt;= <span class="hljs-number">0</span>; slow--){ <span class="hljs-comment">// slow控制原数组</span><br>            <span class="hljs-keyword">if</span>(s[slow] != <span class="hljs-string">' '</span>){<br>                s[fast] = s[slow];<br>                fast--;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                s[fast] = <span class="hljs-string">'0'</span>; <span class="hljs-comment">// fast控制新数组</span><br>                s[fast<span class="hljs-number">-1</span>] = <span class="hljs-string">'2'</span>;<br>                s[fast<span class="hljs-number">-2</span>] = <span class="hljs-string">'%'</span>;<br>                fast-=<span class="hljs-number">3</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>，代码如下：</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsBcRSel2qh6xCnoNe2WYM4"  --> <p>📝05. 替换空格::<br>2022/11/3: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="/posts/51113/"/>
    <url>/posts/51113/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode）</a></p><h1 id="1-暴力解法"><a class="markdownIt-Anchor" href="#1-暴力解法"></a> 1 暴力解法</h1><p><strong>先排个序</strong><br>for 循环遍历, 如果前一个值和后一个值相同则返回</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>        <span class="hljs-keyword">if</span>(nums[i] == nums[i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> nums[i];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-用哈希"><a class="markdownIt-Anchor" href="#2-用哈希"></a> 2 用哈希</h1><p>![[剑指 Offer 03. 数组中重复的数字 2022-10-27 10.46.55.excalidraw]]</p><p>[[set(🗃)]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">count</span>(nums[i])) <span class="hljs-keyword">return</span> nums[i];<br>            <span class="hljs-keyword">else</span> set.<span class="hljs-built_in">insert</span>(nums[i]);<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>以上算法实现的复杂度分析：</p><pre><code class="hljs">时间复杂度是 O(n)空间复杂度是 O(n)</code></pre><p>时间复杂度 O (n)，对于数据规模 10 万级别的话，运行速度是可以接受的。<br>但是这里的空间复杂度则变为 O(n)，因为哈希表需要申请额外的 n 个空间，这里用到的是典型的空间换时间的思想</p><h1 id="3-用数组效率更高"><a class="markdownIt-Anchor" href="#3-用数组效率更高"></a> 3 用数组效率更高</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> Arry [<span class="hljs-number">100010</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>        <span class="hljs-keyword">if</span>(Arry[nums[i]] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> nums[i]; <span class="hljs-comment">// 2. 看下标值是否出现</span><br>            Arry[nums[i]]++; <span class="hljs-comment">// 1. 通过下标来记录数字值</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsafwY3Dg4y0tNmJm94D0Yu"  --> <p>📝剑指 Offer 03. 数组中重复的数字::<br>2022/10/27: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 流操作</title>
    <link href="/posts/46881/"/>
    <url>/posts/46881/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">fstream: <br>&lt;&lt;: 写操作符<br>&gt;&gt;: 读操作符<br></code></pre></td></tr></tbody></table></figure><p>不知道为啥, excalidraw 显示不出来, 点进去就行了:  [[C++ 流操作 .excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsI5wXnac4x2RzKJwTyySte"  --> <p>#历史记录::<br>2022/10/25🌵C++ 流操作 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 泛型编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>可变模板</title>
    <link href="/posts/7707/"/>
    <url>/posts/7707/</url>
    
    <content type="html"><![CDATA[<p>函数随机多个参数都可以</p><ul><li><p>知道折叠参数的类型：<code>... args</code></p><ul><li>类型:  <code>... Args</code></li><li>参数包 (变量名)：<code>Args ... args</code> (定义变量)</li></ul></li><li><p>知道折叠参数的展开方式<br>![[可变模板 2022-10-25 20.54.34.excalidraw]]</p></li></ul><p>可变参模板类–&gt;特化+递归的方式先展开<br>特化+继承的方式</p><p>![[可变模板 2022-10-25 21.17.45.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsOSxJP7dUCmgJ9HnRhxrlC"  --> <p>#历史记录::<br>2022/10/25🌵可变模板 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 泛型编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类模板</title>
    <link href="/posts/45748/"/>
    <url>/posts/45748/</url>
    
    <content type="html"><![CDATA[<h1 id="1-类模板"><a class="markdownIt-Anchor" href="#1-类模板"></a> 1 类模板</h1><ul><li>类用到了未知类型</li><li>多文件中，类模板不能把<strong>声明</strong>和实现分开 (eg: 声明写到.h 文件中, 实现写到.cpp 文件中是错误的)</li><li>类模板在调用的时候必须要显示调用，不能隐式调用</li><li>类模板不是一个完整类，所以在用到类名的地方，必须要用: "类名&lt;类型＞"方式的去使用</li><li>类模板中也可以传常量<br>![[C++模板全特化和偏特化 2022-10-24 21.26.00.excalidraw]]</li></ul><h2 id="1-函数模板特化"><a class="markdownIt-Anchor" href="#1-函数模板特化"></a> 1 函数模板特化</h2><p>写了一个类, 相当于写了很多个类 (一个类可以充当多个类去使用)<br>![[函数特化.excalidraw]]</p><p><strong>对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类&gt;偏特化类&gt;主版本模板类。</strong></p><blockquote><p>越特殊, 越先调用</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsR494TNYtvpkrcp5t30R4e"  --> <p>#历史记录::<br>2022/10/24🌵类模板 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 泛型编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数模板</title>
    <link href="/posts/41134/"/>
    <url>/posts/41134/</url>
    
    <content type="html"><![CDATA[<h2 id="1-模板语句"><a class="markdownIt-Anchor" href="#1-模板语句"></a> 1 模板语句</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;  <span class="hljs-comment">// 有几个模板类型可以,  typename 可以用 class</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T1 a,T2 b)</span> </span><br><span class="hljs-function"></span>{ <br>    cout&lt;&lt;<span class="hljs-string">"模板函数"</span>&lt;&lt;endl; <br>} <br><br><span class="hljs-keyword">template</span>&lt;&gt; <br><span class="hljs-type">void</span> <span class="hljs-built_in">fun</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span> &gt;(<span class="hljs-type">int</span> a,<span class="hljs-type">char</span> b) <br>{ <br>    cout&lt;&lt;<span class="hljs-string">"全特化"</span>&lt;&lt;endl; <br>}<br><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!question]<br>函数模板，只有全特化，偏特化的功能可以通过函数的重载完成。::   #疑问</p></blockquote><blockquote><p>[!example]<br>![[C++模板全特化和偏特化 2022-10-24 21.01.55.excalidraw]]</p></blockquote><h2 id="2-函数模板的调用-隐式-显示"><a class="markdownIt-Anchor" href="#2-函数模板的调用-隐式-显示"></a> 2 函数模板的调用 (隐式, 显示)</h2><ul><li>隐式调用：根据数据类型自动推断模板类型</li><li>显示调用：显示传入类型，函数名&lt;从传入的类型&gt;（参数);<br>![[C++模板全特化和偏特化 2022-10-24 20.55.34.excalidraw]]</li></ul><h2 id="3-函数模板的缺省-能赋初始值"><a class="markdownIt-Anchor" href="#3-函数模板的缺省-能赋初始值"></a> 3 函数模板的缺省 (能赋初始值)</h2><p>![[C++模板全特化和偏特化 2022-10-24 20.51.55.excalidraw]]</p><h2 id="4-一个类的成员也可以是函数模板"><a class="markdownIt-Anchor" href="#4-一个类的成员也可以是函数模板"></a> 4 一个类的成员也可以是函数模板</h2><blockquote><p>类中的函数是模板函数, 但是类不是模板类</p></blockquote><p>![[C++模板全特化和偏特化 2022-10-24 21.08.38.excalidraw]]</p><h2 id="5-模板函数与普通函数重载时"><a class="markdownIt-Anchor" href="#5-模板函数与普通函数重载时"></a> 5 模板函数与普通函数重载时</h2><p>![[模板函数与普通函数重载时.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObslopD60x2IpY2Z7w2rZ77W"  --> <p>2022/10/24🌵函数模板 ::第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 泛型编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 泛型编程</title>
    <link href="/posts/54604/"/>
    <url>/posts/54604/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!example] 泛型: 使用相同的函数, 但使用不同的数据类型<br>![[泛型 2022-10-24 20.08.41.excalidraw]]</p></blockquote><ul><li>模板分为<ul><li>函数模板<ul><li>对函数模板：模板和特例化版本应该声明在同一头文件，所有同名模板的声明应放在前面，接着是特例化版本。</li></ul></li><li>类模板</li><li>可变模板，</li></ul></li></ul><p>对模板特例化是因为对特定类型，可以利用某些特定知识来提高效率，而不是使用通用模板。</p><ul><li>特化分为<ul><li>全特化<ul><li>一个模板被称为全特化的条件：<ol><li>必须有一个主模板类</li><li>模板类型被全部明确化。</li></ol></li></ul></li><li>偏特化 (局部特化)。</li></ul></li></ul><h1 id="1-函数模板"><a class="markdownIt-Anchor" href="#1-函数模板"></a> 1 [[函数模板]]</h1><h1 id="2-类模板"><a class="markdownIt-Anchor" href="#2-类模板"></a> 2 [[类模板]]</h1><h1 id="3-可变模板"><a class="markdownIt-Anchor" href="#3-可变模板"></a> 3 [[可变模板]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsR9q7xENpddoMfswnI1USz"  --> <p>#历史记录:: <a href="marginnote3app://note/530D1D0F-B624-4D07-B9C3-67EA504B97C7">margin: C++ 泛型编程</a><br>2022/10/24🌵C++模板全特化和偏特化 : 第一次创建</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1MT411g79k/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++泛型编程:一种忽略类型的编程，函数模板/类模板/可变模板。例子到讲解一应俱全。_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ 泛型编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>map &amp;&amp; unordered_map</title>
    <link href="/posts/5492/"/>
    <url>/posts/5492/</url>
    
    <content type="html"><![CDATA[<p>[[map(🗃)]]</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210241703194.png" alt=""><br>map 中元素是一些 key-value 对，关键字起索引作用，值表示和索引相关的数据。</p><p>底层实现：<br>map底层是基于红黑树实现的，因此map内部元素排列是有序的。<br>而 unordered_map 底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。</p><h1 id="1-map"><a class="markdownIt-Anchor" href="#1-map"></a> 1: map:</h1><p>优点：<br>有序性，这是 map 结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。map 的查找、删除、增加等一系列操作时间复杂度稳定，都为 O (logn)。</p><p>缺点：<br>查找、删除、增加等操作平均时间复杂度较慢，与 n 相关。</p><h1 id="2-unordered_map"><a class="markdownIt-Anchor" href="#2-unordered_map"></a> 2: unordered_map:</h1><p>优点：<br>查找、删除、添加的速度快，时间复杂度为常数级 O (1)。</p><p>缺点： 因为unordered_map内部基于哈希表，以(key,value)对的形式存储，因此空间占用率高。<br>unordered_map 的查找、删除、添加的时间复杂度不稳定，平均为 O (1), 取决于哈希函数。极端情况下可能为 O (n)。</p><h1 id="3-问题"><a class="markdownIt-Anchor" href="#3-问题"></a> 3: 问题：</h1><h2 id="31-为什么-insert-之后以前保存的-literator-不会失效"><a class="markdownIt-Anchor" href="#31-为什么-insert-之后以前保存的-literator-不会失效"></a> 3.1: 为什么 insert 之后，以前保存的 literator 不会失效？</h2><p>因为 map 和 set 存储的是结点，不需要内存拷贝和内存移动。但是像 vector 在插入数据时如果内存不够会重新开辟一块内存。map 和 set 的 iterator 指向的是节点的指针，vector 指向的是内存的某个位置</p><h2 id="32-为何-map-和-set-的插入删除效率比其他序列容器高"><a class="markdownIt-Anchor" href="#32-为何-map-和-set-的插入删除效率比其他序列容器高"></a> 3.2: 为何 map 和 set 的插入删除效率比其他序列容器高？</h2><p>因为map和set底部使用红黑树实现，插入和删除的时间复杂度是O(logn),而向vector这样的序列容器插入和删除的时间复杂度是O(N)</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsTGRLHw2VRBzXPPjYv5SKL" --> <p>📝map &amp;&amp; unordered_map::<br>2022/10/24 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>map &amp;&amp; set</title>
    <link href="/posts/40399/"/>
    <url>/posts/40399/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210241654015.png" alt=""></p><p>共同点：<br>都是 C++的关联容器，只是通过它提供的接口对里面的元素进行访问，底层都是采用红黑树实现。</p><p>不同点：<br>set:用来判断某一个元素是不是在一个组里面。<br>map: 映射，相当于字典，把一个值映射成另一个值，可以创建字典。</p><p>优点： 查找某一个数的时间为O(logn);遍历时采用iterator,效果不错。<br>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsyhN2yT851NGIF1qYEqojI" --> <p>📝map &amp;&amp; set::<br>2022/10/24 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>heap &amp;&amp; priority_queue</title>
    <link href="/posts/61183/"/>
    <url>/posts/61183/</url>
    
    <content type="html"><![CDATA[<p>[[小顶锥和大顶锥的原理]]</p><p>heap (堆)：<br>建立在完全二叉树上，分为两种，大根堆，小根堆，其在 STL 中做 priority_queuel 的助手，<br>即以任何顺序将元素推入容器中，然后取出时一定是从优先权最高的元素开始取，完全二叉树具有这样的性质，适合做 poriority_queue 的底层</p><p>priority_queue:<br>优先队列，也是配接器。其内的元素不是按照被推入的顺序排列，而是自动取元素的权值排列，确省情况下利用一个 max-heap 完成，后者是以 vector一表现的完全二叉树。</p><p><a href="marginnote3app://note/32D9442F-1D08-4FB3-8DA7-E200152F2A9D">margin: 源码</a></p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsXe93WEjQKHi1foCu9CNdm" --> <p>📝heap &amp;&amp; priority_queue::<br>2022/10/24 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stack &amp;&amp; queue(🗃)</title>
    <link href="/posts/43255/"/>
    <url>/posts/43255/</url>
    
    <content type="html"><![CDATA[<p>📝stack &amp;&amp; queue::<br>2022/10/24 : 第一次创建</p><!-- basicblock-end --><p>所以 STL 中栈与队列往往不被归类为容器，而被归类为 container adapter（容器适配器）</p><p>概述：栈与队列被称之为 duque 的配接器，其底层是以 deque 为底部架构。通过 deque 执行具体操作</p><p>![[stack &amp;&amp; queue 2022-10-24 16.31.09.excalidraw|700]]</p><p><a href="marginnote3app://note/FF20B2B5-53C9-4FE0-BA51-1373EB74EF54">margin: 源码</a></p><h1 id="1-stack"><a class="markdownIt-Anchor" href="#1-stack"></a> 1: [[stack]]</h1><h1 id="2-queue"><a class="markdownIt-Anchor" href="#2-queue"></a> 2: [[queue]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>🗃️</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deque(双端数组)</title>
    <link href="/posts/21960/"/>
    <url>/posts/21960/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2019080412261860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpa2VfdGhhdA==,size_16,color_FFFFFF,t_70" alt=""></p><p>支持快速随机访问，由于 deque 需要处理内部跳转，因此速度上没有 vector快。</p><h1 id="1-deque-概述"><a class="markdownIt-Anchor" href="#1-deque-概述"></a> 1: deque 概述：</h1><p>deque 是一个双端开口的连续线性空间，其内部为分段连续的空间组成，随时可以增加一段新的空间并链接<br>注意：<br>由于 deque 的迭代器比 vector 要复杂，这影响了各个运算层面，所以除非必要尽量使用 vector; 为了提高效率，在对 deque 进行排序操作的时候，我们可以先把 deque 复制到 vector 中再进行排序最后在复制回 deque</p><h1 id="2-deque-中控器"><a class="markdownIt-Anchor" href="#2-deque-中控器"></a> 2: deque 中控器：</h1><p>deque 是由一段一段的定量连续空间构成。一旦有必要在其头端或者尾端增加新的空间，便配置一段定量连续空间，串接在整个 deque 的头端或者尾端<br>好处：<br>避免"“vector 的重新配置，复制，释放"的轮回，维护连整体连续的假象，并提供随机访问的接口；</p><p>坏处：<br>其迭代器变得很复杂</p><p>![[deque(双端数组) 2022-10-24 15.44.44.excalidraw]]<br>deque 迭代器<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210241555198.png" alt="|800"><br>deque 拥有两个数据成员<br>start 与 finish迭代器，分别由 deque: begin0 与 deque: end () 传回<br>代码: <a href="marginnote3app://note/2E3E757E-49BA-4C0A-924C-0E135F6AF9C1">margin: deque:拥有两个数据成员</a></p><p>deque 数据结构：<br>deque 除了维护一个 map 指针以外，还维护了 start 与 finish 迭代器分别指向第一缓冲区的第一个元素，和最后一个缓冲区的最后一个元素的下一个元素，同时它还必须记住当前 map 的大小。具体结构和源代码看上面</p><p>deque 的构造与管理</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//deque首先自行定义了两个空间配置器</span><br><span class="hljs-keyword">typedef</span> simple_al1oc &lt;value_type, Al1oc&gt; data_allocator;<br><span class="hljs-keyword">typedef</span> simple alloc &lt;pointer, Alloc&gt; map_allocator;<br></code></pre></td></tr></tbody></table></figure><p>dequet 中有一个构造函数用于构造 deque: 结构并赋初值<br>代码: <a href="dequet%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%94%A8%E4%BA%8E%E6%9E%84%E9%80%A0deque:%E7%BB%93%E6%9E%84%E5%B9%B6%E8%B5%8B%E5%88%9D%E5%80%BC">margin: dequet中有一个构造函数用于构造deque:结构并赋初值</a></p><p>接下来就是插入操作的实现，第一，首先判断是否有扩充 map 的需求，若有就扩，然后就是在插入函数中，首先判断是否在结尾或者开头从而判断是否跳跃节点。</p><blockquote><p>下边还有代码, 点上边的链接吧</p></blockquote><h1 id="3-deque-与-vector-的区别"><a class="markdownIt-Anchor" href="#3-deque-与-vector-的区别"></a> 3: deque 与 vector 的区别</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210241628635.png" alt=""></p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsi2oTtK6yTosYOpuAMTBCA" --> <p>📝deque(双端数组)::<br>2022/10/24 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>list</title>
    <link href="/posts/23529/"/>
    <url>/posts/23529/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190804102824357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpa2VfdGhhdA==,size_16,color_FFFFFF,t_70" alt=""></p><h1 id="1-list-设计"><a class="markdownIt-Anchor" href="#1-list-设计"></a> 1: list 设计</h1><p>每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问<br>在哪里添加删除元素性能都很高，不需要移动内存，当然也不需要对每个元素都进行构造与析构了，所以常用来做随机插入和删除操作容器<br>list 属于双向链表，其结点与 list 本身是分开设计的：<br>![[list 2022-10-24 14.48.11.excalidraw]]</p><p>list 是一个环状的双向链表，同时它也满足 STL 对于“前闭后开”的原则，即在链表尾端可以加上空白节点</p><!-- basicblock-start oid="ObsymZwyay7M2Xh2uaY51cJm" deck= "❓疑问::👨🏻‍💻code::C++:: C++ STL::list.md"--><ul><li>[ ]  list 的迭代器的设计： ::  #疑问</li></ul><!-- basicblock-end --><p>迭代器是泛化的指针所以里面重载了-&gt;，一，+，* ()，等运算符，同时迭代器是算法与容器之间的桥梁，<br>算法需要了解容器的方方面面，于是就诞生了 5 种关联类型，（这 5 种类型是必备的，可能还需要其他类型）我们知道算法传入的是迭代器或者指针，算法根据传入的迭代器或指针推断出算法所想要了解的容器里的 5 种关联类型的相关信息。由于光传入指针，算法推断不出来其想要的信息，所以我们需要一个中间商（萃取器）也就是我们所说的 iterator traits 类，对于一般的迭代器，它直接提供迭代器里的关联类型值，而对于指针和常量指针，它采用的类模板偏特化，从而提供其所需要的关联类型的值。</p><p>![[list 2022-10-24 15.16.57.excalidraw]]</p><h1 id="2-vector-和-list-的区别"><a class="markdownIt-Anchor" href="#2-vector-和-list-的区别"></a> 2: vector 和 list 的区别</h1><p>1.vector 底层实现是数组；Iist 是双向链表<br>2.vector 是顺序内存，支持随机访问，Iist 不行</p><!-- basicblock-start oid="Obs1KtZkktriKr4tKsKw6Tem" deck= "❓疑问::👨🏻‍💻code::C++:: C++ STL::list.md"--><ul><li>[ ]  3.vector 在中间节点进行插入删除会导致内存拷贝，list 不会 ::  #疑问</li></ul><!-- basicblock-end --><p>4.vector 一次性分配好内存，不够时才进行翻倍扩容；Iist 每次插入新节点都会进行内存申请<br>5.vector 随机访问性能好，插入删除性能差；list 随机访问性能差，插入删除性能好</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsAgdy7FKbq9qk0T04tMSnI" --> <p>📝list:: <a href="marginnote3app://note/1856DABB-F6C5-4397-AD0B-C8AB85EC6E4D">margin: list(链表)</a><br>2022/10/24 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vector (目录)</title>
    <link href="/posts/54713/"/>
    <url>/posts/54713/</url>
    
    <content type="html"><![CDATA[<p>📝vector::<br>2022/10/21 : 第一次创建</p><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/20190804120900612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpa2VfdGhhdA==,size_16,color_FFFFFF,t_70" alt=""></p><h1 id="1-底层结构"><a class="markdownIt-Anchor" href="#1-底层结构"></a> 1: [[底层结构]]</h1><h1 id="2-vector-原理-扩容过程"><a class="markdownIt-Anchor" href="#2-vector-原理-扩容过程"></a> 2: [[vector 原理 (扩容过程)]]</h1><h1 id="3-vector-api"><a class="markdownIt-Anchor" href="#3-vector-api"></a> 3: [[vector API]]</h1><h1 id="4-vector-源码"><a class="markdownIt-Anchor" href="#4-vector-源码"></a> 4: vector 源码</h1><blockquote><p>源码暂时没看<br><a href="marginnote3app://note/C7CA8DCF-BF03-4A4E-B23A-88ADF2ED37B5">margin: 3. vector源码</a></p></blockquote><h1 id="5-9-vector与list的区别与应用怎么找某vector或者list的倒数第二个元素"><a class="markdownIt-Anchor" href="#5-9-vector与list的区别与应用怎么找某vector或者list的倒数第二个元素"></a> 5: [[9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素]]</h1><h1 id="6-11-vector如何释放空间"><a class="markdownIt-Anchor" href="#6-11-vector如何释放空间"></a> 6: [[11、Vector如何释放空间]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pair 容器</title>
    <link href="/posts/32574/"/>
    <url>/posts/32574/</url>
    
    <content type="html"><![CDATA[<p>保存两个数据成员，用来生成特定类型的模板。<br>使用：<code>pair&lt;T1,T2&gt;p</code>;<br>数据成员是 Public, 两个成员分别是 first 和 second<br>其中 map 的元素是 pair, <code>pair&lt;const key_type, mapped_type&gt;</code> 可以用来遍历关联容器</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;string,<span class="hljs-type">int</span>&gt;p; <br><span class="hljs-keyword">auto</span> map1 = p.<span class="hljs-built_in">cbegin</span>(); <br><span class="hljs-keyword">while</span>(map1 != p.<span class="hljs-built_in">cend</span>()) <br>{ <br>cout&lt;&lt;mapl-&gt;first&lt;&lt;map1-&gt;second&lt;&lt;endl; <br>++map1; <br>}<br><br></code></pre></td></tr></tbody></table></figure><p>对 map 进行插入，元素类型是 pair:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">p.<span class="hljs-built_in">insert</span>({word,<span class="hljs-number">1</span>}); <br>p.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string,<span class="hljs-type">int</span>&gt;(word,<span class="hljs-number">1</span>));<br></code></pre></td></tr></tbody></table></figure><p>insert对不包含重复关键字的容器，插入成功返回<code>pair&lt;迭代器，bool&gt;</code>迭代器指向给定关键字元素，bool指出插入是否成功。</p><!-- basicblock-start oid="ObsSRo5VEciyNiIPQrifZgoP" deck= "❓疑问::👨🏻‍💻code::C++:: C++ STL::pair 容器.md"--><ul><li>[ ]  这是啥意思啊  ::  #疑问</li></ul><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;pair&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(val.<span class="hljs-built_in">begin</span>(), val.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 变量</span><br><span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>(),[](<span class="hljs-keyword">auto</span> &amp;a, <span class="hljs-keyword">auto</span> &amp;b){     <br>    <span class="hljs-keyword">return</span> a.second &gt; b.second; <br>});<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsvU77JC9fEv4SCPRL3fHkO" --> <p>📝pair 容器:: <a href="marginnote3app://note/BBF78FA3-2924-4989-ACAA-8A021296BA54">margin: pair容器</a><br>2022/10/26 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL的优点</title>
    <link href="/posts/35785/"/>
    <url>/posts/35785/</url>
    
    <content type="html"><![CDATA[<p>STL 具有高可重用性，高性能，高移植性，跨平台的优点。</p><h1 id="1-高可重用性"><a class="markdownIt-Anchor" href="#1-高可重用性"></a> 1 高可重用性：</h1><p>STL 中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p><h1 id="2-高性能"><a class="markdownIt-Anchor" href="#2-高性能"></a> 2 高性能：</h1><p>如map 可以高效地从十万条记录里面查找出指定的记录，因为 map 是采用红黑树的变体现的。</p><h1 id="3-高移植性"><a class="markdownIt-Anchor" href="#3-高移植性"></a> 3 高移植性：</h1><p>如在项目A上用 STL编写的模块，可以直接移植到项目B上。<br>STL的一个重要特性是将数据和操作分离<br>数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当"粘合剂”以使算法可以和容器交互运作。</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsEMEWJA3bdxFYn237eNOmv" --> <p>📝STL的优点::<br>2022/10/21 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>STL实现原理及其实现</title>
    <link href="/posts/30241/"/>
    <url>/posts/30241/</url>
    
    <content type="html"><![CDATA[<p>STL 提供了六大组件，彼此之间可以组合套用，这六大组件分别是：<br>容器、算法、迭代器、仿函数、适配器（配接器)、空间配置器。<br>![[STL 六大部件.excalidraw|600]]</p><p>STL 六大组件的交互关系：</p><ol><li>容器通过空间配置器取得数据存储空间</li><li>算法通过迭代器存储容器中的内容</li><li>仿函数可以协助算法完成不同的策略的变化</li><li>适配器可以修饰仿函数。</li></ol><h1 id="1-容器"><a class="markdownIt-Anchor" href="#1-容器"></a> 1 容器</h1><p>各种数据结构，如 vector.、Iist、deque、set、map 等，用来存放数据，从实现角度来看，STL 容器是一种 class template.。</p><h1 id="2-算法"><a class="markdownIt-Anchor" href="#2-算法"></a> 2 算法</h1><p>各种常用的算法，如 sort、find、copy、for_each。从实现的角度来看，STL 算法是一种 function tempalte.</p><h1 id="3-迭代器"><a class="markdownIt-Anchor" href="#3-迭代器"></a> 3 迭代器</h1><p>扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将 operator* ,operator-&gt;, operator++,operator-等指针相关操作予以重载的 class template.。</p><p>所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。<br>原生指针(native pointer)也是一种迭代器。</p><h1 id="4-仿函数"><a class="markdownIt-Anchor" href="#4-仿函数"></a> 4 仿函数</h1><p>行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator () 的 class 或者 class template</p><h1 id="5-适配器"><a class="markdownIt-Anchor" href="#5-适配器"></a> 5 适配器</h1><p>一种用来修饰容器或者仿函数或迭代器接口的东西。<br>STL提供的queue和stack,虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque, 所有操作都由底层的deque供应。<br>空间配置器负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的 clss tempalte.</p><p>一般的分配器的 std: alloctor 都含有两个函数 allocate. 与 deallocte, 这两个函数分别调用 operator new () 与 delete (),  这两个函数的底层又分别是 malloc () and free ();<br>但是每次 malloc 会带来格外开销（因为每次 malloc 一个元素都要带有附加信息)</p><blockquote><p>[!summary] 容器之间的实现关系以及分类：<br>![[STL实现原理及其实现 2022-10-21 16.37.35.excalidraw]]</p></blockquote><p>[[STL的优点]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsP0e5b4TNnOWc28aqQJPL0" --> <p>📝STL实现原理及其实现::<br>2022/10/21 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>运算符重载</title>
    <link href="/posts/22011/"/>
    <url>/posts/22011/</url>
    
    <content type="html"><![CDATA[<blockquote><p>没看完</p></blockquote><p>重载运算符函数可以对运算符作出新的解释，但原有基本语义不变：<br>不改变运算符的优先级<br>不改变运算符的结合性<br>不改变运算符所需要的操作数<br>不能创建新的运算符</p><!-- basicblock-start oid="ObsNP5s1pLfJnKBxLfXvkaPN" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::运算符重载.md"--><ul><li>[ ]  重载运算符函数，本质还是函数调用，所以重载后：::  #疑问</li></ul><!-- basicblock-end --><p>(1) 可以是和调用运算符的方式调用，data1+data2</p><p>(2)也可以是调用函数的方式，operator+(data1,data2), 这就要注意运算符函数的名字是“operator运算符’ 在可以重载的运算符里有逗号、取地址、逻辑与、逻辑或</p><p>不建议重载:<br>逗号、取地址，本身就对类类型有特殊定义；逻辑与、逻辑或，有短路求值属性；逗号、逻辑与、或，定义了求值顺序。<br>运算符重载应该是作为类的成员函数 or 非成员函数（具体后面各小节会涉及）。有个对应知识点，</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObswLX9debqpUJkxZ5pWSNi4"  --> <p>#历史记录:: <a href="marginnote3app://note/23F5AC69-4A7F-4B31-85FC-19D4ADF45155">margin: 运算符重载</a><br>2022/10/21🌵运算符重载 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>future 库</title>
    <link href="/posts/50165/"/>
    <url>/posts/50165/</url>
    
    <content type="html"><![CDATA[<ul><li>[ ]  future 库:: #疑问</li></ul><!-- basicblock-end --><p>用于任务链（即任务 A 的执行必须依赖于任务 B 的返回值）</p><p>1、例子：生产者消费者问题<br>(1) 子线程作为消费者参数是一个 future, 用这个 future 等待一个 int 型的产品：std:future&amp;fut<br>(2）子线程中使用 get() 方法等待一个未来的 future, 返回一个 result<br>(3) 主线程作为生产者，做出一个承诺：std: promise prom<br>(4) 用此承诺中的 get_futuret() 方法获取一个 future<br>(5) 主线程中将子线程创建出来，并将刚刚获取到的 future 作为参数传入<br>(6) 主线程做一些列的生产工作，最后生产完后使用承诺中的 set_value () 方法，参数为刚刚生产出的产品<br>(7）此时产品就会被传到子线程中，子线程就可以使用此产品做一系列动作</p><p>(8) 最后使用 join (方法等待子线程停止，但是 join 只适用于等待没有返回值的线程的情况</p><p>2、如果线程有返回值<br>(1) 使用 async 方法可以进行异步执行<br>参数一：可以选择是马上执行还是等一会执行（即当消费者线程调用 get () 方法时才开始执行）<br>参数二：执行的内容（可以放一个函数对象或 lambda 表达式）<br>(2）生产者使用 async? 方法做生产工作并返回一个 future<br>(3)消费者使用futurel中的get()方法可以获取产品</p><p>![[future 库 2022-10-21 13.39.45.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs76qYFSGvs2j0diOzecD5X"  --> <p>#历史记录:: <a href="marginnote3app://note/41978AFE-60C7-401F-A616-2B47E4E0E043">margin: future库</a><br>2022/10/21🌵future 库 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>信号量</title>
    <link href="/posts/1176/"/>
    <url>/posts/1176/</url>
    
    <content type="html"><![CDATA[<p>1、binary_semaphore<br>定义： 可以当事件来用，只有有信号和无信号两种状态，一次只能被一个线程所持有。</p><p>使用步骤：<br>(1) 初始创建信号量，并且一开始将其置位成无信号状态 std: binary_semaphore sem (0)<br>(2）线程使用 acquire () 方法等待被唤醒<br>(3) 主线程中使用 release() 方法，将信号量变成有信号状态</p><p>2.counting_semaphore<br>定义： 一次可以被很多线程所持有，线程的数量由自己指定</p><p>使用步骤：<br>(1) 创建信号量指定一次可以进入的线程的最大数量，并在最开始将其置位成无信号状态：std:biinary_semaphore&lt;8&gt;sem (0)</p><p>(2) 主线程中创建 10 个线程并且这些线程全部调用 acquire () 方法等待被唤醒。<br>但是主线程使用 release (6) 方法就只能随机启用 6 个线程。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsrMPwOjodPnCGynHY4BERg"  --> <p>#历史记录:: <a href="marginnote3app://note/C7559B6D-F761-4F9A-915E-77B898CE122E">margin: 信号量</a><br>2022/10/21🌵信号量 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>副作用编程</title>
    <link href="/posts/1228/"/>
    <url>/posts/1228/</url>
    
    <content type="html"><![CDATA[<h1 id="1-无副作用编程"><a class="markdownIt-Anchor" href="#1-无副作用编程"></a> 1 无副作用编程</h1><p>存在一个函数，传一个参数 x 进去，里面进行一系列的运算，返回一个 y。<strong>中间的所有过程都是在栈中进行修改</strong></p><h1 id="2-有副作用编程"><a class="markdownIt-Anchor" href="#2-有副作用编程"></a> 2 有副作用编程</h1><p>比如在一个函数运行的过程中对全局变量进行了修改或在屏幕上输出了一些东西。<br>此函数还有可能是类的成员方法，在此方法中如果对成员变量进行了修改，类的状态就会发生改变</p><h1 id="3-在多线程情况下的有副作用编程"><a class="markdownIt-Anchor" href="#3-在多线程情况下的有副作用编程"></a> 3 在多线程情况下的有副作用编程</h1><p>在线程 1 运行的时候对成员变量进行了修改，此时如果再继续运行线程 2，此时线程 2 拥有的就不是这个类的初始状态，运行出来的结果会受到线程 1 的影响</p><p>解决办法：将成员方法设为const,.此时就可以放心进行调用</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsVNR5p7lJ8CzXC2BQQhhKO"  --> <p>#历史记录::<br>2022/10/21🌵副作用编程 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>16. 全排列 II</title>
    <link href="/posts/64375/"/>
    <url>/posts/64375/</url>
    
    <content type="html"><![CDATA[<h1 id="1-47全排列-ii"><a class="markdownIt-Anchor" href="#1-47全排列-ii"></a> 1 47.全排列 II</h1><p><a href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接</a></p><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>：<br><br>-   输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>-   输出： [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br><br>示例 <span class="hljs-number">2</span>：<br><br>-   输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>-   输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]<br><br>提示：<br><br>-   <span class="hljs-number">1</span> &lt;= nums.length &lt;= <span class="hljs-number">8</span><br>-   <span class="hljs-number">-10</span> &lt;= nums[i] &lt;= <span class="hljs-number">10</span><br><br></code></pre></td></tr></tbody></table></figure><p>[[13.子集II]], [[8.组合总和II]]<br>我们分别详细讲解了组合问题和子集问题如何去重</p><ul><li>[ ] 总结去重 #projects</li></ul><p>那么排列问题其实也是一样的套路。<br><strong>还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p><p>![[16. 全排列 II 2022-10-21 11.27.59.excalidraw]]</p><h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码</h1><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsF1F3dloHAJZv1cfH3JgyJ" --> <p>📝16. 全排列 II::<br>2022/10/26 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排列问题</title>
    <link href="/posts/581/"/>
    <url>/posts/581/</url>
    
    <content type="html"><![CDATA[<p>典型例题:  [[15. 全排列]]</p><ul><li><p>每层都是从0开始搜索而不是startIndex</p><ul><li>因为要求每个元素的排列方式</li></ul></li><li><p>需要used数组记录path里都放了哪些元素了</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt; used)</span></span>{<br><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span> <span class="hljs-params">(nums. size (), <span class="hljs-literal">false</span>)</span></span><br><span class="hljs-function"><span class="hljs-comment">// 初始化为 false, 遍历到哪个元素就设成 true</span></span><br></code></pre></td></tr></tbody></table></figure><p>排列问题是回溯算法解决的经典题目，大家可以好好体会体会。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 结束本轮递归开始回溯,💡主要收集叶子节点</span><br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>     <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 目的是: 跳到收集过元素的下一个位置</span><br>     <br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs8zwPF7O7RnEpYIcACYLdb" --> <p>📝排列问题::<br>2022/10/21 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>15. 全排列</title>
    <link href="/posts/34531/"/>
    <url>/posts/34531/</url>
    
    <content type="html"><![CDATA[<h1 id="1-46全排列"><a class="markdownIt-Anchor" href="#1-46全排列"></a> 1 46.全排列</h1><p><a href="https://leetcode.cn/problems/permutations/">力扣题目链接</a></p><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">示例:<br><br>-   输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>-   输出: [ [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] ]<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-回溯三部曲"><a class="markdownIt-Anchor" href="#2-回溯三部曲"></a> 2 回溯三部曲</h1><p>![[15. 全排列 2022-10-21 11.13.28.excalidraw]]</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p><h2 id="21-递归函数参数"><a class="markdownIt-Anchor" href="#21-递归函数参数"></a> 2.1 递归函数参数</h2><p><strong>首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方</strong>。</p><p>可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。<br>但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span><br></code></pre></td></tr></tbody></table></figure><h2 id="22-递归终止条件"><a class="markdownIt-Anchor" href="#22-递归终止条件"></a> 2.2 递归终止条件</h2><p>可以看出叶子节点，就是收割结果的地方。</p><p>那么什么时候，算是到达叶子节点呢？</p><p>当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 此时说明找到了一组</span><br><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) {<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="23-单层搜索的逻辑"><a class="markdownIt-Anchor" href="#23-单层搜索的逻辑"></a> 2.3 单层搜索的逻辑</h2><p>这里和 [[2.组合问题]], [[9.分割回文串]], [[11. 子集问题]]<br>最大的不同就是 for 循环里不用 startIndex 了。</p><p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// path里已经收录的元素，直接跳过</span><br>    used[i] = <span class="hljs-literal">true</span>;<br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, used);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    used[i] = <span class="hljs-literal">false</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>V1 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt; used)</span></span>{<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(used[i] == <span class="hljs-literal">true</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 目的是: 跳到收集过元素的下一个位置</span><br>            used[i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            used[i] = <span class="hljs-literal">false</span>;<br>            <br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// ❗️在这里赋值, 在上面赋值找不到nums.size()</span><br>        <span class="hljs-built_in">backtracking</span>(nums, used);<br>        <span class="hljs-keyword">return</span> result;<br>        <br><br><br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsusRGQqgaBQJWOkxb3HnBj"  --> <p>#历史记录::<br>2022/10/21🌵15. 全排列 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子集问题</title>
    <link href="/posts/20568/"/>
    <url>/posts/20568/</url>
    
    <content type="html"><![CDATA[<p>[[1.回溯算法理论基础]]</p><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        💡<span class="hljs-comment">// 子集问题一般是收集树上的节点. 不用return 操作</span><br>        <span class="hljs-comment">// return;// 结束本轮递归开始回溯, 一般用来最后收集叶子节点</span><br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        💡<span class="hljs-keyword">if</span> 语句对同一树层的去重<br>        <br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs4z6tIB4y2Qy380rd3xn3g" --> <p>📝子集问题::<br>2022/10/26 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14. 递增子序列</title>
    <link href="/posts/30121/"/>
    <url>/posts/30121/</url>
    
    <content type="html"><![CDATA[<h1 id="1-491递增子序列"><a class="markdownIt-Anchor" href="#1-491递增子序列"></a> 1 491.递增子序列</h1><p><a href="https://leetcode.cn/problems/increasing-subsequences/">力扣题目链接</a></p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">示例:<br><br>-   输入: [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]<br>-   输出: [[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">7</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>]]<br></code></pre></td></tr></tbody></table></figure><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是&nbsp;<code>[-100,100]</code>。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><p>[[13.子集II]]中我们是通过排序，再加一个标记数组来达到去重的目的。<br>而本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了。<br><strong>所以不能使用之前的去重逻辑！</strong></p><p>本题给出的示例，还是一个有序数组 [4, 6, 7, 7]，这更容易误导大家按照排序的思路去做了。</p><p>为了有鲜明的对比，我用[4, 7, 6, 7]这个数组来举例，抽象为树形结构如图：</p><p>![[14. 递增子序列 2022-10-21 09.39.00.excalidraw]]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ul><li>递归函数参数</li></ul><p>本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span><br></code></pre></td></tr></tbody></table></figure><ul><li>终止条件</li></ul><p>本题其实类似求子集问题，也是要遍历树形结构找每一个节点，所以和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">回溯算法：求子集问题！</a>一样，可以不加终止条件，startIndex每次都会加1，并不会无限递归。</p><p>但本题收集结果有所不同，题目要求递增子序列大小至少为 2，所以终止代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) {<br>    result.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-comment">// 注意这里不要加return，因为要取树上的所有节点</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索逻辑<ul><li>去重<ul><li>遍历元素小于 path 的最后一个元素的值跳过 (因为题目要求递增数组)</li><li>同一层下, 后边相同的元素要跳过: 用 set 来去重</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">unordered_set&lt;<span class="hljs-type">int</span>&gt; uset; <span class="hljs-comment">// 使用set来对本层元素进行去重</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>    <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>())<br>            || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>()) {<br>            <span class="hljs-keyword">continue</span>;<br>    }<br>    uset.<span class="hljs-built_in">insert</span>(nums[i]); <span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong><code>unordered_set&lt;int&gt; uset;</code> 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！</strong><br>所以没有 pop () 操作</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>V1: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>{<br><br>    <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>){<br>        result.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-comment">// 注意这里不要加return，要取树上的节点</span><br>    }<br>    <span class="hljs-comment">// 💡uset每次都会清空, 因为递归到下一层的时候又重新定义了</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;<span class="hljs-comment">// ❗️放在外边, 下面的if语句才能判断到</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>        <span class="hljs-keyword">if</span>((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>()) || (uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>())){<br>            <span class="hljs-keyword">continue</span>;<br>        }<br>        uset.<span class="hljs-built_in">insert</span>(nums[i]);<span class="hljs-comment">// 记录这个元素在本层用过了，本层后面不能再用了</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">backtracking</span>(nums, i+<span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    }<br>}<br>    <br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!tip] 下次在看<br>以上代码用我用了<code>unordered_set&lt;int&gt;</code>来记录本层元素是否重复使用。<br><strong>其实用数组来做哈希，效率就高了很多</strong>。</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsELbpU5lhyA4ucjyoBimCC"  --> <p>#历史记录::<br>2022/10/21🌵14. 递增子序列 : 抄了一遍⏱0-53</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机中的乱序执行</title>
    <link href="/posts/45791/"/>
    <url>/posts/45791/</url>
    
    <content type="html"><![CDATA[<ul><li>[ ]  1、一定会按正常顺序执行的情况::  #疑问</li></ul><!-- basicblock-end --><ol><li>对同一块内存进行访问，此时访问的顺序不会被编译器修改</li><li>新定义的变量的值依赖于之前定义的变量，此时两个变量定义的顺序不会被编译器修改</li></ol><p>2、其他情况计算机会进行乱序执行</p><p>单线程的情况下允许，但是多线程情况下就会产生问题</p><!-- basicblock-start oid="Obs79mEUQmIZL963vubMe628" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::计算机中的乱序执行.md"--><ul><li>[ ]  3、C++中的库中提供了六种内存模型::  #疑问</li></ul><!-- basicblock-end --><p>用于在多线程的情况下防止编译器的乱序执行<br>(1) memory_order_relaxed 最放松的</p><p>(2) memory_order_consume<br>当客户使用，搭配 releaset 使用，被 release 进行赋值的变量 y, 获取的时候如果写成 consume, 那么所有与 y 有关的变量的赋值一定会被按顺序进行</p><p>(3) memory_order_acquire 用于获取资源</p><p>(4) memory_order_release<br>一般用于生产者，当给一个变量 y 进行赋值的时候，只有自己将这个变量释放了，别人才可以去读，读的时候如果使用 acquire: 来读，编译器会保证在 y 之前被赋值的变量的赋值都在 y 之前被执行，相当于设置了内存屏障<br>(5) memory_order_acq_rel (acquire/release)</p><p>(6) memory_order_seq_cst (squentially consistent)<br>好处：不需要编译器设置内存屏障，morden c++开始就会有底层汇编的能力</p><p>[[副作用编程]]</p><p>[[信号量]]</p><p>[[future 库]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObszBObxRP696kVqonKVQUmA"  --> <p>#历史记录:: <a href="marginnote3app://note/EB2E3DEF-F6F2-4D1E-BC8B-6FFE516DE906">margin: 计算机中的乱序执行</a><br>2022/10/21🌵计算机中的乱序执行 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C 与 C++的内存分配方式</title>
    <link href="/posts/48215/"/>
    <url>/posts/48215/</url>
    
    <content type="html"><![CDATA[<p>![[进程的地址空间分布.excalidraw]]</p><h1 id="1-从静态存储区域分配"><a class="markdownIt-Anchor" href="#1-从静态存储区域分配"></a> 1 从静态存储区域分配</h1><p>内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，如全局变量，static 变量。</p><h1 id="2-在栈上创建"><a class="markdownIt-Anchor" href="#2-在栈上创建"></a> 2 在栈上创建</h1><p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。<br>栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><h1 id="3-从堆上分配动态内存分配"><a class="markdownIt-Anchor" href="#3-从堆上分配动态内存分配"></a> 3 从堆上分配（动态内存分配）</h1><p>程序在运行的时候用malloc或new申请任意多少的内存，程序员负责在何时用free或delete释放内存。动态内存的生存期自己决定，使用非常灵活。</p><blockquote><p>[!tip] 还不如用智能指针, 省心呢</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs51ZKsCRizWUHIr97lqsmg"  --> <p>#历史记录::<br>2022/10/20🌵C 与 C++的内存分配方式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进程的地址空间分布</title>
    <link href="/posts/10783/"/>
    <url>/posts/10783/</url>
    
    <content type="html"><![CDATA[<p>进程的地址空间分布::第一次创建</p><!-- basicblock-end --><p>![[进程的地址空间分布.excalidraw]]</p><h1 id="1-61-什么是内存泄露如何检测与避免堆"><a class="markdownIt-Anchor" href="#1-61-什么是内存泄露如何检测与避免堆"></a> 1: [[61、什么是内存泄露，如何检测与避免|堆]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试题目</title>
    <link href="/posts/15105/"/>
    <url>/posts/15105/</url>
    
    <content type="html"><![CDATA[<h1 id="1-以下为windowsnt32位c程序请计算下面sizeof的值"><a class="markdownIt-Anchor" href="#1-以下为windowsnt32位c程序请计算下面sizeof的值"></a> 1 以下为WindowsNT32位C++程序，请计算下面sizeof的值</h1><p>‌‌‌　　![[测试题目 2022-10-20 21.21.54.excalidraw]]</p><h1 id="2-分析运行下面的-test-函数会有什么样的结果"><a class="markdownIt-Anchor" href="#2-分析运行下面的-test-函数会有什么样的结果"></a> 2 分析运行下面的 Test 函数会有什么样的结果</h1><p>‌‌‌　　![[测试题目 2022-10-20 21.29.08.excalidraw]]</p><h1 id="3-margin-5-按照下面描述的要求写程序"><a class="markdownIt-Anchor" href="#3-margin-5-按照下面描述的要求写程序"></a> 3 <a href="marginnote3app://note/01314AD5-74D6-4B28-87DC-D66E4468EA26">margin: 5、按照下面描述的要求写程序</a></h1><blockquote><p>不想看</p></blockquote><h1 id="4-进程的地址空间分布"><a class="markdownIt-Anchor" href="#4-进程的地址空间分布"></a> 4 [[进程的地址空间分布]]</h1><h1 id="5-c-与-c的内存分配方式"><a class="markdownIt-Anchor" href="#5-c-与-c的内存分配方式"></a> 5 [[C 与 C++的内存分配方式]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsqMyQOpJUmgaxrcRwbA3kZ"  --> <p>#历史记录::<br><a href="marginnote3app://note/FCA58332-0A24-428C-8279-6E04E253D12A">margin: 测试题目</a></p><p>2022/10/20🌵测试题目 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存泄露</title>
    <link href="/posts/20746/"/>
    <url>/posts/20746/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是内存泄露"><a class="markdownIt-Anchor" href="#1-什么是内存泄露"></a> 1 什么是内存泄露？</h1><p>内存泄漏 (memory leak) 是指由于疏忽或错误造成了<strong>程序未能释放掉不再使用的内存</strong>的情况。<br>内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><p>可以使用Valgrind,mtrace进行内存泄漏检查。</p><p>什么操作会导致内存泄露？<br>指针指向改变，未释放动态分配内存。</p><h1 id="2-内存泄漏的分类"><a class="markdownIt-Anchor" href="#2-内存泄漏的分类"></a> 2 内存泄漏的分类</h1><p>(1) 堆内存泄漏 (Heap leak)<br>对内存指的是程序运行中根据需要分配通过 malloc,realloc new 等从堆中分配的一块内存，再是完成后必须通过调用对应的 free 或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生 Heap Leak.</p><!-- basicblock-start oid="ObskegOr30AfO2xCHRTeAHLG" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::内存泄露.md"--><p>(2) 系统资源泄露 (Resource Leak) ::<br>主要指程序使用系统分配的资源比如 Bitmap,handle,SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</p><!-- basicblock-end --><p>(3) 没有将基类的析构函数定义为虚函数<br>当基类指针指向子类对象时，<strong>如果基类的析构函数不是virtual,那么子类的析构函数将不会被调用</strong>，子类的资源没有正确是释放，因此造成内存泄露。</p><h1 id="3-如何防止内存泄露"><a class="markdownIt-Anchor" href="#3-如何防止内存泄露"></a> 3 如何防止内存泄露？</h1><ul><li><p>将内存的分配封装在类中，构造函数分配内存，析构函数释放内存；</p></li><li><p><a href="%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">使用智能指针</a></p></li></ul><h1 id="4-构造函数析构函数要设为虚函数吗为什么"><a class="markdownIt-Anchor" href="#4-构造函数析构函数要设为虚函数吗为什么"></a> 4 构造函数，析构函数要设为虚函数吗，为什么？</h1><!-- basicblock-start oid="ObstNJIwhGTcH9PirHGpLowH" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::内存泄露.md"--><h2 id="41-构造函数"><a class="markdownIt-Anchor" href="#41-构造函数"></a> 4.1 构造函数::</h2><!-- basicblock-end --><blockquote><p>[!question] 设计模式中抽象构造函数就是虚函数啊<br>构造函数不需要，没有意义。虚函数调用是在部分信息下完成工作的机制，允许我们只知道接口而不知道对象的确切类型。要创建一个对象，你需要知道对象的完整信息。特别是，你需要知道你想要创建的确切类型。因此，构造函数不应该被定义为虚函数。</p></blockquote><h2 id="42-析构函数"><a class="markdownIt-Anchor" href="#42-析构函数"></a> 4.2 析构函数</h2><p>析构函数需要。当派生类对象中有内存需要回收时，如果析构函数不是虚函数，不会触发动态绑定，只会调用基类析构函数，导致派生类资源无法释放，造成内存泄漏。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs9csa6vySkSVWDdPoTRqqK"  --> <p>#历史记录::<br>2022/10/20🌵内存泄露 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串函数</title>
    <link href="/posts/6626/"/>
    <url>/posts/6626/</url>
    
    <content type="html"><![CDATA[<h1 id="1-strcpy"><a class="markdownIt-Anchor" href="#1-strcpy"></a> 1 strcpy()</h1><p>把从 strsrc 地址开始且含有 <code>\O</code> 结束符的字符串, 复制到以 strdest 开始的地址空间，<br>返回值的类型为 <code>char*</code></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">strcpy</span> <span class="hljs-params">( <span class="hljs-type">char</span> *strDest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> strSrc)</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsQnb3jtH3OQohGpwGiXsuq" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::字符串函数.md"--><h2 id="1-实现内存拷贝函数"><a class="markdownIt-Anchor" href="#1-实现内存拷贝函数"></a> 1 实现内存拷贝函数::</h2><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strcpy</span> <span class="hljs-params">( <span class="hljs-type">char</span> *strDest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> strSrc)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">assert</span> <span class="hljs-params">( (strDest != <span class="hljs-literal">NULL</span>) &amp;&amp; (strsrc!= <span class="hljs-literal">NULL</span>) )</span></span>;<br><span class="hljs-type">char</span> *address = strDest <br><span class="hljs-keyword">while</span>( (*strDest++ = *strSrc++) != <span class="hljs-string">'\0'</span>) ;<br><span class="hljs-keyword">return</span> address;<br><br></code></pre></td></tr></tbody></table></figure><p>‌‌‌<br>![[字符串函数 2022-10-20 21.46.36.excalidraw]]</p><!-- basicblock-start oid="ObsXtfED8VBBxOlbKX5O3Wgd" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::字符串函数.md"--><h2 id="2-假如考虑-dst-和-src-内存重叠的情况strcpy-该怎么实现"><a class="markdownIt-Anchor" href="#2-假如考虑-dst-和-src-内存重叠的情况strcpy-该怎么实现"></a> 2 假如考虑 dst 和 src 内存重叠的情况，strcpy 该怎么实现::</h2><!-- basicblock-end --><p><a href="marginnote3app://note/B3CCC4DA-EBFC-40FB-8E82-2126D75E1395">margin: 假如考虑dst和src内存重叠的情况,strcpy该怎么实现</a><br>‌‌‌![[字符串函数 2022-10-20 21.56.10.excalidraw]]</p><h1 id="2-strlen"><a class="markdownIt-Anchor" href="#2-strlen"></a> 2 strlen ()</h1><p>计算给定字符串的长度。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">strlen</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!principle]-<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210202046126.png" alt=""></p></blockquote><h1 id="3-strcat"><a class="markdownIt-Anchor" href="#3-strcat"></a> 3 strcat ()</h1><p>作用是把 src 所指字符串添加到 dest 结尾处。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span> * dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span> src)</span></span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!principle]-<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210202049202.png" alt=""></p></blockquote><h1 id="4-strcmp"><a class="markdownIt-Anchor" href="#4-strcmp"></a> 4 strcmp ()</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//strcmp的实现</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> str1,<span class="hljs-type">const</span> <span class="hljs-type">char</span> str2)</span>{<br>比较两个字符串设这两个字符串为 str1,str2, <br>若 str1 == str2, 则返回零<br>若 str1 &lt; str2, 则返回负数<br>若 str1 &gt; str2, 则返回正<br><br><br><br>assert(str1 &amp;str2); <br><span class="hljs-comment">//找到首个不相等的字符</span><br><span class="hljs-keyword">while</span>(*str1 &amp;&amp; *str2 &amp;&amp; (*str1 == *str2)) { <br>        str1++;<br>        str2++; <br>    }<br><span class="hljs-keyword">return</span> *str1 -*str2; <br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsMDrHBn9MXdAT3ksQnLEcD"  --> <p>#历史记录:: <a href="marginnote3app://note/56EA588D-C1FA-4C28-8B3A-C621894541E4">margin: C++内存模型</a><br>2022/10/20🌵字符串操作函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++内存模型</title>
    <link href="/posts/57131/"/>
    <url>/posts/57131/</url>
    
    <content type="html"><![CDATA[<h1 id="1-字符串函数"><a class="markdownIt-Anchor" href="#1-字符串函数"></a> 1 [[字符串函数]]</h1><h1 id="2-内存泄露"><a class="markdownIt-Anchor" href="#2-内存泄露"></a> 2 [[内存泄露]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObszrXJN2VqrgRXMx2lRfyTD"  --> <p>#历史记录::<br>2022/10/20🌵C++内存模型 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++强制类型转换</title>
    <link href="/posts/2120/"/>
    <url>/posts/2120/</url>
    
    <content type="html"><![CDATA[<p>关键字：static_cast、dynamic_.cast、reinterpret_cast 和 const_.cast</p><blockquote><p>[!summary]<br>上行转换：把派生类的指针或引用转换成基类表示<br>下行转换：把基类的指针或引用转换为派生类表示</p></blockquote><h1 id="1-static_cast"><a class="markdownIt-Anchor" href="#1-static_cast"></a> 1 static_cast</h1><p>![[C++强制类型转换 excalidraw]]</p><p>没有运行时类型检查来保证转换的安全性</p><p>用于低风险的转换： 基本类型<br>高风险转换：指针，引用…</p><p>进行上行转换是安全的<br>进行下行转换，由于没有动态类型检查，所以是不安全的。</p><p>使用：</p><ol><li>用于基本数据类型之间的转换，如把 int 转换成 char。</li><li>把任何类型的表达式转换成 void 类型。</li></ol><h1 id="2-dynamic_cast"><a class="markdownIt-Anchor" href="#2-dynamic_cast"></a> 2 dynamic_cast</h1><p>在进行下行转换时，dynamic_.cast具有类型检查（信息在虚函数中）的功能，比static_cast更安全。<br>转换后必须是类的指针、引用或者 void*, 基类要有虚函数，可以交叉转换。</p><p>dynamic 本身只能用于存在虚函数的父子关系的强制类型转换；<br>对于指针，转换失败则返回 nullptr,<br>对于引用，转换失败会抛出异常。</p><h1 id="3-reinterpret_cast"><a class="markdownIt-Anchor" href="#3-reinterpret_cast"></a> 3 reinterpret_cast</h1><p>可以将整型转换为指针，也可以把指针转换为数组；可以在指针和引用里进行肆无忌惮的转换，平台移植性比价差。</p><h1 id="4-const-cast"><a class="markdownIt-Anchor" href="#4-const-cast"></a> 4 const cast</h1><p>常量指针转换为非常量指针，并且仍然指向原来的对象。常量引用被转换为非常量引用，并且仍然指向原来的对象。去掉类型的 const 或 volatile 属性。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs22QG2rbF0HFJWqbqkIVPs"  --> <p>#历史记录::<br>2022/10/20🌵C++强制类型转换 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>智能指针</title>
    <link href="/posts/47719/"/>
    <url>/posts/47719/</url>
    
    <content type="html"><![CDATA[<p>智能指针 : 第一次创建:: <a href="https://www.bilibili.com/video/BV123411T747/?spm_id_from=333.788.recommend_more_video.4&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++智能指针初学者20分钟入门[搬运自油管#code_beauty]_哔哩哔哩_bilibili</a></p><!-- basicblock-end --><h1 id="1-分类"><a class="markdownIt-Anchor" href="#1-分类"></a> 1: 分类</h1><blockquote><p>[!summary] 智能指针就是类，类中有一个成员，管理着原始指针</p></blockquote><p>智能指针是为了解决动态分配内存导致内存泄露和多次释放同一内存所提出的，C11 标准中放在 <code>&lt;memory&gt;</code> 头文件。<br>包括：</p><ul><li>独占指针</li><li>共享指针</li><li>弱指针</li></ul><p>c++中为什么要有智能指针: 解决不用的指针未释放的问题</p><p>智能指针是类模板，在栈上创建智能指针对象。<br>把普通指针交给智能指针对象。<br>智能指针对象过期时，系统会自动调用智能指针对象的柝构函数。释放普通指针的内存</p><p>![[unique_ptr &amp; shared_ptr.excalidraw]]</p><h2 id="11-unique_ptr"><a class="markdownIt-Anchor" href="#11-unique_ptr"></a> 1.1: [[unique_ptr]]</h2><h2 id="12-shared_ptr"><a class="markdownIt-Anchor" href="#12-shared_ptr"></a> 1.2: [[shared_ptr]]</h2><h2 id="13-weak_ptr"><a class="markdownIt-Anchor" href="#13-weak_ptr"></a> 1.3: [[weak_ptr]]</h2><h1 id="2-3-使用智能指针管理内存资源raii是怎么回事"><a class="markdownIt-Anchor" href="#2-3-使用智能指针管理内存资源raii是怎么回事"></a> 2: [[3、使用智能指针管理内存资源，RAII是怎么回事？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽象类与接口的实现</title>
    <link href="/posts/48213/"/>
    <url>/posts/48213/</url>
    
    <content type="html"><![CDATA[<p>接口描述了类的行为和功能，而不需要完成类的特定实现；<br><strong>C++接口是使用抽象类来实现的</strong></p><p>1、类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用"=0”来指定的。<br>2、设计抽象类（通常称为 ABC) 的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 案例： 计算面积</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> { <br><span class="hljs-keyword">public</span>: <br><span class="hljs-comment">//提供接口框架的纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setwidth</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> </span><br><span class="hljs-function">    </span>{ <br>        width w; <br>    } <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> </span><br><span class="hljs-function">    </span>{ <br>        height h; <br>    } <br>    <span class="hljs-keyword">protected</span>: <br>        <span class="hljs-type">int</span> width; <br>        <span class="hljs-type">int</span> height; <br>};<br><span class="hljs-comment">//派生类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写</span><br>        <span class="hljs-keyword">return</span> (width * height); <br>    } <br>}; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span> : <span class="hljs-keyword">public</span> Shape {<br><span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{ <br>    <span class="hljs-keyword">return</span> (width height)/<span class="hljs-number">2</span>; <br>    } <br>};<br><br><br><span class="hljs-comment">// 主函数</span><br>Rectangle Rect; <span class="hljs-comment">// 正方形</span><br>Triangle Tri; <span class="hljs-comment">// 三角形</span><br><br>Rect.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">5</span>); <br>Rect.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">7</span>); <br>Rect.<span class="hljs-built_in">getArea</span>(); <span class="hljs-comment">//35 </span><br><br>Tri.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">5</span>); <br>Tri.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">7</span>); <br>Tri.<span class="hljs-built_in">getArea</span>(); <span class="hljs-comment">//17</span><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsqUM6ANNttuM5ZquDHit3f"  --> <p>#历史记录::<br>2022/10/20🌵抽象类与接口的实现 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>13.子集II</title>
    <link href="/posts/15381/"/>
    <url>/posts/15381/</url>
    
    <content type="html"><![CDATA[<h1 id="1-90子集ii"><a class="markdownIt-Anchor" href="#1-90子集ii"></a> 1 90.子集II</h1><p><a href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接</a></p><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：<strong>解集不能包含重复的子集。</strong><br>示例:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">-   输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>-   输出: [ [<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [] ]<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>![[13.子集II 2022-10-20 11.19.12.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1，通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        result.<span class="hljs-built_in">push_back</span>(path);<span class="hljs-comment">// 每次都要收集结点</span><br><br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-comment">// 💡在同一个树层手上去重</span><br>            <span class="hljs-keyword">if</span>(i &gt; startIndex){ <span class="hljs-comment">// ❗️不是&gt;0，因为每次的起始位置不一样;也可以这样写：if (i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1] )</span><br>                <span class="hljs-keyword">if</span>(nums[i] == nums[i <span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>; <br>            }<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            <br>        }<br>    }<br>    <br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// ❗️去重需要先排序</span><br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^3c5r8l</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsMTYdlMRYsnTbWppwVya8k"  --> <p>#历史记录::<br>2022/10/20🌵13.子集II : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11. 子集问题</title>
    <link href="/posts/36387/"/>
    <url>/posts/36387/</url>
    
    <content type="html"><![CDATA[<h1 id="1-子集"><a class="markdownIt-Anchor" href="#1-子集"></a> 1 子集</h1><p><a href="https://leetcode.cn/problems/subsets/">力扣题目链接</a></p><p>给定一组不含重复元素的整数数组&nbsp;nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">示例: 输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] 输出: [ [<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">1</span>], &nbsp; [<span class="hljs-number">2</span>], &nbsp; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], &nbsp; [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], &nbsp; [] ]<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>求子集问题和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a>和<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a>又不一样了。</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong><br>有同学问了，什么时候for可以从0开始呢？<br>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。 ^isql7c</p><p>以示例中<code>nums = [1,2,3]</code>为例把求子集抽象为树型结构，如下：</p><p>![[11. 子集问题 2022-10-20 10.37.58.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= nums.<span class="hljs-built_in">size</span>()) { <span class="hljs-comment">// 终止条件可以不加</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>在注释中，可以发现可以不写终止条件，因为本来我们就要遍历整棵树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从i+1开始的。</p><blockquote><p>[!bug]<br>![[11. 子集问题 2022-10-20 11.05.19.excalidraw]]</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs8NGIsFeeXukAZDZMDW95r"  --> <p>#历史记录::<br>2022/10/20🌵11. 子集问题 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>final</title>
    <link href="/posts/62558/"/>
    <url>/posts/62558/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/4ba9bea12264">https://www.jianshu.com/p/4ba9bea12264</a></p><p>讲讲为什么要使用 static 和 final，</p><p>static可以保证在一个线程未使用其他同步机制的情况下总是可以读到一个类的静态变量的初始<br>值</p><p>final修饰的变量值不会改变。但是在多线程的环境中，它还会保证两点，1. 其他线<br>程所看到的final字段必然是初始化完毕的。 2. final修饰的变量不会被程序重排序。</p><p>static 保证了变量的初始值，final 保证了不被 JIT 编译器重排序。对于一个单例模式来说，它所在的类在被引用的时候，static 会保证它被初始化完毕，且是所有线程所见的初始化，final 保证了实例初始化过程的顺寻性。两者结合保证了这个实例创建的唯一性。讲讲为什么要使用 static 和 final</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRQQVndw0YJcAy7bLAkC0g"  --> <p>#历史记录::<br>2022/10/19🌵final : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>创建型模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>套接字函数(目录)</title>
    <link href="/posts/24218/"/>
    <url>/posts/24218/</url>
    
    <content type="html"><![CDATA[<h1 id="1-套接字函数"><a class="markdownIt-Anchor" href="#1-套接字函数"></a> 1: 套接字函数</h1><h2 id="11-socket"><a class="markdownIt-Anchor" href="#11-socket"></a> 1.1: socket</h2><p>![[socket API]]</p><h2 id="12-bind"><a class="markdownIt-Anchor" href="#12-bind"></a> 1.2: [[bind]]</h2><h2 id="13-listen"><a class="markdownIt-Anchor" href="#13-listen"></a> 1.3: listen</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> backlog)</span>;    <span class="hljs-comment">// /proc/sys/net/core/somaxconn(能够连接的最大数所在的文档目录)     </span><br>- 功能:监听这个socket上的连接    <br>- 参数:        <br>    - - sockfd : 通过socket()函数得到的文件描述符        <br>    - - backlog : 未连接的和已经连接的和的最大值, <span class="hljs-number">5</span><br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="14-accpet"><a class="markdownIt-Anchor" href="#14-accpet"></a> 1.4: accpet</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;     <br>- 功能:接收客户端连接,默认是一个阻塞的函数,阻塞等待客户端连接     <br>- 参数:             <br>    - - sockfd : 用于监听的文件描述符            <br>    - - addr : 传出参数,记录了连接成功后客户端的地址信息(ip,port)             <br>    - - addrlen : 指定第二个参数的对应的内存大小    <br>- 返回值:            <br>    -  成功 :用于通信的文件描述符            <br>    -  失败 : <span class="hljs-number">-1</span><br><br></code></pre></td></tr></tbody></table></figure><p>socklen_t：就是整数类型，跟int类型</p><h2 id="15-connect"><a class="markdownIt-Anchor" href="#15-connect"></a> 1.5: connect</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span>; <br>    - 功能: 客户端连接服务器    <br>    - 参数:             <br>        - sockfd : 用于通信的文件描述符            <br>        - addr : 客户端要连接的服务器的地址信息            <br>        - addrlen : 第二个参数的内存大小    <br>    - 返回值:成功 <span class="hljs-number">0</span>, 失败 <span class="hljs-number">-1</span> <br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;   <span class="hljs-comment">// 写数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;          <span class="hljs-comment">// 读数据</span><br><br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsCnFBsDEfv249MNnBn3Fxl"  --> <p>#历史记录::<br>2022/10/19🌵套接字函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bind</title>
    <link href="/posts/12261/"/>
    <url>/posts/12261/</url>
    
    <content type="html"><![CDATA[<h1 id="1-api"><a class="markdownIt-Anchor" href="#1-api"></a> 1: API</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>; <span class="hljs-comment">// socket命名    </span><br>- 功能:绑定,将fd 和本地的IP + 端口进行绑定    <br>- 参数:             <br>    - - sockfd : 通过socket函数得到的文件描述符            <br>    - - addr : 需要绑定的socket地址,这个地址封装了ip和端口号的信息            <br>    - - addrlen : 第二个参数结构体占的内存大小<br>    测试<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-bind函数什么时候调用失败"><a class="markdownIt-Anchor" href="#2-bind函数什么时候调用失败"></a> 2: bind函数什么时候调用失败？</h1><p>在 web 服务器中，<code>bind()</code> 方法调用失败的主要原因有两种：</p><ol><li><p>尝试绑定一个已被占用的端口。如果一个端口已被其他程序占用，那么 <code>bind()</code> 方法会调用失败。</p></li><li><p>权限问题。如果当前用户没有权限绑定到该端口，那么 <code>bind()</code> 方法也会调用失败。</p><ol><li>[[端口等级权限]]</li></ol></li></ol><p>一般没有设置 [[source/_posts/👨🏻‍💻code/项目/webserver/API/端口复用|端口复用]] 的话就比较容易调用失败。</p><p>比如服务器遇到某些情况进程崩了，然后它就会进行四次挥手进入TIME_WAIT状态。这个状态回持续2MSL的时间，<br>如果没有设置端口复用，那么在这个时间内重启服务器，bind就会失败。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsklyxDVPfPLqv2GiUKGZn0"  --> <p>#历史记录::<br>2022/10/19🌵bind : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.复原 IP 地址</title>
    <link href="/posts/33042/"/>
    <url>/posts/33042/</url>
    
    <content type="html"><![CDATA[<h1 id="1-93复原ip地址"><a class="markdownIt-Anchor" href="#1-93复原ip地址"></a> 1 93.复原IP地址</h1><p><a href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接</a></p><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个<strong>整数</strong>（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>：<br><br>-   输入：s = <span class="hljs-string">"25525511135"</span><br>-   输出：[<span class="hljs-string">"255.255.11.135"</span>,<span class="hljs-string">"255.255.111.35"</span>]<br><br>示例 <span class="hljs-number">2</span>：<br><br>-   输入：s = <span class="hljs-string">"0000"</span><br>-   输出：[<span class="hljs-string">"0.0.0.0"</span>]<br><br>示例 <span class="hljs-number">3</span>：<br><br>-   输入：s = <span class="hljs-string">"1111"</span><br>-   输出：[<span class="hljs-string">"1.1.1.1"</span>]<br><br>示例 <span class="hljs-number">4</span>：<br><br>-   输入：s = <span class="hljs-string">"010010"</span><br>-   输出：[<span class="hljs-string">"0.10.0.10"</span>,<span class="hljs-string">"0.100.1.0"</span>]<br><br>示例 <span class="hljs-number">5</span>：<br><br>-   输入：s = <span class="hljs-string">"101023"</span><br>-   输出：[<span class="hljs-string">"1.0.10.23"</span>,<span class="hljs-string">"1.0.102.3"</span>,<span class="hljs-string">"10.1.0.23"</span>,<span class="hljs-string">"10.10.2.3"</span>,<span class="hljs-string">"101.0.2.3"</span>]<br><br>提示：<br><br>-   <span class="hljs-number">0</span> &lt;= s.length &lt;= <span class="hljs-number">3000</span><br>-   s 仅由数字组成<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>切割问题，<strong>切割问题就可以使用回溯搜索法把所有可能性搜出来</strong>，</p><p>![[10.复原 IP 地址 2022-10-19 09.58.13.excalidraw]]</p><h2 id="21-回溯三部曲"><a class="markdownIt-Anchor" href="#21-回溯三部曲"></a> 2.1 回溯三部曲</h2><p>回溯其实就是横向遍历，纵向递归的组合。</p><ul><li>递归参数</li></ul><p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a></p><p>startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。<br>本题我们还需要一个变量pointNum，记录添加逗点的数量。<br>所以代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; result;<span class="hljs-comment">// 记录结果</span><br><span class="hljs-comment">// startIndex: 搜索的起始位置，pointNum:添加逗点的数量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span> {<br></code></pre></td></tr></tbody></table></figure><ul><li>递归终止条件</li></ul><p>终止条件和<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a>情况就不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。</p><p>pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。<br>然后验证一下第四段是否合法，如果合法就加入到结果集里<br>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (pointNum == <span class="hljs-number">3</span>) { <span class="hljs-comment">// 逗点数量为3时，分隔结束</span><br>    <span class="hljs-comment">// 判断第四段子字符串是否合法，如果合法就放进result中</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>        result.<span class="hljs-built_in">push_back</span>(s);<br>    }<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></tbody></table></figure><ul><li>单层搜索的逻辑</li></ul><p>在<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a>中已经讲过在循环遍历中如何截取子串。</p><p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中 <code>[startIndex, i]</code> 这个区间就是截取的子串，需要判断这个子串是否合法。<br>如果合法就在字符串后面加上符号<code>.</code>表示已经分割。<br>如果不合法就结束本层循环，如图中剪掉的分支：</p><p>然后就是递归和回溯的过程：<br>递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符<code>.</code>），同时记录分割符的数量pointNum 要 +1。<br>回溯的时候，就将刚刚加入的分隔符<code>.</code> 删掉就可以了，pointNum也要-1。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.size(); i++) {<br>    <span class="hljs-keyword">if</span> (isValid(s, startIndex, i)) { <span class="hljs-comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span><br>        s.insert(s.begin() + i + <span class="hljs-number">1</span> , <span class="hljs-string">'.'</span>);  <span class="hljs-comment">// 在i的后面插入一个逗点</span><br>        pointNum++;<br>        backtracking(s, i + <span class="hljs-number">2</span>, pointNum);   <span class="hljs-comment">// 插入逗点之后下一个子串的起始位置为i+2</span><br>        pointNum--;                         <span class="hljs-comment">// 回溯</span><br>        s.erase(s.begin() + i + <span class="hljs-number">1</span>);         <span class="hljs-comment">// 回溯删掉逗点</span><br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 不合法，直接结束本层循环</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="22-判断子串是否合法"><a class="markdownIt-Anchor" href="#22-判断子串是否合法"></a> 2.2 判断子串是否合法</h2><p>最后就是在写一个判断段位是否是有效段位了。</p><p>主要考虑到如下三点：</p><ul><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ul><p>代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {<br>    <span class="hljs-keyword">if</span> (start &gt; end) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-keyword">if</span> (s[start] == <span class="hljs-string">'0'</span> &amp;&amp; start != end) { <span class="hljs-comment">// 0开头的数字不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) {<br>        <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-string">'9'</span> || s[i] &lt; <span class="hljs-string">'0'</span>) { <span class="hljs-comment">// 遇到非数字字符不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">'0'</span>);<br>        <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">255</span>) { <span class="hljs-comment">// 如果大于255了不合法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>回溯算法模板：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span> {<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        backtracking(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsKiXJfuhrFs5Bqkz8LA4nD" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::10.复原 IP 地址.md"--><p>不懂</p><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt;ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(string&amp; s,<span class="hljs-type">int</span> cnt,<span class="hljs-type">int</span> index,string&amp; str)</span></span>{<br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> || index==s.<span class="hljs-built_in">size</span>() ){<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">4</span> &amp;&amp; index==s.<span class="hljs-built_in">size</span>())<br>                ans.<span class="hljs-built_in">push_back</span>(str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>));<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++){<br>            <span class="hljs-keyword">if</span>(index+i&gt;s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(s[index]==<span class="hljs-string">'0'</span> &amp;&amp; i!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span> &amp;&amp; s.<span class="hljs-built_in">substr</span>(index,i)&gt;<span class="hljs-string">"255"</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// ❓能直接比较吗</span><br>            str+=s.<span class="hljs-built_in">substr</span>(index,i);<br>            str.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">'.'</span>);<br>            <span class="hljs-built_in">backtrace</span>(s,cnt+<span class="hljs-number">1</span>,index+i,str);<br>            str = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,str.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>);<br>        }<br>    }<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>{<br>        string str =<span class="hljs-string">""</span>;<br>        <span class="hljs-built_in">backtrace</span>(s,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,str);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>V1: 未通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    vector&lt;string&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> pointNum)</span></span>{<br>        <span class="hljs-keyword">if</span>(pointNum == <span class="hljs-number">3</span>){<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)){<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s, startIndex, i)){<br>                s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>, <span class="hljs-string">'.'</span>);<br>                <span class="hljs-built_in">backtracking</span>(s, i+<span class="hljs-number">2</span>, pointNum++);<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>);<br><br>            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        }<br>    }<br>    <span class="hljs-comment">// 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">if</span>(start &gt; end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(s[start] == <span class="hljs-string">'0'</span> &amp;&amp; start != end) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//0开头的数字不合法</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt;= end; i++){<br>            <span class="hljs-keyword">if</span>(s[i] &gt; <span class="hljs-string">'9'</span> || s[i] &lt; <span class="hljs-string">'0'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            num = num * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">'0'</span>);<br>            <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span> || s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsc9cRkdPWZYtXBJubKQ8Bg"  --> <p>#历史记录::<br>2022/10/19🌵10.复原 IP 地址 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>socket API</title>
    <link href="/posts/61849/"/>
    <url>/posts/61849/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span>      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span>  <span class="hljs-comment">// 包含了这个头文件,上面两个就可以省略</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> protocol)</span>;     <br>- 功能:创建一个套接字    <br>-        - 参数:         <br>            - domain: 协议族            <br>                - AF_INET : ipv4 <br>                - AF_INET6 : ipv6             <br>                - AF_UNIX, AF_LOCAL : 本地套接字通信(进程间通信)         <br>            - type: 通信过程中使用的协议类型            <br>                - SOCK_STREAM : 流式协议            <br>                - SOCK_DGRAM  : 报式协议       <br>            - protocol : 具体的一个协议。一般写<span class="hljs-number">0</span>             <br>                - SOCK_STREAM : 流式协议默认使用 TCP             <br>                - SOCK_DGRAM  : 报式协议默认使用 UDP         <br>          - 返回值:            <br>             - 成功:返回文件描述符,操作的就是内核缓冲区。<br>             - 失败:<span class="hljs-number">-1</span><br><span class="hljs-comment">// </span><br>- example <span class="hljs-title function_">socket</span><span class="hljs-params">(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsx2iCnBjqj6vx1dM0NpCj6"  --> <p>#历史记录::<br>2022/10/18🌵socket API : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>API</category>
      
    </categories>
    
    
    <tags>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 通信流程</title>
    <link href="/posts/2368/"/>
    <url>/posts/2368/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论</h1><blockquote><p>[!summary] TCP 和 UDP  -&gt; 传输层的协议<br>UDP: 用户数据报协议, 面向无连接, 可以单播, 多播, 广播, 面向数据报, 不可靠</p></blockquote><p>TCP: 传输控制协议, 面向连接的, 可靠的, 基于字节流, 仅支持<strong>单播传输</strong><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210182124220.png" alt=""></p><h1 id="2-tcp-通信的流程"><a class="markdownIt-Anchor" href="#2-tcp-通信的流程"></a> 2 TCP 通信的流程</h1><blockquote><p>[!example]<br>![[TCP 通信流程.excalidraw]]</p></blockquote><h2 id="21-套接字函数目录"><a class="markdownIt-Anchor" href="#21-套接字函数目录"></a> 2.1 [[套接字函数(目录)]]</h2><h1 id="3-tcp通信代码案例"><a class="markdownIt-Anchor" href="#3-tcp通信代码案例"></a> 3 [[TCP通信代码案例]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsaD42SDJDMOtSLlKp97zNB"  --> <p>#历史记录::<br>2022/10/18🌵TCP 通信流程 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>open函数</title>
    <link href="/posts/51479/"/>
    <url>/posts/51479/</url>
    
    <content type="html"><![CDATA[<h1 id="1-功能"><a class="markdownIt-Anchor" href="#1-功能"></a> 1 功能</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// open 函数的声明</span><br><span class="hljs-comment">// 打开一个已经存在的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><br><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></tbody></table></figure><p>为什么要有三个头文件？<br>函数的申明在 <code>fcntl.h</code> 头文件里，<code>flags</code> 在Linux系统中定义为一个宏放在其他的头文件里。</p><p>为什么可以有两个同名的 <code>open</code> 函数？<br>C语言没有函数重载，通过可变参数 <code>mode_t mode</code> 实现同名函数的效果。</p><h1 id="2-api"><a class="markdownIt-Anchor" href="#2-api"></a> 2 API</h1><h2 id="21-open函数"><a class="markdownIt-Anchor" href="#21-open函数"></a> 2.1 open函数：</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// open 函数的声明</span><br><span class="hljs-comment">// 打开一个已经存在的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br>参数：<br>- pathname：要打开的文件路径<br>- flags：对文件的操作权限设置还有其他设置<br>- O_RDONLY：只读<br>- O_WRONLY：只写<br>- O_RDWR：可读可写<br>这三个设置是互斥的(必选项)<br>返回值：返回一个新的文件描述符，如果调用失败，返回 <span class="hljs-number">-1</span> ，系统会把错误号赋值给errno<br>errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号<br>perror：查看具体的错误<br>- example <span class="hljs-type">int</span> fd = open(<span class="hljs-string">" /dev/null"</span>，O_RDWR)；返回值是一个文件描述符<br><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-type">int</span> open(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode);<br></code></pre></td></tr></tbody></table></figure><h2 id="22-close-函数说明文档-man-2-close"><a class="markdownIt-Anchor" href="#22-close-函数说明文档-man-2-close"></a> 2.2 close 函数（说明文档 <code>man 2 close</code> ）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsBwYtWCv5jsLoXcGsA0aDN" --> <h2 id="23-案例"><a class="markdownIt-Anchor" href="#23-案例"></a> 2.3 案例::</h2><!-- basicblock-end --><p>查找 <code>a.txt</code> 文件，找不到文件，文件描述符返回 -1，用 <code>perror</code> 打印错误描述，关闭文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// open.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>  <span class="hljs-comment">// 打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"a.txt"</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>    }<br>    <span class="hljs-comment">// 关闭</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译 <code>open.c</code> 文件 <code>gcc open.c -o open</code> ，执行输出错误描述：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">open: No such file or directory<br></code></pre></td></tr></tbody></table></figure><h1 id="3-open-创建新文-不用它新建"><a class="markdownIt-Anchor" href="#3-open-创建新文-不用它新建"></a> 3 open 创建新文 (不用它新建)</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// open 函数的声明</span><br><span class="hljs-comment">// 创建一个新的文件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br>参数：<br>- pathname：要打开的文件路径<br>- flags：对文件的操作权限设置还有其他设置<br>- 必选项：O_RDONLY，O_WRONLY，O_RDWR，这三个设置是互斥的<br>- 可选项：O_CREAT 文件不存在，创建新文件<br>      - mode：八进制的数，表示用户对创建出的新的文件的操作权限，比如：<span class="hljs-number">0775</span><br>      最终的权限是：mode &amp; ~umask<br>      umask -&gt; <span class="hljs-number">0002</span>, ~umaske = <span class="hljs-number">0777</span><span class="hljs-number">-0002</span> = <span class="hljs-number">0775</span><br>      <span class="hljs-number">0777</span>-&gt; <span class="hljs-number">111111111</span><br>      &amp; <span class="hljs-number">0775</span>-&gt; <span class="hljs-number">111111101</span><br>      ---------------------<br>       <span class="hljs-number">111111101</span>-&gt; <span class="hljs-number">0775</span><br>      按位与：<span class="hljs-number">0</span> 和任何数都为 <span class="hljs-number">0</span><br>      umask 的作用是抹去某些权限，umask 可以自己设计<br>返回值：返回一个新的文件描述符，如果调用失败，返回 <span class="hljs-number">-1</span> ，系统会把错误号赋值给errno<br>errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号<br>perror：查看具体的错误<br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// create.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>  <span class="hljs-comment">// 创建一个新的文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"create.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>    }<br>    <span class="hljs-comment">// 关闭</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>编译 <code>create.c</code> 文件 <code>gcc create.c -o create</code> ，创建了新文件 <code>create.txt</code> 。</p><p>查看权限，<code>ll create.txt</code> 。</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rwxr-xr-x<span class="hljs-number"> 1 </span>root root<span class="hljs-number"> 0 </span>4月  <span class="hljs-number"> 3 </span>14:49 create.txt<br></code></pre></td></tr></tbody></table></figure><p><code>-rwxr-xr-x</code> 对应 0775 权限。</p><p>open 函数中的 flags 为什么用按位或 <code>|</code> 来连接？</p><p>flags函数是一个int类型的数据，占4个字节，32位；</p><p>flags 32个位，每一位就是一个标志位。用 <code>|</code> 相当于把后一个 flag加到前一个flag上。</p><h1 id="4-其他知识"><a class="markdownIt-Anchor" href="#4-其他知识"></a> 4 其他知识</h1><p>centOS安装manpages</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">yum -y install man-pages<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">man <span class="hljs-number">2</span> open<br><span class="hljs-comment">// 第二章是Linux系统函数说明文档，open 在第二章查找</span><br><span class="hljs-comment">// 第三章是标准C库说明文档</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174431.png" alt="image-20220403111757618|600"></p><p>查看返回值</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">/<span class="hljs-keyword">return</span> value<br></code></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174505.png" alt="image-20220403113343555|700"></p><h2 id="41-perror-函数说明文档-man-3-perror"><a class="markdownIt-Anchor" href="#41-perror-函数说明文档-man-3-perror"></a> 4.1 perror 函数（说明文档 <code>man 3 perror</code> ）</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">perror</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span>; <br>作用：打印 errno 对应的错误描述<br>s 参数：用户描述，比如 hello，最终输出的内容是 hello:xxx(实际的错误描述)<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsNGo7g0yv5w1mhRAopsfdA"  --> <p>#历史记录::<br>2022/10/18🌵open函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件描述符</title>
    <link href="/posts/30559/"/>
    <url>/posts/30559/</url>
    
    <content type="html"><![CDATA[<p>![[文件描述符.excalidraw]]</p><p>对可执行文件进行读取或写的操作，可执行程序运行起来后，操作系统会生成一个进程，在对应的文件比如 english.txt ，进行读取或写入等操作，用标准 C 的 IO 文件库去操作，fopen 打开文件，调用 fread 读取数据，或者调用 fwrite 写入数据，<strong>为什么在程序当中用 fopen 打开文件后，调用 fread ，或者调用 fwrite ，它就能够去找到磁盘上的 english.txt 文件，对它进行操作呢？</strong></p><p>因为它里面有文件描述符，调用 fopen 函数，会返回一个 <code>FILE * fp</code> 文件指针，这个文件指针里就封装了文件描述符，</p><p>用 fclose 关闭文件描述符的时候，这个文件描述符就会被释放，被释放后就可以重新去使用，如果文件描述符被占用，它需要到文件描述符表里找一个最小的没有被占用的，文件描述符去使用。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsB9xFivKh9pT0dtEE0x1YB"  --> <p>#历史记录::<br>2022/10/18🌵文件描述符 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>read函数和write函数</title>
    <link href="/posts/49161/"/>
    <url>/posts/49161/</url>
    
    <content type="html"><![CDATA[<h1 id="1-api"><a class="markdownIt-Anchor" href="#1-api"></a> 1 API</h1><p>查看说明文档</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">man <span class="hljs-number">2</span> read<br>man <span class="hljs-number">2</span> write<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// read 函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br>参数：<br>      - fd: 文件描述符，open 得到的，通过这个文件描述符操作某个文件<br>        - buf: 需要读取数据存放的地方，数组的地址（传出参数）<br>        - count: 指定的数组的大小<br>    返回值：<br>        - 成功: <br>          &gt; <span class="hljs-number">0</span>: 返回实际的读取到的字节数<br>            = <span class="hljs-number">0</span>: 文件已经读取完了<br>        - 失败: <span class="hljs-number">-1</span> ，并且设置 errno<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// write 函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br>参数：<br>      - fd: 文件描述符，open 得到的，通过这个文件描述符操作某个文件<br>        - buf: 要往磁盘写入的数据<br>        - count: 要写的数据的实际的大小<br>    返回值：<br>        - 成功: 实际写入的字节数<br>        - 失败: <span class="hljs-number">-1</span> ，并且设置 errno<br></code></pre></td></tr></tbody></table></figure><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例</h1><p>文件拷贝：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// copyfile.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 1. 通过 open 打开 english.txt 文件</span><br>    <span class="hljs-type">int</span> srcfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"english.txt"</span>, O_RDONLY);  <span class="hljs-comment">// 源文件的文件描述符</span><br>    <span class="hljs-keyword">if</span> (srcfd == <span class="hljs-number">-1</span>){<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 2. 创建一个心的文件（拷贝文件）</span><br>    <span class="hljs-type">int</span> destfd = <span class="hljs-built_in">open</span>(<span class="hljs-string">"cpy.txt"</span>, O_WRONLY | O_CREAT, <span class="hljs-number">0664</span>); <span class="hljs-comment">// 目标文件的描述符</span><br>    <span class="hljs-keyword">if</span> (destfd == <span class="hljs-number">-1</span>){<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 3. 频繁的读写操作 </span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((len = <span class="hljs-built_in">read</span>(srcfd, buf, <span class="hljs-built_in">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>) {<br>        <span class="hljs-built_in">write</span>(destfd, buf, len);<br>    }<br><br>    <span class="hljs-comment">// 4. 关闭文件</span><br>    <span class="hljs-built_in">close</span>(destfd);<br>    <span class="hljs-built_in">close</span>(srcfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs0ROCqozgb3GI26vbP9plE"  --> <p>#历史记录::<br>2022/10/18🌵read函数和write函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UML</title>
    <link href="/posts/46375/"/>
    <url>/posts/46375/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!example] <a href="https://www.bilibili.com/video/BV1P741127u7?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=471.443684">07:51</a><br>![[UML 外国小哥.excalidraw]]</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsU9I0J1ZYIUOJ9fSHeZMUm"  --> <p>#历史记录:: <a href="https://www.bilibili.com/video/BV1P741127u7?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">UML Class Diagram Tutorial（视频字幕一体）_哔哩哔哩_bilibili</a></p><p>2022/10/16🌵UML : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>面向对象原则</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>UDP</title>
    <link href="/posts/11300/"/>
    <url>/posts/11300/</url>
    
    <content type="html"><![CDATA[<h1 id="1-udp-通信"><a class="markdownIt-Anchor" href="#1-udp-通信"></a> 1 UDP 通信::</h1><blockquote><p>[!example]-<br>![[UDP 2022-10-11 20.29.05.excalidraw]]</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *dest_addr, <span class="hljs-type">socklen_t</span> addrlen)</span>;<br>- 参数:<br>- sockfd : 通信的fd<br>- buf : 要发送的数据<br>- len : 发送数据的长度<br>- flags : <span class="hljs-number">0</span><br>- dest_addr : 通信的另外一端的地址信息(💡要把信息传回去)<br>- addrlen : 地址的内存大小<br>- 返回值:<br>- 成功返回接收的数据个数<br>- 失败返回<span class="hljs-number">-1</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">                        <span class="hljs-keyword">struct</span> sockaddr *src_addr, <span class="hljs-type">socklen_t</span> *addrlen)</span>;<br>- 参数:<br>- sockfd : 通信的fd<br>- buf : 接收数据的数组<br>- len : 数组的大小<br>- flags : <span class="hljs-number">0</span><br>- src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="hljs-literal">NULL</span><br>- addrlen : 地址的内存大小<br>- 返回值:<br>- 成功返回接收的数据个数<br>- 失败返回<span class="hljs-number">-1</span><br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-广播"><a class="markdownIt-Anchor" href="#2-广播"></a> 2 广播::</h1><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的 IP 地址，这个 IP 中子网内主机标志部分的二进制全部为 1。<br>192.168.10.<strong>255</strong>: 主机标志</p><ul><li><strong>a.只能在局域网中使用。</strong></li><li>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210181518222.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置广播属性的函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> optlen)</span>;<br>- sockfd : 文件描述符<br>        - level : SOL_SOCKET<br>        - optname : SO_BROADCAST<br>        - optval : <span class="hljs-type">int</span>类型的值，为<span class="hljs-number">1</span>表示允许广播<br>        - optlen : optval的大小<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>‌‌‌![[UDP 通信案例.excalidraw]]</p></blockquote><h1 id="3-组播-多播"><a class="markdownIt-Anchor" href="#3-组播-多播"></a> 3 组播 (多播)</h1><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。<br>单播和广播是寻址方案的两个极端 (要么单个要么全部)，多播则意在两者之间提供一种折中方案。<br>多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。</p><p>a.组播既可以用于局域网，也可以用于广域网<br>b.客户端需要加入多播组，才能接收到多播的数据</p><p>![[UDP 2022-10-18 17.14.30.excalidraw]]<br>相比广播:<br>服务端增加多播的属性<br>客户端加入多播</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval,<span class="hljs-type">socklen_t</span> optlen)</span></span>;<br><br>    <span class="hljs-comment">// 服务器设置多播的信息，外出接口</span><br>    - level : IPPROTO_IP<br>    - optname : IP_MULTICAST_IF <span class="hljs-comment">// 多播</span><br>    - optval : <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span><br><span class="hljs-comment">// 客户端加入到多播组:</span><br>    - level : IPPROTO_IP<br>    - optname : IP_ADD_MEMBERSHIP - optval : <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ip_mreq</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ip_mreq</span><br>{<br>    <span class="hljs-comment">/* IP multicast address of group. */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> imr_multiaddr; <span class="hljs-comment">// 组播的IP地址</span><br>    <span class="hljs-comment">/* Local IP address of interface.  */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span> imr_interface;<span class="hljs-comment">// 本地的IP地址</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> <span class="hljs-type">in_addr_t</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span><br>{<br>    <span class="hljs-type">in_addr_t</span> s_addr;<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs5rq3hvi0Z0cGlqk8xrPfL"  --> <p>#历史记录::<br>2022/10/11🌵UDP : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>epoll</title>
    <link href="/posts/3465/"/>
    <url>/posts/3465/</url>
    
    <content type="html"><![CDATA[<p>epoll 简单原理::<br>2022/10/10🌵epoll 简单原理 : 第一次创建</p><!-- basicblock-end --><!-- basicblock-start oid="ObsqFJEXPMFmz6H4WcW4ZML4" --> <h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1: 原理::</h1><!-- basicblock-end --> <blockquote><p>[!example]-  原理<br>![[epoll 与 select  .excalidraw]]<br>![[epoll 原理流程图.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsrIkU5kkDXgPJ4upMFlX31" --> <h1 id="2-epoll-操作函数"><a class="markdownIt-Anchor" href="#2-epoll-操作函数"></a> 2: epoll 操作函数::</h1><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-comment">/*  epoll_create: </span><br><span class="hljs-comment">建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，</span><br><span class="hljs-comment">一个是需要检 测的文件描述符的信息(红黑树)</span><br><span class="hljs-comment">一个是就绪列表，存放检测到数据发送改变的文件描述符信息(双向 链表)。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br>- 参数:<br>size : 随便写一个数，必须大于<span class="hljs-number">0</span><br>目前没有意义了, 所以随便写一个数(改进过后就不用 size 了, 以前底层实现是哈希表, 现在是红黑树)。<br>- 返回值:<br><span class="hljs-number">-1</span> : 失败<br>&gt;<span class="hljs-number">0</span> : 文件描述符，操作epoll实例的<br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// epoll_ctl: 对epoll实例进行管理:添加文件描述符信息，删除信息，修改信息</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span></span>;<br>- 参数:<br>- epfd : epoll实例对应的文件描述符<br>- op : 要进行什么操作 <br>- EPOLL_CTL_ADD: 添加 (添加到红黑树中)<br>- EPOLL_CTL_MOD: 修改 <br>- EPOLL_CTL_DEL: 删除<br>- fd : 要检测的文件描述符<br>- event : 检测文件描述符什么事情<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> {<br>    <span class="hljs-type">uint32_t</span>     events; <span class="hljs-comment">// 检测的事件  /* Epoll events */</span><br>    <span class="hljs-type">epoll_data_t</span> data; <span class="hljs-comment">// 用户的一些数据信息 /* User data variable */</span><br>};<br>常见的Epoll检测事件:<br>- EPOLLIN <span class="hljs-comment">// 检测读事件</span><br>    - EPOLLOUT<br>    - EPOLLERR<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span> { <span class="hljs-comment">// union 下边数据只有一个会有用</span><br>    <span class="hljs-type">void</span>        *ptr;<br>    <span class="hljs-type">int</span>          fd; <span class="hljs-comment">// 只用这个就行</span><br>    <span class="hljs-type">uint32_t</span>     u32;<br>    <span class="hljs-type">uint64_t</span>     u64;<br>} <span class="hljs-type">epoll_data_t</span>;<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// epoll_wait: 检测函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span></span>;<br>- 参数:<br>- epfd : epoll实例对应的文件描述符<br>- events : 传出参数，保存了发送了变化的文件描述符的信息 (结构数组大小)<br>- maxevents : 第二个参数结构体数组的大小<br>- timeout : 阻塞时间<br>-  <span class="hljs-number">0</span> : 不阻塞<br>- <span class="hljs-number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞 <br>- &gt;<span class="hljs-number">0</span> : 阻塞的时长(毫秒)<br>- 返回值:<br>- 成功，返回发送变化的文件描述符的个数 (&gt; <span class="hljs-number">0</span>) <br>- 失败 <span class="hljs-number">-1</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs6VQ8QsEABPtSsfDzmhMKv" --> <h1 id="3-案例"><a class="markdownIt-Anchor" href="#3-案例"></a> 3: 案例::</h1><!-- basicblock-end --><h2 id="31-epollc"><a class="markdownIt-Anchor" href="#31-epollc"></a> 3.1: epoll.c</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br># <span class="hljs-number">4</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> saddr;<br>    saddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-built_in">bind</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-built_in">sizeof</span>(saddr));<br><br>    <span class="hljs-comment">// 监听</span><br>    <span class="hljs-built_in">listen</span>(lfd, <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 调用epoll_create()创建一个epoll实例</span><br>    <span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中: 💡即 rbr(红黑树)</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> epev;<br>    epev.events = EPOLLIN;<br>    epev.data.fd = lfd;<br>    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> epevs[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br><span class="hljs-comment">// 调用 epoll_wait 来检测实例</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epfd, epevs, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<span class="hljs-comment">// 有改变的文件描述符直接传出到 epevs 中</span><br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">"epoll_wait"</span>);<span class="hljs-comment">// 抛出异常</span><br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<span class="hljs-comment">// 退出</span><br>        }<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ret = %d\n"</span>, ret);<span class="hljs-comment">// 有几个事件发生改变了</span><br><span class="hljs-comment">// 遍历改变事件的数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++) {<br><br>            <span class="hljs-type">int</span> curfd = epevs[i].data.fd;<br><br>            <span class="hljs-keyword">if</span>(curfd == lfd) {<br>                <span class="hljs-comment">// 监听的文件描述符有数据达到，有客户端连接</span><br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">accept</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>                epev.events = EPOLLIN | EPOLLOUT; <span class="hljs-comment">// 💡如果是监听两种事件, 要根据不同的事件进行不同的处理, 如下边的continue</span><br>                epev.data.fd = cfd;<br>                <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">if</span>(epevs[i].events &amp; EPOLLOUT) {<br>                    <span class="hljs-keyword">continue</span>;<br>                }   <br>                <span class="hljs-comment">// 有数据到达，需要通信</span><br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(curfd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">"read"</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 说明对方关闭连接了</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client closed...\n"</span>);<br>                    <span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 删除</span><br>                    <span class="hljs-built_in">close</span>(curfd);<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, buf);<br>                    <span class="hljs-built_in">write</span>(curfd, buf, <span class="hljs-built_in">strlen</span>(buf) + <span class="hljs-number">1</span>);<br>                }<br><br>            }<br><br>        }<br>    }<br><br>    <span class="hljs-built_in">close</span>(lfd);<br>    <span class="hljs-built_in">close</span>(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="32-clientc"><a class="markdownIt-Anchor" href="#32-clientc"></a> 3.2: client.c</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">seraddr</span>;</span><br>    inet_pton(AF_INET, <span class="hljs-string">"127.0.0.1"</span>, &amp;seraddr.sin_addr.s_addr);<br>    seraddr.sin_family = AF_INET;<br>    seraddr.sin_port = htons(<span class="hljs-number">9999</span>);<br><br>    <span class="hljs-comment">// 连接服务器</span><br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;seraddr, <span class="hljs-keyword">sizeof</span>(seraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">char</span> sendBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-built_in">sprintf</span>(sendBuf, <span class="hljs-string">"send data %d"</span>, num++);<br>        write(fd, sendBuf, <span class="hljs-built_in">strlen</span>(sendBuf) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 接收</span><br>        <span class="hljs-type">int</span> len = read(fd, sendBuf, <span class="hljs-keyword">sizeof</span>(sendBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, sendBuf);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器已经断开连接...\n"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// sleep(1); // 睡眠一秒, 很难检测两个事件 所以下边改小了</span><br>        usleep(<span class="hljs-number">1000</span>);<br>    }<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsqE5ATwry3LVR1AyeslTWm" --> <h1 id="4-lt-etepoll-的工作模式"><a class="markdownIt-Anchor" href="#4-lt-etepoll-的工作模式"></a> 4: [[LT &amp; ET(Epoll 的工作模式)]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.6 项目整体流程代码实现</title>
    <link href="/posts/12028/"/>
    <url>/posts/12028/</url>
    
    <content type="html"><![CDATA[<h1 id="1-有限状态机"><a class="markdownIt-Anchor" href="#1-有限状态机"></a> 1 有限状态机</h1><p>逻辑单元内部的一种高效编程方法:有限状态机(finite state machine)。<br>测试<br>有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">STATE_MACHINE</span>( Package _pack )<br>{<br>    PackageType _type = _pack.<span class="hljs-built_in">GetType</span>();<br>    <span class="hljs-keyword">switch</span>( _type )<br>    {<br>    <span class="hljs-keyword">case</span> type_A:<br>    <span class="hljs-built_in">process_package_A</span>( _pack );<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> type_B:<br>    <span class="hljs-built_in">process_package_B</span>( _pack );<br>    <span class="hljs-keyword">break</span>;<br>} <br>}<br><br><br></code></pre></td></tr></tbody></table></figure><p>这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。<br>状态之间的转移是需要状态机内部驱动，如下代码:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">STATE_MACHINE</span>()<br>{<br>State cur_State = type_A;<br><span class="hljs-keyword">while</span>( cur_State != type_C )<br>{<br><br>    Package _pack = <span class="hljs-built_in">getNewPackage</span>();<br>    <span class="hljs-keyword">switch</span>( cur_State )<br>    {<br>    <span class="hljs-keyword">case</span> type_A:<br>    <span class="hljs-built_in">process_package_state_A</span>( _pack );<br>    cur_State = type_B;<br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> type_B:<br>    <span class="hljs-built_in">process_package_state_B</span>( _pack );<br>    cur_State = type_C;<br>    <span class="hljs-keyword">break</span>;<br>} <br>}<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>该状态机包含三种状态:type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状 态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过 getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据 包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一 趟循环时，它将执行新的状态对应的逻辑。</p><h1 id="2-epolloneshot事件"><a class="markdownIt-Anchor" href="#2-epolloneshot事件"></a> 2 EPOLLONESHOT事件</h1><blockquote><p>[!summary] 即使可以使用 ET 模式<br>边缘触发模式(ET 模式): 有数据到来了,没有读完前, 是不会触发的<br>水平触发模式: 一有数据到来, 就会触发</p></blockquote><p>一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个 问题。<br>比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读(EPOLLIN 再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。<br>于 是就出现了两个线程同时操作一个 socket 的局面。<br><strong>一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。</strong></p><p>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异 常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事 件。</p><p>这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思 考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进 而让其他工作线程有机会继续处理这个 socket。</p><h1 id="3-服务器压力测试"><a class="markdownIt-Anchor" href="#3-服务器压力测试"></a> 3 服务器压力测试</h1><p>Webbench 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发。</p><pre><code class="hljs">测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。展示服务器的两项内容:每秒钟响应请求数和每秒钟传输数据量。</code></pre><p>基本原理:Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的 结果通过pipe 告诉父进程，父进程做最终的统计结果。<br>测试示例</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">webbench -c <span class="hljs-number">1000</span>  -t  <span class="hljs-number">30</span>   http:<span class="hljs-comment">//192.168.110.129:10000/index.html</span><br><br>参数:  <br>-c 表示客户端数<br>-t 表示时间<br></code></pre></td></tr></tbody></table></figure><h1 id="4-代码"><a class="markdownIt-Anchor" href="#4-代码"></a> 4 代码</h1><p>http_conn.cpp</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"http_conn.h"</span> <span class="hljs-comment">// 导入头文件</span></span><br><br><span class="hljs-comment">// 定义HTTP响应的一些状态信息</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ok_200_title = <span class="hljs-string">"OK"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_400_title = <span class="hljs-string">"Bad Request"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_400_form = <span class="hljs-string">"Your request has bad syntax or is inherently impossible to satisfy.\n"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_403_title = <span class="hljs-string">"Forbidden"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_403_form = <span class="hljs-string">"You do not have permission to get file from this server.\n"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_404_title = <span class="hljs-string">"Not Found"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_404_form = <span class="hljs-string">"The requested file was not found on this server.\n"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_500_title = <span class="hljs-string">"Internal Error"</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* error_500_form = <span class="hljs-string">"There was an unusual problem serving the requested file.\n"</span>;<br><br><span class="hljs-comment">// 网站的根目录</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* doc_root = <span class="hljs-string">"/home/nowcoder/webserver/resources"</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-type">int</span> fd )</span> </span>{<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>}<br><br><span class="hljs-comment">// 向epoll中添加需要监听的文件描述符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> one_shot )</span> </span>{<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLRDHUP;<br>    <span class="hljs-keyword">if</span>(one_shot) <br>    {<br>        <span class="hljs-comment">// 防止同一个通信被不同的线程处理</span><br>        event.events |= EPOLLONESHOT;<br>    }<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-comment">// 设置文件描述符非阻塞</span><br>    <span class="hljs-built_in">setnonblocking</span>(fd);  <br>}<br><br><span class="hljs-comment">// 从epoll中移除监听的文件描述符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removefd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd )</span> </span>{<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_DEL, fd, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">close</span>(fd);<br>}<br><br><span class="hljs-comment">// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ev)</span> </span>{<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );<br>}<br><br><span class="hljs-comment">// 所有的客户数</span><br><span class="hljs-type">int</span> http_conn::m_user_count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的</span><br><span class="hljs-type">int</span> http_conn::m_epollfd = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 关闭连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::close_conn</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span>(m_sockfd != <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">removefd</span>(m_epollfd, m_sockfd);<br>        m_sockfd = <span class="hljs-number">-1</span>;<br>        m_user_count--; <span class="hljs-comment">// 关闭一个连接，将客户总数量-1</span><br>    }<br>}<br><br><span class="hljs-comment">// 初始化连接,外部调用初始化套接字地址</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::init</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> sockaddr_in&amp; addr)</span></span>{<br>    m_sockfd = sockfd;<br>    m_address = addr;<br>    <br>    <span class="hljs-comment">// 端口复用</span><br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>( m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in">sizeof</span>( reuse ) );<br>    <span class="hljs-built_in">addfd</span>( m_epollfd, sockfd, <span class="hljs-literal">true</span> );<br>    m_user_count++;<br>    <span class="hljs-built_in">init</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br><br>    bytes_to_send = <span class="hljs-number">0</span>;<br>    bytes_have_send = <span class="hljs-number">0</span>;<br><br>    m_check_state = CHECK_STATE_REQUESTLINE;    <span class="hljs-comment">// 初始状态为检查请求行</span><br>    m_linger = <span class="hljs-literal">false</span>;       <span class="hljs-comment">// 默认不保持链接  Connection : keep-alive保持连接</span><br><br>    m_method = GET;         <span class="hljs-comment">// 默认请求方式为GET</span><br>    m_url = <span class="hljs-number">0</span>;              <br>    m_version = <span class="hljs-number">0</span>;<br>    m_content_length = <span class="hljs-number">0</span>;<br>    m_host = <span class="hljs-number">0</span>;<br>    m_start_line = <span class="hljs-number">0</span>;<br>    m_checked_idx = <span class="hljs-number">0</span>;<br>    m_read_idx = <span class="hljs-number">0</span>;<br>    m_write_idx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">bzero</span>(m_read_buf, READ_BUFFER_SIZE);<br>    <span class="hljs-built_in">bzero</span>(m_write_buf, READ_BUFFER_SIZE);<br>    <span class="hljs-built_in">bzero</span>(m_real_file, FILENAME_LEN);<br>}<br><br><span class="hljs-comment">// 循环读取客户数据，直到无数据可读或者对方关闭连接</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::read</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span>( m_read_idx &gt;= READ_BUFFER_SIZE ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    <span class="hljs-type">int</span> bytes_read = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br>        <span class="hljs-comment">// 从m_read_buf + m_read_idx索引出开始保存数据，大小是READ_BUFFER_SIZE - m_read_idx</span><br>        bytes_read = <span class="hljs-built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, <br>        READ_BUFFER_SIZE - m_read_idx, <span class="hljs-number">0</span> );<br>        <span class="hljs-keyword">if</span> (bytes_read == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-keyword">if</span>( errno == EAGAIN || errno == EWOULDBLOCK ) {<br>                <span class="hljs-comment">// 没有数据</span><br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_read == <span class="hljs-number">0</span>) {   <span class="hljs-comment">// 对方关闭连接</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br>        m_read_idx += bytes_read;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 解析一行，判断依据\r\n</span><br><span class="hljs-function">http_conn::LINE_STATUS <span class="hljs-title">http_conn::parse_line</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">char</span> temp;<br>    <span class="hljs-keyword">for</span> ( ; m_checked_idx &lt; m_read_idx; ++m_checked_idx ) {<br>        temp = m_read_buf[ m_checked_idx ];<br>        <span class="hljs-keyword">if</span> ( temp == <span class="hljs-string">'\r'</span> ) {<br>            <span class="hljs-keyword">if</span> ( ( m_checked_idx + <span class="hljs-number">1</span> ) == m_read_idx ) {<br>                <span class="hljs-keyword">return</span> LINE_OPEN;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( m_read_buf[ m_checked_idx + <span class="hljs-number">1</span> ] == <span class="hljs-string">'\n'</span> ) {<br>                m_read_buf[ m_checked_idx++ ] = <span class="hljs-string">'\0'</span>;<br>                m_read_buf[ m_checked_idx++ ] = <span class="hljs-string">'\0'</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            }<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( temp == <span class="hljs-string">'\n'</span> )  {<br>            <span class="hljs-keyword">if</span>( ( m_checked_idx &gt; <span class="hljs-number">1</span>) &amp;&amp; ( m_read_buf[ m_checked_idx - <span class="hljs-number">1</span> ] == <span class="hljs-string">'\r'</span> ) ) {<br>                m_read_buf[ m_checked_idx<span class="hljs-number">-1</span> ] = <span class="hljs-string">'\0'</span>;<br>                m_read_buf[ m_checked_idx++ ] = <span class="hljs-string">'\0'</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            }<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> LINE_OPEN;<br>}<br><br><span class="hljs-comment">// 解析HTTP请求行，获得请求方法，目标URL,以及HTTP版本号</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::parse_request_line</span><span class="hljs-params">(<span class="hljs-type">char</span>* text)</span> </span>{<br>    <span class="hljs-comment">// GET /index.html HTTP/1.1</span><br>    m_url = <span class="hljs-built_in">strpbrk</span>(text, <span class="hljs-string">" \t"</span>); <span class="hljs-comment">// 判断第二个参数中的字符哪个在text中最先出现</span><br>    <span class="hljs-keyword">if</span> (! m_url) { <br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    <span class="hljs-comment">// GET\0/index.html HTTP/1.1</span><br>    *m_url++ = <span class="hljs-string">'\0'</span>;    <span class="hljs-comment">// 置位空字符，字符串结束符</span><br>    <span class="hljs-type">char</span>* method = text;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>(method, <span class="hljs-string">"GET"</span>) == <span class="hljs-number">0</span> ) { <span class="hljs-comment">// 忽略大小写比较</span><br>        m_method = GET;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    <span class="hljs-comment">// /index.html HTTP/1.1</span><br>    <span class="hljs-comment">// 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</span><br>    m_version = <span class="hljs-built_in">strpbrk</span>( m_url, <span class="hljs-string">" \t"</span> );<br>    <span class="hljs-keyword">if</span> (!m_version) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    *m_version++ = <span class="hljs-string">'\0'</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>( m_version, <span class="hljs-string">"HTTP/1.1"</span>) != <span class="hljs-number">0</span> ) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * http://192.168.110.129:10000/index.html</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(m_url, <span class="hljs-string">"http://"</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span> ) {   <br>        m_url += <span class="hljs-number">7</span>;<br>        <span class="hljs-comment">// 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span><br>        m_url = <span class="hljs-built_in">strchr</span>( m_url, <span class="hljs-string">'/'</span> );<br>    }<br>    <span class="hljs-keyword">if</span> ( !m_url || m_url[<span class="hljs-number">0</span>] != <span class="hljs-string">'/'</span> ) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br>    m_check_state = CHECK_STATE_HEADER; <span class="hljs-comment">// 检查状态变成检查头</span><br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 解析HTTP请求的一个头部信息</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::parse_headers</span><span class="hljs-params">(<span class="hljs-type">char</span>* text)</span> </span>{   <br>    <span class="hljs-comment">// 遇到空行，表示头部字段解析完毕</span><br>    <span class="hljs-keyword">if</span>( text[<span class="hljs-number">0</span>] == <span class="hljs-string">'\0'</span> ) {<br>        <span class="hljs-comment">// 如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，</span><br>        <span class="hljs-comment">// 状态机转移到CHECK_STATE_CONTENT状态</span><br>        <span class="hljs-keyword">if</span> ( m_content_length != <span class="hljs-number">0</span> ) {<br>            m_check_state = CHECK_STATE_CONTENT;<br>            <span class="hljs-keyword">return</span> NO_REQUEST;<br>        }<br>        <span class="hljs-comment">// 否则说明我们已经得到了一个完整的HTTP请求</span><br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( text, <span class="hljs-string">"Connection:"</span>, <span class="hljs-number">11</span> ) == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 处理Connection 头部字段  Connection: keep-alive</span><br>        text += <span class="hljs-number">11</span>;<br>        text += <span class="hljs-built_in">strspn</span>( text, <span class="hljs-string">" \t"</span> );<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>( text, <span class="hljs-string">"keep-alive"</span> ) == <span class="hljs-number">0</span> ) {<br>            m_linger = <span class="hljs-literal">true</span>;<br>        }<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( text, <span class="hljs-string">"Content-Length:"</span>, <span class="hljs-number">15</span> ) == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 处理Content-Length头部字段</span><br>        text += <span class="hljs-number">15</span>;<br>        text += <span class="hljs-built_in">strspn</span>( text, <span class="hljs-string">" \t"</span> );<br>        m_content_length = <span class="hljs-built_in">atol</span>(text);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( text, <span class="hljs-string">"Host:"</span>, <span class="hljs-number">5</span> ) == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 处理Host头部字段</span><br>        text += <span class="hljs-number">5</span>;<br>        text += <span class="hljs-built_in">strspn</span>( text, <span class="hljs-string">" \t"</span> );<br>        m_host = text;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"oop! unknow header %s\n"</span>, text );<br>    }<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 我们没有真正解析HTTP请求的消息体，只是判断它是否被完整的读入了</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::parse_content</span><span class="hljs-params">( <span class="hljs-type">char</span>* text )</span> </span>{<br>    <span class="hljs-keyword">if</span> ( m_read_idx &gt;= ( m_content_length + m_checked_idx ) )<br>    {<br>        text[ m_content_length ] = <span class="hljs-string">'\0'</span>;<br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    }<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 主状态机，解析请求</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::process_read</span><span class="hljs-params">()</span> </span>{<br>    LINE_STATUS line_status = LINE_OK;<br>    HTTP_CODE ret = NO_REQUEST;<br>    <span class="hljs-type">char</span>* text = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK))<br>                || ((line_status = <span class="hljs-built_in">parse_line</span>()) == LINE_OK)) {<br>        <span class="hljs-comment">// 获取一行数据</span><br>        text = <span class="hljs-built_in">get_line</span>();<br>        m_start_line = m_checked_idx;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"got 1 http line: %s\n"</span>, text );<br><br>        <span class="hljs-keyword">switch</span> ( m_check_state ) {<br>            <span class="hljs-keyword">case</span> CHECK_STATE_REQUESTLINE: {<br>                ret = <span class="hljs-built_in">parse_request_line</span>( text );<br>                <span class="hljs-keyword">if</span> ( ret == BAD_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                }<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">case</span> CHECK_STATE_HEADER: {<br>                ret = <span class="hljs-built_in">parse_headers</span>( text );<br>                <span class="hljs-keyword">if</span> ( ret == BAD_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ret == GET_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">do_request</span>();<br>                }<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">case</span> CHECK_STATE_CONTENT: {<br>                ret = <span class="hljs-built_in">parse_content</span>( text );<br>                <span class="hljs-keyword">if</span> ( ret == GET_REQUEST ) {<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">do_request</span>();<br>                }<br>                line_status = LINE_OPEN;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-keyword">default</span>: {<br>                <span class="hljs-keyword">return</span> INTERNAL_ERROR;<br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>}<br><br><span class="hljs-comment">// 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，</span><br><span class="hljs-comment">// 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其</span><br><span class="hljs-comment">// 映射到内存地址m_file_address处，并告诉调用者获取文件成功</span><br><span class="hljs-function">http_conn::HTTP_CODE <span class="hljs-title">http_conn::do_request</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// "/home/nowcoder/webserver/resources"</span><br>    <span class="hljs-built_in">strcpy</span>( m_real_file, doc_root );<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>( doc_root );<br>    <span class="hljs-built_in">strncpy</span>( m_real_file + len, m_url, FILENAME_LEN - len - <span class="hljs-number">1</span> );<br>    <span class="hljs-comment">// 获取m_real_file文件的相关的状态信息，-1失败，0成功</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">stat</span>( m_real_file, &amp;m_file_stat ) &lt; <span class="hljs-number">0</span> ) {<br>        <span class="hljs-keyword">return</span> NO_RESOURCE;<br>    }<br><br>    <span class="hljs-comment">// 判断访问权限</span><br>    <span class="hljs-keyword">if</span> ( ! ( m_file_stat.st_mode &amp; S_IROTH ) ) {<br>        <span class="hljs-keyword">return</span> FORBIDDEN_REQUEST;<br>    }<br><br>    <span class="hljs-comment">// 判断是否是目录</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">S_ISDIR</span>( m_file_stat.st_mode ) ) {<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    }<br><br>    <span class="hljs-comment">// 以只读方式打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>( m_real_file, O_RDONLY );<br>    <span class="hljs-comment">// 创建内存映射</span><br>    m_file_address = ( <span class="hljs-type">char</span>* )<span class="hljs-built_in">mmap</span>( <span class="hljs-number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">close</span>( fd );<br>    <span class="hljs-keyword">return</span> FILE_REQUEST;<br>}<br><br><span class="hljs-comment">// 对内存映射区执行munmap操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::unmap</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">if</span>( m_file_address )<br>    {<br>        <span class="hljs-built_in">munmap</span>( m_file_address, m_file_stat.st_size );<br>        m_file_address = <span class="hljs-number">0</span>;<br>    }<br>}<br><br><span class="hljs-comment">// 写HTTP响应</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::write</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">if</span> ( bytes_to_send == <span class="hljs-number">0</span> ) {<br>        <span class="hljs-comment">// 将要发送的字节为0，这一次响应结束。</span><br>        <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLIN ); <br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-comment">// 分散写</span><br>        temp = <span class="hljs-built_in">writev</span>(m_sockfd, m_iv, m_iv_count);<br>        <span class="hljs-keyword">if</span> ( temp &lt;= <span class="hljs-number">-1</span> ) {<br>            <span class="hljs-comment">// 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，</span><br>            <span class="hljs-comment">// 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。</span><br>            <span class="hljs-keyword">if</span>( errno == EAGAIN ) {<br>                <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT );<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-built_in">unmap</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        }<br><br>        bytes_have_send += temp;<br>        bytes_to_send -= temp;<br><br>        <span class="hljs-keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="hljs-number">0</span>].iov_len)<br>        {<br>            m_iv[<span class="hljs-number">0</span>].iov_len = <span class="hljs-number">0</span>;<br>            m_iv[<span class="hljs-number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);<br>            m_iv[<span class="hljs-number">1</span>].iov_len = bytes_to_send;<br>        }<br>        <span class="hljs-keyword">else</span><br>        {<br>            m_iv[<span class="hljs-number">0</span>].iov_base = m_write_buf + bytes_have_send;<br>            m_iv[<span class="hljs-number">0</span>].iov_len = m_iv[<span class="hljs-number">0</span>].iov_len - temp;<br>        }<br><br>        <span class="hljs-keyword">if</span> (bytes_to_send &lt;= <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-comment">// 没有数据要发送了</span><br>            <span class="hljs-built_in">unmap</span>();<br>            <span class="hljs-built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN);<br><br>            <span class="hljs-keyword">if</span> (m_linger)<br>            {<br>                <span class="hljs-built_in">init</span>();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-keyword">else</span><br>            {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br><br>    }<br><br>    <br>}<br><br><span class="hljs-comment">// 往写缓冲中写入待发送的数据</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_response</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ... )</span> </span>{<br>    <span class="hljs-keyword">if</span>( m_write_idx &gt;= WRITE_BUFFER_SIZE ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    va_list arg_list;<br>    <span class="hljs-built_in">va_start</span>( arg_list, format );<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">vsnprintf</span>( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="hljs-number">1</span> - m_write_idx, format, arg_list );<br>    <span class="hljs-keyword">if</span>( len &gt;= ( WRITE_BUFFER_SIZE - <span class="hljs-number">1</span> - m_write_idx ) ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>    m_write_idx += len;<br>    <span class="hljs-built_in">va_end</span>( arg_list );<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_status_line</span><span class="hljs-params">( <span class="hljs-type">int</span> status, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* title )</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"%s %d %s\r\n"</span>, <span class="hljs-string">"HTTP/1.1"</span>, status, title );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_headers</span><span class="hljs-params">(<span class="hljs-type">int</span> content_len)</span> </span>{<br>    <span class="hljs-built_in">add_content_length</span>(content_len);<br>    <span class="hljs-built_in">add_content_type</span>();<br>    <span class="hljs-built_in">add_linger</span>();<br>    <span class="hljs-built_in">add_blank_line</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_content_length</span><span class="hljs-params">(<span class="hljs-type">int</span> content_len)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"Content-Length: %d\r\n"</span>, content_len );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_linger</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"Connection: %s\r\n"</span>, ( m_linger == <span class="hljs-literal">true</span> ) ? <span class="hljs-string">"keep-alive"</span> : <span class="hljs-string">"close"</span> );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_blank_line</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"%s"</span>, <span class="hljs-string">"\r\n"</span> );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_content</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span>* content )</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>( <span class="hljs-string">"%s"</span>, content );<br>}<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::add_content_type</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add_response</span>(<span class="hljs-string">"Content-Type:%s\r\n"</span>, <span class="hljs-string">"text/html"</span>);<br>}<br><br><span class="hljs-comment">// 根据服务器处理HTTP请求的结果，决定返回给客户端的内容</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_conn::process_write</span><span class="hljs-params">(HTTP_CODE ret)</span> </span>{<br>    <span class="hljs-keyword">switch</span> (ret)<br>    {<br>        <span class="hljs-keyword">case</span> INTERNAL_ERROR:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">500</span>, error_500_title );<br>            <span class="hljs-built_in">add_headers</span>( <span class="hljs-built_in">strlen</span>( error_500_form ) );<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_500_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> BAD_REQUEST:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">400</span>, error_400_title );<br>            <span class="hljs-built_in">add_headers</span>( <span class="hljs-built_in">strlen</span>( error_400_form ) );<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_400_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> NO_RESOURCE:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">404</span>, error_404_title );<br>            <span class="hljs-built_in">add_headers</span>( <span class="hljs-built_in">strlen</span>( error_404_form ) );<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_404_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FORBIDDEN_REQUEST:<br>            <span class="hljs-built_in">add_status_line</span>( <span class="hljs-number">403</span>, error_403_title );<br>            <span class="hljs-built_in">add_headers</span>(<span class="hljs-built_in">strlen</span>( error_403_form));<br>            <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">add_content</span>( error_403_form ) ) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FILE_REQUEST:<br>            <span class="hljs-built_in">add_status_line</span>(<span class="hljs-number">200</span>, ok_200_title );<br>            <span class="hljs-built_in">add_headers</span>(m_file_stat.st_size);<br>            m_iv[ <span class="hljs-number">0</span> ].iov_base = m_write_buf;<br>            m_iv[ <span class="hljs-number">0</span> ].iov_len = m_write_idx;<br>            m_iv[ <span class="hljs-number">1</span> ].iov_base = m_file_address;<br>            m_iv[ <span class="hljs-number">1</span> ].iov_len = m_file_stat.st_size;<br>            m_iv_count = <span class="hljs-number">2</span>;<br><br>            bytes_to_send = m_write_idx + m_file_stat.st_size;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br>    m_iv[ <span class="hljs-number">0</span> ].iov_base = m_write_buf;<br>    m_iv[ <span class="hljs-number">0</span> ].iov_len = m_write_idx;<br>    m_iv_count = <span class="hljs-number">1</span>;<br>    bytes_to_send = m_write_idx;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-comment">// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_conn::process</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 解析HTTP请求</span><br>    HTTP_CODE read_ret = <span class="hljs-built_in">process_read</span>();<br>    <span class="hljs-keyword">if</span> ( read_ret == NO_REQUEST ) {<br>        <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLIN );<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <br>    <span class="hljs-comment">// 生成响应</span><br>    <span class="hljs-type">bool</span> write_ret = <span class="hljs-built_in">process_write</span>( read_ret );<br>    <span class="hljs-keyword">if</span> ( !write_ret ) {<br>        <span class="hljs-built_in">close_conn</span>();<br>    }<br>    <span class="hljs-built_in">modfd</span>( m_epollfd, m_sockfd, EPOLLOUT);<br>}<br></code></pre></td></tr></tbody></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span><span class="hljs-comment">// 网络相关, 导入这个上面两个不用导了</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span> <span class="hljs-comment">// 文件描述符</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-comment">// 同步的类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"locker.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"threadpool.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"http_conn.h"</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FD 65536   <span class="hljs-comment">// 最大的文件描述符个数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 10000  <span class="hljs-comment">// 一次可以监听的最大的事件数量</span></span><br><br><span class="hljs-comment">// 添加文件描述符 到 epoll 中</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> one_shot )</span></span>;<span class="hljs-comment">// 声明成外部的, 写到 http_conn 中</span><br><span class="hljs-comment">// 从 epoll 删除文件描述符</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">removefd</span><span class="hljs-params">( <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd )</span></span>;<br><span class="hljs-comment">// 修改文件活述符</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">modfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ev)</span></span>;<br><br><span class="hljs-comment">// 添加信号捕捉</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addsig</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">void</span>( handler )(<span class="hljs-type">int</span>))</span></span>{<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> sa;<br>    <span class="hljs-built_in">memset</span>( &amp;sa, <span class="hljs-string">'\0'</span>, <span class="hljs-built_in">sizeof</span>( sa ) ); <span class="hljs-comment">// 清空 sa</span><br>    sa.sa_handler = handler;<span class="hljs-comment">// 用我们传递进来的handler</span><br>    <span class="hljs-built_in">sigfillset</span>( &amp;sa.sa_mask );<span class="hljs-comment">// 设置临时阻塞的信号集</span><br>    <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">sigaction</span>( sig, &amp;sa, <span class="hljs-literal">NULL</span> ) != <span class="hljs-number">-1</span> );<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[] )</span> </span>{<br>    <br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">1</span> ) { <span class="hljs-comment">// ,没有端口号</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">"usage: %s port_number\n"</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-comment">// 获取端口号, atoi: 转化成整数</span><br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">1</span>] );<br>    <span class="hljs-comment">// 对 SIGPIE 信号处理: 忽略它</span><br>    <span class="hljs-built_in">addsig</span>( SIGPIPE, SIG_IGN );<br>    <span class="hljs-comment">// 创建线程池，初始化线程池</span><br>    <span class="hljs-comment">// http_conn 是处理任务的类</span><br>    threadpool&lt; http_conn &gt;* pool = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">try</span> {<br>        pool = <span class="hljs-keyword">new</span> threadpool&lt;http_conn&gt;;<br>    } <span class="hljs-built_in">catch</span>( ... ) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-comment">// 创建一个数组用于保存所有客户端的信息</span><br>    http_conn* users = <span class="hljs-keyword">new</span> http_conn[ MAX_FD ];<span class="hljs-comment">// MAX_FD: 宏定义(在上边)</span><br>    <span class="hljs-comment">// 创建监听的套接字</span><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    address.sin_addr.s_addr = INADDR_ANY;<br>    address.sin_family = AF_INET;<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port ); <span class="hljs-comment">// 大端小端转换字节序</span><br><br>    <span class="hljs-comment">// 设置端口复用 在绑定之前设置</span><br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in">sizeof</span>( reuse ) );<br><br>    <span class="hljs-comment">// 绑定</span><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( <span class="hljs-keyword">struct</span> sockaddr* )&amp;address, <span class="hljs-built_in">sizeof</span>( address ) );<br>    <br>    <span class="hljs-comment">// 监听</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br><br>    <span class="hljs-comment">// 创建epoll对象，和事件数组，添加</span><br>    epoll_event events[ MAX_EVENT_NUMBER ]; <span class="hljs-comment">//  [宏定义] : 最大可以监听的个数</span><br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">5</span> );<br><br>    <span class="hljs-comment">// 将监听的文件描述符添加到epoll对象中</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, listenfd, <span class="hljs-literal">false</span> );<br>    http_conn::m_epollfd = epollfd;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br>        <br>        <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span> );<br>        <br>        <span class="hljs-keyword">if</span> ( ( number &lt; <span class="hljs-number">0</span> ) &amp;&amp; ( errno != EINTR ) ) {<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">"epoll failure\n"</span> );<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++ ) {<br>            <br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>            <br>            <span class="hljs-keyword">if</span>( sockfd == listenfd ) {<br>                <br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>                <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>( client_address );<br>                <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( <span class="hljs-keyword">struct</span> sockaddr* )&amp;client_address, &amp;client_addrlength );<br>                <br>                <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> ) {<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">"errno is: %d\n"</span>, errno );<br>                    <span class="hljs-keyword">continue</span>;<br>                } <br><br>                <span class="hljs-keyword">if</span>( http_conn::m_user_count &gt;= MAX_FD ) {<br>                    <span class="hljs-built_in">close</span>(connfd);<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                users[connfd].<span class="hljs-built_in">init</span>( connfd, client_address);<br><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; ( EPOLLRDHUP | EPOLLHUP | EPOLLERR ) ) {<br><br>                users[sockfd].<span class="hljs-built_in">close_conn</span>();<br><br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN) {<br><br>                <span class="hljs-keyword">if</span>(users[sockfd].<span class="hljs-built_in">read</span>()) {<br>                    pool-&gt;<span class="hljs-built_in">append</span>(users + sockfd);<br>                } <span class="hljs-keyword">else</span> {<br>                    users[sockfd].<span class="hljs-built_in">close_conn</span>();<br>                }<br><br>            }  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( events[i].events &amp; EPOLLOUT ) {<br><br>                <span class="hljs-keyword">if</span>( !users[sockfd].<span class="hljs-built_in">write</span>() ) {<br>                    users[sockfd].<span class="hljs-built_in">close_conn</span>();<br>                }<br><br>            }<br>        }<br>    }<br>    <br>    <span class="hljs-built_in">close</span>( epollfd );<br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">delete</span> [] users;<br>    <span class="hljs-keyword">delete</span> pool;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRqHai9rjyzxK3vO20JNy5" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.6 项目整体流程代码实现.md" --> <p>#历史记录::<br>2022/10/10🌵5.6 项目整体流程代码实现 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>纯铜英文期刊</title>
    <link href="/posts/27580/"/>
    <url>/posts/27580/</url>
    
    <content type="html"><![CDATA[<p>塑性流动加工的梯度结构纯铜板的形成机理、力学性能和热稳定性研究</p><blockquote><p><a href="marginnote3app://note/F158768A-F97E-4FD8-8CA4-00359048DCE2">margin: Yuning Zeng</a></p></blockquote><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1: 引言</h1><h1 id="2-pfm流程的原则"><a class="markdownIt-Anchor" href="#2-pfm流程的原则"></a> 2: PFM流程的原则</h1><p>原理图<br>![[挤出切削变形区示意图.30.excalidraw|900]]</p><h1 id="3-实验和有限元模拟程序"><a class="markdownIt-Anchor" href="#3-实验和有限元模拟程序"></a> 3: 实验和有限元模拟程序</h1><p>实体模型与有限元模型图</p><h2 id="31-实验程序"><a class="markdownIt-Anchor" href="#31-实验程序"></a> 3.1: 实验程序</h2><h2 id="32-有限元仿真程序"><a class="markdownIt-Anchor" href="#32-有限元仿真程序"></a> 3.2: 有限元仿真程序</h2><h1 id="4-结果和讨论"><a class="markdownIt-Anchor" href="#4-结果和讨论"></a> 4: 结果和讨论</h1><h2 id="41-纯铜片的成型工艺"><a class="markdownIt-Anchor" href="#41-纯铜片的成型工艺"></a> 4.1: 纯铜片的成型工艺</h2><p>几个区的示意图<br>![[挤出切削不同阶段成形过程.excalidraw]]</p><h2 id="42-有限元仿真结果及有限元仿真结果讨论"><a class="markdownIt-Anchor" href="#42-有限元仿真结果及有限元仿真结果讨论"></a> 4.2: 有限元仿真结果及有限元仿真结果讨论</h2><h3 id="421-速度分布"><a class="markdownIt-Anchor" href="#421-速度分布"></a> 4.2.1: 速度分布</h3><h3 id="422-应变分布"><a class="markdownIt-Anchor" href="#422-应变分布"></a> 4.2.2: 应变分布</h3><h3 id="423-应变率分布"><a class="markdownIt-Anchor" href="#423-应变率分布"></a> 4.2.3: 应变率分布</h3><h3 id="424-不同轨迹的等效应变变化"><a class="markdownIt-Anchor" href="#424-不同轨迹的等效应变变化"></a> 4.2.4: 不同轨迹的等效应变变化</h3><h2 id="43-pfm过程的实验结果和讨论"><a class="markdownIt-Anchor" href="#43-pfm过程的实验结果和讨论"></a> 4.3: PFM过程的实验结果和讨论。</h2><h3 id="431-金相"><a class="markdownIt-Anchor" href="#431-金相"></a> 4.3.1: 金相</h3><p>微观结构观察试样的观察面与硬度测试试样的测试面一致, 也需要与硬度测试试样一样进行冷镶嵌<br>对于金相显微镜试样,首先进行粗磨、精磨、粗抛光及精抛光至镜面效果,然后在室温下使用事先配比好的腐蚀液(50ml 盐酸+100ml 水+5g 三氯化铁)对试样表面进行 25s 左右的金相腐蚀,最后将腐蚀好的微观结构观察试样放置于智能型倒置金相显微镜中进行微观结构观察。</p><h3 id="432-ebsd"><a class="markdownIt-Anchor" href="#432-ebsd"></a> 4.3.2: EBSD</h3><p>微观结构观察试样的观察面与硬度测试试样的测试面一致, 也需要与硬度测试试样一样进行冷镶嵌<br>对于 EBSD 试样, 首先进行粗磨、 精磨、 粗抛光及精抛光至镜面效果, 然后进行碱洗-水冲-酸洗-水冲并迅速吹干, 接着在室温下使用事先配比好的电解抛光液(700ml 磷酸+300ml 水) 对试样表面进行电压 1.8V、 时间 7-10min 的电解抛光, 最后将抛光好的微观结构观察试样放置于场发射扫描电子显微镜中并利用 EBSD 技术进行微观结构观察与晶粒尺寸统计等。</p><h3 id="433-拉伸"><a class="markdownIt-Anchor" href="#433-拉伸"></a> 4.3.3: 拉伸</h3><p>由于本研究所制备的梯度结构纯铜片材尺寸较小, 无法按照标准尺寸加工拉伸性能测试试样, 故通过线切割按照非标准尺寸加工试样, 所加工的非标拉伸性能测试试样如图 2-10 所示。同时, 由于梯度结构纯铜片材在性能上的特殊性, 不可将拉伸性能测试试样的表面进行粗磨, 只需经过 3000 目的砂纸精磨至表面划痕细腻均匀、方向统一即可进行拉伸性能测试。<br>另外, 由于实验中无法安装引伸计, 所以实验所测位移并非试样标距段的真实位移, 而是电子万能试验机上夹具与下夹具之间的位移。<br>为了保证延伸率的准确性,本研究通过游标卡尺对实验前后拉伸性能测试试样的标距段长度进行测试, 并依据相关公式计算相应的延伸率</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211021307290.png" alt="|500"></p><h3 id="434-硬度"><a class="markdownIt-Anchor" href="#434-硬度"></a> 4.3.4: [[硬度]]</h3><h2 id="44-纯铜片的热稳定性"><a class="markdownIt-Anchor" href="#44-纯铜片的热稳定性"></a> 4.4: 纯铜片的热稳定性</h2><h3 id="441-金相"><a class="markdownIt-Anchor" href="#441-金相"></a> 4.4.1: 金相</h3><h3 id="442-硬度"><a class="markdownIt-Anchor" href="#442-硬度"></a> 4.4.2: 硬度</h3><h3 id="443-拉伸"><a class="markdownIt-Anchor" href="#443-拉伸"></a> 4.4.3: 拉伸</h3><h1 id="5-结论"><a class="markdownIt-Anchor" href="#5-结论"></a> 5: 结论</h1><p>‌‌<br>![[纯铜英文期刊 2022-11-02 09.57.20.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsP3v8lp7LdlvqIh9YR4xUa"  --> <p>📝纯铜英文期刊::<br>2022/11/2: 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
      <category>论文学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 多表查询</title>
    <link href="/posts/5516/"/>
    <url>/posts/5516/</url>
    
    <content type="html"><![CDATA[<p>我们之前在讲解SQL语句的时候,讲解了DQL语句,也就是数据查询语句,但是之前讲解的查询都是单表查询,而本章节我们要学习的则是多表查询操作,主要从以下几个方面进行讲解。::</p><!-- basicblock-end --><h2 id="01-数据准备"><a class="markdownIt-Anchor" href="#01-数据准备"></a> 0.1 数据准备</h2><p>1). 删除之前 emp, dept表的测试数据<br>2). 执行如下脚本,创建emp表与dept表并插入测试数据</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- 创建dept表,并插入数据<br>create table dept(     <br>id   int auto_increment comment 'ID' primary key,<br>name varchar(50) not null comment '部门名称' )comment '部门表'; <br><br>INSERT INTO dept (id, name) VALUES (1, '研发部'), (2, '市场部'),(3, '财务部'), (4, '销售部'), (5, '总经办'), (6, '人事部');<br><br><br>-- 创建emp表,并插入数据<br>create table emp(     <br>id  int auto_increment comment 'ID' primary key,<br>name varchar(50) not null comment '姓名',     <br>age  int comment '年龄',     <br>job varchar(20) comment '职位',     <br>salary int comment '薪资',    <br>entrydate date comment '入职时间',     <br>managerid int comment '直属领导ID',     <br>dept_id int comment '部门ID' <br>)comment '员工表';<br><br>-- 添加外键<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);<br>INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id)<br>VALUES             <br>(1, '金庸', 66, '总裁',20000, '2000-01-01', null,5),             <br>(2, '张无忌', 20, '项目经理',12500, '2005-12-05', 1,1),             <br>(3, '杨逍', 33, '开发', 8400,'2000-11-03', 2,1),             <br>(4, '韦一笑', 48, '开发',11000, '2002-02-05', 2,1),             <br>(5, '常遇春', 43, '开发',10500, '2004-09-07', 3,1),             <br>(6, '小昭', 19, '程序员鼓励师',6600, '2004-10-12', 2,1),             <br>(7, '灭绝', 60, '财务总监',8500, '2002-09-12', 1,3),            <br>(8, '周芷若', 19, '会计',48000, '2006-06-02', 7,3),             <br>(9, '丁敏君', 23, '出纳',5250, '2009-05-13', 7,3),             <br>(10, '赵敏', 20, '市场部总监',12500, '2004-10-12', 1,2),             <br>(11, '鹿杖客', 56, '职员',3750, '2006-10-03', 10,2),             <br>(12, '鹤笔翁', 19, '职员',3750, '2007-05-09', 10,2),             <br>(13, '方东白', 19, '职员',5500, '2009-02-12', 10,2),             <br>(14, '张三丰', 88, '销售总监',14000, '2004-10-12', 1,4),             <br>(15, '俞莲舟', 38, '销售',4600, '2004-10-12', 14,4),             <br>(16, '宋远桥', 40, '销售',4600, '2004-10-12', 14,4),             <br>(17, '陈友谅', 42, null,2000, '2011-10-12', 1,null);<br><br><br><br></code></pre></td></tr></tbody></table></figure><pre><code class="hljs">dept表共6条记录,emp表共17条记录。</code></pre><h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述::</h1><p><strong>多表查询就是指从多张表中查询数据。</strong><br>原来查询单表数据,执行的SQL形式为:select * from emp;<br>那么我们要执行多表查询,就只需要使用逗号分隔多张表即可,如: select * from emp , dept ; 具体的执行结果如下:</p><blockquote><p>[!example]- 笛卡尔积<br>![[笛卡尔积.excalidraw]]</p></blockquote><h1 id="2-多表关系"><a class="markdownIt-Anchor" href="#2-多表关系"></a> 2 多表关系::</h1><blockquote><p>2022/10/08: ⏱0-34, 感觉时间都花在了弄图上边, 调格式上了</p></blockquote><p>由于业务之间相互关联,所以各个表结构之间也存在着各种联系,基本上分为三种:</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><blockquote><p>[!example]-<br>![[5.1 多表关系 2022-10-08 20.14.43.excalidraw]]</p></blockquote><p>用到的代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">create table student_course(<br>id int auto_increment comment '主键' primary key,     <br>studentid int not null comment '学生ID',     <br>courseid  int not null comment '课程ID',     <br>constraint fk_courseid foreign key (courseid) references course (id),     <br>constraint fk_studentid foreign key (studentid) references student (id) <br>)comment '学生课程中间表';<br></code></pre></td></tr></tbody></table></figure><h1 id="3-多表查询的分类"><a class="markdownIt-Anchor" href="#3-多表查询的分类"></a> 3 [[多表查询的分类]]::</h1><!-- basicblock-start oid="ObsKoFz2LyD20rQpsImLWiV4" --> <h1 id="4-多表查询案例"><a class="markdownIt-Anchor" href="#4-多表查询案例"></a> 4 多表查询案例::</h1><!-- basicblock-end --><p>数据环境准备:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">create table salgrade(     <br>grade int,     <br>losal int,     <br>hisal int ) comment '薪资等级表'; <br><br>insert into salgrade values (1,0,3000); <br>insert into salgrade values (2,3001,5000); <br>insert into salgrade values (3,5001,8000); <br>insert into salgrade values (4,8001,10000); <br>insert into salgrade values (5,10001,15000); <br>insert into salgrade values (6,15001,20000); <br>insert into salgrade values (7,20001,25000); <br>insert into salgrade values (8,25001,30000);<br></code></pre></td></tr></tbody></table></figure><p>在这个案例中,我们主要运用上面所讲解的多表查询的语法,完成以下的12个需求即可,而这里主要涉及到的表就三张:emp员工表、dept部门表、salgrade薪资等级表 。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>1). 查询员工的姓名、年龄、职位、部门信息 (隐式内连接) <br>表: emp , dept <br>连接条件: emp.dept_id = dept.id<br>select e.name , e.age , e.job , d.name from emp e, dept d where e.dept_id = d.id; <br><br><br>2). 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息(显式内连接) -- 简化一下查所有所有的字段<br>表: emp , dept <br>连接条件: emp.dept_id = dept.id<br>select * from emp e join dept d on e.dept_id = d.id where e.age &lt; 30; # ❗️on 后边得是e.dept_id = d.id, 否则会有笛卡尔积<br><br><br>3). 查询拥有员工的部门ID、部门名称<br>表: emp , dept <br>连接条件: emp.dept_id = dept.id<br>select distinct  d.id, d.name from emp e, dept d where e.dept_id = d.id; # ❗️没有 distinct 接会出现重复的部门<br><br><br>4). 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接) <br>select e.*, d.name from emp e left join dept d on e.dept_id = d.id where e.age &gt; 40 ;<br><br><br>5). 查询所有员工的工资等级<br>表: emp , salgrade <br>连接条件 : # 大于最小值 ,小于最大值<br>- emp.salary &gt;= salgrade.losal and emp.salary &lt;= salgrade.hisal <br>- emp.salary between salgrade.losal and salgrade.hisal -- 用这个<br>-- 方式一<br>select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary &gt;= s.losal and e.salary &lt;= s.hisal;<br>-- 方式二<br>select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary between s.losal and s.hisal;<br><br><br><br><br>6). 查询 "研发部" 所有员工的信息及 工资等级表<br>: emp , salgrade , dept <br>连接条件 : emp.salary between salgrade.losal and salgrade.hisal , emp.dept_id = dept.id <br>查询条件 : dept.name = '研发部'<br><br>-- 多重 and 条件<br>select e.* , s.grade from emp e, dept d, salgrade s where e.dept_id = d.id and (e.salary between s.losal and s.hisal) and d.name = '研发部';<br><br><br><br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsvUtPcJ5UrJg8tIeyD2QRv" deck = "👨🏻‍💻code::MySQL::基础篇::5. 多表查询.md" --> <p>#历史记录:: <a href="marginnote3app://note/6625B823-D7ED-4B49-B3AF-373D711D018B">margin: 多表查询</a><br>2022/10/8🌵5. 多表查询 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 约束</title>
    <link href="/posts/7394/"/>
    <url>/posts/7394/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述::</h1><p>概念: 约束是作用于表中字段上的规则,用于限制存储在表中的数据。<br>目的: 保证数据库中数据的正确、有效性和完整性。</p><p>分类：</p><table><thead><tr><th>约束</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>非空约束</td><td>NOT NULL</td><td>限制该字段的数据不能为null</td></tr><tr><td>唯一约束</td><td>UNIQUE</td><td>保证该字段的所有数据都是唯一、不重复的</td></tr><tr><td>主键约束</td><td>PRIMARY KEY</td><td>主键是一行数据的唯一标识，要求非空且唯一      <strong>自增：AUTO_INCREMENT</strong></td></tr><tr><td>默认约束</td><td>DEFAULT</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td></tr><tr><td>检查约束</td><td>CHECK</td><td>保证字段值满足某一个条件</td></tr><tr><td>外键约束</td><td>FOREIGN KEY</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td></tr></tbody></table><blockquote><p>[!cite] 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。</p></blockquote><h2 id="11-常用约束"><a class="markdownIt-Anchor" href="#11-常用约束"></a> 1.1 常用约束</h2><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>id int primary key auto_increment,<br>name varchar(10) not null unique,<br>age int check(age &gt; 0 &amp;&amp; age &lt; 120),<br>status char(1) default '1',<br>gender char(1)<br>);<br><br></code></pre></td></tr></tbody></table></figure><p>在为字段添加约束时,我们只需要在字段之后加上约束的关键字即可,需要关注其语法。我们执行上面的SQL把表结构创建完成,然后接下来,就可以通过一组数据进行测试,从而验证一下,约束是否可以生效。</p><p>通过图形化界面来创建表结构时,又该如何来指定约束呢?<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081620473.png" alt="|700"></p><h1 id="2-外键约束"><a class="markdownIt-Anchor" href="#2-外键约束"></a> 2 外键约束::</h1><p>外键:用来让两张表的数据之间建立连接,从而保证数据的一致性和完整性。</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081623336.png" alt=""></p><p>添加外键：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(<br>字段名 字段类型,<br>...<br>[constraint] [外键名称] foreign key(外键字段名) references 主表(主表列名)<br>);<br><br>alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名);<br><br>-- 例子<br>create table student_course(<br>constraint fk_studentid foreign key (studentid) references student (id) <br>)comment '学生课程中间表';<br><br>alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);<br></code></pre></td></tr></tbody></table></figure><p>删除外键：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;<br><br>-- 案例<br>alter table emp drop foreign key fk_emp_dept_id;<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]<br>![[外键约束.excalidraw]]</p></blockquote><h1 id="3-删除更新行为"><a class="markdownIt-Anchor" href="#3-删除更新行为"></a> 3 删除/更新行为::</h1><blockquote><p>2022/10/08⏱0-44</p></blockquote><p>添加了外键之后,再删除父表数据时产生的约束行为,我们就称为删除/更新行为。具体的删除/更新行为有以下几种:</p><table><thead><tr><th>行为</th><th>说明</th><th></th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td><td>默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td><td>默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td><td></td></tr><tr><td>SET NULL</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td><td></td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td><td></td></tr></tbody></table><p>怎么在表格中换行</p><blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081759671.png" alt="|700"></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">更改删除/更新行为：<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;<br><br>-- 例子<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade ;<br><br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update set null on delete set null ;<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]  cascade, set null<br>由于NO ACTION 是默认行为,我们前面语法演示的时候,已经测试过了,就不再演示了,这里我们再演示其他的两种行为:CASCADE、SET NULL。<br>![[4. 约束 2022-10-08 17.34.27.excalidraw]]</p></blockquote><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsFNToqDZ3IcPFgTPYaQJa1"  --> <p>#历史记录:: <a href="marginnote3app://note/ED900578-977B-4CA9-B9C2-666A5E4687EC">margin: 约束</a><br>2022/10/8🌵4. 约束 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3. 函数</title>
    <link href="/posts/62444/"/>
    <url>/posts/62444/</url>
    
    <content type="html"><![CDATA[<h2 id="01-函数类型"><a class="markdownIt-Anchor" href="#01-函数类型"></a> 0.1 函数类型::</h2><!-- basicblock-end --><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><p>我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可</p><!-- basicblock-start oid="ObsKSH7ufFoInhssMhmdqMW7" --> <h1 id="1-字符串函数"><a class="markdownIt-Anchor" href="#1-字符串函数"></a> 1 字符串函数::</h1><!-- basicblock-end --><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, sn)</td><td>字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr><tr><td>REPLACE(column, source, replace)</td><td>替换字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br><br><br>A.concat:字符串拼接<br>select concat('Hello',' MySQL'); <br><br>B.lower :全部转小写<br>select lower('Hello');<br><br>C.upper :全部转大写<br>select upper('Hello');<br><br>D. lpad :左填充<br>select lpad('01',5,'-'); # 结果: ---01<br><br>E.rpad:右填充<br>select rpad('01',5,'-');# 结果: 01--- <br><br>F.trim:去除空格<br>select trim('HelloMySQL'); <br><br>G.substring:截取子字符串<br>select substring('Hello MysQL',1,5);<br><br><br><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-  由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。<br>![[函数 2022-10-07 18.10.44.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsDtGNTSJ0yZVyjGc2bGFAV" --> <h1 id="2-数值函数"><a class="markdownIt-Anchor" href="#2-数值函数"></a> 2 数值函数::</h1><!-- basicblock-end --><p>常见函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数 含小数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>A. ceil：向上取整<br>select ceil(1.1);<br><br>B. floor：向下取整<br>select floor (1.9)；<br><br>C. mod：取模<br>select mod (7, 4);<br><br>D. rand：获取随机数: 0-1<br>select rand();<br><br>E. ROUND(x, y) | 求参数x的四舍五入值，💡保留y位小数<br>select round (2.344, 2)；<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]- 案例：通过数据库的函数，生成一个六位数的随机验证码。<br>![[函数 2022-10-07 18.55.42.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsmaWB98mahsbm9WAJ90ZmE" --> <h1 id="3-日期函数"><a class="markdownIt-Anchor" href="#3-日期函数"></a> 3 日期函数::</h1><!-- basicblock-end --><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 例子<br>A. curdate:当前日期<br>select curdate();<br><br>B. curtime：当前时间<br>select curtime()；<br><br>C. now：当前日期和时间<br>select now()；<br><br>D. YEAR, MONTH, DAY: 当前年、月、日<br>select YEAR (now());<br>select MONTH (now());<br>select DAY (now());<br><br>E. date_add：增加指定的时间间隔<br>select date add (now(), INTERVAL 70 YEAR ); # 显示推迟后的时间<br><br>F. datediff：获取两个日期相差的天数<br>select datediff( '2021-10-01', '2021-12-01');<br><br><br><br>-- 案例<br>查询所有员工的入职天数,并根据入职天数倒序排序。<br>思路: 入职天数,就是通过当前日期 - 入职日期,所以需要使用datediff函数来完成。<br>select name, datediff(curdate(), entrydate) as 'entrydays' from emp order by entrydays desc;<br><br><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs5veD2X1nBfsnfJh348rSI" --> <h1 id="4-流程函数"><a class="markdownIt-Anchor" href="#4-流程函数"></a> 4 流程函数::</h1><!-- basicblock-end --><p>流程函数也是很常用的一类函数,可以在SQL语句中实现条件筛选,从而提高语句的效率。</p><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value, t, f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">-- A. if<br>select if(false, 'Ok', 'Error');# 返回 error<br><br>-- B. ifnull<br>select ifnull('Ok','Default'); # 返回 ok<br>select ifnull('','Default'); # 返回' '<br>select ifnull(null,'Default');# 返回 default<br><br>-- C. case when then else end<br>需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----&gt; 一线城市 , 其他 ----&gt; 二线城市)<br>select     <br>name,     <br>( case workaddress when '北京' then '一线城市' when '上海' then '一线城市' else '二线城市' end ) as '工作地址' <br>from emp;<br><br><br><br></code></pre></td></tr></tbody></table></figure><p>案例: 判定分数等级</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>create table score(     <br>id int comment 'ID',     <br>name varchar(20) comment '姓名',     <br>math int comment '数学',     <br>english int comment '英语',     <br>chinese int comment '语文' ) comment '学员成绩表'; <br><br>insert into score(id, name, math, english, chinese) <br>VALUES (1, 'Tom', 67, 88, 95 ), (2, 'Rose' , 23, 66, 90),(3, 'Jack', 56, 98, 76);<br><br>-- 案例: 判定分数等级<br>select     <br>id,     <br>name,     <br>(case when math &gt;= 85 then '优秀' when math &gt;=60 then '及格' else '不及格' end ) '数学',     <br>(case when english &gt;= 85 then '优秀' when english &gt;=60 then '及格' else '不及格' end ) '英语',     <br>(case when chinese &gt;= 85 then '优秀' when chinese &gt;=60 then '及格' else '不及格' end ) '语文' <br>from score;<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210081543332.png" alt="|500"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2TzjfwTbXfSo9jbzy7fBR" deck = "👨🏻‍💻code::MySQL::基础篇::函数.md" --> <p>#历史记录:: <a href="marginnote3app://note/C3962258-9992-4B8D-9965-7F23B17EC41A">margin: 函数</a><br>2022/10/7🌵函数 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DQL</title>
    <link href="/posts/28801/"/>
    <url>/posts/28801/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1: 定义::</h1><p>DQL英文全称是Data Query Language(数据查询语言),数据查询语言,用来查询数据库中表的记录。</p><p><strong>查询关键字: SELECT</strong></p><p>在一个正常的业务系统中,查询操作的频次是要远高于增删改的,当我们去访问企业官网、电商网站, 在这些网站中我们所看到的数据,实际都是需要从数据库中查询并展示的。而且在查询的过程中,可能还会涉及到条件、排序、分页等操作。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210070122175.png" alt="|500"></p><p>我们先来完成如下数据准备工作:<br>![[DQL 2022-10-07 01.44.53.excalidraw]]</p><!-- basicblock-start oid="ObsmTlFpONTSrFV2gxpEZK7b" --> <h1 id="2-基本语法"><a class="markdownIt-Anchor" href="#2-基本语法"></a> 2: 基本语法::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">select<br>字段列表<br>from<br>表名列表<br>where<br>条件列表<br>group by<br>分组字段列表<br>having<br>分组后条件列表<br>order by<br>排序字段列表<br>limit<br>分页参数<br></code></pre></td></tr></tbody></table></figure><p>我们在讲解这部分内容的时候，会将上面的完整语法进行拆分，分为以下几个部分：</p><ul><li>基本查询（不带任何条件）</li><li>条件查询(where)</li><li>聚合函数(count、 max、 min、 avg、 sum)</li><li>分组查询 (group by) ^246cb8</li><li>排序查询 (order by)</li><li>分页查询 (limit)</li></ul><h2 id="21-基础查询"><a class="markdownIt-Anchor" href="#21-基础查询"></a> 2.1: 基础查询</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">查询多个字段：<br>SELECT 字段1, 字段2, 字段3, ... FROM 表名;<br><br>SELECT * FROM 表名;<br>这个命令也可以直接查看表. 相当于双击表名<br>注意 : * 号代表查询所有字段,在实际开发中尽量少用(不直观、影响效率)<br><br><br>-- 案例<br>A. 查询指定字段 name, workno, age并返回<br>select name,workno,age from emp;<br><br>B. 查询返回所有字段<br>select * from emp;<br>select id ,workno,name,gender,age,idcard,workaddress,entrydate from emp; <br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">设置别名：<br>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;<br>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; # as 可以省略<br><br>-- <br>C. 查询所有员工的工作地址,起别名<br>select workaddress as '工作地址' from emp; # 将 workaddress 表头改名为 工作地址 <br>-- as可以省略<br>select workaddress '工作地址' from emp;<br><br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">去除重复记录：<br>SELECT DISTINCT 字段列表 FROM 表名;<br>-- <br>D. 查询公司员工的上班地址有哪些(不要重复)<br>select distinct workaddress '工作地址' from emp;<br><br></code></pre></td></tr></tbody></table></figure><h2 id="22-条件查询"><a class="markdownIt-Anchor" href="#22-条件查询"></a> 2.2: 条件查询</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">语法：<br>SELECT 字段列表 FROM 表名 WHERE 条件列表;<br></code></pre></td></tr></tbody></table></figure><p>条件列表</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt; 或 !=</td><td>不等于</td></tr><tr><td>BETWEEN … AND …</td><td>在某个范围内（含最小、最大值）</td></tr><tr><td>IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td>IS NULL</td><td>是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或 &amp;&amp;</td><td>并且（多个条件同时成立）</td></tr><tr><td>OR 或 ||</td><td>或者（多个条件任意一个成立）</td></tr><tr><td>NOT 或 !</td><td>非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 年龄等于30<br>select * from employee where age = 30;<br>-- 年龄小于30<br>select * from employee where age &lt; 30;<br>-- 小于等于<br>select * from employee where age &lt;= 30;<br>-- 💡没有身份证<br>select * from employee where idcard is null or idcard = '';<br>-- 有身份证<br>select * from employee where idcard;<br>select * from employee where idcard is not null;<br>-- 不等于<br>select * from employee where age != 30;<br>-- 💡年龄在20到30之间<br>select * from employee where age between 20 and 30;<br>select * from employee where age &gt;= 20 &amp;&amp; age &lt;= 30;<br>-- 下面语句不报错，但查不到任何信息<br>select * from employee where age between 30 and 20;<br>-- 性别为女且年龄小于30<br>select * from employee where age &lt; 30 and gender = '女';<br>-- 💡年龄等于25或30或35<br>select * from employee where age = 25 or age = 30 or age = 35;<br>select * from employee where age in (25, 30, 35);<br>-- 💡姓名为两个字<br>select * from employee where name like '__';<br>-- 💡身份证最后为X<br>select * from employee where idcard like '%X';<br></code></pre></td></tr></tbody></table></figure><h2 id="23-聚合查询聚合函数"><a class="markdownIt-Anchor" href="#23-聚合查询聚合函数"></a> 2.3: 聚合查询(聚合函数)</h2><p><strong>定义: 将一列数据作为一个整体,进行纵向计算 。</strong></p><p>常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">语法：<br>SELECT 聚合函数(字段列表) FROM 表名;<br>-- 注意 : NULL值是不参与所有聚合函数运算的<br><br>-- count：<br><br>SELECT count(id) from emp where workaddress = '北京';-- 统计所有北京id的个数<br>select count(*) from emp; -- 统计的是总记录数<br>select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数<br><br>对于count聚合函数,统计符合条件的总记录数,还可以通过 count(数字/字符串)的形式进行统计查询,比如: <br>select count(1) from emp;<br>对于count(*) 、count(字段)、 count(1) 的具体原理,我们在进阶篇中SQL优化部分会详细讲解,此处大家只需要知道如何使用即可。<br><br>-- max(min, avg同理)<br>统计该企业员工的最大年龄<br>select max(age) from emp;<br><br>-- sum:<br>统计西安地区员工的年龄之和<br>select sum(age) from emp where workaddress = '西安';<br><br></code></pre></td></tr></tbody></table></figure><h2 id="24-分组查询"><a class="markdownIt-Anchor" href="#24-分组查询"></a> 2.4: 分组查询</h2><p>分组通常和聚合一起使用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">语法：<br>select 字段列表 from 表名 [ where 条件 ] group by 分组字段名 [ having 分组后的过滤条件 ];<br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]- 案例<br>![[DQL 2022-10-07 02.43.47.excalidraw]]</p></blockquote><!-- basicblock-start oid="ObsAFulek30agKeIv1dOd1Ny" --> <p>where与having区别::</p><ul><li>执行时机不同:<ul><li>where是分组之前进行过滤,不满足where条件,不参与分组;💡where 是前提</li><li>而having是分组之后对结果进行过滤。</li></ul></li><li>判断条件不同:<ul><li>where不能对聚合函数进行判断,而having可以。</li></ul></li></ul><!-- basicblock-end --><blockquote><p>[!tip]<br>![[DQL 2022-10-07 02.59.44.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obsx03wDUvDEnWDoItJOZ7Pe" --> <h2 id="25-排序查询"><a class="markdownIt-Anchor" href="#25-排序查询"></a> 2.5: 排序查询::</h2><p>排序在日常开发中是非常常见的一个操作,有升序排序,也有降序排序。<br>eg: 淘宝价格排序</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"># 语法<br>SELECT  字段列表  FROM   表名  ORDER  BY  字段1  排序方式1 , 字段2  排序方式2 ;<br># 排序方式<br>ASC : 升序(默认值) <br>DESC: 降序<br># 注意事项: <br>• 如果是升序, 可以不指定排序方式ASC ;  <br>• 如果是多字段排序,当第一个字段值相同时,才会根据第二个字段进行排序 ;<br><br><br>-- 案例<br>根据年龄对公司的员工进行升序排序<br>select * from emp order by age asc; <br>select * from emp order by age;<br><br><br>根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序<br>select * from emp order by age asc , entrydate desc;<br><br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="26-分页查询"><a class="markdownIt-Anchor" href="#26-分页查询"></a> 2.6: 分页查询::</h2><p>分页操作在业务系统开发时,也是非常常见的一个功能,我们在网站中看到的各种各样的分页条,后台都需要借助于数据库的分页操作。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210071508398.png" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"># 语法: 💡能够限制查询数<br>SELECT  字段列表  FROM   表名  LIMIT  起始索引, 查询记录数 ;<br># 注意事项:  <br>• 起始索引从0开始,起始索引 = (查询页码 - 1)* 每页显示记录数。# 相当于按记录数来起始<br>• 分页查询是数据库的方言,不同的数据库有不同的实现,MySQL中是LIMIT。<br>• 如果查询的是第一页数据,起始索引可以省略,直接简写为 limit 10。<br><br>-- 案例<br>A. 查询第1页员工数据, 每页展示10条记录<br>select * from emp limit 0,10; <br>select * from emp limit 10;<br><br><br>B. 查询第2页员工数据, 每页展示10条记录 --------&gt; (页码-1)*页展示记录数 = 1 * 10 <br># 💡相当于按记录数来起始: 第一页有 10 条记录, 从第二页开始查, 就是从记录数 10 开始查<br>select * from emp limit 10,10;<br><br><br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-总案例"><a class="markdownIt-Anchor" href="#3-总案例"></a> 3: 总案例::</h1><blockquote><p>[!example]-<br>![[DQL 2022-10-07 15.36.01.excalidraw]]</p></blockquote><h1 id="4-执行顺序"><a class="markdownIt-Anchor" href="#4-执行顺序"></a> 4: 执行顺序::</h1><p>![[DQL 2022-10-07 15.48.57.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsCelZnX9SL1a3qahScdRDo"  --> <p>#历史记录:: <a href="marginnote3app://note/EEC18942-1567-4B4E-AE11-3CD513BFBE88">margin: DQL</a><br>2022/10/7🌵DQL : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DML</title>
    <link href="/posts/45173/"/>
    <url>/posts/45173/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!summary] DML<br>英文全称是Data Manipulation Language(数据操作语言），用来对数据库中表的数据记录进行增、删、改操作。</p></blockquote><ul><li>添加数据（INSERT)</li><li>修改数据 (UPDATE)</li><li>删除数据（DELETE)</li></ul><h1 id="1-添加数据"><a class="markdownIt-Anchor" href="#1-添加数据"></a> 1 添加数据::</h1><p>注意事项：<br>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。<br><strong>字符串和日期型数据应该包含在引号中。</strong><br>插入的数据大小，应该在字段的规定范围内。</p><h2 id="11-给指定字段添加数据"><a class="markdownIt-Anchor" href="#11-给指定字段添加数据"></a> 1.1 给指定字段添加数据：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">insert into 表名 (字段名1, 字段名2, ...)  values (值1, 值2, ...);<br>-- <br>insert into employee(id,workno,name,gender,age,idcard,entrydate) values(1,'1','Itcast','男',10,'123456789012345678','2000-01-01');<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!example]-<br>![[DML 2022-10-06 00.31.52.excalidraw]]</p></blockquote><p>插入数据完成之后,我们有两种方式,查询数据库的数据::<br>方式一: 在左侧的表名上双击,就可以查看这张表的数据。</p><p>方式二: 可以直接一条查询数据的SQL语句, 语句如下:<br>select * from employee;</p><blockquote><p>[!example]-<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210070048690.png" alt=""></p></blockquote><h2 id="12-给全部字段添加数据"><a class="markdownIt-Anchor" href="#12-给全部字段添加数据"></a> 1.2 给全部字段添加数据：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">INSERT INTO 表名 VALUES (值1, 值2, ...);<br><br>案例:插入数据到employee表,具体的SQL如下:<br>insert into employee values(2,'2','张无忌','男',18,'123456789012345670','2005-0101'); # 不需要()中的字段了<br><br></code></pre></td></tr></tbody></table></figure><h2 id="13-批量添加数据"><a class="markdownIt-Anchor" href="#13-批量添加数据"></a> 1.3 批量添加数据：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">批量添加给制定字段<br>insert into 表名 (字段名1, 字段名2, ...)  values (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;<br>批量添加给全部字段<br>insert into 表名 values (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;<br><br>案例:批量插入数据到employee表,具体的SQL如下:<br>insert into employee values<br>(3,'3','韦一笑','男',38,'123456789012345670','2005-0101'),<br>(4,'4','赵敏','女',18,'123456789012345670','2005-01-01');<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-修改和删除数据"><a class="markdownIt-Anchor" href="#2-修改和删除数据"></a> 2 修改和删除数据::</h1><h2 id="21-修改"><a class="markdownIt-Anchor" href="#21-修改"></a> 2.1 修改</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">修改数据：<br>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];<br><br>-- 案例<br>-- 修改id为1的数据, 将name修改为小昭, gender修改为 女<br>update employee set name = '小昭' , gender = '女' where id = 1;<br><br>-- 将所有的员工入职日期修改为 2008-01-01<br>update employee set entrydate = '2008-01-01';<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!summary] 注意事项:  修改语句的条件可以有,也可以没有,如果没有条件,则会修改整张表的所有数据。</p></blockquote><h2 id="22-删除"><a class="markdownIt-Anchor" href="#22-删除"></a> 2.2 删除</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">删除数据：<br>DELETE FROM 表名 [ WHERE 条件 ];<br><br>1. 删除gender为女的员工<br>delete from employee where gender = '女';<br>2. 删除所有员工<br>delete from employee;<br><br></code></pre></td></tr></tbody></table></figure><p>注意事项:</p><ul><li>DELETE 语句的条件可以有,也可以没有,如果没有条件,则会删除整张表的所有数据。</li></ul><ul><li>&amp; DELETE 语句不能删除某一个字段的值(可以使用UPDATE,将该字段值置为NULL即可)。</li><li>当进行删除全部数据操作时,datagrip会提示我们,询问是否确认删除,我们直接点击Execute即可。</li><li>drop table if exists employee; 这条语句也行<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210070119528.png" alt="|900"></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2SZz0uCEihdZdGnNfEkXe"  --> <p>#历史记录:: <a href="marginnote3app://note/2D1CA3EB-60E9-4BA1-92C6-AB4674C7D92D">margin: DML</a><br>2022/10/5🌵DML : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 图形化操作工具</title>
    <link href="/posts/30270/"/>
    <url>/posts/30270/</url>
    
    <content type="html"><![CDATA[<p>data grip</p><p><a href="marginnote3app://note/5FA7E791-08D2-4EF2-A742-AB7884CFF7CB">margin: 2.4 图形化界面工具</a></p><p><a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=11&amp;spm_id_from=pageDriver&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">11. 基础-SQL-图形化界面工具DataGrip_哔哩哔哩_bilibili</a></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsi2gVkNNr6eS7FWSW1PDay" deck = "👨🏻‍💻code::MySQL::基础篇::MySQL 图形化操作工具.md" --> <p>#历史记录::<br>2022/10/5🌵MySQL 图形化操作工具 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DDL-表操作-修改&amp;删除</title>
    <link href="/posts/26414/"/>
    <url>/posts/26414/</url>
    
    <content type="html"><![CDATA[<h1 id="1-添加字段"><a class="markdownIt-Anchor" href="#1-添加字段"></a> 1 添加字段::</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs MySQL">alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];<br>案例：<br>为emp表增加一个新的字段 呢称 : 为nickname，类型为varchar(20)<br>alter table emp add nickname varchar (20) comment，呢称，；<br></code></pre></td></tr></tbody></table></figure><h1 id="2-修改数据类型"><a class="markdownIt-Anchor" href="#2-修改数据类型"></a> 2 修改数据类型::</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改数据类型：<br>alter table 表名 modify 字段名 新数据类型(长度);<br></code></pre></td></tr></tbody></table></figure><h1 id="3-修改字段和字段类型"><a class="markdownIt-Anchor" href="#3-修改字段和字段类型"></a> 3 修改字段和字段类型::</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs MySQL"><br>修改字段名和字段类型：<br>alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];<br>#<br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br>alter table emp change nickname username varchar(30) COMMENT '昵称';<br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-删除字段"><a class="markdownIt-Anchor" href="#4-删除字段"></a> 4 删除字段::</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">删除字段：<br>alter table 表名 drop 字段名;<br><br># eg: 将emp表的字段username删除<br>alter table emp drop username;<br><br></code></pre></td></tr></tbody></table></figure><h1 id="5-修改表名"><a class="markdownIt-Anchor" href="#5-修改表名"></a> 5 修改表名::</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">修改表名:<br>alter table 表名 rename to 新表名<br><br>将emp表的表名修改为 employee<br>alter table emp rename to employee;<br></code></pre></td></tr></tbody></table></figure><h1 id="6-删除表"><a class="markdownIt-Anchor" href="#6-删除表"></a> 6 删除表::</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>1️⃣删除表：<br>drop table [if exists] 表名;<br>可选项 if exists 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作（如果不加该参数项，删除一张不存在的表，执行将会报错）。<br>案例：<br>如果tb_user表存在，则删除tb_user表<br>drop table if exists tb_user<br><br>-- <br>2️⃣删除表，并重新创建该表：<br>truncate table 表名;<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!tip] 注意: 在删除表的时候,表中的全部数据也都会被删除。</p></blockquote><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRggLLZfhMOUfXK3sobeh5" --> <p>#历史记录::<br>2022/10/5🌵DDL-表操作-修改&amp;删除 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DDL-表操作 - 数据类型及案例</title>
    <link href="/posts/56597/"/>
    <url>/posts/56597/</url>
    
    <content type="html"><![CDATA[<p>MySQL中的数据类型有很多,主要分为三类:数值类型、字符串类型、日期时间类型。</p><!-- basicblock-start oid="ObsV1tJOlEWjOZFU9KuxKF5E" --> <h1 id="1-数值型"><a class="markdownIt-Anchor" href="#1-数值型"></a> 1 数值型::</h1><!-- basicblock-end --><p>![[表操作-数值类型.excalidraw]]</p><!-- basicblock-start oid="Obs9FCdm1BRgvwo3ijuMKtyi" --> <h1 id="2-字符串类型"><a class="markdownIt-Anchor" href="#2-字符串类型"></a> 2 字符串类型::</h1><!-- basicblock-end --><p>![[表操作-字符串类型.excalidraw]]</p><!-- basicblock-start oid="ObsQCAj6WFSDP2zXKXK3YpES" --> <h1 id="3-日期时间类型"><a class="markdownIt-Anchor" href="#3-日期时间类型"></a> 3 日期时间类型::</h1><!-- basicblock-end --><p>![[表操作-日期时间类型.excalidraw]]</p><!-- basicblock-start oid="Obsq5ot6Un6FchfJzaDCHOWU" --> <h1 id="4-表操作-案例"><a class="markdownIt-Anchor" href="#4-表操作-案例"></a> 4 表操作-案例::</h1><!-- basicblock-end --> ^voh3gu<p>![[表操作 - 数据类型及案例 2022-10-05 21.24.45.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZX7NTl4oh0tX2XVxpa9Ou" deck = "👨🏻‍💻code::MySQL::基础篇::表操作 - 数据类型及案例.md" --> <p>#历史记录::<a href="marginnote3app://note/2C94BB82-06C3-46AA-8B87-716BE2DB0177">margin: 表操作-数据类型</a></p><p>2022/10/5🌵表操作 - 数据类型及案例 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.1 DDL</title>
    <link href="/posts/26898/"/>
    <url>/posts/26898/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!summary] DDL: (define) 数据定义语言，用来定义数据库对象（数据库、表、字段）, 包括建表修改表结构</p></blockquote><!-- basicblock-start oid="Obs6fFAKH8lvhhpaeHmbYfkV" --> <h1 id="1-数据库操作"><a class="markdownIt-Anchor" href="#1-数据库操作"></a> 1 数据库操作::</h1><!-- basicblock-end --><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询所有数据库：<br>SHOW DATABASES;: 中间有一个空格<br><br>查询当前使用的数据库：<br>SELECT DATABASE();<br><br>创建数据库：<br>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];<br><br>删除数据库：<br>DROP DATABASE [ IF EXISTS ] 数据库名;<br># drop database test;🌵drop database if exists test;<br><br>使用(切换)数据库：<br>USE 数据库名;<br></code></pre></td></tr></tbody></table></figure><h2 id="11-创建数据库"><a class="markdownIt-Anchor" href="#11-创建数据库"></a> 1.1 创建数据库：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs MySQl">CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];<br><br>-- eg:<br><br>- create database test;<br>- create database if not exists test; <br>- create database test default charset utf8mb4;<br>不推荐使用 UTF8 字符集<br>因为UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsRRkazYjRl96V95qa6PPNe" --> <h1 id="2-表操作"><a class="markdownIt-Anchor" href="#2-表操作"></a> 2 表操作 ::</h1><!-- basicblock-end --><blockquote><p>[!example]- DDL表操作案例.<br>![[DDL表操作 案例.excalidraw]]</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">查询当前数据库所有表：<br>SHOW TABLES;<br># use sys; show tables; // 查看系统数据库的所有表<br><br>查询表结构：💡内容没有那个详细<br>DESC 表名;<br><br>查询指定表的建表语句: 💡内容详细<br>SHOW CREATE TABLE 表名;<br></code></pre></td></tr></tbody></table></figure><p>创建表：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段1 字段1类型 [COMMENT 字段1注释],# 中括号内代表可选参数<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br></code></pre></td></tr></tbody></table></figure><p><strong>最后一个字段后面没有逗号</strong></p><h2 id="21-ddl-表操作-数据类型及案例"><a class="markdownIt-Anchor" href="#21-ddl-表操作-数据类型及案例"></a> 2.1 [[DDL-表操作 - 数据类型及案例]]</h2><h2 id="22-ddl-表操作-修改删除"><a class="markdownIt-Anchor" href="#22-ddl-表操作-修改删除"></a> 2.2 [[DDL-表操作-修改&amp;删除]]</h2><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsudejHcETZsM9AaCMqkhJf"  --> <p>#历史记录::<br>2022/10/5🌵DDL : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. SQL通用语法及分类</title>
    <link href="/posts/34318/"/>
    <url>/posts/34318/</url>
    
    <content type="html"><![CDATA[<h1 id="1-sql通用语句"><a class="markdownIt-Anchor" href="#1-sql通用语句"></a> 1 SQL通用语句::</h1><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释：<br>单行注释：–注释内容 或＃注释内容(MySQL特有）<br>多行注释：<code>/*注释内容*/</code></li></ol><!-- basicblock-end --><!-- basicblock-start oid="ObsMSURpGzRBpaCc3MzzNkDe" --> <h1 id="2-sql-分类"><a class="markdownIt-Anchor" href="#2-sql-分类"></a> 2 SQL 分类::</h1><ul><li>[[DDL]]: 数据定义语言，用来定义数据库对象（数据库、表、字段）</li><li>[[DML]]: 数据操作语言，用来对数据库表中的数据进行增删改</li><li>[[DQL]]: 数据查询语言，用来查询数据库中表的记录</li><li>[[MySQL 用户管理(DCL)|DCL]] : 数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><blockquote><p>[!cite]<br>DDL: Data <strong>Definition</strong> Language<br>DML:  Data <strong>Manipulation</strong> Language<br>DOL:  Data <strong>Query</strong> Language<br>DCL:  Data <strong>Control</strong> Language</p></blockquote><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyzEnmazQgB5WqxrI0IPlx" deck = "👨🏻‍💻code::MySQL::基础篇::SQL通用语法及分类.md" --> <p>#历史记录::<br>2022/10/5🌵SQL通用语法及分类 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 安装与配置</title>
    <link href="/posts/11270/"/>
    <url>/posts/11270/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1N64y1s7fw/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">软件安装｜macOS下超详细的MySQL安装_哔哩哔哩_bilibili</a></p><h1 id="1-下载"><a class="markdownIt-Anchor" href="#1-下载"></a> 1 下载</h1><p>去官网下 arm64 版本<br>下完按照提示下一步下一步就行</p><h1 id="2-配置"><a class="markdownIt-Anchor" href="#2-配置"></a> 2 配置</h1><!-- basicblock-start oid="ObstNeeUBUyW9KUUemQInMli" --> <p><a href="https://www.bilibili.com/video/BV1N64y1s7fw/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=213.693476">03:33</a>添加环境变量::</p><p>在 .bash_profile文件中</p><p>目的是让 MySQL 的命令能够在任意路径下的终端下使用, 如果不添加环境变量只能在 MySQL 安装目录下的终端下使用<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210051716228.png" alt=""></p><!-- basicblock-end --><!-- basicblock-start oid="ObsuQtl7k0szWEO5xa12fv3h" --> <p><a href="https://www.bilibili.com/video/BV1N64y1s7fw/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=335.373534">05:35</a><br>使环境变量中的命令变得长期生效, 如果不配置的话, 关机后再开机还要运行一遍: source .bash_profile<br>::<br>配置 .zshrc 文件<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210051713212.png" alt=""></p><blockquote><p>[!bug] 发现 添加这条命令后, 终端的命令用不了了, 我还是删了</p></blockquote><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsoljPDRz9JABikOh9QF4Es" deck = "👨🏻‍💻code::MySQL::基础篇::MySQL 安装与配置.md" --> <p>#历史记录::<br>2022/10/5🌵MySQL 安装与配置 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/11/"/>
    <url>/posts/11/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础篇"><a class="markdownIt-Anchor" href="#1-基础篇"></a> 1 基础篇</h1><h2 id="11-函数"><a class="markdownIt-Anchor" href="#11-函数"></a> 1.1 函数</h2><h2 id="12-约束"><a class="markdownIt-Anchor" href="#12-约束"></a> 1.2 约束</h2><h3 id="121-外键约束"><a class="markdownIt-Anchor" href="#121-外键约束"></a> 1.2.1 外键约束</h3><h4 id="1211-删除更新行为"><a class="markdownIt-Anchor" href="#1211-删除更新行为"></a> 1.2.1.1 删除/更新行为</h4><h2 id="13-多表查询"><a class="markdownIt-Anchor" href="#13-多表查询"></a> 1.3 多表查询</h2><h3 id="131-多表关系"><a class="markdownIt-Anchor" href="#131-多表关系"></a> 1.3.1 多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="1311-一对多"><a class="markdownIt-Anchor" href="#1311-一对多"></a> 1.3.1.1 一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="1312-多对多"><a class="markdownIt-Anchor" href="#1312-多对多"></a> 1.3.1.2 多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="1313-一对一"><a class="markdownIt-Anchor" href="#1313-一对一"></a> 1.3.1.3 一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="132-查询"><a class="markdownIt-Anchor" href="#132-查询"></a> 1.3.2 查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="133-内连接查询"><a class="markdownIt-Anchor" href="#133-内连接查询"></a> 1.3.3 内连接查询</h3><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工姓名，及关联的部门的名称<br>-- 隐式<br>select e.name, d.name from employee as e, dept as d where e.dept = d.id;<br>-- 显式<br>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="134-外连接查询"><a class="markdownIt-Anchor" href="#134-外连接查询"></a> 1.3.4 外连接查询</h3><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>相当于查询表1的所有数据，包含表1和表2交集部分数据</p><p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 左<br>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;<br>select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样<br>-- 右<br>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;<br></code></pre></td></tr></tbody></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="135-自连接查询"><a class="markdownIt-Anchor" href="#135-自连接查询"></a> 1.3.5 自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工及其所属领导的名字<br>select a.name, b.name from employee a, employee b where a.manager = b.id;<br>-- 没有领导的也查询出来<br>select a.name, b.name from employee a left join employee b on a.manager = b.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="136-联合查询-union-union-all"><a class="markdownIt-Anchor" href="#136-联合查询-union-union-all"></a> 1.3.6 联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表A ...<br>UNION [ALL]<br>SELECT 字段列表 FROM 表B ...<br></code></pre></td></tr></tbody></table></figure><h4 id="1361-注意事项"><a class="markdownIt-Anchor" href="#1361-注意事项"></a> 1.3.6.1 注意事项</h4><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul><h3 id="137-子查询"><a class="markdownIt-Anchor" href="#137-子查询"></a> 1.3.7 子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="1371-标量子查询"><a class="markdownIt-Anchor" href="#1371-标量子查询"></a> 1.3.7.1 标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;=</p><p>例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部所有员工<br>select id from dept where name = '销售部';<br>-- 根据销售部部门ID，查询员工信息<br>select * from employee where dept = 4;<br>-- 合并（子查询）<br>select * from employee where dept = (select id from dept where name = '销售部');<br><br>-- 查询xxx入职之后的员工信息<br>select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx');<br></code></pre></td></tr></tbody></table></figure><h4 id="1372-列子查询"><a class="markdownIt-Anchor" href="#1372-列子查询"></a> 1.3.7.2 列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><p>例子：</p><h4 id="1373"><a class="markdownIt-Anchor" href="#1373"></a> 1.3.7.3</h4><h2 id="14-事务"><a class="markdownIt-Anchor" href="#14-事务"></a> 1.4 事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1. 查询张三账户余额<br>select * from account where name = '张三';<br>-- 2. 将张三账户余额-1000<br>update account set money = money - 1000 where name = '张三';<br>-- 此语句出错后张三钱减少但是李四钱没有增加<br>模拟sql语句错误<br>-- 3. 将李四账户余额+1000<br>update account set money = money + 1000 where name = '李四';<br><br>-- 查看事务提交方式<br>SELECT @@AUTOCOMMIT;<br>-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效<br>SET @@AUTOCOMMIT = 0;<br>-- 提交事务<br>COMMIT;<br>-- 回滚事务<br>ROLLBACK;<br><br>-- 设置手动提交后上面代码改为：<br>select * from account where name = '张三';<br>update account set money = money - 1000 where name = '张三';<br>update account set money = money + 1000 where name = '李四';<br>commit;<br></code></pre></td></tr></tbody></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction;<br>select * from account where name = '张三';<br>update account set money = money - 1000 where name = '张三';<br>update account set money = money + 1000 where name = '李四';<br>commit;<br></code></pre></td></tr></tbody></table></figure><h3 id="141-四大特性acid"><a class="markdownIt-Anchor" href="#141-四大特性acid"></a> 1.4.1 四大特性ACID</h3><p>^ac7aff</p><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="142-并发事务"><a class="markdownIt-Anchor" href="#142-并发事务"></a> 1.4.2 并发事务</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a></p></blockquote><p>并发事务隔离级别：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="2-进阶篇"><a class="markdownIt-Anchor" href="#2-进阶篇"></a> 2 进阶篇</h1><h2 id="21-存储引擎"><a class="markdownIt-Anchor" href="#21-存储引擎"></a> 2.1 存储引擎</h2><p>MySQL体系结构：</p><h2 id="22-性能分析"><a class="markdownIt-Anchor" href="#22-性能分析"></a> 2.2 性能分析</h2><h3 id="221-查看执行频次"><a class="markdownIt-Anchor" href="#221-查看执行频次"></a> 2.2.1 查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE 'Com_______';</code> 或者 <code>SHOW SESSION STATUS LIKE 'Com_______';</code><br>例：<code>show global status like 'Com_______'</code></p><h3 id="222-慢查询日志"><a class="markdownIt-Anchor" href="#222-慢查询日志"></a> 2.2.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：<br># 开启慢查询日志开关<br>slow_query_log=1<br># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>long_query_time=2<br>更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like 'slow_query_log';</code></p><h3 id="223-profile"><a class="markdownIt-Anchor" href="#223-profile"></a> 2.2.3 profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="224-explain"><a class="markdownIt-Anchor" href="#224-explain"></a> 2.2.4 explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br># 直接在select语句之前加上关键字 explain / desc<br>EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><h2 id="23-索引"><a class="markdownIt-Anchor" href="#23-索引"></a> 2.3 索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="231-索引结构"><a class="markdownIt-Anchor" href="#231-索引结构"></a> 2.3.1 索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2311-b-tree"><a class="markdownIt-Anchor" href="#2311-b-tree"></a> 2.3.1.1 B-Tree</h4><p><img src="https://dhc.pythonanywhere.com/media/editor/%E4%BA%8C%E5%8F%89%E6%A0%91_20220316153214227108.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BA%A2%E9%BB%91%E6%A0%91_20220316163142686602.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B-Tree%E7%BB%93%E6%9E%84_20220316163813441163.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="2312-btree"><a class="markdownIt-Anchor" href="#2312-btree"></a> 2.3.1.2 B+Tree</h4><p>结构图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE_20220316170700591277.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E7%BB%93%E6%9E%84%E5%9B%BE_20220316171730865611.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="2313-hash"><a class="markdownIt-Anchor" href="#2313-hash"></a> 2.3.1.3 Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dhc.pythonanywhere.com/media/editor/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE_20220317143226150679.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="2314-面试题"><a class="markdownIt-Anchor" href="#2314-面试题"></a> 2.3.1.4 面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="232-索引分类"><a class="markdownIt-Anchor" href="#232-索引分类"></a> 2.3.2 索引分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dhc.pythonanywhere.com/media/editor/%E5%8E%9F%E7%90%86%E5%9B%BE_20220318194454880073.png" alt="大致原理" title="大致原理"><br><img src="https://dhc.pythonanywhere.com/media/editor/%E6%BC%94%E7%A4%BA%E5%9B%BE_20220319215403721066.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="2321-思考题"><a class="markdownIt-Anchor" href="#2321-思考题"></a> 2.3.2.1 思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 10;<br>select * from user where name = 'Arm';<br>-- 备注：id为主键，name字段创建的有索引<br></code></pre></td></tr></tbody></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="233-语法"><a class="markdownIt-Anchor" href="#233-语法"></a> 2.3.3 语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>-- 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br>-- 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br><br>-- 删除索引<br>drop index idx_user_email on tb_user;<br></code></pre></td></tr></tbody></table></figure><h3 id="234-使用规则"><a class="markdownIt-Anchor" href="#234-使用规则"></a> 2.3.4 使用规则</h3><h4 id="2341-最左前缀法则"><a class="markdownIt-Anchor" href="#2341-最左前缀法则"></a> 2.3.4.1 最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。</p><h4 id="2342-索引失效情况"><a class="markdownIt-Anchor" href="#2342-索引失效情况"></a> 2.3.4.2 索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = '15';</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like '%工程';</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="2343-sql-提示"><a class="markdownIt-Anchor" href="#2343-sql-提示"></a> 2.3.4.3 SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession="软件工程";</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession="软件工程";</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession="软件工程";</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="2344-覆盖索引回表查询"><a class="markdownIt-Anchor" href="#2344-覆盖索引回表查询"></a> 2.3.4.4 覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name='xxx';</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name='xxx';</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username='itcast';</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="2345-前缀索引"><a class="markdownIt-Anchor" href="#2345-前缀索引"></a> 2.3.4.5 前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(distinct email) / count(*) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;<br></code></pre></td></tr></tbody></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="2346-单列索引联合索引"><a class="markdownIt-Anchor" href="#2346-单列索引联合索引"></a> 2.3.4.6 单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';</code><br>这句只会用到phone索引字段</p><h5 id="23461-注意事项"><a class="markdownIt-Anchor" href="#23461-注意事项"></a> 2.3.4.6.1 注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="235-设计原则"><a class="markdownIt-Anchor" href="#235-设计原则"></a> 2.3.5 设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="24-sql-优化"><a class="markdownIt-Anchor" href="#24-sql-优化"></a> 2.4 SQL 优化</h2><h3 id="241-插入数据"><a class="markdownIt-Anchor" href="#241-插入数据"></a> 2.4.1 插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）<br>mysql --local-infile -u root -p<br># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>select @@local_infile;<br># 执行load指令将准备好的数据，加载到表结构中<br>load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\n';<br></code></pre></td></tr></tbody></table></figure><h3 id="242-主键优化"><a class="markdownIt-Anchor" href="#242-主键优化"></a> 2.4.2 主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="243-order-by优化"><a class="markdownIt-Anchor" href="#243-order-by优化"></a> 2.4.3 order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="244-group-by优化"><a class="markdownIt-Anchor" href="#244-group-by优化"></a> 2.4.4 group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="245-limit优化"><a class="markdownIt-Anchor" href="#245-limit优化"></a> 2.4.5 limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 此语句耗时很长<br>select * from tb_sku limit 9000000, 10;<br>-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询<br>select id from tb_sku order by id limit 9000000, 10;<br>-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit<br>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);<br>-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度<br>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;<br></code></pre></td></tr></tbody></table></figure><h3 id="246-count优化"><a class="markdownIt-Anchor" href="#246-count优化"></a> 2.4.6 count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="247-update优化避免行锁升级为表锁"><a class="markdownIt-Anchor" href="#247-update优化避免行锁升级为表锁"></a> 2.4.7 update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = '123' where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = '123' where name = 'test';</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p><h1 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型"></a> 3 数据类型</h1><h2 id="31-整型"><a class="markdownIt-Anchor" href="#31-整型"></a> 3.1 整型</h2><table><thead><tr><th>类型名称</th><th>取值范围</th><th>大小</th></tr></thead><tbody><tr><td>TINYINT</td><td>-128〜127</td><td>1个字节</td></tr><tr><td>SMALLINT</td><td>-32768〜32767</td><td>2个宇节</td></tr><tr><td>MEDIUMINT</td><td>-8388608〜8388607</td><td>3个字节</td></tr><tr><td>INT (INTEGHR)</td><td>-2147483648〜2147483647</td><td>4个字节</td></tr><tr><td>BIGINT</td><td>-9223372036854775808〜9223372036854775807</td><td>8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="32-浮点型"><a class="markdownIt-Anchor" href="#32-浮点型"></a> 3.2 浮点型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>FLOAT</td><td>单精度浮点数</td><td>4 个字节</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>8 个字节</td></tr><tr><td>DECIMAL (M, D)，DEC</td><td>压缩的“严格”定点数</td><td>M+2 个字节</td></tr></tbody></table><h2 id="33-日期和时间"><a class="markdownIt-Anchor" href="#33-日期和时间"></a> 3.3 日期和时间</h2><table><thead><tr><th>类型名称</th><th>日期格式</th><th>日期范围</th><th>存储需求</th></tr></thead><tbody><tr><td>YEAR</td><td>YYYY</td><td>1901 ~ 2155</td><td>1 个字节</td></tr><tr><td>TIME</td><td>HH:MM:SS</td><td>-838:59:59 ~ 838:59:59</td><td>3 个字节</td></tr><tr><td>DATE</td><td>YYYY-MM-DD</td><td>1000-01-01 ~ 9999-12-3</td><td>3 个字节</td></tr><tr><td>DATETIME</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td>8 个字节</td></tr><tr><td>TIMESTAMP</td><td>YYYY-MM-DD HH:MM:SS</td><td>1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td>4 个字节</td></tr></tbody></table><h2 id="34-字符串"><a class="markdownIt-Anchor" href="#34-字符串"></a> 3.4 字符串</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度非二进制字符串</td><td>M 字节，1&lt;=M&lt;=255</td></tr><tr><td>VARCHAR(M)</td><td>变长非二进制字符串</td><td>L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255</td></tr><tr><td>TINYTEXT</td><td>非常小的非二进制字符串</td><td>L+1字节，在此，L&lt;2^8</td></tr><tr><td>TEXT</td><td>小的非二进制字符串</td><td>L+2字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMTEXT</td><td>中等大小的非二进制字符串</td><td>L+3字节，在此，L&lt;2^24</td></tr><tr><td>LONGTEXT</td><td>大的非二进制字符串</td><td>L+4字节，在此，L&lt;2^32</td></tr><tr><td>ENUM</td><td>枚举类型，只能有一个枚举字符串值</td><td>1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td>SET</td><td>一个设置，字符串对象可以有零个或 多个SET成员</td><td>1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="35-二进制类型"><a class="markdownIt-Anchor" href="#35-二进制类型"></a> 3.5 二进制类型</h2><table><thead><tr><th>类型名称</th><th>说明</th><th>存储需求</th></tr></thead><tbody><tr><td>BIT(M)</td><td>位字段类型</td><td>大约 (M+7)/8 字节</td></tr><tr><td>BINARY(M)</td><td>固定长度二进制字符串</td><td>M 字节</td></tr><tr><td>VARBINARY (M)</td><td>可变长度二进制字符串</td><td>M+1 字节</td></tr><tr><td>TINYBLOB (M)</td><td>非常小的BLOB</td><td>L+1 字节，在此，L&lt;2^8</td></tr><tr><td>BLOB (M)</td><td>小 BLOB</td><td>L+2 字节，在此，L&lt;2^16</td></tr><tr><td>MEDIUMBLOB (M)</td><td>中等大小的BLOB</td><td>L+3 字节，在此，L&lt;2^24</td></tr><tr><td>LONGBLOB (M)</td><td>非常大的BLOB</td><td>L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="4-权限一览表"><a class="markdownIt-Anchor" href="#4-权限一览表"></a> 4 权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Grant Table Column</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td style="text-align:left">Synonym for “all privileges”</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td style="text-align:left"><code>Alter_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td style="text-align:left"><code>Alter_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td style="text-align:left"><code>Create_priv</code></td><td style="text-align:left">Databases, tables, or indexes</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td style="text-align:left"><code>Create_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td style="text-align:left"><code>Create_routine_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td style="text-align:left"><code>Create_tablespace_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td style="text-align:left"><code>Create_tmp_table_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td style="text-align:left"><code>Create_user_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td style="text-align:left"><code>Create_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td style="text-align:left"><code>Delete_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td style="text-align:left"><code>Drop_priv</code></td><td style="text-align:left">Databases, tables, or views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td style="text-align:left"><code>Drop_role_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td style="text-align:left"><code>Event_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td style="text-align:left"><code>Execute_priv</code></td><td style="text-align:left">Stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td style="text-align:left"><code>File_priv</code></td><td style="text-align:left">File access on server host</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td style="text-align:left"><code>Grant_priv</code></td><td style="text-align:left">Databases, tables, or stored routines</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td style="text-align:left"><code>Index_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td style="text-align:left"><code>Insert_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td style="text-align:left"><code>Lock_tables_priv</code></td><td style="text-align:left">Databases</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td style="text-align:left"><code>Process_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td style="text-align:left">See <code>proxies_priv</code> table</td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td style="text-align:left"><code>References_priv</code></td><td style="text-align:left">Databases or tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td style="text-align:left"><code>Reload_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td style="text-align:left"><code>Repl_client_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td style="text-align:left"><code>Repl_slave_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td style="text-align:left"><code>Select_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td style="text-align:left"><code>Show_db_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td style="text-align:left"><code>Show_view_priv</code></td><td style="text-align:left">Views</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td style="text-align:left"><code>Shutdown_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td style="text-align:left"><code>Super_priv</code></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td style="text-align:left"><code>Trigger_priv</code></td><td style="text-align:left">Tables</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td style="text-align:left"><code>Update_priv</code></td><td style="text-align:left">Tables or columns</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td style="text-align:left">Synonym for “no privileges”</td><td style="text-align:left">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th style="text-align:left">Privilege</th><th style="text-align:left">Context</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td style="text-align:left">Dual password administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td style="text-align:left">Allow queries blocked by audit log filter</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td style="text-align:left">Audit log administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td style="text-align:left">Backup administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Backup and Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td style="text-align:left">Clone administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td style="text-align:left">Firewall administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td style="text-align:left">Redo log archiving administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td style="text-align:left">NDB Cluster</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td style="text-align:left">Authentication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td style="text-align:left"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td style="text-align:left">Replication administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td style="text-align:left">Resource group administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr><tr><td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td style="text-align:left">Server administration</td></tr></tbody></table><h1 id="5-图形化界面工具"><a class="markdownIt-Anchor" href="#5-图形化界面工具"></a> 5 图形化界面工具</h1><ul><li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h1 id="6-安装"><a class="markdownIt-Anchor" href="#6-安装"></a> 6 安装</h1><h1 id="7-小技巧"><a class="markdownIt-Anchor" href="#7-小技巧"></a> 7 小技巧</h1><ol><li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table_schema "Database Name"<br>     , SUM(data_length + index_length) / (1024 * 1024) "Database Size in MB"<br>FROM information_schema.TABLES<br>GROUP BY table_schema;<br></code></pre></td></tr></tbody></table></figure><h1 id="8-后续内容"><a class="markdownIt-Anchor" href="#8-后续内容"></a> 8 后续内容</h1><p>后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。<br>目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。<br><strong>在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力</strong><br><strong><a href="https://github.com/Buildings-Lei/mysql_note/blob/main/README.md">https://github.com/Buildings-Lei/mysql_note/blob/main/README.md</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>MySQL</category>
      
      <category>基础篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23 种设计模式的概念</title>
    <link href="/posts/33665/"/>
    <url>/posts/33665/</url>
    
    <content type="html"><![CDATA[<h1 id="1-创建型模式"><a class="markdownIt-Anchor" href="#1-创建型模式"></a> 1 创建型模式::</h1><!-- basicblock-end --><h2 id="11-工厂方法factory-method模式工厂方法模式"><a class="markdownIt-Anchor" href="#11-工厂方法factory-method模式工厂方法模式"></a> 1.1 工厂方法(factory method)模式：[[工厂方法模式]]</h2><p>定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟</p><h2 id="12-抽象工厂abstract-factory模式抽象工厂模式"><a class="markdownIt-Anchor" href="#12-抽象工厂abstract-factory模式抽象工厂模式"></a> 1.2 抽象工厂(abstract factory)模式：[[抽象工厂模式]]</h2><p>提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定他们具体的类</p><h2 id="13-原型prototype模式"><a class="markdownIt-Anchor" href="#13-原型prototype模式"></a> 1.3 原型(prototype)模式：</h2><p>用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象</p><h2 id="14-单例singleton模式单例模式"><a class="markdownIt-Anchor" href="#14-单例singleton模式单例模式"></a> 1.4 单例(singleton)模式：[[单例模式]]</h2><p>保证一个类只有一个实例，并提供一个访问它的全局访问点</p><h2 id="15-构建器builder模式"><a class="markdownIt-Anchor" href="#15-构建器builder模式"></a> 1.5 构建器(builder)模式：</h2><p>将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示</p><!-- basicblock-start oid="ObsKWo536mEWs62dfYTTMUIw" --> <h1 id="2-结构型模式"><a class="markdownIt-Anchor" href="#2-结构型模式"></a> 2 结构型模式::</h1><p><strong>让类和类进行组合，获得更大的结构。</strong></p><!-- basicblock-end --><h2 id="21-适配器adapter模式适配器模式"><a class="markdownIt-Anchor" href="#21-适配器adapter模式适配器模式"></a> 2.1 适配器(adapter)模式：[[适配器模式]]</h2><p>将一个类的接口转换成用户希望得到的另一个接口。它使原本不相容的接口得以协同工作—一速记关键字：<strong>转换接口</strong></p><h2 id="22-桥接bridge模式"><a class="markdownIt-Anchor" href="#22-桥接bridge模式"></a> 2.2 桥接(bridge)模式：</h2><p>将类的抽象部分和它的实现部分分离开来，使它们可以独立地变化一一速记关键字：<strong>继承树拆分</strong></p><h2 id="23-组合composite模式"><a class="markdownIt-Anchor" href="#23-组合composite模式"></a> 2.3 组合(composite)模式：</h2><p>将对象组合成树型结构以表示"整体-部分" 的层次结构，使得用户对单个对象和组合对象的使用具有一致性一一速记关键字：<strong>树形目录结构</strong></p><h2 id="24-装饰decorator模式装饰模式"><a class="markdownIt-Anchor" href="#24-装饰decorator模式装饰模式"></a> 2.4 装饰(decorator)模式：[[装饰模式]]</h2><p>动态地给一个对象添加一些额外的职责。它提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活一一速记关键字：<strong>附加职责</strong><br>给英雄穿衣服</p><h2 id="25-外观facade模式外观模式"><a class="markdownIt-Anchor" href="#25-外观facade模式外观模式"></a> 2.5 外观(facade)模式：[[外观模式]]</h2><p>定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用一一速记关键字：<strong>对外统一接口</strong></p><h2 id="26-享元flyweight模式"><a class="markdownIt-Anchor" href="#26-享元flyweight模式"></a> 2.6 享元(flyweight)模式：</h2><p>提供支持大量细粒度对象共享的有效方法</p><h2 id="27-代理proxy模式代理模式"><a class="markdownIt-Anchor" href="#27-代理proxy模式代理模式"></a> 2.7 代理(proxy)模式：[[代理模式]]</h2><p>为其他对象提供一种代理以控制这个对象的访问</p><!-- basicblock-start oid="Obsi4OYJSSfluYBmiXxIJ5us" --> <h1 id="3-行为型模式"><a class="markdownIt-Anchor" href="#3-行为型模式"></a> 3 行为型模式::</h1><p><strong>用来对类或对象怎样交互和怎样分配职责进行描述。</strong></p><!-- basicblock-end --><h2 id="31-职责链chain-of-responsibility模式"><a class="markdownIt-Anchor" href="#31-职责链chain-of-responsibility模式"></a> 3.1 职责链(chain of responsibility)模式：</h2><p>通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链接起来，在链中传递请<br>求，直到有一个对象处理这个请求一一<strong>速记关键字：传递职责</strong></p><h2 id="32-命令command模式命令模式"><a class="markdownIt-Anchor" href="#32-命令command模式命令模式"></a> 3.2 命令(command)模式：[[命令模式]]</h2><p>将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的<br>操作一一速记关键字：<strong>日志记录，可撤销</strong></p><h2 id="33-解释器interpreter模式"><a class="markdownIt-Anchor" href="#33-解释器interpreter模式"></a> 3.3 解释器(interpreter)模式：</h2><p>给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</p><h2 id="34-迭代器iterator模式"><a class="markdownIt-Anchor" href="#34-迭代器iterator模式"></a> 3.4 迭代器(iterator)模式：</h2><p>提供一种方法来顺序访问一个聚合对象中的各个元素而不需要暴露该对象的内部表示</p><h2 id="35-中介者mediator模式"><a class="markdownIt-Anchor" href="#35-中介者mediator模式"></a> 3.5 中介者(mediator)模式：</h2><p>用一个中介对象来封装一系列的对象交互。它使各对象不需要显式地相互调用，从而达到低耦合，还可以独立地改<br>变对象间的交互一一速记关键字：<strong>不直接引用</strong></p><h2 id="36-备忘录memento模式"><a class="markdownIt-Anchor" href="#36-备忘录memento模式"></a> 3.6 备忘录(memento)模式：</h2><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可用在以后将该对象恢复到原先保存的状态</p><h2 id="37-观察者observer模式观察者模式"><a class="markdownIt-Anchor" href="#37-观察者observer模式观察者模式"></a> 3.7 观察者(observer)模式：[[观察者模式]]</h2><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新<br>红绿灯</p><h2 id="38-状态state模式"><a class="markdownIt-Anchor" href="#38-状态state模式"></a> 3.8 状态(state)模式：</h2><p>允许一个对象在其内部状态改变时改变它的行为—一速记关键字：状态变成类</p><h2 id="39-策略strategy模式策略模式"><a class="markdownIt-Anchor" href="#39-策略strategy模式策略模式"></a> 3.9 策略(strategy)模式：[[策略模式]]</h2><p>定义一系列算法，把它们一个个封装起来，并且使它们之间可互相替换，从而让算法可以独立于使用它的用户而变化</p><h2 id="310-模板方法template-method模式模板方法模式"><a class="markdownIt-Anchor" href="#310-模板方法template-method模式模板方法模式"></a> 3.10 模板方法(template method)模式：[[模板方法模式]]</h2><p>定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤</p><h2 id="311-访问者visitor模式"><a class="markdownIt-Anchor" href="#311-访问者visitor模式"></a> 3.11 访问者(visitor)模式：</h2><p>‌‌‌表示一个作用于某对象结构中的各元素的操作，使得在不改变各元素的类的前提下定义作用于这些元素的新操作</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsQ6vFJBCtQkl42MCnlF6AL" --> <p>#历史记录:: <a href="marginnote3app://note/BACBD414-669E-47DC-AE8C-336DEA8B6050">margin: 23种设计模式的概念</a><br>2022/10/4🌵23 种设计模式的概念 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工厂模式</title>
    <link href="/posts/6014/"/>
    <url>/posts/6014/</url>
    
    <content type="html"><![CDATA[<h1 id="1-工厂模式"><a class="markdownIt-Anchor" href="#1-工厂模式"></a> 1 工厂模式::</h1><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。<br>[[简单工厂模式]]<br>[[抽象工厂模式]]<br>[[工厂方法模式]]</p><p>不过，在GoF的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsg1TSG5zausg0cjBJykwg3" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::工厂模式.md" --> <p>#历史记录::<br>2022/10/4🌵工厂模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>创建型模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式的类别</title>
    <link href="/posts/51386/"/>
    <url>/posts/51386/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!summary] 单例模式的特点：<br>单例类只有一个实例对象<br>该单例对象必须由单例类自行创建<br>单例类对外提供一个访问该单例的全局访问点</p></blockquote><p>创建步骤:</p><ol><li>构造方法私有, 避免外部随便 new</li><li>定义私有的静态单例对象</li><li>对外提供一个访问单例对象的全局访问点<br>重点是单例对象是怎么创建的</li></ol><!-- basicblock-start oid="ObsSYsFf2je5c3qMeVyD8CfH" --> <h1 id="1-懒汉式"><a class="markdownIt-Anchor" href="#1-懒汉式"></a> 1 懒汉式::</h1><!-- basicblock-end --><p>![[懒汉式.excalidraw|1200]]</p><h2 id="11-线程不安全"><a class="markdownIt-Anchor" href="#11-线程不安全"></a> 1.1 线程不安全</h2><p><strong>优点</strong>： 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。<br><strong>需要时才创建</strong></p><p><strong>缺点：</strong><br>线程不安全，多线程环境下，如果多个线程同时进入了<code>if(uniquelnstance == nul)</code>,<br>若此时还未实例化，也就是<code>uniquelnstance==null</code>,那么就会有多个线程执行<code>uniquelnstance=new Singleton();</code>,就会实例化多个实例；此时就不是单例模式了</p><h2 id="12-线程安全"><a class="markdownIt-Anchor" href="#12-线程安全"></a> 1.2 线程安全</h2><p>优点： 延迟实例化，节约了资源，并且是线程安全的。</p><p>缺点： 性能降低了, 实例已经实例化，依然每次都会有锁, 每次只能拿到锁的线程进入该方法, **使线程阻塞，等待时间过长。</p><h2 id="13-双重检查锁实现线程安全"><a class="markdownIt-Anchor" href="#13-双重检查锁实现线程安全"></a> 1.3 双重检查锁实现（线程安全）</h2><p>![[双重检查锁实现（线程安全）.excalidraw|1500]]</p><p>优点： 延迟实例化，节约了资源；线程安全；并且相对于线程安全的懒汉式，性能提高了。<br>缺点： volatile关键字，对性能也有一些影响。</p><!-- basicblock-start oid="Obs8gNBKJObBARZqzMYgfTub" --> <h1 id="2-饿汉式线程安全"><a class="markdownIt-Anchor" href="#2-饿汉式线程安全"></a> 2 饿汉式(线程安全)::</h1><!-- basicblock-end --><p><strong>(直接创建，理解为main执行前，就创建好了)</strong></p><p>![[饿 汉式.02.excalidraw|1200]]</p><p>优点： 提起实例化好了一个实例，避免了线程不安全问题的出现，</p><p>缺点：</p><ul><li>直接实例化了实例，不再延迟实例化；</li></ul><ul><li>若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，<strong>都会使操作系统的资源浪费。</strong></li></ul><blockquote><p>[!example]<br>这种方式导致的问题就像你下载个游戏软件，可能你游戏地图还没有打开呢，但是程序已经将这些地图全部实例化。<br>到你手机上最明显体验就一开游戏内存满了，手机卡了，需要换了。</p></blockquote><!-- basicblock-start oid="ObsSygJ8Gefm1ic4Z2atOcij" --> <h1 id="3-静态内部类实现线程安全"><a class="markdownIt-Anchor" href="#3-静态内部类实现线程安全"></a> 3 静态内部类实现（线程安全）::</h1><p>[[static 关键字]] ^ougi2n</p><!-- basicblock-end --><p>![[静态内部类实现（线程安全）.excalidraw|1000]]</p><!-- basicblock-start oid="ObsEYuFkVke6paJdREdPRUCU" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::单例模式的类别.md"--><h1 id="4-枚举类实现线程安全-不懂"><a class="markdownIt-Anchor" href="#4-枚举类实现线程安全-不懂"></a> 4 枚举类实现（线程安全):: 不懂</h1><!-- basicblock-end --><p>![[枚举类实现（线程安全).excalidraw]]</p><p>优点： 写法简单，线程安全，天然防止反射和反序列化调用。防止反序列化</p><blockquote><p>序列化： 把java对象转换为字节序列的过程；<br>反序列化： 通过这些字节序列在内存中新建java对象的过程；</p></blockquote><p>说明：<br>反序列化将一个单例实例对象写到磁盘再读回来，从而获得了一个新的实例。<br>我们要防止反序列化，避免得到多个实例，枚举类天然防止反序列化。<br>其他单例模式可以通过重写readResolve()方法，从而防止反序列化，使实例唯一重写</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210041606500.png" alt="|800"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs55CGtGg3QXrFKt66EazYc"  --> <p>#历史记录:: <a href="marginnote3app://note/0188497B-BEF3-46C4-8B7E-56873D2DB0D9">margin : 单例模型6种实现及各实现的优缺点</a><br>2022/10/4🌵单例模式的类别 : 第一次创建</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1344y1g7CL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">单例模式之静态内部类方式_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>创建型模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>装饰模式</title>
    <link href="/posts/14040/"/>
    <url>/posts/14040/</url>
    
    <content type="html"><![CDATA[<h1 id="1-装饰模式的理论"><a class="markdownIt-Anchor" href="#1-装饰模式的理论"></a> 1 装饰模式的理论::</h1><!-- basicblock-end --><blockquote><p>[!summary] 定义: 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<br>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。</p></blockquote><blockquote><p>[!tip] 什么时候用:<br>装饰模式就是把要附加的功能分别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择的、按顺序的使用装饰功能包装对象。</p></blockquote><p><a href="marginnote3app://note/F16ED398-5E2B-41C1-9410-41BA1ACA0301">margin: 装饰模式结构图</a>: 我感觉不用看这个, 看懂最下边的案例就行<br>![[装饰模式 2022-10-04 21.54.22.excalidraw]]</p><!-- basicblock-start oid="ObsFYjtkPH0qFp3VXZuFqZbR" --> <h1 id="2-装饰模式的案例"><a class="markdownIt-Anchor" href="#2-装饰模式的案例"></a> 2 装饰模式的案例::</h1><!-- basicblock-end --><p>给一个英雄穿上各种衣服(装备), 以增加各种属性</p><p><img src="https://img-blog.csdnimg.cn/fbd2e070adea42f8b43e60b19c4f5a71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//一般情况下，用继承实现类的功能拓展</span><br><span class="hljs-comment">//装饰模式 可以动态给一个类增加功能</span><br><br><span class="hljs-comment">//抽象英雄</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHero</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mHp;<br><span class="hljs-type">int</span> mMp;<br><span class="hljs-type">int</span> mAt;<span class="hljs-comment">// 攻击力</span><br><span class="hljs-type">int</span> mDf;<span class="hljs-comment">// 防御力</span><br>};<br><br><span class="hljs-comment">//具体英雄</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroA</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroA</span>() {<br>mHp = <span class="hljs-number">0</span>;<br>mMp = <span class="hljs-number">0</span>;<br>mAt = <span class="hljs-number">0</span>;<br>mDf = <span class="hljs-number">0</span>;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"血量："</span> &lt;&lt; mHp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"魔法："</span> &lt;&lt; mMp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"攻击："</span> &lt;&lt; mAt &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"防御："</span> &lt;&lt; mDf &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//英雄穿上某个装饰物 那么他还是个英雄</span><br><span class="hljs-comment">//装饰物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractEquipmet</span> : <span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AbstractEquipmet</span>(AbstractHero* hero) {<br><span class="hljs-keyword">this</span>-&gt;pHero = hero; <span class="hljs-comment">// 继承之前的属性</span><br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>AbstractHero* pHero;<br><br>};<br><br><span class="hljs-comment">//狂徒</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KuangtuEquipment</span> :<span class="hljs-keyword">public</span> AbstractEquipmet {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">KuangtuEquipment</span>(AbstractHero* hero) :<span class="hljs-built_in">AbstractEquipmet</span>(hero) {} <span class="hljs-comment">// ❓应该是继承之前的属性吧</span><br><span class="hljs-comment">//增加额外的功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddKuangtu</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄穿上狂徒之后..."</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;mHp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mHp;<br><span class="hljs-keyword">this</span>-&gt;mMp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mMp;<br><span class="hljs-keyword">this</span>-&gt;mAt = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mAt;<br><span class="hljs-keyword">this</span>-&gt;mDf = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mDf + <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;pHero;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">AddKuangtu</span>();<br>cout &lt;&lt; <span class="hljs-string">"血量："</span> &lt;&lt; mHp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"魔法："</span> &lt;&lt; mMp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"攻击："</span> &lt;&lt; mAt &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"防御："</span> &lt;&lt; mDf &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//无尽</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wujing</span> : <span class="hljs-keyword">public</span> AbstractEquipmet {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Wujing</span>(AbstractHero* hero) :<span class="hljs-built_in">AbstractEquipmet</span>(hero) {}<br><span class="hljs-comment">//增加额外的功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddWujing</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄穿上无尽之后..."</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;mHp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mHp;<br><span class="hljs-keyword">this</span>-&gt;mMp = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mMp;<br><span class="hljs-keyword">this</span>-&gt;mAt = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mAt + <span class="hljs-number">80</span>;<br><span class="hljs-keyword">this</span>-&gt;mDf = <span class="hljs-keyword">this</span>-&gt;pHero-&gt;mDf;<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;pHero;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowStatus</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">AddWujing</span>();<br>cout &lt;&lt; <span class="hljs-string">"血量："</span> &lt;&lt; mHp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"魔法："</span> &lt;&lt; mMp &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"攻击："</span> &lt;&lt; mAt &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">"防御："</span> &lt;&lt; mDf &lt;&lt; endl;<br>}<br>};<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>AbstractHero* hero = <span class="hljs-keyword">new</span> HeroA;<br>hero-&gt;<span class="hljs-built_in">ShowStatus</span>();<br>cout &lt;&lt; <span class="hljs-string">"----------------------------"</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//给裸奔的英雄穿上衣服后</span><br>hero = <span class="hljs-keyword">new</span> <span class="hljs-built_in">KuangtuEquipment</span>(hero);<br>hero-&gt;<span class="hljs-built_in">ShowStatus</span>();<br><br>cout &lt;&lt; <span class="hljs-string">"----------------------------"</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//装备武器</span><br>hero = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Wujing</span>(hero);<br>hero-&gt;<span class="hljs-built_in">ShowStatus</span>();<br><br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/f27bb61be3924b958509187cb02c9442.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><!-- basicblock-start oid="Obs9XzwL64CuPFabz88Ayxfm" --> <h1 id="3-装饰模式的优缺点"><a class="markdownIt-Anchor" href="#3-装饰模式的优缺点"></a> 3 装饰模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1)对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</p><p>(2)可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。</p><p>(3)可以对一个对象进行多次装饰。</p><p>(4)具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</p><p><strong>缺点：</strong></p><p>使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。</p><!-- basicblock-start oid="ObsysPFc7oqSZNfC01E2tz7l" --> <h1 id="4-装饰模式的适用场景"><a class="markdownIt-Anchor" href="#4-装饰模式的适用场景"></a> 4 装饰模式的适用场景::</h1><!-- basicblock-end --><p>(1) 动态、透明的方式给单个对象添加职责。</p><p>(2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。</p><p>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObswmkOaFSGS0t3Vq594ZSmF" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::结构型模式::装饰模式.md" --> <p>#历史记录::<br>2022/10/4🌵装饰模式 : 第一次创建</p><!-- basicblock-end --><p><a href="marginnote3app://note/8B983839-DEFA-4C02-933D-D7C97AFE5A8F">margin: 装饰模式</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式</title>
    <link href="/posts/7741/"/>
    <url>/posts/7741/</url>
    
    <content type="html"><![CDATA[<h1 id="1-观察者模式的理论"><a class="markdownIt-Anchor" href="#1-观察者模式的理论"></a> 1 观察者模式的理论::</h1><!-- basicblock-end --><p>它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。<br>这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。<br>![[观察者模式 2022-10-04 20.36.01.excalidraw]]</p><h2 id="11-主要构成"><a class="markdownIt-Anchor" href="#11-主要构成"></a> 1.1 主要构成</h2><p><strong>Subject(抽象被观察者)</strong>：<br>将所有观察者对象保存到一个集合里（通常是ArrayList),主题可以有任意数量的观察者，抽象主题提供增加、删除观察者对象的接口(attach、detach)</p><p><strong>Observer(抽象观察者)</strong>：<br>它定义了一个更新接口方法(update),使得在得到主题更改通知时更新自己</p><p><strong>ConcreteSubject(具体被观察者)</strong>：  红绿灯<br>有关状态存入具体观察者对象，具体被观察者的内部状态发生改变时，给所有加入过的观察者发送通知。</p><p><strong>ConcreteObserver(具体观察者)</strong>：车辆<br>实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</p><h2 id="12-优缺点"><a class="markdownIt-Anchor" href="#12-优缺点"></a> 1.2 优缺点</h2><p>优点： 解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换</p><p>缺点： 调试复杂，而且在java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。</p><!-- basicblock-start oid="ObsoM1zvXwXJcvLx9wrf8Wra" --> <h1 id="2-观察者模式的案例"><a class="markdownIt-Anchor" href="#2-观察者模式的案例"></a> 2 观察者模式的案例::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/faea0b63bf5547849e88e3b8a42c27c6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span><span class="hljs-comment">// 英雄队列</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象的英雄</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractHero</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroA</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroA</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄A正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄A停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroB</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroB</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄B正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄B停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroC</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroC</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄C正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄C停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroD</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroD</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄D正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄D停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroE</span> :<span class="hljs-keyword">public</span> AbstractHero {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">HeroE</span>() {<br>cout &lt;&lt; <span class="hljs-string">"英雄E正在撸Boss..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"英雄E停止撸，待机状态..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//观察目标抽象: BOSS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBoss</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//添加观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//删除观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">deleteHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//通知所有观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//具体的观察者 BOSSA</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BOSSA</span> :<span class="hljs-keyword">public</span> AbstractBoss {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//添加观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>{<br>pHeroList.<span class="hljs-built_in">push_back</span>(hero); <span class="hljs-comment">// 往队列里添加一个英雄</span><br>}<br><span class="hljs-comment">//删除观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">deleteHero</span><span class="hljs-params">(AbstractHero* hero)</span> </span>{<br>pHeroList.<span class="hljs-built_in">remove</span>(hero);<br>}<br><span class="hljs-comment">//通知所有观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">for</span> (list&lt;AbstractHero*&gt;::iterator it = pHeroList.<span class="hljs-built_in">begin</span>(); it != pHeroList.<span class="hljs-built_in">end</span>();it++) {<br>(*it)-&gt;<span class="hljs-built_in">Update</span>();<br>}<br>}<br><span class="hljs-keyword">public</span>:<br>list&lt;AbstractHero*&gt; pHeroList;<span class="hljs-comment">// 英雄队列</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">//创建观察者</span><br>AbstractHero* heroA = <span class="hljs-keyword">new</span> HeroA;<br>AbstractHero* heroB = <span class="hljs-keyword">new</span> HeroB;<br>AbstractHero* heroC = <span class="hljs-keyword">new</span> HeroC;<br>AbstractHero* heroD = <span class="hljs-keyword">new</span> HeroD;<br>AbstractHero* heroE = <span class="hljs-keyword">new</span> HeroE;<br><br><span class="hljs-comment">//创建观测目标</span><br>AbstractBoss* bossA = <span class="hljs-keyword">new</span> BOSSA;<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroA);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroB);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroC);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroD);<br>bossA-&gt;<span class="hljs-built_in">addHero</span>(heroE);<br><br>cout &lt;&lt; <span class="hljs-string">"heroC阵亡..."</span> &lt;&lt; endl;<br>bossA-&gt;<span class="hljs-built_in">deleteHero</span>(heroC);<br><br>cout &lt;&lt; <span class="hljs-string">"BOSS死了...通知其他英雄停止攻击，抢装备..."</span> &lt;&lt; endl;;<br>bossA-&gt;<span class="hljs-built_in">notify</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/197e38fd39f34c4a888b3b3d706486e1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsAevvR48nFdqLiDjbPFxmB"  --> <p>#历史记录::<br>2022/10/4🌵观察者模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/posts/58640/"/>
    <url>/posts/58640/</url>
    
    <content type="html"><![CDATA[<h1 id="1-策略模式的理论"><a class="markdownIt-Anchor" href="#1-策略模式的理论"></a> 1 策略模式的理论::</h1><!-- basicblock-end --><blockquote><p>[!Summary] 我感觉策略模式就是普通的继承+重写: 看例子吧</p></blockquote><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。<br>策略模式让算法独立于使用它的客户而独立变化。</p><blockquote><p>[!summary]  总结: 对象通过不同的策略完成不同的动作<br>也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为引起环境角色表现出不同的行为。</p></blockquote><h2 id="11-优缺点"><a class="markdownIt-Anchor" href="#11-优缺点"></a> 1.1 优缺点</h2><p><strong>优点:</strong></p><p>(1)策略模式提供了对“<strong>开闭原则”的完美支持</strong>，<br>用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p><p>(2)使用策略模式可以避免多重条件选择语句(if-else)。</p><blockquote><p>[!quote] 直接修改 if-else 语句可能会导致错误<br>多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。</p></blockquote><p>(3)策略模式提供了一种算法的复用机制。<br>由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。</p><p><strong>缺点：</strong></p><p>(1)客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<strong>策略模式只适用于客户端知道所有的算法或行为的情况。</strong><br>这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，<strong>策略模式只适用于客户端知道所有的算法或行为的情况。</strong></p><p>(2)策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p><h2 id="12-主要构成"><a class="markdownIt-Anchor" href="#12-主要构成"></a> 1.2 主要构成</h2><p>Stragety(策略的抽象，接口)<br>ConcreteStragetyA、ConcreteStrategyB.(具体的策略实现类)<br>Context(用来操作策略的上下文环境类)：环境类的构造函数包含了Strategy类，通过多态传进来不同的具体策略(ConcreteStrategyA。ConcreteStrategyB)来调用不同策略的方法</p><!-- basicblock-start oid="ObsPa45lYeT48TZkO5sG4axM" --> <h1 id="2-策略模式的案例"><a class="markdownIt-Anchor" href="#2-策略模式的案例"></a> 2 策略模式的案例::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/ea96f816090a48c8937389ac64ba8010.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象武器 武器策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WeaponStrategy</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">UseWeapon</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife</span> : <span class="hljs-keyword">public</span> WeaponStrategy { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">UseWeapon</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 重写</span><br>cout &lt;&lt; <span class="hljs-string">"使用匕首!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AK47</span> : <span class="hljs-keyword">public</span> WeaponStrategy{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">UseWeapon</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"使用AK47!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWeapon</span><span class="hljs-params">(WeaponStrategy* weapon)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pWeapon = weapon;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThrowWeapon</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 挥舞武器(使用武器)</span><br><span class="hljs-keyword">this</span>-&gt;pWeapon-&gt;<span class="hljs-built_in">UseWeapon</span>();<br>}<br><span class="hljs-keyword">private</span>:<br>WeaponStrategy* pWeapon;<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">//创建角色</span><br>Character* character = <span class="hljs-keyword">new</span> Character;<br><br><span class="hljs-comment">//武器策略</span><br>WeaponStrategy* knife = <span class="hljs-keyword">new</span> Knife;<br>WeaponStrategy* ak47 = <span class="hljs-keyword">new</span> AK47;<br><br>character-&gt;<span class="hljs-built_in">setWeapon</span>(knife);<br>character-&gt;<span class="hljs-built_in">ThrowWeapon</span>();<br><br>character-&gt;<span class="hljs-built_in">setWeapon</span>(ak47);<br>character-&gt;<span class="hljs-built_in">ThrowWeapon</span>();<br><br><span class="hljs-keyword">delete</span> ak47;<br><span class="hljs-keyword">delete</span> knife;<br><span class="hljs-keyword">delete</span> character;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsQ7GseC9e9gV5sAjQvFl3X" --> <h1 id="3-策略模式的适用场景"><a class="markdownIt-Anchor" href="#3-策略模式的适用场景"></a> 3 策略模式的适用场景::</h1><!-- basicblock-end --><p>准备一组算法，并将每一个算法封装起来，使得它们可以互换。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsJ2qpT7MLTVZ8c5qcAAldg" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::行为型模式::策略模式.md" --> <p>#历史记录::<br>2022/10/4🌵策略模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>命令模式</title>
    <link href="/posts/22978/"/>
    <url>/posts/22978/</url>
    
    <content type="html"><![CDATA[<h1 id="1-命令模式的理论"><a class="markdownIt-Anchor" href="#1-命令模式的理论"></a> 1 命令模式的理论</h1><p>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；<br>对请求排队或者记录请求日志，以及支持可撤销的操作。<br>命令模式是一种对象行为型模式，其别名为动作(Action)模式或事(Transaction)模式。</p><p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</p><p><img src="https://img-blog.csdnimg.cn/b6bc474a9cd640a3bdfa50f75544f544.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h1 id="2-命令模式的案例"><a class="markdownIt-Anchor" href="#2-命令模式的案例"></a> 2 命令模式的案例</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span><span class="hljs-comment">// 给请求排队</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//协议处理类: 💡处理客户端可能发来的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleClientProtocol</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//处理增加金币</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddMoney</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家增加金币！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//处理增加钻石</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddDiamod</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家增加钻石！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//处理玩家装备</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddEquipment</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家穿装备！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//处理玩家升级</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddLevel</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"给玩家升级！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//命令接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCommand</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//处理客户端请求的接口</span><br>};<br><br><span class="hljs-comment">//处理增加金币请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddMoneyCommand</span> :<span class="hljs-keyword">public</span> AbstractCommand {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddMoneyCommand</span>(HandleClientProtocol* protocol) { <span class="hljs-comment">// ❓</span><br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写</span><br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddMoney</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//处理增加钻石的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddDimondCommnd</span> :<span class="hljs-keyword">public</span> AbstractCommand{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddDimondCommnd</span>(HandleClientProtocol* protocol) {<br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddDiamod</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//处理玩家装备装备的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddEquipmentCommnd</span> :<span class="hljs-keyword">public</span> AbstractCommand {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddEquipmentCommnd</span>(HandleClientProtocol* protocol) {<br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddEquipment</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//处理玩家升级的请求</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddLevelCommand</span> :<span class="hljs-keyword">public</span> AbstractCommand {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddLevelCommand</span>(HandleClientProtocol* protocol) {<br><span class="hljs-keyword">this</span>-&gt;pProtocol = protocol;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;pProtocol-&gt;<span class="hljs-built_in">AddLevel</span>();<br>}<br><span class="hljs-keyword">public</span>:<br>HandleClientProtocol* pProtocol;<br>};<br><br><span class="hljs-comment">//服务器程序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRequest</span><span class="hljs-params">(AbstractCommand* command)</span> </span>{<br>mCommands.<span class="hljs-built_in">push</span>(command); <span class="hljs-comment">// 入队</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startHandle</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 开始处理</span><br><span class="hljs-keyword">while</span> (!mCommands.<span class="hljs-built_in">empty</span>()) {<br><br><span class="hljs-built_in">Sleep</span>(<span class="hljs-number">2000</span>);<br><br>AbstractCommand* command = mCommands.<span class="hljs-built_in">front</span>();<br>command-&gt;<span class="hljs-built_in">handle</span>();<br>mCommands.<span class="hljs-built_in">pop</span>();<br>}<br>}<br><span class="hljs-keyword">public</span>:<br>queue&lt;AbstractCommand*&gt; mCommands;<span class="hljs-comment">// 待处理的请求都在这里, 让他们排队</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><br>HandleClientProtocol* protocol = <span class="hljs-keyword">new</span> HandleClientProtocol;<br><span class="hljs-comment">//客户端增加金币的请求</span><br>AbstractCommand* addmoney = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddMoneyCommand</span>(protocol);<br><span class="hljs-comment">//客户端增加钻石的请求</span><br>AbstractCommand* adddimond = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddDimondCommnd</span>(protocol);<br><span class="hljs-comment">//客户端穿装备的请求</span><br>AbstractCommand* addequiment = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddEquipmentCommnd</span>(protocol);<br><span class="hljs-comment">//客户端升级的请求</span><br>AbstractCommand* addlevel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddLevelCommand</span>(protocol);<br><br><span class="hljs-comment">//将客户端请求加入到处理的队列中</span><br>Server* server = <span class="hljs-keyword">new</span> Server;<br>server-&gt;<span class="hljs-built_in">addRequest</span>(addmoney);<br>server-&gt;<span class="hljs-built_in">addRequest</span>(adddimond);<br>server-&gt;<span class="hljs-built_in">addRequest</span>(addequiment);<br>server-&gt;<span class="hljs-built_in">addRequest</span>(addlevel);<br><br><span class="hljs-comment">//服务器开始处理请求</span><br>server-&gt;<span class="hljs-built_in">startHandle</span>();<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-命令模式的优缺点"><a class="markdownIt-Anchor" href="#3-命令模式的优缺点"></a> 3 命令模式的优缺点</h1><p><strong>优点：</strong></p><p>​ (1)降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</p><p>(2)新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。</p><p>(3)可以比较容易地设计一个命令队列或宏命令（组合命令）。</p><p><strong>缺点：</strong><br>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</p><h1 id="4-命令模式的适用场景"><a class="markdownIt-Anchor" href="#4-命令模式的适用场景"></a> 4 命令模式的适用场景</h1><p>(1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</p><p>(2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</p><p>(3) 系统需要将一组操作组合在一起形成宏命令。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsv9P0LVOEViF3ttUYB6qU7" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::行为型模式::命令模式.md" --> <p>#历史记录::<br>2022/10/2🌵命令模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板方法模式</title>
    <link href="/posts/42856/"/>
    <url>/posts/42856/</url>
    
    <content type="html"><![CDATA[<p>行为型模式: 用来对类或对象怎样交互和怎样分配职责进行描述。</p><!-- basicblock-start oid="Obs0wj56nH90qhsOwgG1cLQt" --> <h1 id="1-模板方法的理论"><a class="markdownIt-Anchor" href="#1-模板方法的理论"></a> 1 模板方法的理论::</h1><!-- basicblock-end --><p>![[模板方法模式 2022-10-02 22.58.16.excalidraw]]</p><ul><li>&amp; 定义一个操作中算法的<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020">框架</a>，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li></ul><!-- basicblock-start oid="ObsdstvOGbnX9W0wLZrnfd9r" --> <h1 id="2-模板方法的案例"><a class="markdownIt-Anchor" href="#2-模板方法的案例"></a> 2 模板方法的案例::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/618b7109db364e98bb0b9e99870ed137.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DrinkTemplate</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//注水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boildwater</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//加辅助料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//模板方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Make</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">Boildwater</span>();<br><span class="hljs-built_in">Brew</span>();<br><span class="hljs-built_in">PourInCup</span>();<br><span class="hljs-built_in">AddSomething</span>();<br>}<br>};<br><br><span class="hljs-comment">//冲泡咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> DrinkTemplate {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//注水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boildwater</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"煮山泉水..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"冲泡咖啡..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"咖啡倒入杯中..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//加辅助料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddSomething</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"加糖，加牛奶，加点醋..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//冲泡茶</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> DrinkTemplate {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//注水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boildwater</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"煮自来水..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"冲泡铁观音..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"茶水倒入杯中..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">//加辅助料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">AddSomething</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"加糖，加柠檬，加生姜..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><br>DrinkTemplate* tea = <span class="hljs-keyword">new</span> Tea;<br>tea-&gt;<span class="hljs-built_in">Make</span>();<br><br>cout &lt;&lt; <span class="hljs-string">"----------------"</span> &lt;&lt; endl;<br><br>DrinkTemplate* coffee = <span class="hljs-keyword">new</span> Coffee;<br>coffee-&gt;<span class="hljs-built_in">Make</span>();<br><br><span class="hljs-keyword">delete</span> tea;<br><span class="hljs-keyword">delete</span> coffee;<br>}<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsSJ1jlWHX1gT3RxypseEhf" --> <h1 id="3-模板方法模式的优缺点"><a class="markdownIt-Anchor" href="#3-模板方法模式的优缺点"></a> 3 模板方法模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1)在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</p><p>(2)模板方法模式是一种代码复用技术，它在类库设计中尤为重要，<strong>它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</strong></p><p>(3)可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</p><p>(4)在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</p><p><strong>缺点：</strong><br>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2PZn2klaTlt8zwXXH41qS" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::行为型模式::模板方法模式.md" --> <p>#历史记录::<br>2022/10/2🌵模板方法模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>行为型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>适配器模式</title>
    <link href="/posts/39555/"/>
    <url>/posts/39555/</url>
    
    <content type="html"><![CDATA[<h1 id="1-适配器模式理论"><a class="markdownIt-Anchor" href="#1-适配器模式理论"></a> 1 适配器模式理论::</h1><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/5b3e4c76c6d94290936feeb60948108c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><blockquote><p>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><!-- basicblock-start oid="ObsNl3SHTLsjJZdKnoU0uiZR" --> <h1 id="2-适配器模式案例"><a class="markdownIt-Anchor" href="#2-适配器模式案例"></a> 2 适配器模式案例::</h1><!-- basicblock-end --><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//💡适配器模式 就是将已经写好的接口(但是这个接口不符合需求), 转换成目标接口</span><br><br><span class="hljs-comment">//这函数我已经写好了</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Myprint</span>{<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1,<span class="hljs-type">int</span> v2)</span> </span>{<br>cout &lt;&lt; v1 + v2 &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//定义目标接口 我要适配成什么样的，</span><br><span class="hljs-comment">//要适配成只能传一个参数的，适配for_each第三个参数的适用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>= <span class="hljs-number">0</span>;{<span class="hljs-comment">// 💡目标接口, 只有一个参数</span><br><br>};<br><br><span class="hljs-comment">//写适配器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapater</span> :<span class="hljs-keyword">public</span> Target {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Adapater</span>(<span class="hljs-type">int</span> param) {<br><span class="hljs-keyword">this</span>-&gt;param = param;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(v,param)</span></span>;<br>}<br><span class="hljs-keyword">public</span>:<br>Myprint print;<br><span class="hljs-type">int</span> param;<br>};<br><br><span class="hljs-comment">//MyBind2nd，原来param固定的10，现在提供一个方法改</span><br><span class="hljs-function">Adapater <span class="hljs-title">MyBind2nd</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Adapater</span>(v);<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>{<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {<br>v.<span class="hljs-built_in">push_back</span>(i);<br>}<br><br><span class="hljs-comment">//适配器模式的运用</span><br><span class="hljs-comment">//for_each()的第三个参数是个带一个参数的函数，但是Myprint需要两个参数</span><br>for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MyBind2nd</span>(<span class="hljs-number">10</span>));<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsmDTz27IdYee6u3DZUTCan" --> <h1 id="3-适配器模式的优缺点"><a class="markdownIt-Anchor" href="#3-适配器模式的优缺点"></a> 3 适配器模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1)将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p><p>(2)增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p><p>(3)灵活性和扩展性都非常好，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p><p><strong>缺点：</strong></p><p>适配器中置换适配者类的某些方法比较麻烦。</p><!-- basicblock-start oid="ObsN8UYJcNVWVxTFOlqKIia8" --> <h1 id="4-适配器模式的适用场景"><a class="markdownIt-Anchor" href="#4-适配器模式的适用场景"></a> 4 适配器模式的适用场景::</h1><!-- basicblock-end --><p>(1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</p><p>(2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsrmtbAdbqS65DuTo7TmCAI" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::结构型模式::适配器模式.md" --> <p>#历史记录::<br>2022/10/2🌵适配器模式 : 代码没听懂⏱0-15<br><a href="https://www.bilibili.com/video/BV1Mb411t7ut?p=34&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">3-04 适配器模式_哔哩哔哩_bilibili</a></p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>外观模式</title>
    <link href="/posts/33101/"/>
    <url>/posts/33101/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><blockquote><p>废话理论（建议直接看总结）：</p><p>根据迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。</p><p>Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。</p></blockquote><blockquote><p>[!summary] 总结：<br>外观模式就是将复杂的子类系统抽象到同一个的接口进行管理，外界只需要通过此接口与子类系统进行交互，而不必要直接与复杂的子类系统进行交互。</p></blockquote><!-- basicblock-start oid="ObsNzszGnr0QFlXbyTcA0BUi" --> <h1 id="2-外观模式的案例"><a class="markdownIt-Anchor" href="#2-外观模式的案例"></a> 2 外观模式的案例::</h1><!-- basicblock-end --><p>根据类图，实现家庭影院外观模式应用。<br>实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，dvd打开；<br>实现游戏模式：电视打开，音响打开，游戏机打开。</p><p><img src="https://img-blog.csdnimg.cn/6b54a7eca1714ea4983ec47f238ce192.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5q-V5Yqg57Si5p2l5Za9,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//电视机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Televison</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"电视机打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"电视机关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//灯</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"灯打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"灯关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//音箱</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Audio</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"音箱打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"音箱关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//麦克风</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Microphone</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"麦克风打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"麦克风关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//DVD</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DVDPlayer</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"DVD播放器打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"DVD播放器关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">//游戏机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Gamemachine</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">On</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"游戏机打开..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Off</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"游戏机关闭"</span> &lt;&lt; endl;<br>}<br>};<br><span class="hljs-comment">// 💡外观模式 1</span><br><span class="hljs-comment">//KTV模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KTVModel</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">KTVModel</span>() {  <span class="hljs-comment">// 创建对象</span><br>pTv = <span class="hljs-keyword">new</span> Televison;<br>pLight = <span class="hljs-keyword">new</span> Light;<br>pAudio = <span class="hljs-keyword">new</span> Audio;<br>pMicrophone = <span class="hljs-keyword">new</span> Microphone;<br>pDVD = <span class="hljs-keyword">new</span> DVDPlayer;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnKtv</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 打开</span><br>pTv-&gt;<span class="hljs-built_in">On</span>();<br>pLight-&gt;<span class="hljs-built_in">Off</span>();<br>pAudio-&gt;<span class="hljs-built_in">On</span>();<br>pMicrophone-&gt;<span class="hljs-built_in">On</span>();<br>pDVD-&gt;<span class="hljs-built_in">On</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OffKtv</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 关闭</span><br>pTv-&gt;<span class="hljs-built_in">Off</span>();<br>pLight-&gt;<span class="hljs-built_in">On</span>();<br>pAudio-&gt;<span class="hljs-built_in">Off</span>();<br>pMicrophone-&gt;<span class="hljs-built_in">Off</span>();<br>pDVD-&gt;<span class="hljs-built_in">Off</span>();<br>}<br><br>~<span class="hljs-built_in">KTVModel</span>() { <span class="hljs-comment">// 析构</span><br><span class="hljs-keyword">delete</span> pTv;<br><span class="hljs-keyword">delete</span> pLight;<br><span class="hljs-keyword">delete</span> pAudio;<br><span class="hljs-keyword">delete</span> pMicrophone;<br><span class="hljs-keyword">delete</span> pDVD;<br>}<br><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 先定义对象</span><br>Televison* pTv;<br>Light* pLight;<br>Audio* pAudio;<br>Microphone* pMicrophone;<br>DVDPlayer* pDVD;<br>};<br><br><span class="hljs-comment">// 游戏模式同理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>KTVModel* ktv = <span class="hljs-keyword">new</span> KTVModel; <span class="hljs-comment">// 只和 KEVmode 打交道就行了</span><br>ktv-&gt;<span class="hljs-built_in">OnKtv</span>();<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">system</span>(<span class="hljs-string">"pause"</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsNnwrWwy6xyYvYmICn3jY1" --> <h1 id="3-外观模式的优缺点"><a class="markdownIt-Anchor" href="#3-外观模式的优缺点"></a> 3 外观模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong></p><p>(1) 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。<br>通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</p><p>(2)它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，<strong>只需要调整外观类</strong>即可。</p><p>(3)一个子系统的修改对其他子系统没有任何影响。</p><p><strong>缺点：</strong></p><p>(1)不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。</p><p>(2)如果设计不当，<strong>增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</strong></p><!-- basicblock-start oid="Obsa9mNTBwX4GDzWgvOJKc2m" --> <h1 id="4-外观模式的适用场景"><a class="markdownIt-Anchor" href="#4-外观模式的适用场景"></a> 4 外观模式的适用场景::</h1><!-- basicblock-end --><p>(1) 复杂系统需要简单入口使用。</p><p>(2) 客户端程序与多个子系统之间存在很大的依赖性。</p><p>(3) 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsew9tJ8MecAJrNV6P29x4s"  --> <p>#历史记录::<br>2022/10/2🌵外观模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/posts/48004/"/>
    <url>/posts/48004/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><p>代理模式的定义：<strong>为其他对象提供一种代理(方式)以控制对这个对象的访问</strong>。<br>在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><p>![[代理模式结构图.excalidraw]]<br>![[代理模式 2022-10-02 20.43.18.excalidraw]]</p><h2 id="11-远程代理"><a class="markdownIt-Anchor" href="#11-远程代理"></a> 1.1 远程代理</h2><p>一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。</p><blockquote><p>[!example]<br>“哈，其实你是一定用过的，WebService <a href="http://xn--3ds.NET">在.NET</a> 中的应用是怎么做的？”<br>“哦，我明白什么叫远程代理了，当我在应用程序的项目中加入一个 web 引用，引用一个 webService,<br>时会在项目中生成一个 WebReference 的文件夹和一些文件，其实它们就是代理，这就使得客户端程序<br>用代理就可以解决远程访问的问题。原来这就是代理模式的应用呀。”</p></blockquote><h2 id="12-虚拟代理"><a class="markdownIt-Anchor" href="#12-虚拟代理"></a> 1.2 虚拟代理</h2><p>根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象，这样就可以达到性能的最优化。</p><blockquote><p>[!example]<br>比如说你打开一个很大的 HTML 网页时，里面可能有很多的文字和图片，但你还是可以很快打开它，此时你所看到的是所有的文字，但图片却是一张一张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。<br>原来浏览器当中是用代理模式来优化下载的。</p></blockquote><h2 id="13-安全代理"><a class="markdownIt-Anchor" href="#13-安全代理"></a> 1.3 安全代理</h2><p>用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。</p><h2 id="14-智能指引"><a class="markdownIt-Anchor" href="#14-智能指引"></a> 1.4 智能指引</h2><p>是指当调用真实的对象时，代理处理另外一些事。</p><p>1如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。</p><p>代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。<br>“哦，明白。说白了，代理就是真实对象的代表。</p><h1 id="2-代理模式的案例"><a class="markdownIt-Anchor" href="#2-代理模式的案例"></a> 2 代理模式的案例::</h1><blockquote><p>传统方法局限：是个人都能调用</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">//提供一种代理来控制对其他对象的访问</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstraactCommonInterface</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-comment">//我已经写好的系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mysystem</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"系统启动..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//必须有权限验证，不是所有人都能来启动我的启动，必须提供用户名和密码</span><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">//这样不行。是个人都能启动</span><br>Mysystem* system = <span class="hljs-keyword">new</span> Mysystem;<br>system -&gt; <span class="hljs-built_in">run</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//提供一种代理来控制对其他对象的访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstraactCommonInterface</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-comment">//我已经写好的系统</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mysystem</span> :<span class="hljs-keyword">public</span> AbstraactCommonInterface{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"系统启动..."</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//💡: 用一个代理类来管理用户</span><br><span class="hljs-comment">// 必须有权限验证，不是所有人都能来启动我的启动，必须提供用户名和密码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MysystemProxy</span> :<span class="hljs-keyword">public</span> AbstraactCommonInterface {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MysystemProxy</span>(string username,string password) {<br><span class="hljs-keyword">this</span>-&gt;mUsername = username;<br><span class="hljs-keyword">this</span>-&gt;mPassword = mPassword;<br><br>}<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkUsernameAndPassword</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (mUsername == <span class="hljs-string">"admin"</span>&amp;&amp;mPassword == <span class="hljs-string">"admin"</span>) { <span class="hljs-comment">// admin 只是一个例子</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkUsernameAndPassword</span>()) {<br>cout &lt;&lt; <span class="hljs-string">"用户名和密码正确，验证通过..."</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;pSystem-&gt;<span class="hljs-built_in">run</span>();<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"用户名或密码错误，权限不足...."</span> &lt;&lt; endl;<br>}<br>}<br>~<span class="hljs-built_in">MysystemProxy</span>() { <span class="hljs-comment">// 析构函数</span><br><span class="hljs-keyword">if</span> (pSystem != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> pSystem;<br>}<br>}<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 💡需要的变量</span><br>Mysystem* pSystem;<br>string mUsername;<br>string mPassword;<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>MysystemProxy* proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MysystemProxy</span>(<span class="hljs-string">"root"</span>,<span class="hljs-string">"admin"</span>); <span class="hljs-comment">// 💡通过代理启动</span><br>proxy-&gt;<span class="hljs-built_in">run</span>();<br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">//这样不行。是个人都能启动</span><br>Mysystem* system = <span class="hljs-keyword">new</span> Mysystem;<br>system -&gt; <span class="hljs-built_in">run</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//调用代理模式</span><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/ab34facdb3e74edf86bf646b2491cd0d.png#pic_center" alt="在这里插入图片描述"></p><h1 id="3-代理模式的优缺点"><a class="markdownIt-Anchor" href="#3-代理模式的优缺点"></a> 3 代理模式的优缺点::</h1><p><strong>优点：</strong></p><p>(1)能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。<br>(2)客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，<strong>符合开闭原则</strong>，系统具有较好的灵活性和可扩展性。</p><p><strong>缺点：</strong><br>代理实现较为复杂。</p><h1 id="4-代理模式的适用场景"><a class="markdownIt-Anchor" href="#4-代理模式的适用场景"></a> 4 代理模式的适用场景::</h1><p>为其他对象提供一种代理以控制对这个对象的访问。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsgHSYGOytuVKUVix8FoW7G" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::结构型模式::代理模式.md" --> <p>#历史记录:: <a href="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">margin: 代理模式</a><br>2022/10/2🌵代理模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>结构型模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/posts/56170/"/>
    <url>/posts/56170/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单列模式: 系统只有一个对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{};<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>{<br><br>A a; <span class="hljs-comment">// 这个系统中只能有一个 A 类型的对象</span><br><br>}<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!summary] 单例模式: 保证一个类仅有一个实例，并提供一个访问它的全局访问点<br>方便对实例个数的控制并节约系统资源。</p></blockquote><p>![[单例模式 2022-10-04 14.40.48.excalidraw]]</p><!-- basicblock-start oid="ObsHlpWnjsCHM3IRkNfhQlY8" --> <h1 id="2-实现单例步骤"><a class="markdownIt-Anchor" href="#2-实现单例步骤"></a> 2 实现单例步骤::</h1><!-- basicblock-end --><p><strong>使用</strong></p><ul><li>私有构造函数<ul><li>不能让别人 new 它， 确保单例类只能自己创建实例</li></ul></li><li>私有静态变量<ul><li>确保只有一个实例</li></ul></li><li>公有静态函数<ul><li>提供静态对外接口，可以让用户获得单例对象</li></ul></li></ul><p>私有构造函数保证了不能通过构造函数来创建对象，只能通过公有静态函数返回唯一私有静态变量</p><!-- basicblock-start oid="ObsdmaP5SKhIhMztoi9JmS5M" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::单例模式.md"--><p><strong>原则:</strong></p><ol><li>私有构造 (防止类通过常规方法实例化)</li><li>以静态方法或者枚举返回实例。 (保证实例的唯一性)</li><li>确保实例只有一个，尤其是多线程环境。(保证创建实例的线程安全)</li><li>❓确保反序列化时不会重新构造对象。(在有序列化反序列化的场景下防止单例被莫名破坏)</li></ol> <!-- basicblock-end --><blockquote><p>[!tip]<br>简单来说就是，单例类的构造方不让其他人修改和使用；<br>并且单例类自己只创建一个实例，这个实例，其他人也无法修改和直接使用；<br>然后单例类提供一个调用方法，想用这个实例，只能调用。这样就确保了全局只创建了一个实例。<br><a href="https://www.bilibili.com/video/BV1Mb411t7ut?p=23&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=256.728737">04:16</a></p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<br><span class="hljs-keyword">private</span>: <span class="hljs-comment">// 1️⃣.构造函数私有化 : 不能让别人 new 它</span><br><span class="hljs-built_in">A</span>() {<br>a = <span class="hljs-keyword">new</span> A;<br>}<br><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//2️⃣.增加静态 + 私有, 的当前类的指针变量</span><br><span class="hljs-comment">// private 的原因是不能让别人直接访问到 a, 想访问它只能通过 getInstance</span><br><span class="hljs-comment">// 如果用 public, 别人可以直接通过 A::a 访问到 A</span><br><span class="hljs-type">static</span> A* a; <span class="hljs-comment">// 💡加了 static 后, 静态的成员函数可以通过类名去调用: A::a;</span><br><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//3️⃣.提供静态对外接口(public)，可以让用户获得单例对象</span><br><span class="hljs-function"><span class="hljs-type">static</span> A* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> a;<br>}<br>};<br><br><br>A* A::a = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 类外初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>{<br>A a; <span class="hljs-comment">// ❗️或A*a=new A;  这两个会调用构造函数，要让不能构造函数, 想访问它只能通过 getInstance</span><br>A::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">// 访问 a</span><br>}<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs7JAJIyiYk5eIowHrKVi9b" --> <h1 id="3-单例模式的类别"><a class="markdownIt-Anchor" href="#3-单例模式的类别"></a> 3 [[单例模式的类别]]::</h1><!-- basicblock-end --><h1 id="4-懒汉-饿汉黑马案例"><a class="markdownIt-Anchor" href="#4-懒汉-饿汉黑马案例"></a> 4 懒汉, 饿汉黑马案例</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//单例 分为懒汉式 饿汉式</span><br><br><span class="hljs-comment">// ---💡接着上面的代码的---</span><br><span class="hljs-comment">//1.懒汉式(需要的时候才会创建)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_lazy</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_lazy</span>() { cout &lt;&lt; <span class="hljs-string">"我是懒汉构造！"</span> &lt;&lt; endl; }<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_lazy* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 第一次用的时候在创建</span><br><span class="hljs-keyword">if</span> (pSingleton == <span class="hljs-literal">NULL</span>) {<br>pSingleton = <span class="hljs-keyword">new</span> Singleton_lazy;<br>}<br><span class="hljs-keyword">return</span> pSingleton;<br>}<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_lazy* pSingleton;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_lazy* Singleton_lazy::pSingleton = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//2.饿汉式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_hungry</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_hungry</span>() { cout &lt;&lt; <span class="hljs-string">"我是饿汉构造！"</span> &lt;&lt; endl; }<span class="hljs-comment">// 💡在 main 函数之前就创建了</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_hungry* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> pSingleton;<span class="hljs-comment">// 💡上面没有判断了</span><br>}<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_hungry* pSingleton;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_hungry* Singleton_hungry::pSingleton = <span class="hljs-keyword">new</span> Singleton_hungry;<span class="hljs-comment">// 💡在这 new, 在 main 函数之前就创建了</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>Singleton_lazy* p1 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">// 💡取到单例对象</span><br>Singleton_lazy* p2 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p1 == p2) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式！"</span> &lt;&lt; endl;<br>}<br><br>Singleton_hungry* p3 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<span class="hljs-comment">// 💡取到单例对象</span><br>Singleton_hungry* p4 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p3 == p4) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式!"</span> &lt;&lt; endl;<br>}<br>}<br><span class="hljs-comment">// 💡经测试, 以上两个都是单例对象</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-comment">//A a; // 或A*a=new A;  这两个会调用构造函数，要让不能构造函数</span><br><span class="hljs-comment">//A::getInstance();💡静态的成员函数可以通过类名去调用</span><br><br><span class="hljs-built_in">test01</span>();<br>cout &lt;&lt; <span class="hljs-string">"main函数开始执行！"</span> &lt;&lt; endl;<br><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsTE2UQF3DlSrNjS7wSnSIc" --> <h1 id="5-单例对象释放"><a class="markdownIt-Anchor" href="#5-单例对象释放"></a> 5 单例对象释放::</h1><!-- basicblock-end --><p>不用考虑内存释放问题</p><blockquote><p>1.单例对象从头到尾就一份内存，也不大, 没必要释放</p><p>2.如果非要提供释放，可以写一个析构函数: 运行完自动释放：</p></blockquote><p>如果在类中提供一个函数去释放, 那么只要有一个人调用了函数, 整个代码其他用到单例对象的地方都不管用了<br>所以不能提供释放的函数</p><p>//💡💡如果非要写，可以加个析构函数，运行完自动释放</p><p>看💡💡</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//实现单例步骤</span><br><span class="hljs-comment">//1.构造函数私有化</span><br><span class="hljs-comment">//2.增加静态私有的当前类的指针变量</span><br><span class="hljs-comment">//3.提供静态对外接口，可以让用户获得单例对象</span><br><br><span class="hljs-comment">//单例 分为懒汉式 饿汉式</span><br><br><span class="hljs-comment">//1.懒汉式(需要的时候才会创建)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_lazy</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_lazy</span>() { cout &lt;&lt; <span class="hljs-string">"我是懒汉构造！"</span> &lt;&lt; endl; }<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_lazy* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (pSingleton == <span class="hljs-literal">NULL</span>) {<br>pSingleton = <span class="hljs-keyword">new</span> Singleton_lazy;<br>}<br><span class="hljs-keyword">return</span> pSingleton;<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0 </span><br><span class="hljs-comment">//💡💡这样释放不行，万一谁手贱释放，就直接没了，这个权限不能给</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">freeSpace</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">if</span> (pSingleton != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> pSingleton;<br>}<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//💡💡如果非要写，可以加个这个，运行完自动释放</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Garbo</span> {<br>~<span class="hljs-built_in">Garbo</span>() {<br><span class="hljs-keyword">if</span> (pSingleton != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> pSingleton;<br>}<br>}<br>};<br><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_lazy* pSingleton;<br><span class="hljs-type">static</span> Garbo garbo;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_lazy* Singleton_lazy::pSingleton = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//2.饿汉式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton_hungry</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">Singleton_hungry</span>() { cout &lt;&lt; <span class="hljs-string">"我是饿汉构造！"</span> &lt;&lt; endl; }<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> Singleton_hungry* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> pSingleton;<br>}<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> Singleton_hungry* pSingleton;<br>};<br><br><span class="hljs-comment">//类外初始化</span><br>Singleton_hungry* Singleton_hungry::pSingleton = <span class="hljs-keyword">new</span> Singleton_hungry;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>Singleton_lazy* p1 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<br>Singleton_lazy* p2 = Singleton_lazy::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p1 == p2) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式！"</span> &lt;&lt; endl;<br>}<br><br>Singleton_hungry* p3 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<br>Singleton_hungry* p4 = Singleton_hungry::<span class="hljs-built_in">getInstance</span>();<br><span class="hljs-keyword">if</span> (p3 == p4) {<br>cout &lt;&lt; <span class="hljs-string">"两个指针指向同一块内存空间，是单例！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"不是单例模式!"</span> &lt;&lt; endl;<br>}<br>}<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br>Singleton_lazy::<span class="hljs-built_in">freeSpace</span>();<br>}<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">test01</span>();<br>cout &lt;&lt; <span class="hljs-string">"main函数开始执行！"</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsQhGVkIZ2Q9Bkn6O5B6sLf" --> <p>多线程概念::![[多线程.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsN7XTfOhM7pW8auRlyPK27" --> <h1 id="6-单例模式的优缺点"><a class="markdownIt-Anchor" href="#6-单例模式的优缺点"></a> 6 单例模式的优缺点::</h1><!-- basicblock-end --><p><strong>优点：</strong><br>先说个定义<br>(1)单例模式提供了对唯一实例的受控访问<br>(2)节约系统资源。由于在系统内存中只存在一个对象。<br><strong>有些实例，全局只需要一个就够了，使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。</strong></p><p><strong>缺点：</strong><br>(1) 扩展略难。单例模式中没有抽象层。<br>(2) 单例类的职责过重。</p><!-- basicblock-start oid="Obsa0pwoZD3yUTwIhPW3JRi6" --> <h1 id="7-单例模式的适用场景"><a class="markdownIt-Anchor" href="#7-单例模式的适用场景"></a> 7 单例模式的适用场景::</h1><h2 id="71-应用场景举例"><a class="markdownIt-Anchor" href="#71-应用场景举例"></a> 7.1 应用场景举例：</h2><p>1.网站计数器<br>2.应用程序的日志应用<br>3.Web项目中的配置对象的读取<br>4.<strong>数据库连接池</strong><br>5.多线程池<br>6.windows的资源管理器</p><h2 id="72-使用场景总结"><a class="markdownIt-Anchor" href="#72-使用场景总结"></a> 7.2 使用场景总结：</h2><ul><li>系统<strong>只需要一个实例对象</strong>，<br>如系统要求提供一个唯一的序列号生成器或资源管理器（像windows的资源管理器），<br>资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例<strong>只允许使用一个公共访问点</strong>，除了该公共访问点，不能通过其他途径访问该实例。</li><li><strong>频繁实例化然后又销毁的对象</strong>，使用单例模式可以提高性能</li><li><strong>经常使用的对象，但实例化时耗费时间或者资源多，</strong><br>如<strong>数据库连接池</strong>，使用单例模式，可以提高性能，降低资源损坏</li><li>使用线程池之类的控制资源时，使用单例模式，可以方便资源之间的通信</li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsNrP9PIGHBwETRCuXiR300"--> <p>#历史记录:: <a href="marginnote3app://note/70635F09-3528-44A0-AA4B-85CB0B593041">margin</a><br>2022/10/2🌵单列模式 : 第一次创建: ⏱1-18</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1Mb411t7ut?p=23&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">2-08 单例模式_饿汉式和懒汉式创建_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>创建型模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/posts/56456/"/>
    <url>/posts/56456/</url>
    
    <content type="html"><![CDATA[<h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1 原理::</h1><p>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，<br>但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。</p><p>抽象工厂模式为工厂方法模式的进一步延伸，其将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。<br><strong>虽然对于新增一个产品族很方便，并且也符合开闭原则，但是新增一个产品等级结构，会对整个工厂结构进行大改</strong><br>![[抽象工厂模式 2022-10-02 15.48.45.excalidraw]]</p><p><strong>应用</strong><br>Spring中的BeanFactory</p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApple</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//中国苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaApple</span> :<span class="hljs-keyword">public</span> AbstractApple {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"中国苹果！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//美国苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAApple</span> :<span class="hljs-keyword">public</span> AbstractApple {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"美国苹果！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//日本苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanApple</span> :<span class="hljs-keyword">public</span> AbstractApple {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"日本苹果！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//抽象香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBanana</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//中国香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaBanana</span> :<span class="hljs-keyword">public</span> AbstractBanana {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"中国香蕉！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//美国香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USABanan</span> :<span class="hljs-keyword">public</span> AbstractBanana {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"美国香蕉！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//日本香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanBanan</span> :<span class="hljs-keyword">public</span> AbstractBanana {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"日本香蕉！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//抽象鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractPear</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><br><span class="hljs-comment">//中国鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaPear</span>:<span class="hljs-keyword">public</span> AbstractPear{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"中国鸭梨！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//美国鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAPear</span> :<span class="hljs-keyword">public</span> AbstractPear {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"美国鸭梨！"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//日本鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanPear</span> :<span class="hljs-keyword">public</span> AbstractPear {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"日本鸭梨！"</span> &lt;&lt; endl;<br>}<br>};<br><br><br><span class="hljs-comment">//抽象工厂 💡针对产品族</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//中国工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChinaFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaApple;<span class="hljs-comment">// ❓ChinaApple只是一个变量名吗</span><br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span></span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaBanana;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChinaPear;<br>}<br>};<br><br><span class="hljs-comment">//美国工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USAFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USAApple;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> USABanan;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>  USAPear;<br>}<br>};<br><br><span class="hljs-comment">//日本工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JapanFactory</span> :<span class="hljs-keyword">public</span> AbstractFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractApple* <span class="hljs-title">CreateApple</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanApple;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractBanana* <span class="hljs-title">CreateBanana</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JapanBanan;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractPear* <span class="hljs-title">CreatePear</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span>  JapanPear;<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>AbstractFactory* factory = <span class="hljs-literal">NULL</span>;<br>AbstractApple* apple = <span class="hljs-literal">NULL</span>;<br>AbstractBanana* banana = <span class="hljs-literal">NULL</span>;<br>AbstractPear* pear = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//中国工厂, 其他同理</span><br>factory = <span class="hljs-keyword">new</span> ChinaFactory;<br>apple = factory-&gt;<span class="hljs-built_in">CreateApple</span>();<br>banana = factory-&gt;<span class="hljs-built_in">CreateBanana</span>();<br>pear = factory-&gt;<span class="hljs-built_in">CreatePear</span>();<br><br>apple-&gt;<span class="hljs-built_in">ShowName</span>();<br>banana-&gt;<span class="hljs-built_in">ShowName</span>();<br>pear-&gt;<span class="hljs-built_in">ShowName</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3 总结::</h1><h2 id="31-优缺点"><a class="markdownIt-Anchor" href="#31-优缺点"></a> 3.1 优缺点</h2><ul><li>优点：<br>(1)拥有工厂方法模式的优点</li></ul><p>(2)当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p><p>(3)增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><ul><li>缺点：<br><strong>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</strong></li></ul><h2 id="32-适用场景"><a class="markdownIt-Anchor" href="#32-适用场景"></a> 3.2 适用场景</h2><p>(1) <strong>系统中有多于一个的产品族</strong>。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</p><p>(2) 产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObscOitdWqzcsdqVkwoIBEr8" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::抽象工厂模式.md" --> <p>#历史记录::<br>2022/10/2🌵抽象工厂模式 : 第一次创建, ⏱</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>创建型模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>工厂方法模式</title>
    <link href="/posts/31151/"/>
    <url>/posts/31151/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><blockquote><p>[!summary] 简单工厂模式 + 开闭原则 = 工厂方法模式<br>工厂方法模式中，将简单工厂中的工厂类变为一个抽象接口。<br>负责给出不同工厂应该实现的方法，自身不再负责创建各种产品，而是将具体的创建操作交给实现该接口的子工厂类来做。<br>通过多态的形式解决了简单工厂模式不符合开闭原则的问题。<br>虽然在新增产品时不仅要新增一个产品类还要实现与之对应的子工厂，但是相较于简单工厂模式更符合开闭原则<br>![[工厂方法模式 2022-10-01 10.45.51.excalidraw]]</p></blockquote><!-- basicblock-start oid="Obsgj6Ogz3tyFxGHBLaXbs37" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::创建型模型::工厂方法模式.md"--><p><a href="marginnote3app://note/94C1FA5E-7AAF-424E-972F-42365D72D715">margin: 实际应用</a></p><!-- basicblock-end --><p>JDK中的Collection接口中Iterator的实现。<br>Collection中不同的实现类生产适合于自己的迭代器对象<br>1.Factory:Collection<br>1.SubFactoryA:LinkedList<br>2.SubFactoryB:ArrayList</p><p>2.Product:Iterator<br>1.ProductA:Listltr<br>2.ProductB:Itr<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210042126232.png" alt=""></p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210042114098.png" alt=""></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象水果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruit</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是苹果!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是香蕉!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pear</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是鸭梨!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruitFactory</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 💡它变成多个函数</span><br>};<br><br><br><span class="hljs-comment">//苹果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>}<br>};<br><br><span class="hljs-comment">//香蕉工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PearFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>}<br>};<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>AbstractFruitFactory* factory = <span class="hljs-literal">NULL</span>;<br>AbstractFruit* fruit = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//创建一个苹果工厂</span><br>factory = <span class="hljs-keyword">new</span> AppleFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br><br><span class="hljs-comment">//创建一个香蕉工厂</span><br>factory = <span class="hljs-keyword">new</span> BananaFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br><br><span class="hljs-comment">//创建一个鸭梨工厂</span><br>factory = <span class="hljs-keyword">new</span> PearFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><span class="hljs-keyword">delete</span> factory;<br>fruit = <span class="hljs-literal">NULL</span>;<br>factory = <span class="hljs-literal">NULL</span>;<br><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="21-知识点"><a class="markdownIt-Anchor" href="#21-知识点"></a> 2.1 知识点</h2><!-- basicblock-start oid="ObsqjzA56mA9sGh7nWGUQ7NL" --> <p>如何抽象函数, 让一个函数名实现不同的功能. ::<br>先继承，再重写<br>这也叫策略模式</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruitFactory</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 抽象函数</span><br>};<br><br><br><span class="hljs-comment">//苹果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<span class="hljs-comment">// 1️⃣先继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 2️⃣再重写</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>}<br>};<br><span class="hljs-comment">// ---🌵同理---</span><br><br><span class="hljs-comment">//香蕉工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BananaFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PearFactory</span> :<span class="hljs-keyword">public</span> AbstractFruitFactory {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> AbstractFruit* <span class="hljs-title">CreateFruit</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>}<br>};<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h1 id="3-使用场景"><a class="markdownIt-Anchor" href="#3-使用场景"></a> 3 使用场景::</h1><ol><li>客户端不知道它所需要的对象的类。<ol><li>我们直接和抽象工厂打交道</li></ol></li><li>抽象工厂类通过其子类来指定创建哪个对象。</li></ol><!-- basicblock-start oid="ObsYg9aiafi86nrpz6WDexgs" --> <h1 id="4-工厂方法模式的总结"><a class="markdownIt-Anchor" href="#4-工厂方法模式的总结"></a> 4 工厂方法模式的总结::</h1><!-- basicblock-end --><p>传统方法：如果想创建两个苹果，得具体实例化两个，然后再调用功能，以后再用还得记名字</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Apple a；<br>a.<span class="hljs-built_in">func</span>();<br>Aplle b；<br>b.<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></tbody></table></figure><p>工厂方法模式：可以不用具体一个对象，然后调用</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">factory = <span class="hljs-keyword">new</span> AppleFactory;<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<span class="hljs-comment">//造a</span><br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>();<span class="hljs-comment">//造b</span><br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br></code></pre></td></tr></tbody></table></figure><hr><!-- basicblock-end --><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsle4CtAZeZpu6u9Zy1H0d4" --> <p>#历史记录:: <a href="marginnote3app://note/615E1303-5D29-444A-BF5C-E20B69A3E587">margin: 工厂方法模式</a><br>2022/10/2🌵工厂方法模式 :  第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>创建型模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简单工厂模式</title>
    <link href="/posts/59366/"/>
    <url>/posts/59366/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><p>[[UML 外国小哥.excalidraw]]<br>![[简单工厂模式理论.excalidraw]]<br><strong>优点：</strong></p><ol><li>客户端和具体实现类解耦（不直接发生关系）</li><li>对于某些对象创建过程比较复杂情况，我们不用考虑这些了</li></ol><p>缺点</p><ul><li>简单工厂模式，增加新的功能是通过修改源代码实现，不符合开闭原则</li></ul><blockquote><p>增加水果需要修改水果源代码，简单的新建对象需要修改工厂源代码</p></blockquote><ul><li>这个类职责过重，这个类发生问题，影响很多使用这个工厂的模块</li></ul><blockquote><p>并且若是有多个判断条件共同决定创建对象，则后期修改会越来越复杂。</p></blockquote><p><strong>实际应用</strong><br>JDK中的DateFormate、Calendar类都有使用，通过不同参数返回我们需要的对象。</p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202210042102793.png" alt=""></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象水果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFruit</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//苹果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> :<span class="hljs-keyword">public</span> AbstractFruit { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<span class="hljs-comment">// 重写</span><br>cout &lt;&lt; <span class="hljs-string">"我是苹果!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//香蕉</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是香蕉!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//鸭梨</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pear</span> :<span class="hljs-keyword">public</span> AbstractFruit {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">ShowName</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"我是鸭梨!"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//水果工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitFactor</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 直接拿来用, 不用关心创建对象</span><br><span class="hljs-function"><span class="hljs-type">static</span> AbstractFruit * <span class="hljs-title">CreateFruit</span><span class="hljs-params">(string flag)</span> </span>{ <span class="hljs-comment">// 💡要设置成静态方法</span><br><span class="hljs-comment">// 静态可以不用对象调用，直接类名加点方法，不是静态需要创建对象然后调用, 不用static 无法创建对象</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-string">"apple"</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple;<br>}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">"banana"</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Banana;<br>}<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag == <span class="hljs-string">"pear"</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear;<br>}<br><span class="hljs-keyword">else</span> {<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br>}<br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>FruitFactor* factory = <span class="hljs-keyword">new</span> FruitFactor;<span class="hljs-comment">// 创建变量</span><br>AbstractFruit* fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">"apple"</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">"banana"</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = factory-&gt;<span class="hljs-built_in">CreateFruit</span>(<span class="hljs-string">"pear"</span>);<br>fruit-&gt;<span class="hljs-built_in">ShowName</span>();<br><span class="hljs-keyword">delete</span> fruit;<br><br>fruit = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">delete</span> factory;<br>factory = <span class="hljs-literal">NULL</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>^jw3irr</p><p>不难看出，Fruit类是一个“巨大的”类，在该类的设计中存在如下几个问题：</p><p>(1) 在Fruit类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。</p><p>(2) Fruit类的职责过重，它负责初始化和显示所有的水果对象，将各种水果对象的初始化代码和显示代码集中在一个类中实现，<strong>违反了“单一职责原则”</strong>，不利于类的重用和维护；</p><p>(3) 当需要增加新类型的水果时，<strong>必须修改Fruit类的源代码，违反了“开闭原则”。</strong></p><ul><li>&amp; 所以简单工厂模式没有列入 23 种设计模式</li></ul><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3 总结::</h1><h2 id="31-简单工厂模式的优缺点"><a class="markdownIt-Anchor" href="#31-简单工厂模式的优缺点"></a> 3.1 <strong>简单工厂模式的优缺点</strong></h2><p>优点：</p><p>(1)实现了对象创建和使用的分离。<br>(2)不需要记住具体类名，记住参数即可，减少使用者记忆量。</p><p>缺点：<br>(1)对工厂类职责过重，一旦不能工作，系统受到影响。<br>(2)<strong>违反“单一职责原则”</strong>，将各种水果对象的初始化代码和显示代码集中在一个类中实现，增加系统中类的个数，复杂度和理解度增加。<br>(3)<strong>违反“开闭原则”</strong>，添加新产品需要修改工厂逻辑，工厂越来越复杂。</p><h2 id="32-适用场景"><a class="markdownIt-Anchor" href="#32-适用场景"></a> 3.2 适用场景</h2><p>（1）工厂类负责<strong>创建的对象较少</strong>: 由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>（2）客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsq5b3m24aCiZqAxEMlm8Qi" --> <p>#历史记录::<br>2022/9/30🌵简单工厂模式 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>创建型模型</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>依赖倒转原则</title>
    <link href="/posts/53557/"/>
    <url>/posts/53557/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!summary] 依赖于抽象 (接口)，不要依赖具体的实现 (类)，也就是针对接口编程。<br>![[依赖倒转原则 2022-09-30 18.26.39.excalidraw]]</p></blockquote><h1 id="1-第一种情况-一层依赖一层"><a class="markdownIt-Anchor" href="#1-第一种情况-一层依赖一层"></a> 1 第一种情况: 一层依赖一层</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;;<br><br><br><span class="hljs-comment">//银行工作人员</span><br><span class="hljs-comment">// 这里违背了单一功能原则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankWorker</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveService</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理存款业务..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">payService</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理支付业务..."</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tranferService</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理转账业务..."</span> &lt;&lt; endl;<br>}<br><br>};<br><br><span class="hljs-comment">//中层模块, 封装好的方法</span><br><span class="hljs-comment">// 把类抽出来变成单个函数, 每个函数只做一件事</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSaveBussiness</span><span class="hljs-params">(BankWorker* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">saveService</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPayBussiness</span><span class="hljs-params">(BankWorker* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">payService</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doTranferBussiness</span><span class="hljs-params">(BankWorker* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">tranferService</span>();<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// 业务逻辑</span><br>BankWorker* worker = <span class="hljs-keyword">new</span> BankWorker;<br><span class="hljs-built_in">doSaveBussiness</span>(worker);  <span class="hljs-comment">//办理存款业务</span><br><span class="hljs-built_in">doPayBussiness</span>(worker); <span class="hljs-comment">//办理支付业务</span><br><span class="hljs-built_in">doTranferBussiness</span>(worker); <span class="hljs-comment">//办理转账业务</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-第二种情况-基于中间类"><a class="markdownIt-Anchor" href="#2-第二种情况-基于中间类"></a> 2 第二种情况: 基于中间类</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;;<br><br><span class="hljs-comment">//依赖倒转原则</span><br><span class="hljs-comment">//抽象层: 把存款, 转账等业务抽象出来</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractWorkerBank</span> { <br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 办理业务  </span><br>};<br><br><span class="hljs-comment">//只办理存款业务 :  单独设置每个函数: 先继承在重写函数, 下边函数同理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveBankWorker</span> : <span class="hljs-keyword">public</span>  AbstractWorkerBank { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写</span><br>cout &lt;&lt; <span class="hljs-string">"办理存款业务"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//只办理转账业务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferBankWorker</span> : <span class="hljs-keyword">public</span>  AbstractWorkerBank {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理转账业务"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//只办理付款业务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PayBankWorker</span> : <span class="hljs-keyword">public</span>  AbstractWorkerBank {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doBussiness</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"办理付款业务"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//💡高层模块: 依赖于抽象层</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoBankBussiness</span><span class="hljs-params">(AbstractWorkerBank* worker)</span> </span>{<br>worker-&gt;<span class="hljs-built_in">doBussiness</span>();<br><span class="hljs-keyword">delete</span> worker;<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br><br><span class="hljs-built_in">DoBankBussiness</span>(<span class="hljs-keyword">new</span> SaveBankWorker); <span class="hljs-comment">//办理存款业务</span><br><span class="hljs-built_in">DoBankBussiness</span>(<span class="hljs-keyword">new</span> TransferBankWorker); <span class="hljs-comment">//办理转账业务</span><br><span class="hljs-built_in">DoBankBussiness</span>(<span class="hljs-keyword">new</span> PayBankWorker); <span class="hljs-comment">//办理付款业务</span><br><br>}<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs0yGHY0U19xpLxTKImma6D"  --> <p>#历史记录::<br>2022/9/30🌵依赖倒转原则 : 第一次创建<br>2022/10/16: anki 复习</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>面向对象原则</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>合成复用原则</title>
    <link href="/posts/14793/"/>
    <url>/posts/14793/</url>
    
    <content type="html"><![CDATA[<h1 id="1-合成复用原则"><a class="markdownIt-Anchor" href="#1-合成复用原则"></a> 1 合成复用原则::</h1><blockquote><p>[!summary] 对于继承和组合，优先使用组合。<br>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系</p></blockquote><p>1、概念：<br>优先使用组合 contains a（聚合 has a)，而不是继承 is a 来达到目的<br>[[UML 外国小哥.excalidraw]]</p><blockquote><p>[!summary] 白箱/黑箱复用<br>继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用）</p><p>组合/聚合复用：耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用）<br>。</p></blockquote><!-- basicblock-start oid="Obsq9zKIzZUCS8raf1riTXBX" deck= "❓疑问::👨🏻‍💻code::设计模式::C++ 设计模式::面向对象原则::合成复用原则.md"--><p>2、原因：<br>继承会将实现细节暴露给子类，继承复用破坏了封装性，是白箱复用<br>使用继承时需要考虑里氏替换原则</p><p>3、优点：<br>新类对象存取成员对象只通过成员对象的接口，是黑箱复用，系统更灵活，降低耦合度，可以在运行时动态进行，<br>新对象可动态引用与成员对象类型相同的对象</p><!-- basicblock-end --><p>4、缺点：<br>需要管理较多对象</p><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCar</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>};<br><br><span class="hljs-comment">//大众车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dazhong</span> :<span class="hljs-keyword">public</span> AbstractCar {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 把 run 函数实现(重写)</span><br>cout &lt;&lt; <span class="hljs-string">"大众车启动"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//拖拉机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuolaji</span> : <span class="hljs-keyword">public</span> AbstractCar {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"拖拉机启动"</span> &lt;&lt; endl;<br>}<br>};<br><br><span class="hljs-comment">//笨方法，针对具体类 不适用继承</span><br><span class="hljs-comment">// 每个人要想开车, 都要单独继承那个车</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">// 💡人 1: 想开拖拉机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> :<span class="hljs-keyword">public</span> Tuolaji {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tuolaji</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">run</span>();<br>}<br>};<br><span class="hljs-comment">// 人 2 : 想开大众</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span> :<span class="hljs-keyword">public</span> Dazhong {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dazhong</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">run</span>();<br>}<br>};<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//💡可以使用合成复用原则</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCar</span><span class="hljs-params">(AbstractCar* car)</span> </span>{ <span class="hljs-comment">// 创建一个抽象车的变量</span><br><span class="hljs-keyword">this</span>-&gt;car = car;<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Doufeng</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;car-&gt;<span class="hljs-built_in">run</span>();<br><span class="hljs-comment">// 类似析构函数, 释放指针, 也可以在外边写成析构函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;car != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;car;<br><span class="hljs-keyword">this</span>-&gt;car = <span class="hljs-literal">NULL</span>;<br>}<br>}<br><br><span class="hljs-keyword">public</span>:<br>AbstractCar* car; <span class="hljs-comment">// 抽象出来car指针, 写一个类来解决问题</span><br>};<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br>Person* p = <span class="hljs-keyword">new</span> Person;<br>p-&gt;<span class="hljs-built_in">setCar</span>(<span class="hljs-keyword">new</span> Dazhong); <span class="hljs-comment">// 传入什么开什么</span><br>p-&gt;<span class="hljs-built_in">Doufeng</span>();<br><br>p-&gt;<span class="hljs-built_in">setCar</span>(<span class="hljs-keyword">new</span> Tuolaji);<br>p-&gt;<span class="hljs-built_in">Doufeng</span>();<br><br><span class="hljs-keyword">delete</span> p;<br>}<br><br><br><span class="hljs-comment">//继承和组合优先使用组合</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsL6awL3zwRbLriSZBmPRDw"  --> <p>#历史记录:: <a href="marginnote3app://note/262903F4-1774-445A-88FE-A9457DEB99AE">margin: 组合复用原则</a><br>2022/9/30🌵合成复用原 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>面向对象原则</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>迪米特原则（最少知道原则）</title>
    <link href="/posts/10716/"/>
    <url>/posts/10716/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><p>概念：<br>一个对象应当对其他对象有尽可能少的了解，即不和陌生人说话<br>"朋友圈"概念（以下情况是该对象朋友）：</p><p>1、 this:</p><ol><li>该对象方法中的参数</li><li>实例变量直接引用的对象</li><li>实例变量如果是一个聚集 （聚合对象），聚集中的元素</li><li>该对象方法中创建的变量</li></ol><p>2、要求：</p><ol><li>优先考虑将一个类设计成不变类</li><li>尽量降低一个类的访问权限</li><li>谨慎使用 Serializable（持久化，通过序列化一个对象，将其写入磁盘，以后程序调用时重新恢复该对象）</li><li>尽量降低成员的访问权限</li></ol><p>3、优点：降低类之间的耦合</p><p>4、缺点：过多使用迪米特法则，会产生大量中介类，设计变复杂</p><p>尽量在知道越少的情况下, 把事情办好</p><blockquote><p>[!tip]   一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）</p></blockquote><h1 id="2-案例"><a class="markdownIt-Anchor" href="#2-案例"></a> 2 案例::</h1><p>![[迪米特原则（最少知道原则） 2022-09-30 16.37.13.excalidraw]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//迪米特原则，又叫最少知道原则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBuilding</span> {<span class="hljs-comment">// 💡抽象类, 应该是虚函数的原因吧</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//楼盘A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildingA</span> :<span class="hljs-keyword">public</span> AbstractBuilding { <span class="hljs-comment">// 继承</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">// ❗️public 下别人才能访问到</span><br><span class="hljs-built_in">BuildingA</span>() { <br>mQuilty = <span class="hljs-string">"高品质"</span>; <span class="hljs-comment">// 设置属性</span><br>};<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写父类函数</span><br>cout &lt;&lt; <span class="hljs-string">"楼盘A"</span> &lt;&lt; mQuilty&lt;&lt;<span class="hljs-string">"被售卖！"</span>&lt;&lt;endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mQuilty;<br>}<br><span class="hljs-keyword">public</span>:<br>string mQuilty; <span class="hljs-comment">// 创建一个属性 </span><br>};<br><br><span class="hljs-comment">// ---🌵下边同理---</span><br><br><span class="hljs-comment">//楼盘B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuildingB</span> :<span class="hljs-keyword">public</span> AbstractBuilding {<br><span class="hljs-keyword">public</span>: <br><span class="hljs-built_in">BuildingB</span>() { mQuilty = <span class="hljs-string">"低品质"</span>; };<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span> </span>{<br>cout &lt;&lt; <span class="hljs-string">"楼盘B"</span> &lt;&lt; mQuilty &lt;&lt; <span class="hljs-string">"被售卖！"</span> &lt;&lt; endl;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">getQuality</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mQuilty;<br>}<br><span class="hljs-keyword">public</span>:<br>string mQuilty;<br>};<br><br><span class="hljs-comment">//用户调用v1: 💡一个一个的去问价, 这样不好</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br>BuildingA* ba = <span class="hljs-keyword">new</span> BuildingA;<br><span class="hljs-comment">// 判断低品质楼盘是否被售卖</span><br><span class="hljs-keyword">if</span> (ba-&gt;mQuilty == <span class="hljs-string">"低品质"</span>) { <br>ba-&gt;<span class="hljs-built_in">sale</span>();<br>}<br><br>BuildingB* bb = <span class="hljs-keyword">new</span> BuildingB;<br><span class="hljs-keyword">if</span> (bb-&gt;mQuilty == <span class="hljs-string">"低品质"</span>) {<br>bb-&gt;<span class="hljs-built_in">sale</span>();<br>}<br>}<br><br><span class="hljs-comment">//💡增加一个中介类, 用来维护楼盘</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> { <span class="hljs-comment">// 也可以是抽象类, 比如有中介 A, 中介 B. 如果以后好要好拓展的话, 必须做成抽象类</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Mediator</span>() {<br>AbstractBuilding* building = <span class="hljs-keyword">new</span> BuildingA; <span class="hljs-comment">// 创建 A 楼盘</span><br>vBuilding.<span class="hljs-built_in">push_back</span>(building);<span class="hljs-comment">// 添加新楼盘</span><br>building = <span class="hljs-keyword">new</span> BuildingB;<span class="hljs-comment">// 同理</span><br>vBuilding.<span class="hljs-built_in">push_back</span>(building);<br>};<br><br><span class="hljs-comment">//对外提供接口: 💡用户是需要某一个楼盘, 所以函数返回值是楼盘指针</span><br><span class="hljs-function">AbstractBuilding* <span class="hljs-title">findMyBuilding</span><span class="hljs-params">(string quality)</span> </span>{ <span class="hljs-comment">// 参数: 提供想要什么样的品质的房子</span><br><span class="hljs-comment">//for (vector&lt;AbstractBuilding*&gt;::iterator it = vBuilding.begin(); it != vBuilding.end(); it++) {</span><br><span class="hljs-comment">//if ((*it)-&gt;getQuality() == quality){</span><br><span class="hljs-comment">//return *it;</span><br><span class="hljs-comment">//}</span><br><span class="hljs-comment">//}</span><br><span class="hljs-comment">// 💡这样写更好</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : vBuilding) {<br><span class="hljs-keyword">if</span> ((it)-&gt;<span class="hljs-built_in">getQuality</span>() == quality) {<br><span class="hljs-keyword">return</span> it; <span class="hljs-comment">// 返回想要楼盘</span><br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>}<br><br>~<span class="hljs-built_in">Mediator</span>() { <span class="hljs-comment">// 析构函数, 用来释放函数</span><br><span class="hljs-keyword">for</span> (vector&lt;AbstractBuilding*&gt;::iterator it = vBuilding.<span class="hljs-built_in">begin</span>(); it != vBuilding.<span class="hljs-built_in">end</span>(); it++) {<br><span class="hljs-keyword">if</span> (*it != <span class="hljs-literal">NULL</span>) {<br><span class="hljs-keyword">delete</span> *it;<br>}<br>}<br>}<br><span class="hljs-keyword">public</span>:<br>vector&lt;AbstractBuilding*&gt; vBuilding; <span class="hljs-comment">// 💡创建一个抽象的楼盘, 方便 管理所有楼盘</span><br>};<br><span class="hljs-comment">// 用户调用 v2: 直接跟中介打交道</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{<br>Mediator* mediator = <span class="hljs-keyword">new</span> Mediator;<br><br>AbstractBuilding* building = mediator-&gt;<span class="hljs-built_in">findMyBuilding</span>(<span class="hljs-string">"高品质"</span>);<br><br><span class="hljs-keyword">if</span> (building != <span class="hljs-literal">NULL</span>) {<br>building-&gt;<span class="hljs-built_in">sale</span>();<br>}<br><span class="hljs-keyword">else</span> {<br>cout &lt;&lt; <span class="hljs-string">"没有符合您条件的楼盘！"</span> &lt;&lt; endl;<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test02</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRrR88KlayiXedR3qO1jYy" deck = "👨🏻‍💻code::设计模式::C++ 设计模式::面向对象原则::迪米特原则（最少知道原则）.md" --> <p>#历史记录::<br>2022/9/30🌵迪米特原则（最少知道原则） : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>面向对象原则</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>开闭原则</title>
    <link href="/posts/65425/"/>
    <url>/posts/65425/</url>
    
    <content type="html"><![CDATA[<h1 id="1-开闭原则"><a class="markdownIt-Anchor" href="#1-开闭原则"></a> 1 开闭原则</h1><blockquote><p>[!summary] 开闭原则，对扩展开放，对修改关闭，增加功能是通过增加代码来实现，而不是去修改源代码<br>![[2. C++设计模式-面向对象原则 2022-09-30 15.15.02.excalidraw]]</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//开闭原则，对扩展开放，对修改关闭，增加功能是通过增加代码来实现，而不是去修改源代码</span><br><br><br><span class="hljs-comment">//写一个抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCaculator</span> {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// virtual 虚函数关键字</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>= <span class="hljs-number">0</span>;<br>};<br><br><span class="hljs-comment">//加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlusCalcultor</span> :<span class="hljs-keyword">public</span> AbstractCaculator { <span class="hljs-comment">// 继承抽象类</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;mA = a;<br><span class="hljs-keyword">this</span>-&gt;mB = b;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 重写抽象类的函数</span><br><span class="hljs-keyword">return</span> mA + mB;<br>}<br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 定义两个操作数</span><br><span class="hljs-type">int</span> mA;<br><span class="hljs-type">int</span> mB;<br>};<br><br><span class="hljs-comment">// 下边同理, 增加功能只是增加类, 而没有修改原代码</span><br><br><span class="hljs-comment">//减法计算器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinuteCalcultor</span> :<span class="hljs-keyword">public</span> AbstractCaculator {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;mA = a;<br><span class="hljs-keyword">this</span>-&gt;mB = b;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mA - mB;<br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mA;<br><span class="hljs-type">int</span> mB;<br>};<br><br><span class="hljs-comment">//乘法计算器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplyCalcultor</span> :<span class="hljs-keyword">public</span> AbstractCaculator {<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setOperatorNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br><span class="hljs-keyword">this</span>-&gt;mA = a;<br><span class="hljs-keyword">this</span>-&gt;mB = b;<br>}<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">return</span> mA * mB;<br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mA;<br><span class="hljs-type">int</span> mB;<br>};<br><span class="hljs-comment">// ---</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// 用加法计算器, 就 new 那个类</span><br>AbstractCaculator* calcultor = <span class="hljs-keyword">new</span> PlusCalcultor;<br>calcultor-&gt;<span class="hljs-built_in">setOperatorNumber</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<br>cout&lt;&lt;calcultor-&gt;<span class="hljs-built_in">getResult</span>()&lt;&lt;endl;<br><br><span class="hljs-keyword">delete</span> calcultor;  <span class="hljs-comment">//不删除的话就变成一个野指针了</span><br><br>calcultor = <span class="hljs-keyword">new</span> MinuteCalcultor;<br>calcultor-&gt;<span class="hljs-built_in">setOperatorNumber</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; calcultor-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">delete</span> calcultor;<br>calcultor = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">//需要立刻置为NULL</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">test01</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>[[this 指针]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs9mqw4bbQs5GtDqV3JoDHx"  --> <p>#历史记录::<br>2022/9/30🌵开闭原则 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>面向对象原则</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>this 指针</title>
    <link href="/posts/39691/"/>
    <url>/posts/39691/</url>
    
    <content type="html"><![CDATA[<h1 id="1-用法"><a class="markdownIt-Anchor" href="#1-用法"></a> 1 用法::</h1><p>![[this 指针 2022-09-30 15.56.56.excalidraw]]</p><ol><li><p>tihs 指针不占用类的内存</p></li><li><p>this 指针存的是什么<br>1.对于构造函数是本身的地址，</p><ol start="2"><li>对于成员函数: 是用调用对象的首地址</li></ol></li><li><p>静态的成员函数是没办法操作this？为什么？<br>静态函数先于对象存在 是所有对象共有的 没有this<br><a href="https://www.bilibili.com/video/BV1C7411Y7Kb/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=892.941194">14:52</a></p></li></ol><h1 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2 原理::</h1><p>![[this 指针 2022-09-30 16.09.51.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsdfc8wLx6VitFN6dX3VVXy"  --> <p>#历史记录::<br>2022/9/30🌵this 指针 : 第一次创建</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1C7411Y7Kb/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">【小神仙讲 c++教程】this指针讲解_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. C++设计模式-面向对象原则</title>
    <link href="/posts/34643/"/>
    <url>/posts/34643/</url>
    
    <content type="html"><![CDATA[<p>学习设计模式将有助于更加深入地理解面向对象思想，让你知道::</p><ol><li>如何将代码分散在几个不同的类中？</li><li>为什么要有“接口”？</li><li>何谓针对抽象编程？</li><li>何时不应该使用继承？</li><li>如果不修改源代码增加新功能？ N</li><li>更好地阅读和理解现有类库与其他系统中的源代码。<br>学习设计模式会让你早点脱离面向对象编程的"菜乌期〞。</li></ol><h1 id="1-面向对象设计原则"><a class="markdownIt-Anchor" href="#1-面向对象设计原则"></a> 1 <a href="https://so.csdn.net/so/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1&amp;spm=1001.2101.3001.7020">面向对象</a>设计原则</h1><p>向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。<br>面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。</p><blockquote><p>[!summary] 原则的目的：高内聚，低耦合</p></blockquote><p>![[2. C++设计模式-面向对象原则 2022-09-30 14.45.46.excalidraw]]</p><h2 id="11-开闭原则非常重要"><a class="markdownIt-Anchor" href="#11-开闭原则非常重要"></a> 1.1 [[开闭原则]]::非常重要</h2><h2 id="12-迪米特原则最少知道原则"><a class="markdownIt-Anchor" href="#12-迪米特原则最少知道原则"></a> 1.2 [[迪米特原则（最少知道原则）]]</h2><h2 id="13-合成复用原则"><a class="markdownIt-Anchor" href="#13-合成复用原则"></a> 1.3 [[合成复用原则]]</h2><h2 id="14-依赖倒转原则"><a class="markdownIt-Anchor" href="#14-依赖倒转原则"></a> 1.4 [[依赖倒转原则]]</h2><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsIq0nAuWPTqgNuu6yo2PJi"  --> <p>#历史记录::<br>2022/9/30🌵2. C++设计模式-面向对象原则 :<br>2022/10/16: anki 复习</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>设计模式</category>
      
      <category>C++ 设计模式</category>
      
      <category>面向对象原则</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯法能解决n层for循环的问题</title>
    <link href="/posts/47391/"/>
    <url>/posts/47391/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第77题-组合"><a class="markdownIt-Anchor" href="#1-第77题-组合"></a> 1 第77题. 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入:&nbsp;n = 4, k = 2<br>输出:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">[  <br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],  <br>]<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObskdNGepvmQRtT1ysKQnMMv" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>本题这是回溯法的经典题目。</p><p>直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。</p><p>代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>输入：n = 100, k = 3 那么就三层for循环，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = j + <span class="hljs-number">1</span>; u &lt;= n; n++) {<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; u &lt;&lt; endl;<br>        }<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><strong>如果n为100，k为50呢，那就50层for循环，是不是开始窒息</strong>。</p><p><strong>此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！</strong></p><p>咋整？</p><p>回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。</p><p>那么回溯法怎么暴力搜呢？</p><p>上面我们说了<strong>要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题</strong>。</p><p>递归来做层叠嵌套（可以理解是开k层for循环），<strong>每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了</strong>。</p><p>此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。<br>eg: [[2.组合问题|2.组合问题]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs8BXO897x6RWPCu6wz5afF" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::回溯法能解决n层for循环的问题.md" --> <p>#历史记录::<br>2022/9/28🌵回溯法能解决n层for循环的问题 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++新特性</title>
    <link href="/posts/24592/"/>
    <url>/posts/24592/</url>
    
    <content type="html"><![CDATA[<h1 id="1-constexpr和const-c新特性"><a class="markdownIt-Anchor" href="#1-constexpr和const-c新特性"></a> 1 [[constexpr和const  (C++新特性)]]::</h1><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs4CjFnETiHrllICn2EFFV2" deck = "👨🏻‍💻code::C++::C++基础::C++新特性.md" --> <p>#历史记录::<br>2022/9/27🌵C++新特性 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>33. 二叉总结篇</title>
    <link href="/posts/34644/"/>
    <url>/posts/34644/</url>
    
    <content type="html"><![CDATA[<ul><li><blockquote><p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93">代码随想录</a></p></blockquote></li></ul><!-- basicblock-start oid="ObsjdkiiY5tysXh4RCgbY7mg" --> <h1 id="1-如何选择遍历顺序"><a class="markdownIt-Anchor" href="#1-如何选择遍历顺序"></a> 1 如何选择遍历顺序::</h1><ul><li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li><li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li><li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li></ul><p>注意在普通二叉树的属性中，我用的是一般为后序，例如: 单纯求深度就用前序，[[13. 二叉树的所有路径]]也用了前序，这是为了方便让父节点指向子节点。</p><p>所以求普通二叉树的属性还是要具体问题具体分析。</p><!-- basicblock-end --><p>![[33. 二叉总结篇 2022-09-27 11.35.38.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsKKiINwntYPzar7npw2rMj" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::33. 二叉总结篇.md" --> <p>#历史记录::<br>2022/9/27🌵33. 二叉总结篇 : ⏱0-10</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33. 把二叉搜索树转换为累加树</title>
    <link href="/posts/61698/"/>
    <url>/posts/61698/</url>
    
    <content type="html"><![CDATA[<h1 id="1-538把二叉搜索树转换为累加树"><a class="markdownIt-Anchor" href="#1-538把二叉搜索树转换为累加树"></a> 1 538.把二叉搜索树转换为累加树</h1><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">力扣题目链接</a></p><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node&nbsp;的新值等于原树中大于或等于&nbsp;node.val&nbsp;的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><p>节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20201023160751832.png" alt="538.把二叉搜索树转换为累加树"></p><ul><li>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</li><li>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</li></ul><p>示例 2：</p><ul><li>输入：root = [0,null,1]</li><li>输出：[1,null,1]</li></ul><p>示例 3：</p><ul><li>输入：root = [1,0,2]</li><li>输出：[3,3,2]</li></ul><p>示例 4：</p><ul><li>输入：root = [3,2,4,1]</li><li>输出：[7,9,4,10]</li></ul><p>提示：</p><ul><li>树中的节点数介于 0 和 104 之间。</li><li>每个节点的值介于 -104 和 104 之间。</li><li>树中的所有值 互不相同 。</li><li>给定的树为二叉搜索树。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>二叉搜索树, 反中序遍历得到递减数组</p><p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。<br>这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，<br>并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过, 用 pre cur(carl 版) 指针就不用在定义一个 sum 变量了(下次看看)⏱0-24</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❗️sum 得放到函数外边, 不然每次递归的时候就重置</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">convertBST</span>(root-&gt;right);<br>        sum += root-&gt;val;<br>        root-&gt;val = sum;<br>        <span class="hljs-built_in">convertBST</span>(root-&gt;left);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs45Ym7GBgeih6pzHoOpalp" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::33. 把二叉搜索树转换为累加树.md" --> <p>#历史记录::<br>2022/9/27🌵33. 把二叉搜索树转换为累加树 : v1, 通过, 用 pre cur(carl 版) 指针就不用在定义一个 sum 变量了 ⏱0-24</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>32. 将有序数组转换为二叉搜索树</title>
    <link href="/posts/16177/"/>
    <url>/posts/16177/</url>
    
    <content type="html"><![CDATA[<h1 id="1-108将有序数组转换为二叉搜索树"><a class="markdownIt-Anchor" href="#1-108将有序数组转换为二叉搜索树"></a> 1 108.将有序数组转换为二叉搜索树</h1><p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">力扣题目链接</a></p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点&nbsp;的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p><img src="https://img-blog.csdnimg.cn/20201022164420763.png" alt="108.将有序数组转换为二叉搜索树"></p><!-- basicblock-start oid="Obs22xPCUGNbwpZPC3aGHhsE" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obs0Dsnzk3RGcsOkyNNLhVD5" --> <p>题目中说要转换为一棵高度平衡二叉搜索树。这和转换为一棵普通二叉搜索树有什么差别呢::<br>其实这里不用强调平衡二叉搜索树，数组构造二叉树，构成平衡树是自然而然的事情，因为<strong>大家默认都是从数组中间位置取值作为节点元素</strong>，一般不会随机取，所以想构成不平衡的二叉树是自找麻烦。</p><!-- basicblock-end --><p>如果根据数组构造一棵二叉树。<br><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。<br>[[18. 从中序与后序遍历序列构造二叉树]]<br>[[19. 最大二叉树]]<br>本题要比上边两道题简单点, 为有序数组构造二叉搜索树，寻找分割点就比较容易了。<br>分割点就是数组中间位置的节点。</p><p>那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？<br>取哪一个都可以，只不过构成了不同的平衡二叉搜索树<br>![[32. 将有序数组转换为二叉搜索树 2022-09-27 10.36.43.excalidraw]]</p><!-- basicblock-start oid="Obsq70n6W7jnqmTZnWc5R4wN" --> <h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><!-- basicblock-end --><p>构造树一般用前序遍历<br>v1, 二叉树有多个, 执行代码不符合没事的, 能通过⏱0-55<br>题解有个左闭右开的写法没看懂</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector%<span class="hljs-number">3</span>Cint%<span class="hljs-number">3</span>E&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>{<br>        <span class="hljs-keyword">if</span>(left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span> (nums[mid]);<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, mid<span class="hljs-number">-1</span>);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, mid+<span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>       <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYFfG1QsXhcRp6fgFuq7eG" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::32. 将有序数组转换为二叉搜索树.md" --> <p>#历史记录::<br>2022/9/27🌵32. 将有序数组转换为二叉搜索树 :v1, 二叉树有多个, 执行代码不符合没事的, 能通过⏱0-55</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>挤出切削制备梯度结构铝带材的新工艺及机理</title>
    <link href="/posts/39144/"/>
    <url>/posts/39144/</url>
    
    <content type="html"><![CDATA[<p>挤出切削制备梯度结构铝带材的新工艺及机理::<br>2022/9/28🌵</p><!-- basicblock-end --><blockquote><p><a href="marginnote3app://note/4F1AF518-98F3-4F7B-B287-0D6FF4C9F7C6">margin</a></p></blockquote><!-- basicblock-start oid="ObsOmqHBx3T1yWz5yAgxvkyb" --> <p><strong>摘要</strong>::</p><!-- basicblock-end --><p>研究结果表明,随着挤出厚度的增加,高应变区范围无明显变化,但低应变区增大,更多的材料从侧向挤出。<br>挤出切削制备的梯度结构铝带材晶粒细化显著,硬度提升明显,晶粒尺寸与硬度在厚度层上均呈明显的梯度分布规律。<br>制备的梯度结构铝带材的拉伸强度随着挤出厚度的增加呈下降趋势,而延伸率有所上升。<br>相比原始样品,梯度结构铝带材的拉伸强度几乎提升了一倍,而延伸率仅略微下降。</p><!-- basicblock-start oid="ObszpDSVAW4ynoQ8IqguoV6u" --> <h1 id="1-挤出切削原理与实验设计"><a class="markdownIt-Anchor" href="#1-挤出切削原理与实验设计"></a> 1: 挤出切削原理与实验设计::</h1><!-- basicblock-end --><p>![[挤出切削变形区示意图.30.excalidraw|900]]<br>考虑到在室温下进行加工, 热传递系数设为 40 (N/s)/(mm/ ) ℃ 。 模 拟 中 , 挤 出 厚 度 值 分 别 设 为1.0 mm、1.2 mm、1.4 mm 和 1.6 mm,挤压速度设为 20 mm/s,不设置背压,保证其他参数不变。有限元计算步长为 0.02 mm, 总步数为 2 500 步, 选择稳态时间作为模拟结果。</p><!-- basicblock-start oid="Obs5ym8ruT8wW6NBO7VHnl5v" --> <h1 id="2-挤出切削成形过程"><a class="markdownIt-Anchor" href="#2-挤出切削成形过程"></a> 2: 挤出切削成形过程::</h1><!-- basicblock-end --><p>挤出切削不同阶段成形过程::<br>![[挤出切削不同阶段成形过程.excalidraw]]</p><!-- basicblock-start oid="ObsjhN8plgPXjC2A9BXSi6Ha" --> <h2 id="21-材料流速"><a class="markdownIt-Anchor" href="#21-材料流速"></a> 2.1: 材料流速::</h2><!-- basicblock-end --><p>![[不同挤出厚度下的材料流速分布图.excalidraw]]</p><!-- basicblock-start oid="ObsQVdbbnTxKdl2xZsiJXO7s" --> <h2 id="22-等效应变"><a class="markdownIt-Anchor" href="#22-等效应变"></a> 2.2: 等效应变::</h2><!-- basicblock-end --><p>![[不同挤出厚度下的等效应变分布图.excalidraw]]</p><!-- basicblock-start oid="Obsf7f991VVsPcxziKgGbEL9" --> <h2 id="23-等效应变率"><a class="markdownIt-Anchor" href="#23-等效应变率"></a> 2.3: 等效应变率::</h2><!-- basicblock-end --><p>![[不同挤出厚度下的等效应变率分布图.excalidraw]]</p><!-- basicblock-start oid="Obs9X8Ra8u78Jcb28iuEwIEo" --> <h2 id="24-等效应力"><a class="markdownIt-Anchor" href="#24-等效应力"></a> 2.4: 等效应力::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 21.38.34.excalidraw]]</p><h2 id="25-温度分布"><a class="markdownIt-Anchor" href="#25-温度分布"></a> 2.5: 温度分布</h2><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 21.54.18.excalidraw]]</p><h1 id="3-挤出切削实验结果分析"><a class="markdownIt-Anchor" href="#3-挤出切削实验结果分析"></a> 3: 挤出切削实验结果分析</h1><!-- basicblock-start oid="Obst1taKUKec30Y2sZt5T9Dh" --> <h2 id="31-成形效果"><a class="markdownIt-Anchor" href="#31-成形效果"></a> 3.1: 成形效果::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 22.05.13.excalidraw]]</p><!-- basicblock-start oid="ObsPMwrdVIMLIBBsMl6TF6JX" --> <h2 id="32-纯铝材料微观组织"><a class="markdownIt-Anchor" href="#32-纯铝材料微观组织"></a> 3.2: 纯铝材料微观组织::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-26 22.10.23.excalidraw]]</p><p>![[晶粒尺寸分布情况.excalidraw]]</p><!-- basicblock-start oid="ObsKGDbQrKgvML5Baw4qtDR1" --> <h2 id="33-梯度结构铝带材的硬度"><a class="markdownIt-Anchor" href="#33-梯度结构铝带材的硬度"></a> 3.3: 梯度结构铝带材的硬度::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-27 11.50.29.excalidraw]]</p><!-- basicblock-start oid="Obsl09KS99NlHQRAk2CJ2utM" --> <h2 id="34-梯度结构铝带材的拉伸性能"><a class="markdownIt-Anchor" href="#34-梯度结构铝带材的拉伸性能"></a> 3.4: 梯度结构铝带材的拉伸性能::</h2><!-- basicblock-end --><p>![[挤出切削制备梯度结构铝带材的新工艺及机理 2022-09-27 12.06.20.excalidraw]]</p><!-- basicblock-start oid="ObsjbPtgt7RHVsHY86kslTK5" --> <h1 id="4-结论"><a class="markdownIt-Anchor" href="#4-结论"></a> 4: 结论::</h1><!-- basicblock-end --><h2 id="41"><a class="markdownIt-Anchor" href="#41"></a> 4.1:</h2><p>通过数值模拟可知挤出切削成形过程可分为三个阶段: 分别是初始切入阶段、初始成形阶段和稳定成形阶段。<br><strong>带材厚度层上的应变梯度明显</strong>,<br>带材根部在挤出通道内形成**Y字形高应变率区域和高温区域 <strong>,<br>应力集中在带材根部与刀具倒棱刀刃的接触部分(B 点)<br>随着挤出厚度的增大,高应变区范围基本无变化,低应变区在厚度层中占比更大</strong>,而应力、应变率和温度的变化均不是很明显。<br>在实际加工中,随着挤出厚度的增加,材料侧向挤出流动时所受挤出通道的限制减弱,导致侧向流出的材料增多,意味着材料转化率提高。</p><h2 id="42"><a class="markdownIt-Anchor" href="#42"></a> 4.2:</h2><p>经过挤出切削加工后,铝带材的晶粒细化显著,沿厚度层方向呈梯度分布,具体表现为带材B 侧细晶层有大量尺寸均匀的细晶分布,<br>从 B 侧到A 侧塑性变形程度减弱,细晶逐渐过渡为尺寸较大的拉长晶。<br>应变的梯度变化导致晶粒尺寸呈梯度分布, <strong>高应变区域的晶粒细化比低应变区的更为彻底</strong>。</p><h2 id="43"><a class="markdownIt-Anchor" href="#43"></a> 4.3:</h2><p>相比纯铝原始材料,梯度结构铝带材的硬度显著提高,抗拉强度为原材料的两倍左右,而延伸率有所下降。<br>晶粒尺寸的梯度变化也导致硬度呈梯度分布。<br><strong>随着挤出厚度的增大,梯度结构铝带材的抗拉强度与延伸率呈“倒置”关系,即抗拉强度下降的同时延伸率提高</strong>。</p><h2 id="44"><a class="markdownIt-Anchor" href="#44"></a> 4.4:</h2><p>挤出切削工艺能够通过改变挤出厚度<strong>实现晶粒沿厚度方向呈不同程度的细化梯度,协调细晶区和粗晶区在厚度层中的占比</strong>,从而兼顾材料的强度和塑性,<br>一步法制备综合性能良好的梯度超细晶结构材料,突破了传统大塑性变形工艺所制备超细晶材料塑性显著降低的局限性,使得材料应用更加广泛。</p><h2 id="45"><a class="markdownIt-Anchor" href="#45"></a> 4.5:</h2><p>挤出切削用于制备梯度材料可行,而且工艺简单, 效率高, 可适用其他大多数中低强度金属。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
      <category>论文学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>31. 修剪二叉搜索树</title>
    <link href="/posts/13253/"/>
    <url>/posts/13253/</url>
    
    <content type="html"><![CDATA[<h1 id="1-修剪二叉搜索树"><a class="markdownIt-Anchor" href="#1-修剪二叉搜索树"></a> 1 修剪二叉搜索树</h1><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">力扣题目链接</a></p><p>给定一个二叉搜索树，同时给定最小边界L&nbsp;和最大边界&nbsp;R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p><img src="https://img-blog.csdnimg.cn/20201014173115788.png" alt="669.修剪二叉搜索树|500"></p><p><img src="https://img-blog.csdnimg.cn/20201014173219142.png" alt="669.修剪二叉搜索树1|500"></p><!-- basicblock-start oid="ObszVInIZro8xkDRE6sZWQl8" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>![[31. 修建二叉搜索树 2022-09-26 10.49.52.excalidraw]]</p><ul><li>对根结点 root进行深度优先遍历。对于当前访问的结点，如果结点为空结点，直接返回空结点；</li><li>如果结点的值小于 low，那么说明该结点及它的左子树都不符合要求，我们返回对它的右结点进行修剪后的结果；</li><li>如果结点的值大于high，那么说明该结点及它的右子树都不符合要求，我们返回对它的左子树进行修剪后的结果；</li><li>如果结点的值位于区间 [low,high]，<ul><li>$ 我们将结点的左结点设为对它的左子树修剪后的结果，</li><li>$ 右结点设为对它的右子树进行修剪后的结果。</li></ul></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 重点关注有❓的地方⏱0-31</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<span class="hljs-comment">// ❓return: ✅一直向下寻找符合的区间的右孩子节点</span><br>    <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>找到一条边就返回::<br>[[递归函的返回值#3 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs8wq4AlSDbqg6cWpM1V1DT" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::31. 修建二叉搜索树.md" --> <p>#历史记录::<br>2022/9/26🌵31. 修建二叉搜索树 : v1, 重点关注有❓的地方⏱0-31</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30. 删除二叉搜索树中的节点</title>
    <link href="/posts/357/"/>
    <url>/posts/357/</url>
    
    <content type="html"><![CDATA[<h1 id="1-450删除二叉搜索树中的节点"><a class="markdownIt-Anchor" href="#1-450删除二叉搜索树中的节点"></a> 1 450.删除二叉搜索树中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">力扣题目链接</a></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的&nbsp;key&nbsp;对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为&nbsp;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，h 为树的高度。</p><p>示例:</p><p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点|500"></p><!-- basicblock-start oid="ObscFkRbYK1BrgDrVtqbfU91" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end -->&gt;<p>二叉搜索树删除节点就涉及到结构调整了</p><p>根据二叉搜索树的性质<br>没找到删除的节点，遍历到空节点直接返回了            💡判断逻辑</p><p><code>// 找到了删除的节点</code></p><ul><li><p>$ 如果目标节点就是当前节点，分为以下三种情况：    💡中<br>其无左子：其<strong>右子顶替其位置</strong>，删除了该节点；<br>其无右子：其<strong>左子顶替其位置</strong>，删除了该节点；<br>其左右子节点都有：<br>1. 取其左子树<br>2. 放到其右子树的最左节点的左孩子上<br>3. 然后右子树顶替其位置，由此删除了该节点。💡转化成了其无左子</p></li><li><p>$ 如果目标节点小于当前节点值，则去左子树中删除；💡左</p></li><li><p>$ 如果目标节点大于当前节点值，则去右子树中删除；💡右</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p><!-- basicblock-start oid="Obs2nnSNEnMWGwUCzBL2MaxO" --> <h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><!-- basicblock-end --><h2 id="31"><a class="markdownIt-Anchor" href="#31"></a> 3.1</h2><p>v1, 通过, 还是很清楚的, 还可以写的简洁点, 看<a href="https://leetcode.cn/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/">别人的题解</a>, 🌵⏱1-12</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>        <span class="hljs-keyword">if</span>(root-&gt;val == key){<br>            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>){<br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 其无左子</span><br>                <span class="hljs-keyword">return</span> root-&gt;right;<span class="hljs-comment">// 💡在 return 下面就不会执行了delete, 这里不写也可以，但C++最好手动释放一下吧, 如果放在上边要重新定义一个 temp</span><br>                <span class="hljs-keyword">delete</span> root;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 其无右子</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>                <span class="hljs-keyword">delete</span> root; <br>            }<br>            <span class="hljs-keyword">else</span>{ <span class="hljs-comment">// 左右孩子都有</span><br>                TreeNode* cur = root-&gt;right;<br>                <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">NULL</span>){<span class="hljs-comment">// 找右子树的最左面的节点</span><br>                    cur = cur-&gt;left;<br>                }<br>                cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 其左子树挂到其右子树的最左面的节点的左孩子上</span><br>                <span class="hljs-keyword">return</span> root-&gt;right; <span class="hljs-comment">// 返回其右子树</span><br>                <span class="hljs-keyword">delete</span> root; <br>            }<br>        }<br>        <span class="hljs-comment">// 💡这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住，代码如下：</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right,key);<br>        <span class="hljs-keyword">return</span> root;<br>        <br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObskD4MXHAnEHdvzf71wHHH4" --> <p>这里相当于把新的节点(处理结果)返回给上一层，<br>遍历到 root 的左孩子了, 逻辑处理的结果要返回给左孩子, 这里就要 root-&gt;left接住，root-&gt;right 同理, 代码如下::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h2 id="32"><a class="markdownIt-Anchor" href="#32"></a> 3.2</h2><p>更简单的题解, 后序遍历也可</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (key &gt; root-&gt;val)    root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);     <span class="hljs-comment">// 去右子树删除</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; root-&gt;val)    root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);  <span class="hljs-comment">// 去左子树删除</span><br>        <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 当前节点就是要删除的节点</span><br>        {<br>            <span class="hljs-keyword">if</span> (! root-&gt;left)   <span class="hljs-keyword">return</span> root-&gt;right; <span class="hljs-comment">// 情况1，欲删除节点无左子</span><br>            <span class="hljs-keyword">if</span> (! root-&gt;right)  <span class="hljs-keyword">return</span> root-&gt;left;  <span class="hljs-comment">// 情况2，欲删除节点无右子</span><br>            TreeNode* node = root-&gt;right;           <span class="hljs-comment">// 情况3，欲删除节点左右子都有 </span><br>            <span class="hljs-keyword">while</span> (node-&gt;left)          <span class="hljs-comment">// 寻找欲删除节点右子树的最左节点</span><br>                node = node-&gt;left;<br>            node-&gt;left = root-&gt;left;    <span class="hljs-comment">// 将欲删除节点的左子树成为其右子树的最左节点的左子树</span><br>            root = root-&gt;right;         <span class="hljs-comment">// 欲删除节点的右子顶替其位置，节点被删除</span><br>        }<br>        <span class="hljs-keyword">return</span> root;    <br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsnJDaOfJXUh5NJtbxV2OSB" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::30. 删除二叉搜索树中的节点.md" --> <p>#历史记录::<br>2022/9/26🌵30. 删除二叉搜索树中的节点 : [第一次创建](&lt;v1, 通过, 还是很清楚的, 还可以写的简洁点, 看<a href="https://leetcode.cn/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/">别人的题解</a>, 🌵⏱1-12&gt;)</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.5 线程同步机制类封装及线程池实现</title>
    <link href="/posts/63427/"/>
    <url>/posts/63427/</url>
    
    <content type="html"><![CDATA[<h1 id="1-线程池"><a class="markdownIt-Anchor" href="#1-线程池"></a> 1 线程池</h1><p>要解决的问题::<br>平时不可能来一个客户端, 就创建一个线程, 因为如果来一万个客户端访问怎么办</p><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所 有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子 线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式:</p><ul><li>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin(轮流 选取)算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器 的整体压力。</li><li>主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任 务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线 程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在 工作队列上。</li></ul><p>![[线程池的一般模型.excalidraw]]</p><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量<br>N :如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来 说，那线程池中的线程数量最好也设置为4(或者+1防止其他因素造成的线程阻塞);</p><p>对于IO密集型的任务(<strong>客户端的访问请求</strong>)，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一 般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p><h2 id="11-总结"><a class="markdownIt-Anchor" href="#11-总结"></a> 1.1 总结</h2><ul><li>空间换时间，浪费服务器的硬件资源，换取运行效率。</li><li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</li><li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。</li><li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。<ul><li><blockquote><p>之前是来一个客户端, 就创建一个线程, 用完再销毁, 现在是不用销毁</p></blockquote></li></ul></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsKCOAsLSF0FpdgRdPXZeY5" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.5 线程同步机制类封装及线程池实现.md" --> <p>#历史记录::<br>2022/9/25🌵5.5 线程同步机制类封装及线程池实现 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.4 服务器编程基本框架和两种高效的事件处理模式</title>
    <link href="/posts/24013/"/>
    <url>/posts/24013/</url>
    
    <content type="html"><![CDATA[<h1 id="1-服务器编程基本框架"><a class="markdownIt-Anchor" href="#1-服务器编程基本框架"></a> 1 服务器编程基本框架::</h1><!-- basicblock-end --><p>![[5.4 服务器编程基本框架和两种高 效的事件处理模式 2022-09-25 15.56.51.excalidraw]]<br>I/O 处理单元是服务器管理客户连接的模块。<br>它通常要完成以下工作:</p><ul><li>等待并接受新的客户连接</li><li>接收 客户数据</li><li>将服务器响应数据返回给客户端<br>但是数据的收发不一定在 I/O 处理单元中执行，也可能在 逻辑单元中执行，具体在何处执行取决于事件处理模式。</li></ul><p>一个逻辑单元<br>通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直 接发送给客户端(具体使用哪种方式取决于事件处理模式)。<strong>服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。</strong></p><p>网络存储单元可以是数据库、缓存和文件，但不是必须的。</p><p>请求队列是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个 逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处 理竞态条件。请求队列通常被实现为池的一部分。<br>- 池: 进程池, 线程池</p><!-- basicblock-start oid="ObsyDWkdrkeCkpTkN3ylKeZ5" --> <h1 id="2-两种高效的事件处理模式"><a class="markdownIt-Anchor" href="#2-两种高效的事件处理模式"></a> 2 两种高效的事件处理模式::</h1><!-- basicblock-end --><ul><li>服务器程序通常需要处理三类事件:I/O 事件、信号及定时事件。<ul><li>I/O事件: 数据的到达与读写</li></ul></li></ul><p>有两种高效的事件处理模式:Reactor和 Proactor，<br><strong>同步 I/O 模型通常用于实现 Reactor 模式</strong><br>异步 I/O 模型通常用于实现 Proactor 模式。</p><ul><li>&amp; 本项目打算用, 同步的 I/O 模型, 模拟出 Proactor 模式</li></ul><!-- basicblock-start oid="ObsQ0hB08klpqYYuA48uN5Fy" --> <h2 id="21-reactor模式"><a class="markdownIt-Anchor" href="#21-reactor模式"></a> 2.1 Reactor模式::</h2><!-- basicblock-end --><p>要求主线程(I/O处理单元)只<strong>负责监听</strong>文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将 socket 可读可写事件放入请求队列，交给工作线程处理。<br>除此之外，主线程不做 任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步 I/O(以 epoll_wait 为例)实现的 Reactor 模式的工作流程是:</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件</li><li>当主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li></ol><p>![[Reactor 模式的工作流程.excalidraw]]</p><!-- basicblock-start oid="Obs9WOvlxhQMk3GpVPtultPm" --> <h2 id="22-proactor模式"><a class="markdownIt-Anchor" href="#22-proactor模式"></a> 2.2 Proactor模式::</h2><!-- basicblock-end --><p>Proactor 模式将所有 I/O 操作都交给主线程和内核来处理(进行读、写)，<strong>工作线程仅仅负责业务逻辑</strong>。使用异步 I/O 模型(以 aio_read 和 aio_write 为例)实现的</p><ul><li>$ Reactor模式的工作线程, 要负责读写和业务逻辑, 主线程只监听</li></ul><p>Proactor 模式的工作流程是:</p><ol><li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置， 以及读操作完成时如何通知应用程序(这里以信号为例)。</li><li>主线程继续处理其他逻辑。</li><li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li></ol><p>![[Proactor 模式的工作流程 .excalidraw]]</p><!-- basicblock-start oid="Obs5XsZ0pZj8fFFv824XsMxf" --> <h1 id="3-模拟-proactor-模式"><a class="markdownIt-Anchor" href="#3-模拟-proactor-模式"></a> 3 模拟 Proactor 模式::</h1><!-- basicblock-end --><p>使用同步 I/O 方式模拟出 Proactor 模式。原理是:主线程执行数据读写操作，读写完成之后，主线程向 工作线程通知这一”完成事件“。<strong>那么从工作线程的角度来看，它们就直接获得了数据读写的结果</strong>，接下来要做的只是对读写的结果进行逻辑处理。</p><p>使用同步 I/O 模型(以 epoll_wait为例)模拟出的 Proactor 模式的工作流程如下:</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ol><p>![[模拟 Proactor 模式的工作流程.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs4iSGdegGxq6BbSRU4qW9t" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.4 服务器编程基本框架和两种高 效的事件处理模式.md" --> <p>#历史记录::<br>2022/9/25🌵5.4 服务器编程基本框架和两种高 效的事件处理模式 : 第一次创建⏱0-51</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 协议(应用层的协议)</title>
    <link href="/posts/39549/"/>
    <url>/posts/39549/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><p>超文本传输协议(Hypertext Transfer Protocol，HTTP)是一个简单的<strong>请求 - 响应协议</strong>，<strong>它通常运行在 TCP 之上</strong>。<br>它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。<br>请求和响应消息的 头以 ASCII 形式给出;而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p><ul><li><blockquote><p>客户端给服务端发消息是请求, 服务端给客户端回消息是相应</p></blockquote></li></ul><!-- basicblock-start oid="ObsVTv1Q355JS3rRhsXBpY5H" --> <h1 id="2-概述"><a class="markdownIt-Anchor" href="#2-概述"></a> 2 概述::</h1><!-- basicblock-end --><p>HTTP 是一个客户端终端(用户)和服务器端(网站)请求和应答的标准(TCP)。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口(<strong>默认端口为80</strong>)。<br>- &gt; 一般的网站都是 80 端口, 默认不写也是 80 端口. eg: <a href="http://www.baidu.com">www.baidu.com</a> = <a href="http://www.baidu.com:80">www.baidu.com:80</a>, 实测冒号不行, 因为是网站限制<br>- $ <a href="https://www.baidu.com:80">https://www.baidu.com:80</a>访问出错是因为这里使用的是https协议，不是http协议，https协议默认端口是443，使用&nbsp;<a href="https://www.baidu.com:443">https://www.baidu.com:443</a> 就可以正常访问了</p><p>我们 称这个客户端为用户代理程序(user agent)。应答的服务器上存储着一些资源，比如 HTML 文件和图 像。我们称这个应答服务器为源服务器(origin server)。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道(tunnel)。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口(默认是80端口)的 TCP 连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比 如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><!-- basicblock-start oid="ObsMfthAg00OJbp2nwGLKik5" --> <h1 id="3-工作原理"><a class="markdownIt-Anchor" href="#3-工作原理"></a> 3 工作原理</h1><!-- basicblock-end --><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客 户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版 本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><ul><li>$ 研究的是 HTTP 报文</li></ul><!-- basicblock-start oid="Obs7qDszJjSyUkybfLVoe0WL" --> <h2 id="31-以下是-http-请求响应的步骤"><a class="markdownIt-Anchor" href="#31-以下是-http-请求响应的步骤"></a> 3.1 以下是 HTTP 请求/响应的步骤::</h2><!-- basicblock-end --><ol><li><p>客户端连接到 Web 服务器<br>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口(默认为 80 )<strong>建立一个 TCP 套接字连接</strong>. 例如，<a href="http://www.baidu.com">http://www.baidu.com</a>。(URL)</p></li><li><p>发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求 头部、空行和请求数据 4 部分组成。</p></li><li><p>服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。<strong>服务器将资源复本写到 TCP 套接字，由客户端读取</strong>。一个 响应由状态行、响应头部、空行和响应数据 4 部分组成。</p></li><li><p>释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接;若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应 头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><ul><li>~</li></ul><!-- basicblock-start oid="Obs4nccFj0T2j0myW9JYXfFY" --> <h2 id="32-网站访问的例子"><a class="markdownIt-Anchor" href="#32-网站访问的例子"></a> 3.2 网站访问的例子::</h2><!-- basicblock-end --><p>例如:在浏览器地址栏键入URL，按下回车之后会经历以下流程:</p><ol><li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p></li><li><p>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</p></li><li><p>浏览器发出读取文件( URL 中域名后面部分对应的文件)的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p></li><li><p>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</p></li><li><p>释放 TCP 连接;</p></li><li><p>浏览器将该 HTML 文本并显示内容。</p></li></ol><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232208911.png" alt="|800"></p><p>HTTP 协议是基于 TCP/IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p><ul><li>&amp; 换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</li></ul><!-- basicblock-start oid="ObsrDdFms5CG2kfXKZrLD703" --> <h1 id="4-http-请求-响应报文格式"><a class="markdownIt-Anchor" href="#4-http-请求-响应报文格式"></a> 4 HTTP 请求-响应报文格式::</h1><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232227414.png" alt="|800"></p><p>![[HTTP 协议(应用层的协议) 2022-09-23 22.30.21.excalidraw]]</p><!-- basicblock-start oid="Obsly8IhndtiuirPRqztqc80" --> <h1 id="5-http状态码"><a class="markdownIt-Anchor" href="#5-http状态码"></a> 5 HTTP状态码::</h1><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232252932.png" alt="|800"></p><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态 的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型:</p><p>1xx消息——请求已被服务器接收，继续处理<br>2xx成功——请求已成功被服务器接收、理解、并接受<br>3xx重定向——需要后续操作才能完成这一请求<br>4xx请求错误——请求含有词法错误或者无法被执行<br>5xx服务器错误——服务器在处理某个正确请求时发生错误</p><p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如"200 OK"，“404 Not Found”，但是WEB开发者仍 然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232252270.png" alt="|900"></p><p>更多状态码:<a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">https://baike.baidu.com/item/HTTP状态码/5053660?fr=aladdin</a></p><!-- basicblock-start oid="ObswjnA4vJp8dHiASiocJtpX" --> <h1 id="6-http请求方法"><a class="markdownIt-Anchor" href="#6-http请求方法"></a> 6 HTTP请求方法::</h1><!-- basicblock-end --><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209232254528.png" alt=""></p><p>HTTP/1.1 协议中共定义了八种方法(也叫“动作”)来以不同方式操作指定的资源:<br>一般都是 get 和 post</p><ol><li><p><strong>GET</strong>: 💡<strong>获取</strong>, 向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副 作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</p><ul><li>&amp; 本项目只用 GET 请求</li></ul></li><li><p>HEAD:与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文 部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该 资源的信息”(元信息或称元数据)。</p></li><li><p><strong>POST</strong>:向指定资源提交数据，请求服务器进行处理(例如提交表单或者上传文件)。数据被包含 在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><ol><li>eg: 填写个人账号</li></ol></li><li><p>PUT:向指定资源位置上传其最新内容。</p></li><li><p>DELETE:请求服务器删除 Request-URI 所标识的资源。</p></li><li><p>TRACE:回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p>OPTIONS:这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*'来代替资源名称，</p><p>向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</p></li><li><p>CONNECT:HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服</p></li></ol><p>务器的链接(经由非加密的 HTTP 代理服务器)</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyzABVQfD8rS9YOaqSFmUt" deck = "👨🏻‍💻code::项目::webserver::5 第五章::HTTP 协议(应用层的协议).md" --> <p>#历史记录::<br>2022/9/23🌵HTTP 协议(应用层的协议) ⏱1-27</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Web Server(网页服务器)</title>
    <link href="/posts/57288/"/>
    <url>/posts/57288/</url>
    
    <content type="html"><![CDATA[<h1 id="1-web-server网页服务器"><a class="markdownIt-Anchor" href="#1-web-server网页服务器"></a> 1 Web Server(网页服务器)::</h1><!-- basicblock-end --><p>一个 Web Server 就是一个服务器软件(程序)，或者是运行这个服务器软件的硬件(计算机)。<br>其主要功能是通过 HTTP 协议与<strong>客户端(通常是浏览器(Browser))</strong>,进行通信，来接收，存储，处理来自 客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容(文件、网页等)或返 回一个 Error 信息。</p><p>![[5.3 Web服务器简介及HTTP协议 2022-09-23 21.38.30.excalidraw]]<br>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则 先将你的域名<strong>解析成相应的 IP 地址</strong>或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。</p><p>这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针 对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。</p><ul><li><p>&amp; 我们研究 HTTP 协议, 就是研究它的报文</p></li><li><p>&amp; HTTP 协议它的底层是基于 TCP 协议去通信的, 因为要保证数据的安全</p></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsdXHLcceexbBUljEM7FA24" deck = "👨🏻‍💻code::项目::webserver::5 第五章::Web Server(网页服务器).md" --> <p>#历史记录::<br>2022/9/23🌵Web Server(网页服务器) : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.3 Web服务器简介及HTTP协议</title>
    <link href="/posts/39188/"/>
    <url>/posts/39188/</url>
    
    <content type="html"><![CDATA[<h1 id="1-web-server网页服务器"><a class="markdownIt-Anchor" href="#1-web-server网页服务器"></a> 1 [[Web Server(网页服务器)]]</h1><h1 id="2-http-协议应用层的协议"><a class="markdownIt-Anchor" href="#2-http-协议应用层的协议"></a> 2 [[HTTP 协议(应用层的协议)]]</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObseOfmcyKHDqmrwX43Jc2xg" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.3 Web服务器简介及HTTP协议.md" --> <p>#历史记录::<br>2022/9/23🌵5.3 Web服务器简介及HTTP协议 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.2 Unix、 Linux上的五种lO模型</title>
    <link href="/posts/43789/"/>
    <url>/posts/43789/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsefwkIjB6k2Z2ese3h5UDz" deck = "👨🏻‍💻code::项目::webserver::5  项目实战与总结::5.2 Unix、 Linux上的五种lO模型.md" --> <p>#历史记录::<br>2022/10/14🌵5.2 Unix、 Linux上的五种lO模型 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电解抛光的流程</title>
    <link href="/posts/30219/"/>
    <url>/posts/30219/</url>
    
    <content type="html"><![CDATA[<p>铝的电解抛光, 其他材料只是溶液不同</p><h1 id="1-准备工作"><a class="markdownIt-Anchor" href="#1-准备工作"></a> 1 准备工作</h1><h2 id="11-先磨样-粗磨到细磨"><a class="markdownIt-Anchor" href="#11-先磨样-粗磨到细磨"></a> 1.1 先磨样, 粗磨到细磨</h2><p>800, 1500, 2500<br>把样品夹好, 略微高出夹紧块一点(太高也不行), 一定轻拿轻放, 不然观察有凹坑<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209231804012.jpeg" alt="|200"></p><h2 id="12-在抛光"><a class="markdownIt-Anchor" href="#12-在抛光"></a> 1.2 在抛光,</h2><p>用专门的那个布, 和抛光喷剂<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209231804321.jpeg" alt="|200"></p><h2 id="13-电解失败如何处理"><a class="markdownIt-Anchor" href="#13-电解失败如何处理"></a> 1.3 电解失败如何处理</h2><p>如果之前电解失败, 观察晶相不好,  查文献得知, 铝在电解抛光前用氢氧化钠溶液先洗一遍, 可去除之前的污渍<br>1. 泡氢氧化钠溶液 1 分钟<br>2. 涮两遍水清洗掉氢氧化钠<br>1. 热水更容易洗掉<br>3. 涮一遍酒精,<br>1. 方便吹干<br>2. 也溶解氢氧化钠<br>4. 用吹风机吹干</p><p>如果还是不行, 就重新磨样(直接从高目数), 抛光, 在电解</p><h1 id="2-电解抛光"><a class="markdownIt-Anchor" href="#2-电解抛光"></a> 2 电解抛光</h1><h2 id="21-清洗样品"><a class="markdownIt-Anchor" href="#21-清洗样品"></a> 2.1 清洗样品</h2><ul><li>涮两遍清水</li><li>涮一遍酒精,<ol><li>方便吹干</li></ol></li><li>用吹风机吹干</li></ul><h2 id="22-电解"><a class="markdownIt-Anchor" href="#22-电解"></a> 2.2 电解</h2><p>溶液: 1:9 高氯酸和酒精<br>电压 20v<br>黑色是阴极, 红色是阳极</p><ul><li>用阳极夹住镊子(样品), 样品表面朝下<ul><li>因为阴极和阳极要对向, 此处阴极向上, 所以阳极要朝下</li></ul></li><li>放入电解液, 立马打开电解器开关和搅拌器开关, 放置 40 秒</li></ul><h2 id="23-最后处理"><a class="markdownIt-Anchor" href="#23-最后处理"></a> 2.3 最后处理</h2><ul><li>在电解液中放置 40 秒后, 拿出来迅速泡两遍水(清洗电解液)</li><li>放进硝酸, 大概十几, 二十秒<ul><li>洗去电解液, 洗去灰</li></ul></li><li>涮一遍酒精,  用吹风机吹干<ol><li>泡酒精是为了方便吹干</li></ol></li><li>包住样品<ul><li>拿个保鲜膜</li><li>样品表面朝上, 用保鲜膜从样品下方包,</li><li>在样品上方留一定空隙在拧一下</li></ul></li></ul><h1 id="3-简单观察"><a class="markdownIt-Anchor" href="#3-简单观察"></a> 3 简单观察</h1><p>不错的效果, 能看出来晶相<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209231801505.jpeg" alt="|700"></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObstdTiQokh0sPEuuqAKheEM" deck = "👨🏻‍🎓科研::电解抛光的流程.md" --> <p>#历史记录::<br>2022/9/23🌵电解抛光的流程 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>29. 二叉搜索树中的插入操作</title>
    <link href="/posts/35027/"/>
    <url>/posts/35027/</url>
    
    <content type="html"><![CDATA[<h1 id="1-701二叉搜索树中的插入操作"><a class="markdownIt-Anchor" href="#1-701二叉搜索树中的插入操作"></a> 1 701.二叉搜索树中的插入操作</h1><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">力扣题目链接</a></p><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p><img src="https://img-blog.csdnimg.cn/20201019173259554.png" alt="701.二叉搜索树中的插入操作|400"></p><p>提示：</p><ul><li>给定的树上的节点数介于 0 和 10^4 之间</li><li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li><li>-10^8 &lt;= val &lt;= 10^8</li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>可以不考虑改变树的结构的插入方式</strong>,  在原先基础上插入就行<br>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbk63ina5g30eo08waja.gif" alt="701.二叉搜索树中的插入操作"><br>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>需要调整二叉树的结构么？ 并不需要。</strong>。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过,  比较简单⏱ 0-25</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-comment">// 下一层将加入节点返回(上边)，本层用root-&gt;left或者root-&gt;right将其接住。</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZDoQppYekSBwSqZhoIrUy" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::29. 二叉搜索树中的插入操作.md" --> <p>#历史记录::<br>2022/9/23🌵29. 二叉搜索树中的插入操作 : v1, 通过,  比较简单⏱ 0-25</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归函数的返回值</title>
    <link href="/posts/49353/"/>
    <url>/posts/49353/</url>
    
    <content type="html"><![CDATA[<p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点:: ^03d9cc</p><h1 id="1-如果需要搜索整棵二叉树且不用处理递归返回值递归函数就不要返回值"><a class="markdownIt-Anchor" href="#1-如果需要搜索整棵二叉树且不用处理递归返回值递归函数就不要返回值"></a> 1 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值</h1><p>[[18. 路径总和|18. 路径总和]]</p><h1 id="2-如果需要搜索整棵二叉树且需要处理递归返回值递归函数就需要返回值"><a class="markdownIt-Anchor" href="#2-如果需要搜索整棵二叉树且需要处理递归返回值递归函数就需要返回值"></a> 2 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。</h1><h2 id="21-28-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#21-28-二叉搜索树的最近公共祖先"></a> 2.1 [[28. 二叉搜索树的最近公共祖先]]</h2><p>搜索一条边的写法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (递归函数(root-&gt;left)) <span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span> (递归函数(root-&gt;right)) <span class="hljs-keyword">return</span> ;<br></code></pre></td></tr></tbody></table></figure><p>搜索整个树写法：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">left = 递归函数(root-&gt;left);<br>right = 递归函数(root-&gt;right);<br>left与right的逻辑处理;<br></code></pre></td></tr></tbody></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><h1 id="3-如果要搜索其中一条符合条件的路径那么递归一定需要返回值因为遇到符合条件的路径了就要及时返回"><a class="markdownIt-Anchor" href="#3-如果要搜索其中一条符合条件的路径那么递归一定需要返回值因为遇到符合条件的路径了就要及时返回"></a> 3 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</h1><ul><li>&amp; 找到目标节点就结束递归的情况<br>eg: [[22. 二叉搜索树中的搜索#^mwvvme]]</li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsysS788jcKXNf67nwqGCgk" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::递归函数什么时候需要返回值.md" --> <p>#历史记录::<br>2022/9/23🌵递归函数什么时候需要返回值 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28. 二叉搜索树的最近公共祖先</title>
    <link href="/posts/694/"/>
    <url>/posts/694/</url>
    
    <content type="html"><![CDATA[<h1 id="1-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#1-二叉搜索树的最近公共祖先"></a> 1 二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">力扣题目链接</a></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://img-blog.csdnimg.cn/20201018172243602.png" alt="235. 二叉搜索树的最近公共祖先"></p><p>示例 1:</p><ul><li>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</li><li>输出: 6</li><li>解释: 节点 2 和节点 8 的最近公共祖先是 6。</li></ul><p>示例 2:</p><ul><li>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</li><li>输出: 2</li><li>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li></ul><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><!-- basicblock-start oid="ObsCQaDIhJ6zuxwfoFILa6R3" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>和[[26. 二叉树的最近公共祖先]]不同，普通二叉树求最近公共祖先需要使用回溯，<strong>从底向上来查找</strong>，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么<strong>只要从上向下遍历就可以了。</strong></p><p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p><p>如图所示：p为节点3，q为节点5</p><p><img src="https://img-blog.csdnimg.cn/20210204150858927.png" alt="235.二叉搜索树的最近公共祖先|500"></p><p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！<br>[[18. 路径总和#^03d9cc]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>用迭代法更好一点</p><blockquote><p>[!example]-</p><!-- basicblock-start oid="ObsQgR0cL03Riw2IWBx5gNbM" --> </blockquote><p>![[28. 二叉搜索树的最近公共祖先 2022-09-30 08.45.39.excalidraw]]::</p><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-26/">Loading Question… - 力扣（LeetCode）</a></p><h2 id="31-迭代"><a class="markdownIt-Anchor" href="#31-迭代"></a> 3.1 迭代</h2><p>v1:通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">while</span>(root) {<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) { <span class="hljs-comment">// ❗️不是 root &gt; p</span><br>                root = root-&gt;left;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) {<br>                root = root-&gt;right;<br>            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// ❗️else 不能省</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-递归"><a class="markdownIt-Anchor" href="#32-递归"></a> 3.2 递归</h2><p>v1, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br><span class="hljs-comment">// 第一种情况</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val){<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        }<br><span class="hljs-comment">// 第二种情况</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val){<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        }<br><span class="hljs-comment">// 第三种情况</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[递归函的返回值#2 1 28 二叉搜索树的最近公共祖先|递归函数什么时候需要返回值]]</p><h1 id="4-迭代"><a class="markdownIt-Anchor" href="#4-迭代"></a> 4 迭代</h1><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsJDQVCmUGJ9XRPcDGiAzEV" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::28. 二叉搜索树的最近公共祖先.md" --> <p>#历史记录::<br>2022/9/23🌵28. 二叉搜索树的最近公共祖先 : 有一点点懵, 还行⏱1-17</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27. 二叉树周末总结</title>
    <link href="/posts/56265/"/>
    <url>/posts/56265/</url>
    
    <content type="html"><![CDATA[<p>看了总结, 那个内容不多,   整理到了二叉搜索树</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsqya4STijB8A9RqffclD01" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::27. 二叉树周末总结.md" --> <p>#历史记录::<br>2022/9/23🌵27. 二叉树周末总结 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26. 二叉树的最近公共祖先</title>
    <link href="/posts/15641/"/>
    <url>/posts/15641/</url>
    
    <content type="html"><![CDATA[<h1 id="1-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#1-二叉树的最近公共祖先"></a> 1 二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:&nbsp; root =&nbsp;[3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p><p>示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p><p>示例&nbsp;2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209221119231.png" alt=""></p><ul><li><blockquote><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">题解的流程图</a></p></blockquote></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1: 看题解的流程图, 很清楚⏱1-05</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q); <span class="hljs-comment">// 左</span><br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span>  &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 公共祖先在右子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<span class="hljs-comment">// 公共祖先在左子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsFdr3s5N4yCB0XTQlmZGaN" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::26. 二叉树的最近公共祖先.md" --> <p>#历史记录::<br>2022/9/22🌵26. 二叉树的最近公共祖先 : v1: 看题解的流程图, 很清楚⏱1-05</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25. 二叉搜索树中的众数</title>
    <link href="/posts/16602/"/>
    <url>/posts/16602/</url>
    
    <content type="html"><![CDATA[<h1 id="1-501二叉搜索树中的众数"><a class="markdownIt-Anchor" href="#1-501二叉搜索树中的众数"></a> 1 501.二叉搜索树中的众数</h1><p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">力扣题目链接</a></p><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有<strong>众数（出现频率最高的元素）</strong>。</p><p>假定 BST 有如下定义：<br>[[二叉搜索树]]</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>例如：</p><p>给定 BST [1,null,2,2],</p><p><img src="https://img-blog.csdnimg.cn/20201014221532206.png" alt="501. 二叉搜索树中的众数"></p><p>返回[2].</p><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><!-- basicblock-start oid="ObsWi09KAKMcXYABbGrnRiQy" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>分两个思路: 是二叉树, 不是二叉树</p><h2 id="21-不是二叉搜索树"><a class="markdownIt-Anchor" href="#21-不是二叉搜索树"></a> 2.1 不是二叉搜索树</h2><p>[[map(🗃)]]<br>如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</p><!-- basicblock-start oid="Obs9OzCi1FIQ44aAkgQKVmlU" --> <p>map 中的排序::<br>C++中如果使用std::map或者std::multimap可以对key排序，但不能对value排序。</p><!-- basicblock-end --><!-- basicblock-start oid="ObsUuRh2eYUEnUnwoLFxdUSI" --> <h2 id="22-是二叉搜索树"><a class="markdownIt-Anchor" href="#22-是二叉搜索树"></a> 2.2 是二叉搜索树::</h2><!-- basicblock-end --><h3 id="221"><a class="markdownIt-Anchor" href="#221"></a> 2.2.1</h3><ul><li>&amp; 中序遍历搜索树, 得到有序数组. 遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了</li></ul><h3 id="222"><a class="markdownIt-Anchor" href="#222"></a> 2.2.2</h3><ul><li>$ 直接在树上操作<ul><li>使用了pre指针和cur指针,<strong>只需要遍历一遍二叉搜索树，就求出了众数的集合</strong></li></ul></li></ul><p>v1, 通过, 抄了一遍,大概明白了⏱0-40</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 第一个节点</span><br>            count = <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pre-&gt;val == cur-&gt;val){<span class="hljs-comment">// 与前一个节点数值相同</span><br>            count++;<br>        }<br>        <span class="hljs-keyword">else</span>{<span class="hljs-comment">// 与前一个节点数值不同</span><br>            count = <span class="hljs-number">1</span>;<br>        }<br>        pre = cur;<span class="hljs-comment">// 更新上一个节点</span><br><br>        <span class="hljs-keyword">if</span>(count == maxCount){<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br>        <span class="hljs-keyword">if</span>(count &gt; maxCount){<span class="hljs-comment">// 不止一个众数的时候</span><br>            maxCount = count;<span class="hljs-comment">// 更新最大频率</span><br>            result.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">// 不要忘记清空result，之前result里的元素都失效了, 因为众数不止一个</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 不会做了<br>这个是只能找出一个众数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">if</span>(pre-&gt;val == cur-&gt;val) count++;<br>        }<br><br>        <span class="hljs-keyword">else</span> count = <span class="hljs-number">1</span>;<br>        pre = cur;<br>        <span class="hljs-keyword">if</span>(count == maxCount){<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br>        <span class="hljs-keyword">if</span>(count &gt; maxCount){<br>            maxCount = count;<br>            result.<span class="hljs-built_in">clear</span>();<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        }<br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);<br>        <span class="hljs-keyword">return</span>;<br><br>        <br>        <br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsecQeY0a3GuLyXMEgccrCp" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::25. 二叉搜索树中的众数.md" --> <p>#历史记录::<br>2022/9/22🌵25. 二叉搜索树中的众数 : v1, 通过, 抄了一遍,大概明白了⏱0-40</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空类</title>
    <link href="/posts/50155/"/>
    <url>/posts/50155/</url>
    
    <content type="html"><![CDATA[<h1 id="1-不含函数或者含有函数"><a class="markdownIt-Anchor" href="#1-不含函数或者含有函数"></a> 1 不含函数或者含有函数::</h1><p>![[空类 2022-09-21 22.16.00.excalidraw]]<br>多重继承的空类的大小也是1。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father1</span>{}; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father2</span>{};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span>:Father1, Father2{};<br></code></pre></td></tr></tbody></table></figure><h1 id="2-含有虚函数"><a class="markdownIt-Anchor" href="#2-含有虚函数"></a> 2 含有虚函数::</h1><p>![[空类 2022-09-21 22.21.22.excalidraw]]</p><!-- basicblock-start oid="ObsKtq9Flxcv4NbeB7B91Ryi" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::空类.md"--><h1 id="3-何时共享虚函数地址表"><a class="markdownIt-Anchor" href="#3-何时共享虚函数地址表"></a> 3 何时共享虚函数地址表::</h1><!-- basicblock-end --><p>如果派生类继承的第一个是基类，且该基类定义了虚函数地址表，则派生类就共享该表首址占用的存储单元。<br>对于除前述情形以外的其他任何情形，派生类在处理完所有基类或虚基类后，根据派生类是否建立了虚函数地址表，确定是否为该表首址分配存储单元。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span>{}; <span class="hljs-comment">//sizeof(x)：1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X {}；<span class="hljs-comment">//sizeof(Y):4 💡虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Z</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> X {}；<span class="hljs-comment">//sizeof(z):4 💡虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Y {}；<span class="hljs-comment">//sizeof(A):8❓</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">public</span> Y, <span class="hljs-keyword">public</span> Z{}; <span class="hljs-comment">//sizeof(B)：8💡两个虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Y, <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> z {}；<span class="hljs-comment">//sizeof(c)：12 ❓</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> ：<span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> C{}；<span class="hljs-comment">//sizeof(D)：16❓</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsSTzxRkOeHVkL1rcMxavtB" deck = "👨🏻‍💻code::C++::C++基础::空类.md" --> <p>#历史记录:: <a href="https://www.bilibili.com/video/BV1LK411s7ES/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++虚函数_哔哩哔哩_bilibili</a><br>2022/9/21🌵空类 :</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么需要虚继承</title>
    <link href="/posts/54153/"/>
    <url>/posts/54153/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><p>虚继承: 使得在派生类中只保留一份间接基类的成员。</p><p>多继承: 是指从多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。</p><ul><li>&amp; 使用多继承经常出现二义性，必须十分小心； 一般只有在比较简单和不易出现二义性或者实在必要情况下才使用多继承，能用单一继承解决问题就不要用多继承。</li></ul><!-- basicblock-start oid="ObsRiK1y7O0WBisAEBS51kpj" --> <h1 id="2-目的"><a class="markdownIt-Anchor" href="#2-目的"></a> 2 目的::</h1><!-- basicblock-end --><p>虚继承的目的是让某个类做出声明，<strong>承诺愿意共享它的基类</strong><br>其中，这个被共享的基类就称为虚基类(Virtual Base Class),<br>其中A就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><!-- basicblock-start oid="ObsAHdpB4FXUD0EriY4SIJ4t" --> <h1 id="3-案例"><a class="markdownIt-Anchor" href="#3-案例"></a> 3 案例::</h1><!-- basicblock-end --><h2 id="31"><a class="markdownIt-Anchor" href="#31"></a> 3.1</h2><p>类A有一个成员变量a,不使用虚继承，那么在类D中直接访问a就会产生歧义。</p><ul><li><p>$ 编译器不知道它究竟来自A-&gt;B-&gt;D这条路径，还是来自A-&gt;C-&gt;D这条路径。</p></li><li><p>? 不是拷贝问题, 而是路径问题吗: ✅是拷贝也是路径问题<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209212204647.png" alt="|700"><br>![[为什么需要虚继承 2022-09-21 21.52.30.excalidraw]]</p></li><li><p>? ✅使用虚继承: 访问 a 只会是类 A 中的 A, 不会是 B, C 中的 a, 因为 BC 中继承的a不是类 A 的拷贝, 而直接是 A 中的 a</p></li></ul><h2 id="32"><a class="markdownIt-Anchor" href="#32"></a> 3.2</h2><p>iostream从istream和ostream直接继承而来，而istream和ostream又都继承自一个共同的名为baseios的类，是典型的菱形继承。<br>此时istream和ostream必须采用虚继承，否则将导致<strong>iostream类中保留两份baseios类的成员</strong></p><ul><li>&amp; 说明了还是拷贝了<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209212209696.png" alt="|700"></li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsuhSYsGn9BeRAJQoLYrBto" deck = "👨🏻‍💻code::C++::C++基础::为什么需要虚继承.md" --> <p>#历史记录::<br>2022/9/21🌵为什么需要虚继承 :</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多态</title>
    <link href="/posts/25357/"/>
    <url>/posts/25357/</url>
    
    <content type="html"><![CDATA[<p>多态::<br>2022/9/21</p><!-- basicblock-end --><p>![[多态 与虚函数 .excalidraw]]</p><h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1: 定义</h1><p>同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为</p><ul><li>（重载实现编译时多态，虚函数实现运行时多态)</li></ul><p>将方法定义在子类中, 每次用同样名字的函数,但是不同子类执行的不一样<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209272024506.png" alt="|500"></p><p><a href="https://www.bilibili.com/video/BV1wZ4y1B7A7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">8分钟搞懂面向对象编程 | 面向过程vs面向对象 | OOP | 封装 继承 多态_哔哩哔哩_bilibili</a></p><h1 id="2-功能"><a class="markdownIt-Anchor" href="#2-功能"></a> 2: 功能</h1><p>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，<br>赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作；</p><blockquote><p>[!summary] 简单一句话：允许将子类类型的指针赋值给父类类型的指针。</p></blockquote><h1 id="3-实现多态有两种方式"><a class="markdownIt-Anchor" href="#3-实现多态有两种方式"></a> 3: 实现多态有两种方式</h1><p>1.[[重写(覆盖override)|覆盖(override)]]：是指子类重新定义父类的虚函数的做法<br>2.[[重载(overload)|重载(overload)]]：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同)</p><ul><li>example 例如： 基类是一个抽象对象一一人，那学生、运动员也是人，而使用这个抽象对象既可以表示学生、也可以表示运动员。</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚函数</title>
    <link href="/posts/24405/"/>
    <url>/posts/24405/</url>
    
    <content type="html"><![CDATA[<p>[[虚函数的实现原理]]</p><p>![[多态 与虚函数 .excalidraw]] ^eaca62</p><p>定义:</p><p>当基类希望派生类定义适合自己的版本，就将这些函数声明成虚函数(virtual)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>{<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Vfunc</span><span class="hljs-params">()</span></span>{};<span class="hljs-comment">// 当基类希望派生类定义适合自己的版本的 Vfunc</span><br><br>};<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObspW69cHg82emHE7dIIIQoJ" --> <p>1、虚函数是动态绑定的<br>也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数，这是虚函数的基本功能。::</p><!-- basicblock-end --><!-- basicblock-start oid="Obsm7oDNTqQec1I6vbJQHXhF" --> <p>2、与多态的关系 （不同继承关系的类对象，调用同一函数产生不同行为）</p><ul><li>&amp; 调用函数的对象必须是指针或者引用</li><li>&amp; 被调用的函数必须是虚函数(virtual)，且完成了虚函数的重写（派生类中有一个跟基类的完全相同虚函数）::</li></ul><!-- basicblock-end --><!-- basicblock-start oid="ObsvJSMSzvYLJlAnldZ9BFvt" --> <p>3、动态绑定, 绑定的是动态类型<br>所对应的函数或属性依赖于对象的动态类型，发生在运行期。::</p><!-- basicblock-end --><!-- basicblock-start oid="Obsu4ScYCweLwvZklIrS9jwf" --> <p>4、构造函数不能是虚函数::<br>而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好，多态是被disable的。</p><!-- basicblock-end --><!-- basicblock-start oid="Obsr7PvRHP5hpPu57rcnnHtA" --> <p>5、虚函数的工作方式::<br>当类中至少有一个虚函数, 编译期就会为类 A生成一个虚函数表<br>依赖虚函数表vtbl工作的，表来保存虚函数地址，当我们用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。这个机制可以保证派生类中的虚函数被调用到。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209212227729.png" alt=""></p><!-- basicblock-end --><!-- basicblock-start oid="ObswXHOHy30OPDCU5xZPNNH2" --> <p>6、析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。::</p><!-- basicblock-end --><!-- basicblock-start oid="ObsNDVJqMokws0GafeU8Y2Jt" --> <p>7、将一个函数定义为纯虚函数。<br>实际上是将这个类定义为抽象类，不能实例化对象；纯虚函数通常没有定义体，但也完全可以拥有。::</p><!-- basicblock-end --><p>8、 inline, static, constructor三种函数都不能带有virtual关键字。<br>(1) inline是在编译时展开，必须要有实体。<br>内联函数是指在编译期间用被调用函数体本身来代替函数的调用指令，但虚函数的多态特性需要在运行时根据对象<br>类型才知道调用哪个虚函数，所以没法在编译时进行内联函数展开。<br>(2) static属于class自己的类相关，必须有实体；<br>static成员没有this指针。virtual函数一定要通过对象来调用，有隐藏的this指针，实例相关。</p><p>9、 析构函数可以是纯虚的<br>但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。</p><p>10、派生类的override虚函数定义必须和父类完全一致。<br>除了一个特例，如果父类中返回值是一个指针或引用，子类override时可以返回这个指针（或引用）的派生。</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsu7HQtjS477mDHwN0DQvXX" --><p>#历史记录::<br>2022/9/21🌵虚函数 :</p><!-- basicblock-end --><p><a href="https://www.bilibili.com/video/BV1LK411s7ES/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">C++虚函数_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 三大特性</title>
    <link href="/posts/3476/"/>
    <url>/posts/3476/</url>
    
    <content type="html"><![CDATA[<p>C++ 三大特性::<br>2022/9/21🌵: <a href="marginnote3app://note/025A6CAE-DC4A-44BE-85DF-74E7B59576A5">margin</a></p><!-- basicblock-end --><h1 id="1-继承"><a class="markdownIt-Anchor" href="#1-继承"></a> 1: [[继承]]</h1><h1 id="2-封装"><a class="markdownIt-Anchor" href="#2-封装"></a> 2: [[封装]]</h1><h1 id="3-多态"><a class="markdownIt-Anchor" href="#3-多态"></a> 3: [[多态]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24.二叉搜索树的最小绝对差</title>
    <link href="/posts/12931/"/>
    <url>/posts/12931/</url>
    
    <content type="html"><![CDATA[<h1 id="1-530二叉搜索树的最小绝对差"><a class="markdownIt-Anchor" href="#1-530二叉搜索树的最小绝对差"></a> 1 530.二叉搜索树的最小绝对差</h1><p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">力扣题目链接</a></p><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20201014223400123.png" alt="530二叉搜索树的最小绝对差"></p><p>提示：树中至少有 2 个节点。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-转成递增数组"><a class="markdownIt-Anchor" href="#21-转成递增数组"></a> 2.1 转成递增数组</h2><p>中序遍历转为递增数组, 在数组中 遍历一遍, 统计出最小差值</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vec.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 💡统计有序数组的最小差值</span><br>            result = <span class="hljs-built_in">min</span>(result, vec[i] - vec[i<span class="hljs-number">-1</span>]);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p><!-- basicblock-start oid="Obs28HoLjKYXLBQlGBUJjUqz" --> <h2 id="22-不转化递增数组而直接比较"><a class="markdownIt-Anchor" href="#22-不转化递增数组而直接比较"></a> 2.2 不转化递增数组而直接比较::</h2><!-- basicblock-end --><p>需要用一个pre节点记录一下cur节点的前一个节点。</p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210204153247458.png" alt="530.二叉搜索树的最小绝对差"></p><p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。<br>v1: 通过, 写了一遍, 断点调试了一遍, 感觉真正搞懂了中序遍历的过程</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-type">int</span> result = INT_MAX;   <br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void 类型不返回任何值</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-literal">NULL</span>){<br>            result = <span class="hljs-built_in">min</span>(result, cur-&gt;val - pre-&gt;val);<br>        }<br>        pre = cur;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right);<br>    }<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsOzXWLboBLrJznvS06xXV0" --> <p>找最小值::<br>先定义一个最大值</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> result = INT_MAX;<br>result = min(result, cur-&gt;val - pre-&gt;val);<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsi3UEGhMdw3d82lqs2PXUR" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::24.二叉搜索树的最小绝对差.md" --> <p>#历史记录::<br>2022/9/21🌵24.二叉搜索树的最小绝对差 : v1: 通过, 写了一遍, 断点调试了一遍, 感觉真正搞懂了中序遍历的过程⏱0-38</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23. 验证二叉搜索树</title>
    <link href="/posts/35976/"/>
    <url>/posts/35976/</url>
    
    <content type="html"><![CDATA[<h1 id="1-98验证二叉搜索树"><a class="markdownIt-Anchor" href="#1-98验证二叉搜索树"></a> 1 98.验证二叉搜索树</h1><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/">力扣题目链接</a></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210203144334501.png" alt="98.验证二叉搜索树"></p><!-- basicblock-start oid="ObshF2z7TepcKWPolt2VhfPy" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><h2 id="21-中序构造递增数组"><a class="markdownIt-Anchor" href="#21-中序构造递增数组"></a> 2.1 中序构造递增数组</h2><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p><p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了</strong></p><h3 id="211-代码"><a class="markdownIt-Anchor" href="#211-代码"></a> 2.1.1 代码</h3><p>v1, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span>{ <span class="hljs-comment">// 💡其实不需要传 vec 参数, vec 在外边定义(全局变量), 函数里边直接 push_back 就行</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void类型, 不能返回 NULL</span><br>        <span class="hljs-built_in">traversal</span>(root-&gt;left, vec);<br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;right, vec);<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">traversal</span>(root, vec);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// ❗️不能i=0, vec[i] &gt;= vec[i+1], 因为 i+1 已经超过了范围</span><br>            <span class="hljs-keyword">if</span>(vec[i<span class="hljs-number">-1</span>] &gt;= vec[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// ❗️要有'='号</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^44p3md</p><!-- basicblock-start oid="ObszbeJDwapQgPZ0NlAU4DG7" --> <p>void类型函数::<br>不能返回 NULL</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span>{<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void类型, 不能返回 NULL</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>[[for 循环]]</p><h2 id="22-直接递归判断是否是递增"><a class="markdownIt-Anchor" href="#22-直接递归判断是否是递增"></a> 2.2 直接递归判断是否是递增</h2><p>在中序遍历的过程中, 逐次比较元素是不是从小到大的<br>carl, 断点调试看懂了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> maxVal = LONG_MIN; <span class="hljs-comment">// 因为后台测试数据中有int最小值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br>        <span class="hljs-comment">// 中序遍历，验证遍历 左 &lt; 中 &lt; 右</span><br>        <span class="hljs-keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsNlPfoaZ3O3Ja9BgmtfHLh" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::23. 验证二叉搜索树.md" --> <p>#历史记录::<br>2022/9/21🌵23. 验证二叉搜索树 : 第一个思路简单, 第二个思路看懂了, 没写⏱0-33</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22. 二叉搜索树中的搜索</title>
    <link href="/posts/11655/"/>
    <url>/posts/11655/</url>
    
    <content type="html"><![CDATA[<h1 id="1-700二叉搜索树中的搜索"><a class="markdownIt-Anchor" href="#1-700二叉搜索树中的搜索"></a> 1 700.二叉搜索树中的搜索</h1><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">力扣题目地址</a></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><p><img src="https://img-blog.csdnimg.cn/20210204155522476.png" alt="700.二叉搜索树中的搜索"></p><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p><!-- basicblock-start oid="Obs4iAVyITtzgH0WdEcIwT0y" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>[[二叉搜索树]]</p><h2 id="21-迭代法"><a class="markdownIt-Anchor" href="#21-迭代法"></a> 2.1 迭代法</h2><p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。<br>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p><p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong><br>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p><p><img src="https://img-blog.csdnimg.cn/20200812190213280.png" alt="二叉搜索树"></p><p>二叉搜索树: 左小右大</p><h3 id="211-代码"><a class="markdownIt-Anchor" href="#211-代码"></a> 2.1.1 代码</h3><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) root = root-&gt;left;<span class="hljs-comment">// 节点值比目标值大, 就往小的地方找即左子树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) root = root-&gt;right;<span class="hljs-comment">// 同理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 此处就是找到的情况了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// ❗️要有找不到的情况</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>第一次看到了如此简单的迭代法，是不是感动的痛哭流涕，哭一会~</p><!-- basicblock-start oid="ObsUEjBtpnDNEmm4clXZSc4h" --> <h2 id="22-递归法"><a class="markdownIt-Anchor" href="#22-递归法"></a> 2.2 递归法::</h2><!-- basicblock-end --><p>在递归遍历的时候，什么时候直接return 递归函数的返回值，什么时候不用加这个 return呢。<br><strong>就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong>[[18. 路径总和#^03d9cc]]</p><h3 id="221-代码"><a class="markdownIt-Anchor" href="#221-代码"></a> 2.2.1 代码::</h3><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val); <span class="hljs-comment">// 💡注意这里的 return</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<span class="hljs-comment">// 💡💡之前都会用一个变量把 return 接住, 不接住的话就直接返回了</span><br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// ❗️这个不能少, 每次都要返回给 if 判断语句那里</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^mwvvme</p><p>v2 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>{ <br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// ❗️NULL 和 val 的顺序不能变</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsPTm0TSQ3ztddcJoB61gUQ" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::22. 二叉搜索树中的搜索.md" --> <p>#历史记录::<br>2022/9/21🌵22. 二叉搜索树中的搜索 :  简单题⏱0-31</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::atomic</title>
    <link href="/posts/59657/"/>
    <url>/posts/59657/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前置与后置1-1-a-是否是线程安全的"><a class="markdownIt-Anchor" href="#1-前置与后置1-1-a-是否是线程安全的"></a> 1 [[前置<ins>与后置</ins>#1 1 a 是否是线程安全的]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsQUI5zgo1uepM3fXwsixYV" --> <h1 id="2-int-ab在c中是否是线程安全的"><a class="markdownIt-Anchor" href="#2-int-ab在c中是否是线程安全的"></a> 2 int a=b在C++中是否是线程安全的::</h1><!-- basicblock-end --><p>int a = b;从C/C++语法的级别来看，这是条语句应该是原子的；但从编译器得到的汇编指令来看，由于现在计算机CPU架构体系的限制，数据不能直接从内存某处搬运到内存另外一处，必须借助寄存器中转，因此这条语句一般对应两条计算机指令，即将变量b的值搬运到某个寄存器（如eax)中，再从该寄存器搬运到变量a的内存地址中：<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209202245531.png" alt=""></p><p>既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第一条指令执行完毕后被剥夺CPU时间片，切换到另一个线程而出现不确定的情况。<br>解决办法：C++11新标准发布后改变了这种困境，新标准提供了对<strong>整形变量原子操作的相关库</strong>，即std:atomic, 这是一个模板类型：</p><ul><li>$</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">atomic</span>:<br><br>我们可以传入具体的整型类型对模板进行实例化，实际上stl库也提供了这些实例化的模板类型<br><br><span class="hljs-comment">// 初始化1</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; value;<br>value = <span class="hljs-number">99</span>;<span class="hljs-comment">// 💡通过</span><br><br><span class="hljs-comment">// 初始化2</span><br><span class="hljs-comment">//下面代码在Linux平台上无法编译通过 (指在gcc编译器）</span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; value = <span class="hljs-number">99</span>;<span class="hljs-comment">// ❗️出错, 系统不允许直接赋值, 禁止编译器自动生成</span><br><span class="hljs-comment">//出错的原因是这行代码调用的是std:：atomic的拷贝构造函数</span><br><span class="hljs-comment">//而根据c++11语言规范，std::atomic的拷贝构造函数使用=delete标记禁止编译器自动生成</span><br><span class="hljs-comment">//g++在这条规则上遵循了c++11语言规范。</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsISsGVqOe4a25Z2d5f4MoL" deck = "👨🏻‍💻code::C++::C++基础::stdatomic.md" --> <p>#历史记录::<br>2022/9/20🌵stdatomic : <a href="marginnote3app://note/AF118F7E-D507-4AA5-AA33-0B9C547E71A7">margin</a></p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前置++与后置++</title>
    <link href="/posts/28971/"/>
    <url>/posts/28971/</url>
    
    <content type="html"><![CDATA[<p>前置<ins>与后置</ins> ::  <a href="marginnote3app://note/F2C85E29-1092-4D10-89F0-9FA8884AA5E0">margin</a></p><!-- basicblock-end --><h1 id="1-前置"><a class="markdownIt-Anchor" href="#1-前置"></a> 1: 前置++</h1><p>前置返回一个引用，后置返回一个对象</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//++i实现代码为：</span><br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>++()<br>{<br><br>  *<span class="hljs-keyword">this</span> += <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>} <br><br><br><br></code></pre></td></tr></tbody></table></figure><p>参与运算时: 使用++后的值,</p><p><strong>最好使用前置++，因为他不会创建临时对象，进而不会带来构造和析构而造成的格外开销。</strong></p><h1 id="2-后置"><a class="markdownIt-Anchor" href="#2-后置"></a> 2: 后置++</h1><p>前置不会产生临时对象，后置必须产生临时对象，<strong>临时对象会导致效率降低</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//i++实现代码为：               </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <br>{<br><span class="hljs-type">int</span> temp = *<span class="hljs-keyword">this</span>;                 <br>   ++*<span class="hljs-keyword">this</span>;                     <br>   <span class="hljs-keyword">return</span> temp;                <br>} <br><br><br></code></pre></td></tr></tbody></table></figure><p>参与运算时: 先使用<ins>之前的的值, 在</ins></p><blockquote><p>[!example]-</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-comment">// 版本 1 = 版本 2</span><br>&gt;<span class="hljs-comment">// 版本 1</span><br>&gt;<span class="hljs-keyword">while</span>(size--){<br>&gt;}<br>&gt;<span class="hljs-comment">// 版本 2</span><br>&gt;<span class="hljs-keyword">while</span>(size){<br>&gt;size--<br>&gt;}<br></code></pre></td></tr></tbody></table></figure></blockquote><p>后置为了返回旧值创建了一个临时对象，在函数结束的时候这个对象就会被销毁</p><h2 id="21-为什么后置返回对象而不是引用"><a class="markdownIt-Anchor" href="#21-为什么后置返回对象而不是引用"></a> 2.1: 为什么后置返回对象，而不是引用</h2><p>因为后置为了返回旧值创建了一个临时对象，在函数结束的时候这个对象就会被销段，如果返回引用，那么我请问你？你的对象对象都被销毁了，你引用啥呢？</p><h2 id="22-2-为什么后置前面也要加const"><a class="markdownIt-Anchor" href="#22-2-为什么后置前面也要加const"></a> 2.2: 2、为什么后置前面也要加const</h2><p><strong>其实也可以不加</strong>，但是为了防止你使用i++++,连续两次的调用后置++重载符，为什么呢？</p><blockquote><p>[!question] 原因：<br>它与内置类型行为不一致；你无法活得你所期望的结果，因为第一次返回的是旧值，而不是原对象，你调用两次后置++，结果只累加了一次，所以我们必须手动禁止其合法化，就要在前面加上const。</p></blockquote><h2 id="23-a-是否是线程安全的"><a class="markdownIt-Anchor" href="#23-a-是否是线程安全的"></a> 2.3: a++ 是否是线程安全的::</h2><p><a href="marginnote3app://note/40E6DB02-A325-4677-B64E-D9A609FE8681">margin</a></p><p>a++：从C/C++语法的级别来看，这是一条语句，应该是原子的；<br>但从编译器得到的汇编指令来看，其实不是原子的。<br>其一般对应三条指令，首先将变量对应的内存值搬运到某个寄存器（如eax)中，然后将该寄存器中的值自增1， 再将该寄存器中的值搬运回a代表的内存中</p><ul><li>cite 系统中没法直接对变量操作, 计算, 赋值…, 需要寄存器里操作, 在搬回本来的内存</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209272001228.png" alt="|400"></p><blockquote><p>[!question]<br>现在假设 i 的值是0，有两个线程，每个线程对变量 i 的值都递增1，预想一下，其结果应该是2，可实际运行结构可能是1,是不是很奇怪？</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209202225411.png" alt="|1000"></p><ul><li>question 没找到指令 456  ✅算了不找了, 没找到</li><li>summary 主要想说: <strong>操作系统线程调度的不确定性</strong>, 线程不是顺序执行的</li></ul>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>📗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21. 合并二叉树</title>
    <link href="/posts/57925/"/>
    <url>/posts/57925/</url>
    
    <content type="html"><![CDATA[<h1 id="1-617合并二叉树"><a class="markdownIt-Anchor" href="#1-617合并二叉树"></a> 1 617.合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">力扣题目链接</a></p><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为&nbsp;NULL 的节点将直接作为新二叉树的节点。</p><p>示例&nbsp;1:</p><p><img src="https://img-blog.csdnimg.cn/20210204153634809.png" alt="617.合并二叉树"></p><p>注意: 合并必须从两个树的根节点开始</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>本题使用哪种遍历都是可以的！</strong></p><p>我们下面以前序遍历为例。<br>中序和后序遍历也行, 但是<strong>前序遍历是最好理解的，我建议大家用前序遍历来做就OK。</strong><br>动画如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif" alt="617.合并二叉树"></p><ol><li><p><strong>确定递归函数的参数和返回值：</strong><br>参数是两个树, 返回值是合并后的树的根节点</p></li><li><p><strong>确定终止条件：</strong><br>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，💡遍历到t1 = NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。</p></li></ol><p>t2 同理</p><p>代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br><span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过, 好理解的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>{<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2;<span class="hljs-comment">// 遍历到t1 的空节点了</span><br>        <span class="hljs-keyword">if</span>(t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1;<span class="hljs-comment">// 同理</span><br><br>        t1-&gt;val += t2-&gt;val;<br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<span class="hljs-comment">// 💡遍历两个二叉树</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br>        <span class="hljs-keyword">return</span> t1;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^okrf9t</p><!-- basicblock-start oid="ObsNZExSDg0KwODwTCCW0DEi" --> <p>同时遍历两个二叉树呢::<br>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。<br>遍历两个二叉树, 用一个变量接住返回值<br>eg:<br>[[8. 对称二叉树#^4yh3i4]]<br>[[21. 合并二叉树#^okrf9t]]</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyTaJnzlbgoRCv7xBABW1H" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::21. 合并二叉树.md" --> <p>#历史记录::<br>2022/9/20🌵21. 合并二叉树 : v1, 通过, 好理解的⏱0-27</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20. 二叉树周末总结</title>
    <link href="/posts/61791/"/>
    <url>/posts/61791/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201010%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html#%E5%91%A8%E4%B8%80">本周小结！（二叉树系列三） | 代码随想录</a></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsHL62fg2ifYOqsvF49gbCm" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::20. 二叉树周末总结.md" --> <p>#历史记录::<br>2022/9/20🌵20. 二叉树周末总结 : 没看</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19. 最大二叉树</title>
    <link href="/posts/48622/"/>
    <url>/posts/48622/</url>
    
    <content type="html"><![CDATA[<h1 id="1-54最大二叉树"><a class="markdownIt-Anchor" href="#1-54最大二叉树"></a> 1 54.最大二叉树</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">力扣题目地址</a></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中<strong>最大值左边部分</strong>构造出的最大二叉树。</li><li>右子树是通过数组中<strong>最大值右边部分</strong>构造出的最大二叉树。</li></ul><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>示例 ：</p><p><img src="https://img-blog.csdnimg.cn/20210204154534796.png" alt="654.最大二叉树"></p><p>提示：</p><p>给定的数组的大小在 [1, 1000] 之间。</p><!-- basicblock-start oid="ObsWDpZhFY65NcAndCNgw5bP" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>最大二叉树的构建过程如下：</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjuvioezg30dw0921ck.gif" alt="654.最大二叉树"></p><!-- basicblock-start oid="Obs4rHsHDdSPcumjAc14BqDe" --> <p><strong>构造树一定采用::<br>前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</strong></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1: 抄了一遍, 还有优化的空间,优化: 直接通过下标构造左子树和右子树</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>    <span class="hljs-comment">// 1️⃣构造根节点</span><br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 构造根节点, 值的话下边会重新覆盖</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>){ <span class="hljs-comment">// 题目说了数组大小是大于等于 1 的,💡如果传入的数组大小为1，说明遍历到了叶子节点了。</span><br>            node-&gt;val = nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">return</span> node;<br>        }<br>        <span class="hljs-comment">// 找到数组的最大值, 即二叉树的根节点</span><br>        <span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; maxValue){<br>                maxValue = nums[i];<br>                maxValueIndex = i;<br>            }<br>        }<br>        <span class="hljs-comment">// 2️⃣给根节点赋值</span><br>        node-&gt;val = maxValue; <span class="hljs-comment">// 重新给根节点赋值</span><br>        <br>        <span class="hljs-comment">//---------💡以上是中节点的处理逻辑: 构造根节点(数组的最大值)-----------</span><br>        <br><br>        <span class="hljs-comment">//💡左: 最大值所在的下标左区间 构造左子树</span><br>        <span class="hljs-keyword">if</span>(maxValueIndex &gt; <span class="hljs-number">0</span>){ <span class="hljs-comment">// 保证左区间至少有一个元素, 跟上面的 if 联动</span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>; <span class="hljs-comment">// 坚持的是左闭右开的原则</span><br>            node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br><br>        <span class="hljs-comment">//💡右: 最大值所在的下标右区间 构造右子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) {<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>; <span class="hljs-comment">// 坚持的是左闭右开的原则</span><br>            node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        }<br>        <span class="hljs-keyword">return</span> node;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>以上代码比较冗余，效率也不高，每次还要切割的时候每次都要定义新的vector（也就是数组），但逻辑比较清晰。</p><!-- basicblock-start oid="ObstWlxuC0GYKOFzr0rctNeY" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::19. 最大二叉树.md"--><p>❓vec 创建的时候直接是左闭右开原则吗::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ❓vec 创建的时候直接是左闭右开原则吗</span><br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>; <span class="hljs-comment">// 坚持的是左闭右开</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObscJCKln3bXKbXv5eVNWtDr" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::19. 最大二叉树.md" --> <p>#历史记录::<br>2022/9/20🌵19. 最大二叉树: v1: 抄了一遍, 还有优化的空间,优化: 直接通过下标构造左子树和右子树⏱ 0-50</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>extern 与 static</title>
    <link href="/posts/63304/"/>
    <url>/posts/63304/</url>
    
    <content type="html"><![CDATA[<h1 id="1-extern-与-static"><a class="markdownIt-Anchor" href="#1-extern-与-static"></a> 1 extern 与 static</h1><h2 id="11-extern"><a class="markdownIt-Anchor" href="#11-extern"></a> 1.1 extern</h2><p>定义：<br>声明外部变量【在函数或者文件外部定义的全局变量】</p><h2 id="12-static"><a class="markdownIt-Anchor" href="#12-static"></a> 1.2 static</h2><p>作用：实现多个对象之间的数据共享+隐藏，并且使用静态成员还不会破坏隐藏原则；默认初始化为0</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsleJQIuqDBYQxuSYlpAEA6" deck = "👨🏻‍💻code::C++::C++基础::extern 与 static.md" --> <p>#历史记录::<br>2022/9/19🌵extern 与 static</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>volatile</title>
    <link href="/posts/27531/"/>
    <url>/posts/27531/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><blockquote><p>若要修改const修饰的变量的值，需要加上关键字[[volatile]];</p></blockquote><p>与const绝对对立的，是类型修饰符</p><ul><li><p>影响编译器编译的结果，用该关键字声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化；</p></li><li><p>会从内存中重新装载内容，而不是直接从寄存器拷贝内容。</p></li></ul><h1 id="2-作用"><a class="markdownIt-Anchor" href="#2-作用"></a> 2 作用：</h1><p>指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，保证对特殊地址的稳定访问</p><h1 id="3-使用场合"><a class="markdownIt-Anchor" href="#3-使用场合"></a> 3 使用场合：</h1><p>在中断服务程序和cpu相关寄存器的定义</p><h1 id="4-举例说明"><a class="markdownIt-Anchor" href="#4-举例说明"></a> 4 举例说明：</h1><p>空循环：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(vo1ati1e <span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100000</span>;i++);<span class="hljs-comment">//它会执行，不会被优化掉</span><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs2aUB5U26q3Lg3FEtSZIZh" --> <p>#历史记录::<br>2022/9/19🌵volatile</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>const和static的区别</title>
    <link href="/posts/45167/"/>
    <url>/posts/45167/</url>
    
    <content type="html"><![CDATA[<h1 id="1-const和static的区别"><a class="markdownIt-Anchor" href="#1-const和static的区别"></a> 1 const和static的区别</h1><h2 id="11-const-关键字"><a class="markdownIt-Anchor" href="#11-const-关键字"></a> 1.1 [[const 关键字]]</h2><h2 id="12-static"><a class="markdownIt-Anchor" href="#12-static"></a> 1.2 static</h2><h2 id="13-区别"><a class="markdownIt-Anchor" href="#13-区别"></a> 1.3 区别</h2><p>![[关键字与运算符 2022-09-19 20.57.19.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsm3NiiLPlpEsAmLU4VhXEF" deck = "👨🏻‍💻code::C++::C++基础::const和static的区别.md" --> <p>#历史记录::<br>2022/9/19🌵const和static的区别</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>new delete &amp; malloc free</title>
    <link href="/posts/1799/"/>
    <url>/posts/1799/</url>
    
    <content type="html"><![CDATA[<p>new delete &amp; malloc free 目录 ::</p><!-- basicblock-end --><h1 id="1-new-delete-原理"><a class="markdownIt-Anchor" href="#1-new-delete-原理"></a> 1: [[new delete 原理]]</h1><h1 id="2-malloc-free-原理"><a class="markdownIt-Anchor" href="#2-malloc-free-原理"></a> 2: [[malloc free 原理]]</h1><h1 id="3-8-new-delete-与-malloc-free的异同四者的异同"><a class="markdownIt-Anchor" href="#3-8-new-delete-与-malloc-free的异同四者的异同"></a> 3: [[8、new  delete 与 malloc  free的异同|四者的异同]]</h1><h1 id="4-既然有了mallocfreec中为什么还需要newdelete呢直接用mallocfree不好吗"><a class="markdownIt-Anchor" href="#4-既然有了mallocfreec中为什么还需要newdelete呢直接用mallocfree不好吗"></a> 4: 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？</h1><ul><li>malloc/free和new/delete都是用来申请内存和回收内存的。</li><li>在对<strong>非基本数据类型</strong>的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。<ul><li>而malloc/free是库函数，是已经编译的代码，所以<strong>不能</strong>把构造函数和析构函数的功能强加给malloc/free，</li><li>所以new/delete是必不可少的。</li></ul></li></ul><h1 id="5-55-malloc申请的存储空间能用delete释放吗"><a class="markdownIt-Anchor" href="#5-55-malloc申请的存储空间能用delete释放吗"></a> 5: [[55、malloc申请的存储空间能用delete释放吗]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>define和inline的区别</title>
    <link href="/posts/58722/"/>
    <url>/posts/58722/</url>
    
    <content type="html"><![CDATA[<h1 id="define和inline的区别"><a class="markdownIt-Anchor" href="#define和inline的区别"></a> define和inline的区别</h1><ol><li>define<br>![[关键字与运算符#3 2 1 define]]</li></ol><p>2、[[inline(内联函数)]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsdErpigQ7nQS2M2D5E2HpE" deck = "👨🏻‍💻code::C++::C++基础::define和inline的区别.md" --> <p>#历史记录::<br>2022/9/19🌵define和inline的区别</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>define和typedef的区别</title>
    <link href="/posts/62768/"/>
    <url>/posts/62768/</url>
    
    <content type="html"><![CDATA[<p>define和typedef的区别 ::</p><!-- basicblock-end --><p>都是用来起别名的</p><h1 id="1-使用区别"><a class="markdownIt-Anchor" href="#1-使用区别"></a> 1: 使用区别</h1><ul><li><p>宏主要用于定义<strong>常量</strong>及书写复杂的内容；typedef主要用于定义<strong>类型</strong>别名。</p><ul><li><strong>一般来说, 我们用 define 给常量起别名, 用 typedef 给类型起别名</strong></li></ul></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p></li><li><p>宏不检查类型；typedef会检查数据类型。</p></li><li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p></li><li><p>注意对指针的操作，<code>typedef char * p_char</code>和<code>#define p_char char *</code>区别巨大。</p></li></ul><h2 id="11-define"><a class="markdownIt-Anchor" href="#11-define"></a> 1.1: define</h2><ol><li>可以给常量起别名 ,</li><li>也可以给类型起别名, 但是只能用一次, 不能连续用<br>eg:</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">define MAX <span class="hljs-number">255</span>; <span class="hljs-comment">// max = 255</span><br>define st <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// st = string</span><br>st a = <span class="hljs-string">"hello"</span> <span class="hljs-comment">//  string a = "hello"</span><br>st b = <span class="hljs-string">"world"</span> <span class="hljs-comment">// 💡只能用一次, 这里就失效了</span><br></code></pre></td></tr></tbody></table></figure><h2 id="12-typedef"><a class="markdownIt-Anchor" href="#12-typedef"></a> 1.2: typedef</h2><ol><li>为一种类型起一个新的名字</li><li>是在编译、运行的时候处理的, 不是在预处理的时候进行替换的</li><li>有对应的数据类型，是要进行判断.<ul><li>💡检查传入的参数, 是否符合我要进行计算的类型</li></ul></li></ol><ul><li>question 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝</li></ul><p>只能给类型起别名, 可以连续用</p><blockquote><p>有些类型特别长, 每次写比较复杂, 所以用一个简单的来代替它</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">string</span> st;  <span class="hljs-comment">// st = string</span><br>st a = <span class="hljs-string">"hello"</span> <span class="hljs-comment">//  string a = "hello"</span><br>st b = <span class="hljs-string">"world"</span> <span class="hljs-comment">//  string b = "world" 💡可以继续用</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209142129292.png" alt="|500"></p><h1 id="2-区别"><a class="markdownIt-Anchor" href="#2-区别"></a> 2: 区别</h1><p>![[GCC 编译过程 .excalidraw]]</p><h2 id="21-define"><a class="markdownIt-Anchor" href="#21-define"></a> 2.1: [[define]]</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指针与引用</title>
    <link href="/posts/28636/"/>
    <url>/posts/28636/</url>
    
    <content type="html"><![CDATA[<p>指针与引用目录 ::<br>2022/9/19🌵</p><!-- basicblock-end --><h1 id="1-引用目录"><a class="markdownIt-Anchor" href="#1-引用目录"></a> 1: [[引用(目录)]]</h1><h1 id="2-指针目录"><a class="markdownIt-Anchor" href="#2-指针目录"></a> 2: [[指针(目录)]]</h1><h1 id="3-3-指针和引用的区别"><a class="markdownIt-Anchor" href="#3-3-指针和引用的区别"></a> 3: [[3、指针和引用的区别]]</h1><h1 id="4-4-在传递函数参数时什么时候该使用指针什么时候该使用引用呢"><a class="markdownIt-Anchor" href="#4-4-在传递函数参数时什么时候该使用指针什么时候该使用引用呢"></a> 4: [[4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>constexpr和const  (C++新特性)</title>
    <link href="/posts/63272/"/>
    <url>/posts/63272/</url>
    
    <content type="html"><![CDATA[<h1 id="1-const-const-关键字"><a class="markdownIt-Anchor" href="#1-const-const-关键字"></a> 1 const :: [[const 关键字]]</h1><h1 id="2-constexpr"><a class="markdownIt-Anchor" href="#2-constexpr"></a> 2 constexpr</h1><p>复杂系统中很难分辨一个初始值是不是常量表达式，可以将变量声明为constexpr类型，由编译器来验证变量的值是否是一个常量表达式。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">constexpr <span class="hljs-type">int</span> n = <span class="hljs-number">20</span>; <br>constexpr <span class="hljs-type">int</span> m = n +<span class="hljs-number">1</span>; <br><span class="hljs-type">static</span> constexpr <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br></code></pre></td></tr></tbody></table></figure><p>必须使用常量初始化： 如果constexpr声明中定义了一个指针，constexpr仅对指针有效，和所指对象无关。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">constexpr <span class="hljs-type">int</span>*p = nullptr;<span class="hljs-comment">//常量指针J顶层</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>*q = nullptr;<span class="hljs-comment">//指向常量的指针 , 左定值, 顶层 const</span><br><span class="hljs-type">int</span>*<span class="hljs-type">const</span> q = nullptr;<span class="hljs-comment">//右定向, 底层 const</span><br></code></pre></td></tr></tbody></table></figure><h2 id="21-constexpr-函数"><a class="markdownIt-Anchor" href="#21-constexpr-函数"></a> 2.1 constexpr 函数</h2><p>constexprl函数是指能用于常量表达式的函数。<br>函数的返回类型和所有形参类型都是字面值类型，函数体有且只有一条return语句。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">constexpr <span class="hljs-type">int</span> <span class="hljs-title function_">new</span><span class="hljs-params">()</span>{<br><span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>为了可以在编译过程展开，constexpr函数被隐式转换成了内联函数。<br>constexpr和内联函数可以在程序中多次定义，一般定义在头文件。</p><h2 id="22-constexpr构造函数"><a class="markdownIt-Anchor" href="#22-constexpr构造函数"></a> 2.2 constexpr构造函数</h2><p>构造函数不能说const,.但字面值常量类的构造函数可以是constexpr。<br>constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。对象调用的成员函数必须使用constexpr修饰</p><h2 id="23-constexprl的好处"><a class="markdownIt-Anchor" href="#23-constexprl的好处"></a> 2.3 constexprl的好处</h2><ul><li>为一些不能修改数据提供保障，写成变量则就有被意外修改的风险。</li><li>有些场景，编译器可以在编译期对constexpr的代码进行优化，提高效率。<ul><li>&amp; 直接编译期间就编译好了, 到了程序执行的时候不会调用函数, 而是直接替换, 有点像 define 的文本替换</li></ul></li><li>相比宏来说，没有额外的开销，但更安全可靠。</li></ul><h1 id="3-区别"><a class="markdownIt-Anchor" href="#3-区别"></a> 3 区别</h1><p>![[关键字与运算符 2022-09-19 21.05.40.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsvU0PwOw9lYipDWjsAAsJF" deck = "👨🏻‍💻code::C++::C++基础::constexpr和const  (C++新特性).md" --> <p>#历史记录::<br>2022/9/19🌵constexpr和const  (C++新特性)</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>const关键字</title>
    <link href="/posts/58873/"/>
    <url>/posts/58873/</url>
    
    <content type="html"><![CDATA[<p>const关键字 ::</p><!-- basicblock-end --><p><strong>const的作用： 被它修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。</strong></p><p>若要修改const修饰的变量的值，需要加上关键字 [[volatile]];<br>若想要修改const成员函数中某些与类状态无关的数据成员，可以使用mutable关键字来修饰这个数据成员；</p><h1 id="1-顶层-const-和底层-const-的用法"><a class="markdownIt-Anchor" href="#1-顶层-const-和底层-const-的用法"></a> 1: [[顶层 const 和底层 const 的用法]]</h1><h1 id="2-区分作用"><a class="markdownIt-Anchor" href="#2-区分作用"></a> 2: <strong>区分作用</strong></h1><ul><li>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</li><li>使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a;<span class="hljs-type">int</span> <span class="hljs-type">const</span> a;<span class="hljs-type">const</span> <span class="hljs-type">int</span> *a;<span class="hljs-type">int</span> *<span class="hljs-type">const</span> a;<br></code></pre></td></tr></tbody></table></figure><ul><li>int const a和const int a均表示定义常量类型a。</li><li>const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)</li><li>int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</li></ul><h1 id="3-48-const关键字的作用有哪些"><a class="markdownIt-Anchor" href="#3-48-const关键字的作用有哪些"></a> 3: [[48、const关键字的作用有哪些]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>目录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小鹤音形</title>
    <link href="/posts/55080/"/>
    <url>/posts/55080/</url>
    
    <content type="html"><![CDATA[<p>![[小鹤音形 2022-09-18 19.01.09.excalidraw]]</p><p>把字拆成小部首, 小部首更常用<br>把一个字中的小且独立的字作为拆分因素<br>比如：“树” 取“木寸”，而不是 “木对” 或“ 权寸”；“喜”取“士口”而不是“吉口”<br>偏旁通常放在通俗的称呼上</p><p>鹤形多数是采用声母定键: 这个字根的声母就是这个字根的键位<br>如：犭反<strong>犬</strong>的q，卩 阝单双<strong>耳</strong>的e，冫氵两三<strong>点</strong>的d；部分成字部件也是取的声母，如：黑h，金j，虫i</p><h1 id="1-拆分规则"><a class="markdownIt-Anchor" href="#1-拆分规则"></a> 1: 拆分规则::</h1><h2 id="11-字取首末-只取第一个字根和最后一个字根"><a class="markdownIt-Anchor" href="#11-字取首末-只取第一个字根和最后一个字根"></a> 1.1: <strong>字取首末</strong>:  只取第一个字根和最后一个字根</h2><p>示例：“画”拆分为“横田凵”，首末取“横凵”</p><h2 id="12-相交不拆"><a class="markdownIt-Anchor" href="#12-相交不拆"></a> 1.2: 相交不拆</h2><p>释义：相交不拆，字根如果与其它笔画相交，则此字根即被破坏而不可取，这样就免去了字中找字的麻烦，而<strong>可以简单直接取到笔画</strong></p><p>示例：“中”，此字中的“口”与笔画竖相交，则此“口”已被破坏，不能再拆为“口”，只能被拆成首末笔“竖竖”，其它如“未” 不能取“二”，“重” 不能取“千”，“里”不能取“ 甲”，“子” 不能取“ 了”，曹，不能取草字头</p><h2 id="13-插隔不取字根如被单笔画插入或被结构隔离则不再被认为是字根"><a class="markdownIt-Anchor" href="#13-插隔不取字根如被单笔画插入或被结构隔离则不再被认为是字根"></a> 1.3: 插隔不取：<strong>字根如被单笔画插入或被结构隔离则不再被认为是字根</strong></h2><p>平: 两个倒八, 插入了干,此时“干”就因为被单笔画插入而不能取,因此 “平”被拆分成“横十”</p><h2 id="14-廴辶优先以廴-辶为部首的字首码先取"><a class="markdownIt-Anchor" href="#14-廴辶优先以廴-辶为部首的字首码先取"></a> 1.4: “廴辶”优先：以“廴 辶”为部首的字，首码先取</h2><p>示例： “这→辶文，建→廴聿</p><h2 id="15-其他"><a class="markdownIt-Anchor" href="#15-其他"></a> 1.5: 其他</h2><p>“日” 只能往上延伸</p><ol><li>单笔画字因无字根可拆，<strong>重复自身笔画码补全四码</strong>，如：一 yiaa、乙 yivv</li><li><strong>单笔画字被用做字根时</strong>，当笔画解，如：旦 djoa、亿 yirv</li><li>繁体字根可视同其简体字根，如：鳥鸟，馬马，魚鱼，車车，糹纟，飠饣，門门，釒钅……等</li></ol><h1 id="2-小字字根的定义"><a class="markdownIt-Anchor" href="#2-小字字根的定义"></a> 2: 小字字根的定义</h1><h2 id="21-基本小字"><a class="markdownIt-Anchor" href="#21-基本小字"></a> 2.1: 基本小字::</h2><p>一个字如果不再包含字或部件则为小字<br>示例：“十之冉我五也垂中”这些字中都不再包含有其它字或部件，所以本身就是小字</p><h2 id="22-衍生小字"><a class="markdownIt-Anchor" href="#22-衍生小字"></a> 2.2: 衍生小字:</h2><h3 id="221-部件或小字以附加单笔画方式衍生出来的字也为小字如果衍生结果含两字则分取"><a class="markdownIt-Anchor" href="#221-部件或小字以附加单笔画方式衍生出来的字也为小字如果衍生结果含两字则分取"></a> 2.2.1: 部件或小字以附加单笔画方式衍生出来的字也为小字，如果衍生结果含两字则分取</h3><p>①、单笔画可以是在小字或部件的不同隔离区附加<br>十→干→午<br>隔离区附加单笔画衍生小字过程：十→木，十→米</p><p>②、💡衍生结果包含两个字就要拆开: eg：兀→元，💡不取"元", 因为“元”可分开为两个字：二儿，所以“元”字分拆为“二儿”，其它同理如：示: 二小，兵: 丘八</p><p>③、“日”部件只向上方衍生字根 示例：“→白→百”等字向上方加单笔画衍生的字根为小字字根；而不向其他方向衍生字根，如“→旦→亘，→旧”等字则不为小字字根</p><h3 id="222-一个字除部件囗匚冂凵勹之外不再含其它部件或字则为小字含则分取"><a class="markdownIt-Anchor" href="#222-一个字除部件囗匚冂凵勹之外不再含其它部件或字则为小字含则分取"></a> 2.2.2: 一个字除部件“囗匚冂凵勹”之外，<strong>不再含其它部件或字</strong>，则为小字，含则分取</h3><pre><code class="hljs">示例：“巨臣勿而出击”等字包含框部件外再无其它部件，则为小字；“匝匹句匀同函”等字含框部件外还含其它部件或字，则分取另：开口框在字中开口时才为部件 , 💡被封口了就不是部件    示例：“同巨击出”等字中的“冂匚凵”**没有被封口即为部件**；“皿且甲”中的“冂”被封了口，则不被认为是部件    💡是框当不当部件，皿中的框不当部件,文档里面写的是皿被封了口，就不能拆分成框了，只能作为小字使用了</code></pre><h2 id="23-小字拆分"><a class="markdownIt-Anchor" href="#23-小字拆分"></a> 2.3: 小字拆分::</h2><p>附加一个单笔画的方式衍生的小字，作为一个字需要拆分时，分取单笔画与衍生前的部分；</p><p>eg: 白 是由"丿"和"日"组成的, 打字的时候就打"丿日"<br>释义：附加一个单笔画衍生的小字，衍生过程即拆分过程。</p><h1 id="3-拆分示例"><a class="markdownIt-Anchor" href="#3-拆分示例"></a> 3: 拆分示例::</h1><p>“鹤”，左部“冖”与“撇”相交，所以拆不出“冖”，取首笔“点”，右部取“鸟”，全码为hedn<br>“走”，上部取“土”，下部取“人”，全码为zztr<br>“武”，取首笔“横”，末部取“止”，此字拆分的字根顺序为：横弋止，全码为wuav，同理“或→戈横，戊→戈撇，越→土折”<br>“难”，左部取“又”，右部“隹”非字根，取“龶”，全码为njyf<br>“战”，左部“占”非字根，取首笔“竖”，右部取“戈”，全码为vjlg<br>“豫”，左部“予”非字根，取“龴”，右部“象”非字根，取末笔“捺”，全码yusn</p><h1 id="4-字根序"><a class="markdownIt-Anchor" href="#4-字根序"></a> 4: 字根序::</h1><p>笔画不停的形成字根<br>从首笔开始与其它笔画（不论顺序）组成字根则为首字根，首字根笔画之外剩余笔画再按剩余首笔画组成字根，直到最末组成的为末字根<br>试”按字根的顺序应为：讠弋 工，所以字根序的首末字根为 讠工。<br>例：匡→匚王 、武→横止 、框→木王 、式→弋工 、挂→扌土 、粤→撇折、潭→氵十、捏→扌土、或→戈横、越→土折</p><h1 id="5-部件"><a class="markdownIt-Anchor" href="#5-部件"></a> 5: 部件</h1><p>![[小鹤音形 2022-09-18 19.55.54.excalidraw]]</p><h1 id="6-小字字根"><a class="markdownIt-Anchor" href="#6-小字字根"></a> 6: 小字字根</h1><p><strong>小字规则字根，免记忆</strong></p><p>小字字根列表（理解<a href="https://help.flypy.com/#/gz?id=xzgz">小字规则</a>的用户请跳过此表）：</p><ul><li><p>一些可能会不认识的小字：戊wù、戌xū、耒lěi、爿pán、豕shǐ、臾yú、聿yù、廿niàn、巳sì、曳yè、夬guài</p><p>a 凹<br>b 百 白 八 卜 匕 卞 不 巴 本 必 丙 半 办<br>c 寸 才 匆 册<br>d 大 丁 刀 歹 刁 东 丹 电 氐<br>e 二 耳 儿 而<br>f 非 方 飞 夫 凡 甫 弗 乏 丰<br>g 广 弓 戈 工 瓜 干 个 甘 丐 果 更 夬<br>h 禾 户 互 乎 火<br>i 川 厂 车 长 叉 尺 丑 臣 成 垂 斥 串 产 出<br>j 巾 几 九 斤 久 巨 己 井 及 夹 甲 臼 韭 戋 柬 击<br>k 口 开 亏<br>l 了 力 乐 来 良 两 里 吏 耒 卵 丽<br>m 木 毛 米 门 马 皿 末 灭 母 民 么 面<br>n 廿 女 牛 鸟 乃 内 农 年<br>p 片 平 爿<br>q 七 千 犬 丘 曲 且 气 乞<br>r 人 入 冉 壬 刃<br>s 三 巳 肃<br>t 土 天 太 屯<br>u 十 尸 士 手 身 水 上 少 术 失 生 世 申 史 升 事 书 束 勺 戍 豕 氏 矢<br>v 止 爪 主 舟 之 正 丈 中 专 朱 州 重 乍<br>w 王 瓦 五 无 万 午 亡 未 乌 韦 勿 为 戊 我 丸 兀<br>x 小 西 心 血 下 夕 乡 戌 习<br>y 又 酉 已 于 义 与 夭 玉 牙 丫 永 尤 也 业 由 央 亚 严 用 幺 禺 臾 尹 禹 夷 弋 聿 雨 曳<br>z 再 自 子</p></li></ul><h1 id="7-简码"><a class="markdownIt-Anchor" href="#7-简码"></a> 7: 简码：</h1><p><strong>一简字：即一码一字（取字的首码即声母），共 26 个</strong></p><p>去　我　二　人　他　　　一　是　出　哦　平<br>　啊　三　的　非　个　　　和　就　可　了<br>　在　小　才　这　不　　　你　没</p><p><strong>二简字：即两码一字（取字的首次码即声韵），共 382 个</strong></p><ul><li>菜少僧多佛无肉 车新帅老将有云 深山谁能弄风月 水里咋让虐毛熊 黑龙森林闹天地 黄牛大户拨窗泥<br>阿翁恰好说空话 爱女当面色从容 怒撒红米她先笑 穷困绿囊贼也完 为何楼高汤更暖 凭啥桥坏应对难<br>目光绕得亲体软 装问跑来您眼前 两间长草各内外 几行热搜求安全 藏传真如修本主 上元太岁共双恩<br>桌边混吃仍需乐 村中走动且请跟 长路正顺或行久 报表群读谈分成 古怪酷图撇粗乱 特强陈某蹦窜戳<br>配料过关调算法 嫩排开口要生抽 昂头每次旁若定 顿额经年只等盘 曾早数日听鸟梦 但因差点总卷然<br>四下帮凑含宁散 最后推却跌碰贴 超贵追买怕卡疼 放浪还看该干吗 亚奥其会忙参与 比赛接连被灭团<br>费用加增够快否 普系吹落很亏么 占据民调都进组 受到肯夸找靠所 并列均宽纯末况 再而以测滚剖剋<br>破产另设做事处 挖坑则选横滨区 藏着换代别叫慢 错论白给任捏催 想送那些同样们 刚丢怎办冷冲转<br>品类套票盆克秒 名片副部段批扎 挂拽抗拴托揣握 抓拉挪扫把扩擦 刘苏岑欧周王反 嗯欸喔哟嘎哈呢<br>得学拆字</li></ul><p>另：补充一二简字 88 个，做＜二重简码＞使用，如果不介意增加的小指使用率，可通过输入 <code>oei</code> 启用</p><p>主要以二字词为主，编码取每个字的前两码组成，<br>三字词全码为前两字首码加末字前两码，<br>四字以上词为前三字首码加末字首码。<br>音形码方案的输入是字词结合的输入，字是基础，词基本是标准意义的词，你不能把“我的、我是。。。”这样的也当词来打，打熟简码字之后有些包含一简字的词可能你也会习惯拆开来打，这应该是确定性更重要的体现</p><p><strong>二简词：</strong> 即两码二字词（取两字的首码即声声），共362个</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZsJXZWtmIdsy6KNsTOJym" --> <p>#历史记录::<br>2022/9/18🌵小鹤音形 :&nbsp;学习完毕⏱1-17</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.13 - 1.16 GDB调试</title>
    <link href="/posts/53653/"/>
    <url>/posts/53653/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是-gdb"><a class="markdownIt-Anchor" href="#1-什么是-gdb"></a> 1 什么是 GDB::</h1><!-- basicblock-end --><ul><li><p>GDB 是由 GNU 软件系统社区提供的调试工具，同 GCC 配套组成了一套完整的开发环 境，GDB 是 Linux 和许多类 Unix 系统中的标准开发环境。</p></li><li><p>一般来说，GDB 主要帮助你完成下面四个方面的功能:</p><ol><li>启动程序，可以按照自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在所指定的调置的断点处停住(断点可以是条件表达式) 。</li><li>当程序被停住时，可以检查此时程序中所发生的事。</li><li>可以改变程序，将一个 BUG 产生的影响修正从而测试其他 BUG。</li></ol></li></ul><!-- basicblock-start oid="Obs5BnIy8bvlfX5kp1ykdMlT"  deck = "source::_posts::👨🏻‍💻code::项目::Linux::命令"--> <p>vim : set nu :: 显示行号</p><!-- basicblock-end --><!-- basicblock-start oid="Obsqtt8hR5mqIUjiUJ3BTNiQ" --> <h1 id="2-准备工作"><a class="markdownIt-Anchor" href="#2-准备工作"></a> 2 准备工作::</h1><!-- basicblock-end --><p>实操：</p><p><strong>编译程序时加入调试信息</strong>： 最后加个-g 参数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc test.c -o test -g <span class="hljs-comment">// 💡生成 gdb 调试文件</span><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209181730028.png" alt=""></p><!-- basicblock-start oid="ObsEYfmxZJFz9Q1F9WF5tSHY" --> <ul><li><code>-g</code> 选项的作用::</li><li><strong>是在可执行文件中加入源代码的信息</strong>，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。</li></ul><!-- basicblock-end --><ul><li>通常，在为调试而编译时，我们会()关掉编译器的优化选项(<code>-O</code>)， 并打开调试选项(<code>-g</code>)。另外，<code>-Wall</code> 在尽量不影响程序行为的情况下选项打开所有 warning，也可以发现许多问题，避免一些不必要的 BUG。</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -g -Wall program.c -o program <span class="hljs-comment">// -Wall 打开所有的警告</span><br><span class="hljs-comment">// program.c : 源文件, program : 可执行程序</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-gdb-命令"><a class="markdownIt-Anchor" href="#3-gdb-命令"></a> 3 GDB 命令</h1><!-- basicblock-start oid="Obs45aiLrLhWAnRCRLht5Q1T" --> <h2 id="31-启动-退出-查看代码"><a class="markdownIt-Anchor" href="#31-启动-退出-查看代码"></a> 3.1 启动、退出、查看代码::</h2><!-- basicblock-end --><p>gdb是一个shell命令<br>下边的命令都是它内部的</p><p>启动和退出</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gdb 可执行程序 <span class="hljs-comment">// 启动程序</span><br>quit <span class="hljs-comment">// q 也行</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObskXJVeR4MNhRzF4jfsQtvo" deck= "❓疑问::👨🏻‍💻code::项目::webserver::1 第一章::1.13 - 1.16 GDB调试.md"--><p>给程序设置参数/获取设置参数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span> args <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-comment">// 💡应该只是设置一个变量而已</span><br>show args<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>GDB使用帮助</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">help<br></code></pre></td></tr></tbody></table></figure><p>查看当前文件代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">list</span>/l<span class="hljs-comment">// 从默认位置显示💡默认显示main函数的代码，一下显示10行</span><br><span class="hljs-built_in">list</span>/l 行号<span class="hljs-comment">// 从指定的行显示💡L 20&nbsp; 显示15-25行，显示上下5行</span><br><span class="hljs-built_in">list</span>/l 函数名<span class="hljs-comment">// 从指定的函数显示</span><br></code></pre></td></tr></tbody></table></figure><p>查看非当前文件代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">list</span>/l 文件名:行号  <span class="hljs-comment">// 💡查看其他文件的代码，一定不能缺后边的":"，否则当成函数名</span><br><span class="hljs-built_in">list</span>/l 文件名:函数名<br></code></pre></td></tr></tbody></table></figure><p>设置显示的行数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">show <span class="hljs-built_in">list</span>/listsize <br><span class="hljs-built_in">set</span> <span class="hljs-built_in">list</span>/listsize 行数<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsF4kPKhxvIKiedM2g1cf5K" --> <h2 id="32-断点操作"><a class="markdownIt-Anchor" href="#32-断点操作"></a> 3.2 断点操作::</h2><!-- basicblock-end --><p>设置断点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">b/<span class="hljs-keyword">break</span> 行号<br>b/<span class="hljs-keyword">break</span> 函数名 <br>b/<span class="hljs-keyword">break</span> 文件名:行号 <br>b/<span class="hljs-keyword">break</span> 文件名:函数<br><br><span class="hljs-comment">// 给其他文件里打断点</span><br>b bubble.cpp :bubbleSort(<span class="hljs-type">int</span>*, <span class="hljs-type">int</span>)<br></code></pre></td></tr></tbody></table></figure><p>查看断点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">i/info b/<span class="hljs-keyword">break</span><br></code></pre></td></tr></tbody></table></figure><p>删除断点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">d/del/delete 断点编号<br></code></pre></td></tr></tbody></table></figure><p>设置断点无效</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">dis/disable 断点编号<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsIHWOtB7YfziFXcV92IKuP" deck= "❓疑问::👨🏻‍💻code::项目::webserver::1 第一章::1.13 - 1.16 GDB调试.md"--><p>无效会使 Enb&nbsp; 变为&nbsp; Enb。/ / &nbsp; Enb：可用的(enable)&nbsp;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y(yes) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n(no)</p><!-- basicblock-end --><p>设置断点生效</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ena/enable 断点编号<br></code></pre></td></tr></tbody></table></figure><p>设置条件断点(一般用在循环的位置)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b/<span class="hljs-keyword">break</span> <span class="hljs-number">10</span> <span class="hljs-keyword">if</span> i==<span class="hljs-number">5</span> <span class="hljs-comment">// 不能用=，因为=是赋值</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsXzNOfXRMhLP8AsNcdZldp" --> <h2 id="33-调试命令"><a class="markdownIt-Anchor" href="#33-调试命令"></a> 3.3 调试命令::</h2><!-- basicblock-end --><p>运行GDB程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">start(程序停在第一行) <br>run(遇到断点才停)<br></code></pre></td></tr></tbody></table></figure><p>继续运行，到下一个断点停</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">c/<span class="hljs-keyword">continue</span><br></code></pre></td></tr></tbody></table></figure><p>向下执行一行代码==(不会进入被调用的函数中)==</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">n/next<br></code></pre></td></tr></tbody></table></figure><p>变量操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">p/print 变量名(打印变量值) <br>ptype 变量名(打印变量类型)<br></code></pre></td></tr></tbody></table></figure><p>向下单步调试==(遇到函数进入函数体)==</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">s/step<br><span class="hljs-title function_">finish</span><span class="hljs-params">(跳出函数体)</span><br></code></pre></td></tr></tbody></table></figure><p>自动变量操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">display 变量名(自动打印指定变量的值) <br>i/info display <span class="hljs-comment">// 查看设置的自动变量</span><br>undisplay 编号<span class="hljs-comment">// 删除自动变量</span><br></code></pre></td></tr></tbody></table></figure><p>其它操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">set</span> var 变量名=变量值 (循环中用的较多) <br>until (跳出循环) <span class="hljs-comment">// ❓要把断点删掉</span><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsA62GNxmefgpysqwb8Vs9q" --> <h1 id="4-具体细节"><a class="markdownIt-Anchor" href="#4-具体细节"></a> 4 具体细节::</h1><ul><li><p>运行到断点，断点的那行并没有执行</p></li><li><p>跳出循环体或者跳出函数体要求下边没有断点了才能跳出</p></li><li><p>? 断点无论是向下一步, 还是不进入函数体的向下一步, 都会正常执行该句</p></li><li><p>设置自动变量就是后边<strong>每次都对变量自动执行print操作</strong>，而不用手动显示变量值,</p><ul><li>&amp; 而如果进入其他函数就不再显示自动打印的变量了，因为已经没有了</li></ul></li><li><p>设置变量值可以在循环中使用，来控制循环变量</p></li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsSpvvGf62ODMnF5x2wbbNh" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.13 - 1.16 GDB调试.md" --> <p>#历史记录::<br>2022/9/18🌵1.13 - 1.16 GDB调试 : 看了所有的命令, 没有实操, 留下了三个❓⏱0-51<br>2022/9/19🌵1.13 - 1.16 GDB调试: 又复习一遍⏱0-30</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.10 - 1.12 makefile</title>
    <link href="/posts/55359/"/>
    <url>/posts/55359/</url>
    
    <content type="html"><![CDATA[<h1 id="1-makefile"><a class="markdownIt-Anchor" href="#1-makefile"></a> 1 Makefile</h1><!-- basicblock-start oid="ObsVCbaeXVzkBEHxQDAmKbkk" --> <h2 id="11-什么是-makefile"><a class="markdownIt-Anchor" href="#11-什么是-makefile"></a> 1.1 什么是 Makefile::</h2><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中， <strong>Makefile 文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作</strong>，因为 Makefile 文件就 像一个 Shell 脚本一样，也可以执行操作系统的命令。</p><p>Makefile 带来的好处就是“自动化编译” ，一旦写好，只需要一个 make 命令，整 个工程完全自动编译，极大的提高了软件开发的效率。make 是一个命令工具，是一个 解释 Makefile 文件中指令的命令工具，一般来说，大多数的 IDE 都有这个命令， 比如 Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。</p><!-- basicblock-end --><!-- basicblock-start oid="ObsAmYpEFlk60gco2w0pNYQs" --> <h2 id="12-makefile-文件命名和规则"><a class="markdownIt-Anchor" href="#12-makefile-文件命名和规则"></a> 1.2 Makefile 文件命名和规则::</h2><!-- basicblock-end --><p>文件命名：makefile 或者 Makefile</p><p>Makefile 规则：</p><ul><li>一个 Makefile 文件中可以有一个或者多个规则</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">目标 : 依赖 <br>    命令(Shell 命令)<span class="hljs-comment">// 前边是 tab 缩进</span><br>    <br></code></pre></td></tr></tbody></table></figure><p>目标:最终要生成的文件(伪目标除外)</p><p>依赖:生成目标所需要的文件或是目标</p><p>命令:通过执行命令对依赖操作生成目标(命令前必须 Tab 缩进)</p><p><strong>- Makefile 中的其它规则一般都是为第一条规则服务的。</strong></p><p>make默认只执行Makefile第一条语句，如果其他语句与第一条无关，则不执行。</p><!-- basicblock-start oid="Obs6liwB1xuL7V0E3XVnOAaY" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <h3 id="121-通过-makefile-自动化编译工程"><a class="markdownIt-Anchor" href="#121-通过-makefile-自动化编译工程"></a> 1.2.1 通过 makefile 自动化编译工程::</h3><p>先安裝一下 make 命令：sudo apt install make</p><p>目标: 对calc中的进行编译一起生成一个app可执行文件</p><p>创建 makefile 文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">vim Makefile <span class="hljs-comment">// Makefile 文件一定命名为Makefile 或者makefile, 不然识别不了</span><br></code></pre></td></tr></tbody></table></figure><p>编辑 makefile ：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">app: sub.c add.c mult.c div.c main.c<span class="hljs-comment">// 目标 : 依赖</span><br>        gcc sub.c add.c mult.c div.c main.c -o app <span class="hljs-comment">// 命令</span><br></code></pre></td></tr></tbody></table></figure><p><code>make</code> 命令: <strong>按<mark>当前目录下</mark>的 makefile 去自动执行命令</strong>，生成了 app。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">make   <span class="hljs-comment">// 相当于执行了:  gcc sub.c add.c mult.c div.c main.c -o app</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obs1xOoIzB6f6HvBbnut4dKl" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <h3 id="122-工作原理"><a class="markdownIt-Anchor" href="#122-工作原理"></a> 1.2.2 工作原理::</h3><!-- basicblock-end --><ul><li>&amp; Makefile 中的其它规则一般都是为第一条规则服务的。</li><li>命令在执行之前，<strong>需要先检查规则中的依赖是否存在</strong></li><li>如果存在，执行命令</li><li>如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令。</li><li>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</li><li>如果依赖的时间比目标的时间晚，需要重新生成目标。<br>eg: main.c 被修改了<br>main.o: main.c<br>gcc -c main.c -o main.o<br>因为main.c的时间比main.o的时间晚，说明了它更新过了。所以要重新执行该命令生成最新的main.o</li><li>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行。</li></ul><p>案例：</p><p>编辑 makefile 文件。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">app: sub.o add.o mult.o div.o main.o <span class="hljs-comment">//💡app 是目标: 后边是他的依赖</span><br>        gcc sub.o add.o mult.o div.o main.o -o app<br><br>sub.o:sub.c <span class="hljs-comment">// 💡二级目标和依赖</span><br>        gcc -c sub.c -o sub.o<br><br>add.o:add.c<br>        gcc -c add.c -o add.o<br><br>mult.o:mult.c<br>        gcc -c mult.c -o mult.o<br><br>div.o:div.c<br>        gcc -c div.c -o div.o<br><br>main.o:main.c<br>        gcc -c main.c -o main.o<br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">make<br><span class="hljs-comment">// 相当于执行了以下命令</span><br>-&gt;<br>gcc -c sub.c -o sub.o <span class="hljs-comment">// 先执行二级目标依赖, 他们是为一级目标依赖提供支持的</span><br>gcc -c add.c -o add.o<br>gcc -c mult.c -o mult.o<br>gcc -c div.c -o div.o<br>gcc -c main.c -o main.o<br>gcc sub.o add.o mult.o div.o main.o -o app<br></code></pre></td></tr></tbody></table></figure><p>而<strong>分规则的</strong>写法，只会重新编译有修改的 .o 文件，再链接生成 app，效率更高。<br>假设只有add.c 修改了，后边只会执行 add.o:add.c 这个命令<br>只更新修改过的</p><p>与前面的 makefile 写法对比：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这里直接一步到位的, -o 命令直接使.c 文件生成了.o 文件</span><br>app: sub.c add.c mult.c div.c main.c<br>        gcc sub.c add.c mult.c div.c main.c -o app<br></code></pre></td></tr></tbody></table></figure><p>当 .c 文件更新时，makefile 在执行规则中的命令时，会比较目标和依赖文件的时间，如果依赖的时间比目标的时间晚，会更新目标。这种写法一旦更新某一个文件，都会执行该命令，重新编译所有的 .o 文件，再链接更新 app 。</p><ul><li>&amp; 所有的规则都是服务于第一条规则的，如果下边的规则生成的不是第一个规则所需的依赖，或者与第一条规则没关系就不会执行(除非特别指定）</li></ul><!-- basicblock-start oid="Obs4fvRLFfjnlOxNz9YXPNdy" --> <h2 id="13-如何简化-makefile-的写法"><a class="markdownIt-Anchor" href="#13-如何简化-makefile-的写法"></a> 1.3 如何简化 makefile 的写法::</h2><ul><li>? 这些好像只能在 makefile 文件下用, 我在外边使用说找不到该命令</li><li>? <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209211553114.png" alt=""></li></ul><!-- basicblock-end --><ul><li><p>自定义变量</p><p><code>变量名=变量值</code>  <code>var=hello</code></p></li></ul><!-- basicblock-start oid="Obs4ecx2iEKtVarUMlbJgmPl" --> <ul><li>预定义变量(提前定义好的变量)::</li></ul><table><thead><tr><th>预定义变量</th><th></th><th>备注</th></tr></thead><tbody><tr><td>AR</td><td>归档维护程序的名称，默认值为 ar</td><td>之前静态库打包用的</td></tr><tr><td>CC</td><td>C 编译器的名称，默认值为 cc</td><td>可以理解成 gcc</td></tr><tr><td>CXX</td><td>C++ 编译器的名称，默认值为 g++</td><td></td></tr><tr><td>$@</td><td>目标的完整名称</td><td>获取某一个内容</td></tr><tr><td>$&lt;</td><td>第一个依赖文件的名称</td><td></td></tr><tr><td>$^</td><td>所有的依赖文件</td><td></td></tr></tbody></table><!-- basicblock-end --><ul><li>如何获取变量的值<br><code>$(变量名)</code><br>eg:<br><code>$(cc)</code>就获取到了 cc<br><code>$(var)</code> 就获取到了 hello</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">$@         $&lt;         $^       <br>这三个是自动变量, 只能在规则的命令中使用, 不能用到规则当中<br><br><span class="hljs-comment">// eg</span><br>目标 ...: 依赖 ... <span class="hljs-comment">// 这是规则</span><br>    命令(Shell 命令)<span class="hljs-comment">// 💡这是规则命令, 只能在这个部分使用</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsfKH9K0Es2e68hifPe4hHn" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <p>用变量简化 makfile 命令::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">app:main.c a.c b.c <span class="hljs-comment">// 💡app 是目标, main.c a.c b.c 是他的依赖</span><br>gcc -c main.c a.c b.c <br><span class="hljs-comment">// 上面的命令可以直接写成这样</span><br>$(CC) -c $^ <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$(cc): gcc</span><br><span class="hljs-comment">$^ : 所有的依赖文件 : main.c a.c b.c</span><br><span class="hljs-comment">$@ : 目标的完整名称 :&nbsp;app          </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"># 定义变量<br>src=sub.o add.o mult.o div.o main.o<span class="hljs-comment">// 定义依赖</span><br>target=app <span class="hljs-comment">// 定义目标</span><br><br>$(target):$(src)<br>        $(CC) $(src) -o $(target)<br><br><span class="hljs-comment">// 下边的二级目标和依赖还要手动写, 怎么解决看下边 ### 1.3.1</span><br>sub.o:sub.c<br>        gcc -c sub.c -o sub.o<br><br>add.o:add.c<br>        gcc -c add.c -o add.o<br><br>mult.o:mult.c<br>        gcc -c mult.c -o mult.o<br><br>div.o:div.c<br>        gcc -c div.c -o div.o<br><br>main.o:main.c<br>        gcc -c main.c -o main.o        <br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsUdagLCQlNQvY2DaxKOpZy"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>复制与删除::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">cp text.c text2.c <span class="hljs-comment">// 在当前目录习复制 text.c</span><br>rm * .o<span class="hljs-comment">// 删除具体后缀的文件</span><br>rm app <span class="hljs-comment">// 删除 app</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="ObseiWUainM23AW7mSTZZRBo" --> <h3 id="131-模式匹配二级目标和依赖怎么简化"><a class="markdownIt-Anchor" href="#131-模式匹配二级目标和依赖怎么简化"></a> 1.3.1 模式匹配(二级目标和依赖怎么简化)::</h3><p>^a51e57</p><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 怎么简化</span><br>sub.o:sub.c<br>        gcc -c sub.c -o sub.o<br>add.o:add.c<br>        gcc -c add.c -o add.o<br>mult.o:mult.c<br>        gcc -c mult.c -o mult.o<br>div.o:div.c<br>        gcc -c div.c -o div.o<br>main.o:main.c<br>        gcc -c main.c -o main.o <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">%.o:%.c<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsDMcIqwYCJ4cTQuls17TCN" --> <p>通配符%::</p><ul><li>%:通配符，匹配一个字符串</li><li>两个%匹配的是同一个字符串</li></ul><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">%.o:%.c <span class="hljs-comment">// 会匹配, sub.o : sub.c, add, mult, div main 同理</span><br>    $(cc) -c $&lt; -o $@ <span class="hljs-comment">// gcc - c sub.o -o app</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$(cc): gcc</span><br><span class="hljs-comment">$^ : 所有的依赖文件 : main.c a.c b.c</span><br><span class="hljs-comment">$@ : 目标的完整名称 :&nbsp;app   </span><br><span class="hljs-comment">$&lt; : 第一个依赖文件的名称</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure><p>改写后：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"># 定义变量<br>src=sub.o add.o mult.o div.o main.o<br>target=app<br>$(target):$(src)<br>        $(CC) $(src) -o $(target)<br>        <br>%.o:%.c<br>        $(CC) -c $&lt; -o $@ <span class="hljs-comment">// gcc - c sub.o -o app</span><br></code></pre></td></tr></tbody></table></figure><ul><li><code>$&lt;</code> 为第一个依赖的名称，</li><li><code>$@</code> 为目标的完整名称，<br><code>%.o:%.c</code>: 首先为 sub.c 生成 sub.o, 后边 add.c, mult.c, div.c, main.c 也能匹配这个规则, 因为一级目标 需要这些二级目标, 所以也会逐个生成</li></ul><!-- basicblock-start oid="ObscwTRNP3NVw5IXIfpM1fDb" --> <h3 id="132-如何简化定义变量的操作"><a class="markdownIt-Anchor" href="#132-如何简化定义变量的操作"></a> 1.3.2 如何简化定义变量的操作::</h3><!-- basicblock-end --><p>定义变量的时候如何自动获取 “.x” 后缀的文件</p><blockquote><p>可以简化定义变量的操作, eg: src=sub.o add.o mult.o div.o main.o</p></blockquote><p>查找指定文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$(wildcard PATTERN...) <span class="hljs-comment">// $(函数名 函数参数)</span><br></code></pre></td></tr></tbody></table></figure><ul><li><p>功能：获取指定目录下<strong>指定类型</strong>的文件列表。</p></li><li><p>参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔。</p></li><li><p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</p></li><li><p>示例：</p></li></ul><!-- basicblock-start oid="undefined" --> <p><code>*</code>通配符::表示任意的</p><!-- basicblock-end --><p><code>$(wildcard ./*.c ./sub/*.c)</code> : 获取当前目录下的.c 文件 和 sub 目录下的.c 文件<br>返回值格式: a.c b.c c.c d.c e.c f.c</p><!-- basicblock-start oid="Obs3pv8eLTaVfMMSJQLJRtpF" --> <h4 id="1321-如何将c-文件变成o-文件"><a class="markdownIt-Anchor" href="#1321-如何将c-文件变成o-文件"></a> 1.3.2.1 如何将.c 文件变成.o 文件::</h4><!-- basicblock-end --><p>查找指定文件并替换：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)<br></code></pre></td></tr></tbody></table></figure><ul><li>示例：</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">$(patsubst %.c, %.o, a.c b.c)<span class="hljs-comment">// 将a.c, b.c 变成 a.o, b.o</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">- 功能：查找&lt;text&gt;中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合<br><br>  模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。<br><br>- &lt;pattern&gt;可以包括通配符`%`，表示任意长度的字串。如果&lt;replacement&gt;<br><br>  中也包含`%`，那么，&lt;replacement&gt;中的这个`%`将是&lt;pattern&gt;中的那个%<br><br>  所代表的字串。(可以用`\`来转义，以`\%`来表示真实含义的`%`字符)<br><br>- 返回：函数返回被替换过后的字符串<br></code></pre></td></tr></tbody></table></figure><p>优化后：</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义变量</span><br><span class="hljs-comment"># add.c sub.c main.c mult.c div.c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span> // 查找当前目录下的.c 文件<br>objs=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span> // 💡将.c 文件替换成.o 文件<br><br>// 💡target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(objs)</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(objs)</span> -o <span class="hljs-variable">$(target)</span><br><br><span class="hljs-section">%.o:%.c</span><br>        <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs3KbfmFrEGqbKcT09Oa6yw" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <h1 id="2-最终版本"><a class="markdownIt-Anchor" href="#2-最终版本"></a> 2 最终版本::</h1><!-- basicblock-end --><p>编译链接后不需要 .o 文件，可以删除，在 makefile 文件里后面加上一条规则。<br>^9qsu74</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义变量</span><br><span class="hljs-comment"># add.c sub.c main.c mult.c div.c</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> ./*.c)</span><br>objs=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span>//💡 .o 文件<br><br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(objs)</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(objs)</span> -o <span class="hljs-variable">$(target)</span><br><br><br><span class="hljs-section">%.o:%.c</span><br>        <span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-section">clean:</span><br>        rm <span class="hljs-variable">$(objs)</span> -f<br></code></pre></td></tr></tbody></table></figure><p><code>clean</code> 规则与第一条规则无关，执行 <code>make</code> 时不会执行 <code>clean</code> 规则。<br>所以只能执行命令make clean删除：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">make clean <span class="hljs-regexp">//</span> 单独执行 clean 命令<br></code></pre></td></tr></tbody></table></figure><hr><p>但当有一个名为 clean 的文件时，因为<code>clean</code> 没有依赖，执行 <code>make clean</code>与名为 clean 的文件对比而更新 clean 文件，导致无法执行 <code>clean</code> 规则。<br>将 <code>clean</code> 定义为伪目标，这样不会生成特定的文件，就不会与名为 clean 的文件对比而无法执行 <code>clean</code> 规则了。</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean // 定义一个伪目标, 这样使用 make clean 就不会与外边的 clean 文件做对比了</span><br><span class="hljs-section">clean:</span><br>        rm <span class="hljs-variable">$(objs)</span> -f<br></code></pre></td></tr></tbody></table></figure><ul><li>&amp; 其实也没必要, 不要在当前目录下创建文件名字为 clean 的文件就行了</li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObshDhqIzljSgBC0Idg3cMFj" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.10 - 1.12 makefile.md" --> <p>#历史记录::<br>2022/9/18🌵1.10 - 1.12 makefile : 简单一点就不用那个简化版本, 复杂的需要简化版本, 我觉得学会原始版本就行. 先掌握了原始版本, 在说简化版的(那个感觉像正则表达式),最终复习版本: [[1.10 - 1.12 makefile#^9qsu74]]⏱2-0,<br>2022/9/19🌵整体复习了一遍, 都看懂了, 简单的⏱0-30</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>18. 从中序与后序遍历序列构造二叉树</title>
    <link href="/posts/31429/"/>
    <url>/posts/31429/</url>
    
    <content type="html"><![CDATA[<h1 id="1-106从中序与后序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#1-106从中序与后序遍历序列构造二叉树"></a> 1 106.从中序与后序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接</a></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>中序遍历 inorder =&nbsp;[9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：</p><p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>![[18. 从中序与后序遍历序列构造二叉树 2022-09-18 10.42.17.excalidraw]]</p><ol><li>后序数组为 0, 空节点<ul><li>&amp; 递归终止条件</li></ul></li><li>后序数组最后一个节点元素为中节点</li><li>寻找中序数组中的中节点,作为切割点</li><li>切中序数组,切成中序左数组和中序右数组 <strong>（顺序别搞反了，一定是先切中序数组）</strong><ul><li>&amp; 因为中序: 左中右: 通过中能够把左右区间找到, 而后序: 左右中, 没法通过中节点把左右区间找到</li></ul></li><li>切后序数组, 切成后序左数组和后序右数组</li><li>递归处理左区间和右区间</li></ol><h2 id="21-思考"><a class="markdownIt-Anchor" href="#21-思考"></a> 2.1 思考</h2><p>前序和中序可以唯一确定一棵二叉树。<br>后序和中序可以唯一确定一棵二叉树。<br>那么前序和后序可不可以唯一确定一棵二叉树呢？<br><strong>前序和后序不能唯一确定一棵二叉树！</strong>，因为没有中序遍历无法确定左右部分，也就是无法分割。<br>举一个例子：</p><p><img src="https://img-blog.csdnimg.cn/20210203154720326.png" alt="106.从中序与后序遍历序列构造二叉树2|700"></p><p>tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。<br>tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。<br>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！<br>所以前序和后序不能唯一确定一棵二叉树！</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><p>v1, 通过, 看懂了, 抄了一遍</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span></span>{<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 💡定义中节点j</span><br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue); <br><br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 💡剪枝</span><br><br>        <span class="hljs-type">int</span> delimiterIndex; <span class="hljs-comment">// 分割符用来确定中序数组中的 "中节点位置下标": 💡用middleINdex更好看一些</span><br>        <span class="hljs-keyword">for</span>(delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++){<br>            <span class="hljs-keyword">if</span>(inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 此时 break 出去后,得到了中节点的下标值</span><br>        }<br>        <span class="hljs-comment">// 💡循环不变量: 左闭右开</span><br>        <span class="hljs-comment">// 切割中序数组: 左中右</span><br>        <span class="hljs-comment">//中序数组的: 左子树区间：[0, delimiterIndex)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<span class="hljs-comment">// 💡下标从 0 开始的, 取不到delimiterIndex</span><br>        <span class="hljs-comment">//中序数组的: 右子树区间: [delimiterIndex + 1, end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br><br>        <span class="hljs-comment">//后序数组 postorder 舍弃末尾元素</span><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br><br>        <span class="hljs-comment">// 切割后序数组: 左右中</span><br>        <span class="hljs-comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span><br>        <span class="hljs-comment">// 后序数组的: 左子树区间[0, leftInorder.size)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-comment">// 后序数组的: 右子树区间[leftInorder.size(), end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        <span class="hljs-comment">// 递归处理</span><br>        <span class="hljs-comment">// 构建左子树, 传入中序数组的左子树区间, 后序数组的左子树区间.这样又是一个中序数组, 一个后序数组, 又可以按照上面的逻辑</span><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br><br>        <span class="hljs-comment">// 构建右子树</span><br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br>        <span class="hljs-keyword">return</span> root;<br><br>        <br><br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt; postorder)</span></span>{<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<span class="hljs-comment">// 💡可以先忽略剪枝</span><br><br>        <span class="hljs-type">int</span> middleIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; middleIndex &lt; inorder.<span class="hljs-built_in">size</span>(); middleIndex++){<br>            <span class="hljs-keyword">if</span>(inorder[middleIndex] == rootValue) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 取出中序数组的中的中节点</span><br>        }<br><span class="hljs-comment">// 💡循环不变量: 左闭右开</span><br><span class="hljs-comment">// 重新定义中序数组的左右区间</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + middleIndex)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + middleIndex + <span class="hljs-number">1</span>, inorder.end())</span></span>;<br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <br><span class="hljs-comment">// 重新定义后序数组的左右区间</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size() , postorder.end())</span></span>; <span class="hljs-comment">// 💡左闭右开, 取得到 middleIndex 那个位置, 看一下exclidraw 就明白了</span><br>        <br><span class="hljs-comment">// 递归处理左右区间</span><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder); <span class="hljs-comment">// 左</span><br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder); <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br><br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>    <span class="hljs-comment">// 💡这里也可以先忽略剪枝</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>此时应该发现了，如上的代码性能并不好，应为每层递归定定义了新的vector（就是数组），既耗时又耗空间，但上面的代码是最好理解的，为了方便读者理解，所以用如上的代码来讲解。</strong><br>下面给出用下标索引写出的代码版本：（思路是一样的，只不过不用重复定义vector了，每次用下标索引来分割）</p><p>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postorderBegin, <span class="hljs-type">int</span> postorderEnd)</span> </span>{<br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorderEnd - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorderEnd - postorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) {<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br>        <span class="hljs-type">int</span> leftPostorderBegin =  postorderBegin;<br>        <span class="hljs-type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是 需要加上 中序区间的大小size</span><br>        <span class="hljs-comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br>        <span class="hljs-type">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>; <span class="hljs-comment">// 排除最后一个元素，已经作为节点了</span><br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    }<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>{<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>());<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-105从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#4-105从前序与中序遍历序列构造二叉树"></a> 4 105.从前序与中序遍历序列构造二叉树</h1><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">力扣题目链接</a></p><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意: 你可以假设树中没有重复的元素。</p><p>例如，给出</p><p>前序遍历 preorder =&nbsp;[3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsZWXTX5hBxE5V1bPIDc5LR"  --> <p>#历史记录::<br>2022/9/18🌵18. 从中序与后序遍历序列构造二叉树 :v1, 通过看懂了, 抄了一遍 , # 105.从前序与中序遍历序列构造二叉树没做⏱1-10<br>2022/9/18🌵18. 从中序与后序遍历序列构造二叉树: v2, 抄了一遍⏱0-15</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年09月15日 实验设计</title>
    <link href="/posts/9190/"/>
    <url>/posts/9190/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsgXRty2uIaSNhMVByK63rc" deck = "👨🏻‍🎓科研::2022::09::2022年09月15日 实验设计.md" --> <p>#历史记录::<br>2022/9/15🌵2022年09月15日 实验设计</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
      <category>2022</category>
      
      <category>09</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关键字与运算符</title>
    <link href="/posts/44179/"/>
    <url>/posts/44179/</url>
    
    <content type="html"><![CDATA[<h1 id="1-指针与引用目录"><a class="markdownIt-Anchor" href="#1-指针与引用目录"></a> 1 [[指针与引用目录]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obs2B8oGr5nTzAffAQrPykHp"  extra = "[margin](marginnote3app://note/DF7FE30B-C7ED-4374-AA09-FDD201AA5A93)"--> <h1 id="2-const-关键字"><a class="markdownIt-Anchor" href="#2-const-关键字"></a> 2 [[const 关键字]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsgLK5epyESFi7Y3d3ciOJg"  extra = "[margin](marginnote3app://note/53F1C912-5C26-418E-AF65-412FA8360CD4)"--> <h1 id="3-define和typedef的区别"><a class="markdownIt-Anchor" href="#3-define和typedef的区别"></a> 3 [[define和typedef的区别]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obsy1SMLwOpHxSLCrrHTVBF9"  extra = "[margin](marginnote3app://note/2C28D3E0-C477-4881-85C5-7E06660DD83B)"--> <h1 id="4-define和inline的区别"><a class="markdownIt-Anchor" href="#4-define和inline的区别"></a> 4 [[define和inline的区别]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obs9omdQgY1cgqxwiut7ieAM"  extra = "[margin](marginnote3app://note/B576E328-63AD-4A2A-B7D5-CADA708C14E1)"--> <h1 id="5-override和overload"><a class="markdownIt-Anchor" href="#5-override和overload"></a> 5 [[override和overload]] ::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsTRZAQ4AT7xrE5t688Ln79"  extra = "[margin](marginnote3app://note/82808465-7D55-484C-A354-9CD4CD5A73AE)"--> <h1 id="6-new-delete-malloc-free-目录"><a class="markdownIt-Anchor" href="#6-new-delete-malloc-free-目录"></a> 6 [[new delete &amp; malloc free 目录]] ::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsHLqiUdLoOGs864sKGvo5P"  extra = "[margin](marginnote3app://note/9E7B3406-DEE7-4CE6-B315-FF5135902FA6)"--> <h1 id="7-constexpr和const-c新特性"><a class="markdownIt-Anchor" href="#7-constexpr和const-c新特性"></a> 7 [[constexpr和const  (C++新特性)]]::</h1><p>[[C++新特性]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsoptukXVhaTzjg3zFG2Vi1" deck= "❓疑问::👨🏻‍💻code::C++::C++基础::关键字与运算符.md"--><h1 id="8-const和static的区别"><a class="markdownIt-Anchor" href="#8-const和static的区别"></a> 8 [[const和static的区别]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsvSnEVdYtjuqO8Jggw5Lho"  extra = "[margin](marginnote3app://note/D21576CA-7330-4573-8A4C-12353C65B912)"--> <h1 id="9-extern-与-static"><a class="markdownIt-Anchor" href="#9-extern-与-static"></a> 9 [[extern 与 static]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsYyg34Q20TONVH4v5d3iws"  extra = "[margin](marginnote3app://note/F2C85E29-1092-4D10-89F0-9FA8884AA5E0)"--> <h1 id="10-前置与后置"><a class="markdownIt-Anchor" href="#10-前置与后置"></a> 10 [[前置<ins>与后置</ins>]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObskjT4JilAyWTfqhHerVJ3h"  extra = "[margin](marginnote3app://note/AF118F7E-D507-4AA5-AA33-0B9C547E71A7)"--> <h1 id="11-stdatomic"><a class="markdownIt-Anchor" href="#11-stdatomic"></a> 11 [[stdatomic]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsyGuXVhYhkcSH0zbyC5ExF"  extra = "[margin](marginnote3app://note/025A6CAE-DC4A-44BE-85DF-74E7B59576A5)"--> <h1 id="12-c-三大特性"><a class="markdownIt-Anchor" href="#12-c-三大特性"></a> 12 [[C++ 三大特性]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsiCuXCs2Z4xHIIoeul3Obb"  extra = "[margin](marginnote3app://note/E065ED15-11D5-44DD-88FC-8183FA89C037)"--> <h1 id="13-虚函数"><a class="markdownIt-Anchor" href="#13-虚函数"></a> 13 [[虚函数]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="Obss2iG3hoVvrTUQes8cQP6V"  extra = "[margin](marginnote3app://note/E4A2E8E7-C6DF-4B57-970D-205737CFFC4C)"--> <h1 id="14-为什么需要虚继承"><a class="markdownIt-Anchor" href="#14-为什么需要虚继承"></a> 14 [[为什么需要虚继承]]::</h1><!-- basicblock-end --><!-- basicblock-start oid="ObsW93KnNeVsEVri938VUYsu"  extra = "[margin](marginnote3app://note/D9853C54-DBD1-4C62-97AE-DA1E98F569AC)"--> <h1 id="15-空类"><a class="markdownIt-Anchor" href="#15-空类"></a> 15 [[空类]]::</h1><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18. 路径总和</title>
    <link href="/posts/38740/"/>
    <url>/posts/38740/</url>
    
    <content type="html"><![CDATA[<p>112.路径总和::<br>2022/09/10🌵112. 路径总和: 递归法看懂了, 理解了回溯的过程(断点调试), 但是没对着打一遍, 迭代法不用看. ⏱1-04<br>2022/09/11🌵113. 路径总和ii, 递归的时候就多了一个回溯操作而已, 看懂了, 但是没对着写一遍代码⏱0-12<br>2022/09/12🌵112. 路径总和:  看v2简短代码, 理解其过程了⏱0-50<br>2022/09/13🌵113. 路径总和ii, v2: 未通过, 错误在❗️处, 不懂怎么解决⏱0-30</p><!-- basicblock-end --><p>相信很多同学都会疑惑，递归函数什么时候要有返回值，什么时候没有返回值，特别是有的时候递归函数返回类型为bool类型。</p><p>那么接下来我通过详细讲解如下两道题，来回答这个问题：</p><ul><li>112.路径总和</li><li>113.路径总和ii</li></ul><h1 id="1-112路径总和"><a class="markdownIt-Anchor" href="#1-112路径总和"></a> 1: 112路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/">力扣题目链接</a></p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明:&nbsp;叶子节点是指没有子节点的节点。</p><p>示例:&nbsp; 给定如下二叉树，以及目标和 sum = 22，</p><p><img src="https://img-blog.csdnimg.cn/20210203160355234.png" alt="112.路径总和1"></p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><h2 id="11-思路"><a class="markdownIt-Anchor" href="#11-思路"></a> 1.1: 思路::</h2><p><img src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和|600"></p><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p><ol><li>确定递归函数的参数和返回类型<br>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。<br>返回值: bool 类型: true, false</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span>   <span class="hljs-comment">// 注意函数的返回类型</span></span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>确定终止条件</li></ol><p>首先计数器如何统计这一条路径的和呢？</p><p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p><p><strong>如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。</strong></p><p>如果遍历到了叶子节点，count不为0，就是没找到。</p><p>递归终止条件代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>确定单层递归的逻辑</li></ol><!-- basicblock-start oid="Obsrzv5G8Uy3849rJgnF7ZzQ" --> <p>终止条件是判断叶子节点::递归的过程中就不要让空节点进入递归了。</p><p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左 ,💡终止条件是判断叶子节点::递归的过程中就不要让空节点进入递归了。</span><br>    count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>    count -= cur-&gt;right-&gt;val;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;right-&gt;val;<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h2 id="12-代码"><a class="markdownIt-Anchor" href="#12-代码"></a> 1.2: 代码</h2><p>carl &amp; v1:</p><!-- basicblock-start oid="ObsvtEcJKanSyKW74de5qkZA" --> <p>回溯的过程::<br>// 💡回溯就是递归在返回上一层的时候在多加一个步骤.<br>// 💡普通的递归返回上一层,只是没有附带一个操作. 这个操作就是回溯</p><!-- basicblock-end --><p>v1, 无法通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>{<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) { <span class="hljs-comment">// 左</span><br>            count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, count);<br>            <span class="hljs-comment">// 💡回溯就是递归在返回上一层的时候在多加一个步骤. </span><br>            <span class="hljs-comment">// 💡普通的递归返回上一层,只是没有附带一个操作. 这个操作就是回溯</span><br>            count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) { <span class="hljs-comment">// 右</span><br>            count -= cur-&gt;right-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, count);<br>            count += cur-&gt;right-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>以上代码精简之后如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">haspathsum</span><span class="hljs-params">(treenode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">haspathsum</span>(root-&gt;left, sum - root-&gt;val) || <span class="hljs-built_in">haspathsum</span>(root-&gt;right, sum - root-&gt;val);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>是不是发现精简之后的代码，已经完全看不出分析的过程了，所以我们要把题目分析清楚之后，在追求代码精简。</strong> 这一点我已经强调很多次了！</p><p>v2: 通过, v1 版不精简版无法通过, 看这个就行</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// ❓为什么返回 true 会直接退出, 返回 false 却不会</span><br>        }<br>        <span class="hljs-comment">// ❗️没办法把两个返回值拆开</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="2-路径总和ii"><a class="markdownIt-Anchor" href="#2-路径总和ii"></a> 2: [[路径总和ii]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17. 找左下角的值</title>
    <link href="/posts/61049/"/>
    <url>/posts/61049/</url>
    
    <content type="html"><![CDATA[<h1 id="1-513找树左下角的值"><a class="markdownIt-Anchor" href="#1-513找树左下角的值"></a> 1 513.找树左下角的值</h1><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">力扣题目链接</a></p><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p>示例 1:</p><p><img src="https://img-blog.csdnimg.cn/20210204152956836.png" alt="513.找树左下角的值"></p><p>示例 2:</p><p><img src="https://img-blog.csdnimg.cn/20210204153017586.png" alt="513.找树左下角的值1"></p><!-- basicblock-start oid="Obs4VYeWXPGHrCmOJadXeitc" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>找出树的最后一行找到最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。</p><p>层序遍历只需要记录最后一行的第一个节点数值就可以了<br>每一层都记录一下第一个节点的值, 然后不断覆盖即可, 到了最后就得到了最后一行的第一个节点</p><!-- basicblock-end --><!-- basicblock-start oid="ObslzqM4Ig02v8E6kbj5Urfv" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码::</h1><!-- basicblock-end --><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 记录最后一行第一个元素, 每一层都覆盖一遍, 直至最后一层</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 💡放到 pop() 上边 下边都行</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);  <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObstWMFjjheISVPVJbxyCfhl" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::17. 找左下角的值.md" --> <p>#历史记录::<br>2022/09/10🌵17. 找左下角的值 : 层序遍历很简单, 递归不用看⏱0-26<br>2022/09/12🌵17. 找左下角的值 : 独立写出来了, 很简单 ⏱0-10</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16.左叶子之和</title>
    <link href="/posts/50095/"/>
    <url>/posts/50095/</url>
    
    <content type="html"><![CDATA[<h1 id="1-404左叶子之和"><a class="markdownIt-Anchor" href="#1-404左叶子之和"></a> 1 404.左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">力扣题目链接</a></p><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><p><img src="https://img-blog.csdnimg.cn/20210204151927654.png" alt="404.左叶子之和1"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p><!-- basicblock-start oid="ObsffknYZdQ1qeK2vt83Mc3d" --> <p>如何判断左叶子节点::<br>通过当前节点无法判断, <strong>要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p><ol><li>如果该节点的左节点不为空，</li><li>该节点的左节点的左节点为空(左孙子)，该节点的左节点的右节点为空，</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    左叶子节点处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>2022/9/19;;;;;;;fsdfsf；;　;张,i。。。。1150-220=930.00</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftlValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left); <span class="hljs-comment">// 💡收集左子树的左叶子和,</span><br>        <span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<span class="hljs-comment">// 💡收集右子树的左叶子和,</span><br>        <span class="hljs-type">int</span> midValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果是判断是左叶子, 就把它的值收集起来(辅给一个中间变量)</span><br>        <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>){<br>            midValue = root-&gt;left-&gt;val;<br>        } <br>        <span class="hljs-comment">// 不断叠加</span><br>        <span class="hljs-type">int</span> sum = midValue + leftlValue +  rightValue;<span class="hljs-comment">// 💡 某个子树的根节点的左叶子和是其左右子树的和,然后返回给该节点, 该节点又成为上一层的左/右子树, 最后不断递归到原始根节点</span><br>        <span class="hljs-keyword">return</span> sum;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2 , 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftSum = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightSum = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️❓  if(!root-&gt;left &amp;&amp; root-&gt;left-&gt;left &amp;&amp; root-&gt;left-&gt;right)不行</span><br>            temp = root-&gt;left-&gt;val;<br>        }<br>        <span class="hljs-type">int</span> sum = temp + leftSum + rightSum;<br>        <span class="hljs-keyword">return</span> sum;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsPayaRA0PkUVLasN5bPggx" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::16.左叶子之和.md" --> <p>#历史记录::<br>2022/09/10🌵16.左叶子之和 : 递归: 大概懂了, sum 那块还有点懵 ➕ 层序遍历没看 ⏱0-33<br>2022/09/12🌵16.左叶子之和 : sum 那块看懂了,  写在了 v1 的代码中⏱0-26</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15. 二叉树中递归带着回溯</title>
    <link href="/posts/63200/"/>
    <url>/posts/63200/</url>
    
    <content type="html"><![CDATA[<p>二叉树中递归带着回溯::</p><p>[[4.组合总和III]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++){ <span class="hljs-comment">// ❗️不要忘记=号</span><br>    <span class="hljs-comment">//sum += i;</span><br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(n, k , i+<span class="hljs-number">1</span>, sum + i); <span class="hljs-comment">// 💡sum + i 直接传进这里跟注释的效果一样</span><br>    <span class="hljs-comment">//sum -= i;</span><br>    path.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></tbody></table></figure><p>[[13. 二叉树的所有路径]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) <span class="hljs-built_in">traversal</span>(cur-&gt;left, path + <span class="hljs-string">"-&gt;"</span>, result); <span class="hljs-comment">// 左  回溯就隐藏在这里</span><br></code></pre></td></tr></tbody></table></figure><p>大家应该可以感受出来，如果把 <code>path + "-&gt;"</code>作为函数参数就是可以的，因为并有没有改变path的数值，执行完递归函数之后，path依然是之前的数值（相当于回溯了）: <strong>相当于后边会执行 path.pop_back()</strong></p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObskFrGZ75Wu05UQz4f05D4w" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::15. 二叉树中递归带着回溯.md" --> <p>#历史记录::<br>2022/09/10🌵15. 二叉树中递归带着回溯 : 看不太懂 ⏱0-13<br>2022/09/12🌵15. 二叉树中递归带着回溯:&nbsp;通过断点调试看懂了, 只看我代码备注💡的 ⏱0-15</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.9 静态库和动态库的对比</title>
    <link href="/posts/43829/"/>
    <url>/posts/43829/</url>
    
    <content type="html"><![CDATA[<h1 id="1-静态库和动态库的对比"><a class="markdownIt-Anchor" href="#1-静态库和动态库的对比"></a> 1 静态库和动态库的对比::</h1><h2 id="11-程序编译成可执行程序的过程"><a class="markdownIt-Anchor" href="#11-程序编译成可执行程序的过程"></a> 1.1 程序编译成可执行程序的过程::</h2><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209111652798.png" alt="|800"></p><ul><li>&amp; 动态库和静态库的区别就在于<strong>链接阶段如何处理库</strong></li></ul><p>静态库: 把库的整个内容拷进去<br>动态库: 告知这个库里有什么东西，在哪里放着，运行的实际过程中才会去找这个库</p><p>这两种处理方式也分别被称为静态链接方式和动态链接方式</p><p>[[静态链接和动态链接]]</p><ul><li><p>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中。</p></li><li><p><strong>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中。</strong></p>  <!-- basicblock-start oid="Obsu7fQJvLLr52HkOlZPBkYd" deck= "❓疑问::👨🏻‍💻code::项目::webserver::1 第一章::1.9 静态库和动态库的对比.md"--><ul><li>程序启动之后，动态库会被动态加载到内存中，通过 ldd (list dynamic dependencies)命令检查动态库依赖关系。</li><li>如何定位共享库文件呢：当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是 由ld-linux.so来完成的，它先后搜索elf文件的 <strong>DT_RPATH</strong>段 ——&gt; <strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong> ——&gt; <strong>/etc/ld.so.cache</strong>文件列表 ——&gt; <strong>/lib/</strong>，/usr/lib 目录找到库文件后将其载入内存。</li></ul>  <!-- basicblock-end --></li></ul><h1 id="2-静态库和动态库的制作过程"><a class="markdownIt-Anchor" href="#2-静态库和动态库的制作过程"></a> 2 静态库和动态库的制作过程::</h1><p>![[1.9 静态库和动态库的对比 2022-09-08 16.41.22.excalidraw]]<br>[[1.4-1.6  静态库和动态库#^hr9kzt]], [[1.4-1.6  静态库和动态库#^8oo3nd]]</p><h1 id="3-静态库与动态库的优缺点"><a class="markdownIt-Anchor" href="#3-静态库与动态库的优缺点"></a> 3 静态库与动态库的优缺点::</h1><h2 id="31-静态库的优缺点"><a class="markdownIt-Anchor" href="#31-静态库的优缺点"></a> 3.1 静态库的优缺点</h2><p>优点:</p><ul><li>静态库被打包到应用程序中加载速度快,<ul><li>&amp; 因为代码直接打包进去了</li></ul></li><li>发布程序无需提供静态库，移植方便</li></ul><p>缺点:</p><ul><li>消耗系统资源，浪费内存</li><li>更新、部署、发布麻烦<ul><li>&amp; 如果静态库更新了,所有使用它的应用程序都需要重新编译、发布给用户(对于玩家来说,只是一个很小的改动,却导致整个程序重新下载,全量更新)。而且静态库占用空间,所以有了动态库<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209151506567.png" alt=""></li></ul></li></ul><h2 id="32-动态库的优缺点"><a class="markdownIt-Anchor" href="#32-动态库的优缺点"></a> 3.2 动态库的优缺点</h2><p>优点:</p><ul><li>可以实现进程间资源共享(共享库)<ul><li>&amp; 因为每一次执行都要调用某路径下的文件, 该路径下的文件可以实现共享，也可以实时修改</li></ul></li><li>更新、部署、发布简单<ul><li>&amp; 动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</li></ul></li><li>可以控制何时加载动态库</li></ul><p>缺点：</p><ul><li>加载速度比静态库慢, 其实相差不太多</li><li>发布程序时需要提供依赖的动态库</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209151506969.png" alt=""></p><p><strong>所以，库较小时建议制作静态库，库较大时建议制作动态库。</strong></p><p><a href="https://zeefan.notion.site/?v=c8f779be7dee48979931444cb7d77ada">https://zeefan.notion.site/?v=c8f779be7dee48979931444cb7d77ada</a></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsn2hnDuXPvMfqmeRaZcaRt" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.9 静态库和动态库的对比.md" --> <p>#历史记录::<br>2022/9/8🌵1.9 静态库和动态库的对比  大概看了一下, 做了卡片</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.1 阻塞和非阻塞、同步和异步(网络 IO)</title>
    <link href="/posts/47674/"/>
    <url>/posts/47674/</url>
    
    <content type="html"><![CDATA[<h1 id="1-阻塞非阻塞-同步异步网络io方面的"><a class="markdownIt-Anchor" href="#1-阻塞非阻塞-同步异步网络io方面的"></a> 1 阻塞/非阻塞、同步/异步(网络IO方面的)::</h1><!-- basicblock-end --><p>典型的一次IO的两个阶段是什么::<br>数据就绪 和 数据读写</p><h2 id="11-数据就绪"><a class="markdownIt-Anchor" href="#11-数据就绪"></a> 1.1 数据就绪</h2><p>根据系统IO操作的就绪状态分为</p><ul><li>阻塞</li><li>非阻塞</li></ul><h2 id="12-数据读写"><a class="markdownIt-Anchor" href="#12-数据读写"></a> 1.2 数据读写</h2><p>根据应用程序和内核的交互方式分为 2</p><ul><li>同步</li><li>异步<ul><li>多路 IO 复用是异步</li></ul></li></ul><p>陈硕(人名):在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。</p><ul><li>&amp; 调用 recv, read 等等都是同步 IO, 使用特殊的接口才是异步 IO</li></ul><p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，<br>数据就绪阶段分为 阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p><ul><li>同步: 表示A向B请求调用一个网络IO接口时(或者调用某个业务逻辑API接口时)，数据的读写都是 由请求方A自己来完成的(不管是阻塞还是非阻塞);</li><li>异步: 表示A向B请求调用一个网络IO接口时 (或者调用某个业务逻辑API接口时)，向B传入请求的事件以及事件发生时通知的方式，A就可以 处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。<ul><li>&amp; 本项目不涉及异步, 因为编程很复杂</li></ul></li></ul><p>![[5.1 阻塞和非阻塞、同步和异步(网络 IO) 2022-09-21 16.37.09.excalidraw]]</p><p>同步阻塞<br>同步非阻塞</p><p>异步阻塞<br>异步非阻塞</p><p>邓东阿帆<br>11红灯红灯</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsnGZZO4uLPB3Gs2SpBicnM" deck = "👨🏻‍💻code::项目::webserver::5 第五章::5.1 阻塞和非阻塞、同步和异步(网络 IO).md" --> <p>#历史记录::<br>2022/9/8🌵5.1 阻塞和非阻塞、同步和异步(网络 IO) : 很好理解 ⏱1-00</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>5  项目实战与总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>14.二叉树周末总结</title>
    <link href="/posts/30222/"/>
    <url>/posts/30222/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObseXnu8DtSTQzxUsk2P21vj" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::14.二叉树周末总结.md" --> <p>#历史记录::<br>2022/9/10🌵14.二叉树周末总结 : 没看</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13. 二叉树的所有路径</title>
    <link href="/posts/41119/"/>
    <url>/posts/41119/</url>
    
    <content type="html"><![CDATA[<h1 id="1-二叉树的所有路径"><a class="markdownIt-Anchor" href="#1-二叉树的所有路径"></a> 1 二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/">力扣题目链接</a></p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。<br>示例:<br><img src="https://img-blog.csdnimg.cn/2021020415161576.png" alt="257.二叉树的所有路径1|600"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>因为要求根节点到叶子节点的路径,只有<strong>用前序遍历(中左右), 才能先父节点, 在孩子节点</strong></p><p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。<br>![[13. 二叉树的所有路径 2022-09-08 10.28.43.excalidraw]]</p><h2 id="21-21递-归函数函数参数以及返回值"><a class="markdownIt-Anchor" href="#21-21递-归函数函数参数以及返回值"></a> 2.1 2.1递 归函数函数参数以及返回值</h2><p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; path, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; result)</span><br></code></pre></td></tr></tbody></table></figure><h2 id="22-确定递归终止条件"><a class="markdownIt-Anchor" href="#22-确定递归终止条件"></a> 2.2 确定递归终止条件</h2><p>再写递归的时候都习惯了这么写：</p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if (cur <span class="hljs-operator">=</span><span class="hljs-operator">=</span> NULL) {<br>    终止处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsWo0JTseUeo6ZW6o58eWaj" --> <p><strong>本题要找到叶子节点，就开始结束的处理逻辑的写法</strong> ::</p><p><strong>那么什么时候算是找到了叶子节点？</strong><br><s>通过父节点来判断叶子节点, 左叶子同理</s><br>当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。</p><p>所以本题的终止条件是：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) {<br>    终止处理逻辑<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不为空才开始递归</span><br><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h3 id="221-终止处理的逻辑"><a class="markdownIt-Anchor" href="#221-终止处理的逻辑"></a> 2.2.1 终止处理的逻辑</h3><!-- basicblock-start oid="ObsYiit19mGwqF3uu5oWbxio" --> <p>使用vector方便来做回溯::</p><p>这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。</p><p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p><!-- basicblock-end --><p>这里我们先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// 遇到叶子节点</span><br>    string sPath;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) { <span class="hljs-comment">// 将path里记录的路径转为string格式</span><br>        sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>        sPath += <span class="hljs-string">"-&gt;"</span>;<br>    }<br>    sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 记录最后一个节点（叶子节点）</span><br>    result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 收集一个路径</span><br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="23-确定单层递归逻辑"><a class="markdownIt-Anchor" href="#23-确定单层递归逻辑"></a> 2.3 确定单层递归逻辑</h2><p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p><p><code>path.push_back(cur-&gt;val);</code></p><p>然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p><p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不为空才开始递归</span><br><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>}<br></code></pre></td></tr></tbody></table></figure><p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p><!-- basicblock-start oid="ObsnMwvRLXkxbDNPD7V0J75I" --> <p>回溯怎么写::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>}<br>path.pop_back();<br></code></pre></td></tr></tbody></table></figure><p>这个回溯就要很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。</p><p><strong>所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p><p>那么代码应该这么写：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (cur-&gt;left) {<br>    traversal(cur-&gt;left, path, result);<br>    path.pop_back(); <span class="hljs-comment">// 回溯</span><br>}<br><span class="hljs-keyword">if</span> (cur-&gt;right) {<br>    traversal(cur-&gt;right, path, result);<br>    path.pop_back(); <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* cur , vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">// 先添加 path</span><br>        <span class="hljs-keyword">if</span>(cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>){<br>            string sPath;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++){<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">"-&gt;"</span>;<br>            }<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]); <span class="hljs-comment">// 最后一个节点要单独记录一下, 因为放到循环里会多一个"-&gt;"</span><br>            result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 记录一次路径</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;left){<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;right){<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>         vector&lt;string&gt; result; <span class="hljs-comment">// 初始化是🈚️</span><br>         vector&lt;<span class="hljs-type">int</span>&gt; path;<br>         <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>         <span class="hljs-built_in">traversal</span>(root, path, result);<br>         <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* cur , vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">//"中", 先添加 path, 因为是到了叶子节点就收集,如果在if结果下边, 就会漏掉叶子节点</span><br>        <span class="hljs-keyword">if</span>(cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 💡到了叶子节点才会执行</span><br>            string sPath;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++){<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">"-&gt;"</span>;<br>            }<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]); <span class="hljs-comment">// 最后一个节点要单独记录一下, 因为放到循环里会多一个"-&gt;"</span><br>            result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 记录一次路径</span><br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// ❓什么也没有 return 只是单纯的返回上一层?💡是的 因为返回值是 void</span><br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;left){ <span class="hljs-comment">// ❗️空指针不进入递归, 否则第一行代码就操作空指针了</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// 回溯</span><br>        }<br>        <span class="hljs-keyword">if</span>(cur-&gt;right){<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 💡返回上一层后开始由下至上执行回溯</span><br>        }<br>    }<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>         vector&lt;string&gt; result; <span class="hljs-comment">// 初始化是🈚️</span><br>         vector&lt;<span class="hljs-type">int</span>&gt; path;<br>         <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>         <span class="hljs-built_in">traversal</span>(root, path, result);<br>         <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3,通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* node, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span>{<br>        path.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 💡如果放到 if 语句下边会漏掉叶子节点</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>){<br>            string sPath;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++){<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">"-&gt;"</span>;<br>            }<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]);<br>            result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// ❗️应当在 if 函数中, 因为 sPath 出去 if 函数就失效了</span><br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// ❗️return 在 if 函数中</span><br>        }<br><br><br>        <span class="hljs-keyword">if</span>(node-&gt;left){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;left, path, result); <span class="hljs-comment">// ❗️不要忘了其他参数: path, result;</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>        <span class="hljs-keyword">if</span>(node-&gt;right){<br>            <span class="hljs-built_in">getPath</span>(node-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>        <span class="hljs-keyword">return</span> ;<br>    }<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        vector&lt;string&gt; result;<br>        <span class="hljs-built_in">getPath</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-精简代码"><a class="markdownIt-Anchor" href="#4-精简代码"></a> 4 精简代码</h1><p>[[15. 二叉树中递归带着回溯]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsQ3rLCCR2MhM7QhYfBTDty" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::13. 二叉树的所有路径.md" --> <p>#历史记录::<br>2022/09/08🌵13. 二叉树的所有路径 :代码抄了一遍, 中间还夹杂着和师弟聊天⏱1-15<br>2022/09/09🌵 13. 二叉树的所有路径 :复习了一遍, 关于回溯的第二遍过程还没想是怎么实现的⏱0-43<br>2022/09/ 11 🌵13. 二叉树的所有路径 : v3 ,熟悉一遍吧, 自己边写边看,不算独立写出来⏱0-30</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.7 - 1.8 动态库加载失败原因</title>
    <link href="/posts/27351/"/>
    <url>/posts/27351/</url>
    
    <content type="html"><![CDATA[<h1 id="1-动态库加载失败的原因"><a class="markdownIt-Anchor" href="#1-动态库加载失败的原因"></a> 1 动态库加载失败的原因</h1><p>工作原理：</p><ul><li>静态库：GCC 进行链接时，会把静态库中代码打包到可执行程序中。</li><li><strong>动态库：GCC 进行链接时，动态库的代码不会被打包到可执行程序中。(报错的原因)</strong></li><li>程序启动之后，动态库会被动态加载到内存中，通过 ldd (list dynamic dependencies)命令检查动态库依赖关系。<strong>列出动态的依赖</strong></li><li>如何定位共享库文件呢：当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的<strong>动态载入器</strong>来获取该绝对路径。</li><li>对于elf格式的可执行程序，是 由<strong><a href="http://ld-linux.so">ld-linux.so</a></strong>(<strong>动态载入器</strong>)来完成的，它先后搜索elf文件的 <strong>DT_RPATH</strong>段 ——&gt; <strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong> ——&gt; <strong>/etc/ld.so.cache</strong>文件列表 ——&gt; <strong>/lib/</strong>，/usr/lib (这个不建议)目录找到库文件后将其载入内存。<ul><li>&amp; 就在这几个目录中，放入你的动态库，让系统找到就行了</li></ul></li></ul><p>ldd 命令检查动态库依赖关系：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> main<br></code></pre></td></tr></tbody></table></figure><p>发现 <code>libcalc.so =&gt; not found</code> ：</p><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">linux-vdso.<span class="hljs-keyword">so</span>.1 =&gt;  (0x00007ffcd55f8000)<br>libcalc.<span class="hljs-keyword">so</span> =&gt; not found<br>libc.<span class="hljs-keyword">so</span>.6 =&gt; /lib64/libc.<span class="hljs-keyword">so</span>.6 (0x00007fe2ddf8f000)<br>/lib64/ld-linux-x86-64.<span class="hljs-keyword">so</span>.2 (0x000055996189f000)<br></code></pre></td></tr></tbody></table></figure><p>动态库加载失败的原因：查找动态库的时候找不到动态库，因为没有指定动态库的绝对路径。</p><p>解决方法：在搜索 elf 文件的路径下配置，这样在查找的时候就能找到。</p><p><strong>DT_RPATH</strong>段改变不了，就需要修改环境变量。<br>发森</p><h2 id="11-配置动态库环境变量"><a class="markdownIt-Anchor" href="#11-配置动态库环境变量"></a> 1.1 配置动态库环境变量</h2><p>海红灯神岛</p><h3 id="111-修改环境变量-ld_library_path"><a class="markdownIt-Anchor" href="#111-修改环境变量-ld_library_path"></a> 1.1.1 修改<strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong>。</h3><p>方法一：临时修改 <strong>环境变量</strong> <strong>LD_LIBRARY_PATH</strong>。</p><p>首先确定动态库所在路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">pwd<br><span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library/lib<br></code></pre></td></tr></tbody></table></figure><p>改变环境变量：</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/lib<br></code></pre></td></tr></tbody></table></figure><p>(<code>:</code> 表示拼接)</p><p>查看设置好的环境变量：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></tbody></table></figure><p>(备注：清除环境变量命令)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> LD_LIBRARY_PATH<br></code></pre></td></tr></tbody></table></figure><p>结果：</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/li<br></code></pre></td></tr></tbody></table></figure><p>用 ldd 命令检查动态库依赖关系：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> main<br></code></pre></td></tr></tbody></table></figure><p>这时候发现 <code>libcalc.so</code> 查找到了路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">linux-vdso.so.<span class="hljs-number">1</span> =&gt;  (<span class="hljs-number">0</span>x00007ffe8efa3000)<br>libcalc.so =&gt; <span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library<span class="hljs-regexp">/lib/</span>libcalc.so(<span class="hljs-number">0</span>x00007f907702f000)<br>libc.so.<span class="hljs-number">6</span> =&gt; <span class="hljs-regexp">/lib64/</span>libc.so.<span class="hljs-number">6</span> (<span class="hljs-number">0</span>x00007f9076c65000)<br><span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span> (<span class="hljs-number">0</span>x00005597336f6000)<br></code></pre></td></tr></tbody></table></figure><p>运行 main 程序成功：</p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">./main<br>a = <span class="hljs-number">20</span>, <span class="hljs-keyword">b</span> = <span class="hljs-number">12</span><br>a + <span class="hljs-keyword">b</span> = <span class="hljs-number">32</span><br>a - <span class="hljs-keyword">b</span> = <span class="hljs-number">8</span><br>a * <span class="hljs-keyword">b</span> = <span class="hljs-number">240</span><br>a / <span class="hljs-keyword">b</span> = <span class="hljs-number">1</span>.<span class="hljs-number">666667</span><br></code></pre></td></tr></tbody></table></figure><p>但是该方法不是永久的，因为环境变量是在终端里配置的，所以重新打开终端就要重新配置环境变量。</p><p>永久配置方法：</p><p>有两种，用户级别的配置和系统级别的配置。</p><p>用户级别的配置：</p><p>home 文件（root）下，其实有一个 <code>.bashrc</code> 文件，配置该文件即可。</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">vim <span class="hljs-string">.bashrc</span><br></code></pre></td></tr></tbody></table></figure><p><code>shift + G</code> 跳到最后一行，按 <code>o</code> 插入。</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/lib<br></code></pre></td></tr></tbody></table></figure><p><code>:wq</code> 保存并退出：<code>esc</code> 键退出 -&gt; <code>:</code> (符号输入)-&gt; <code>wq</code> (保存退出)</p><p>使得修改生效：</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">. <span class="hljs-string">.bashrc</span><br><span class="hljs-string">//</span> 或者<br>source <span class="hljs-string">.bashrc</span><br></code></pre></td></tr></tbody></table></figure><p>在 library 用 ldd 命令检查动态库依赖关系：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> main<br></code></pre></td></tr></tbody></table></figure><p>这时候发现 <code>libcalc.so</code> 查找到了路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">linux-vdso.so.<span class="hljs-number">1</span> =&gt;  (<span class="hljs-number">0</span>x00007ffe8efa3000)<br>libcalc.so =&gt; <span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library<span class="hljs-regexp">/lib/</span>libcalc.so(<span class="hljs-number">0</span>x00007f907702f000)<br>libc.so.<span class="hljs-number">6</span> =&gt; <span class="hljs-regexp">/lib64/</span>libc.so.<span class="hljs-number">6</span> (<span class="hljs-number">0</span>x00007f9076c65000)<br><span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span> (<span class="hljs-number">0</span>x00005597336f6000)<br></code></pre></td></tr></tbody></table></figure><p>系统级别的设置：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></tbody></table></figure><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">export <span class="hljs-title class_">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span><span class="hljs-symbol">:/root/Linux/lesson1</span>.<span class="hljs-number">6</span>/library/lib<br></code></pre></td></tr></tbody></table></figure><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span> <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$LD_LIBRARY_PATH</span><br></code></pre></td></tr></tbody></table></figure><p>发现拼接问题：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:<span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library<span class="hljs-regexp">/lib:/</span>root<span class="hljs-regexp">/Linux/</span>lesson1.<span class="hljs-number">6</span><span class="hljs-regexp">/library/</span>lib:<span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library/lib<br></code></pre></td></tr></tbody></table></figure><p>这是因为前面设置了用户级别的环境变量，导致出错，重新打开 shell 即可。</p><h3 id="112-修改etcldsocache文件"><a class="markdownIt-Anchor" href="#112-修改etcldsocache文件"></a> 1.1.2 修改**/etc/ld.so.cache**文件</h3><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>ld.so.cache<br></code></pre></td></tr></tbody></table></figure><p>发现是二进制文件，无法修改，需要间接地修改。</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo <span class="hljs-keyword">vim</span> /etc/ld.<span class="hljs-keyword">so</span>.<span class="hljs-keyword">conf</span><br></code></pre></td></tr></tbody></table></figure><p>写入路径：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/root/</span>Linux<span class="hljs-regexp">/lesson1.6/</span>library/lib<br></code></pre></td></tr></tbody></table></figure><p>更新：</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo ldconfig</span><br></code></pre></td></tr></tbody></table></figure><h3 id="113-放到lib或usrlib下"><a class="markdownIt-Anchor" href="#113-放到lib或usrlib下"></a> 1.1.3 放到**/lib/**或/usr/lib下</h3><p>不建议用这种方法，因为该目录下有很多系统库，如果自己的库与系统库重名，放进去就会把系统库覆盖掉。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsFwg8X1xKotZmab6Q5JrPy" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.7 动态库加载失败原因.md" --> <p>#历史记录::<br>2022/9/7🌵1.7 动态库加载失败原因 : 没看</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>静态库与动态库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4-1.6  静态库和动态库</title>
    <link href="/posts/52054/"/>
    <url>/posts/52054/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是库"><a class="markdownIt-Anchor" href="#1-什么是库"></a> 1 什么是库</h1><ul><li><p>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用 者一些可以直接拿来用的变量、函数或类。</p></li><li><p>库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。</p></li><li><p>库文件有两种，静态库和动态库(共享库)，区别是:静态库在程序的链接阶段被复制到了程序中;动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p></li><li><p>库的好处：1.代码保密 2.方便部署和分发</p></li></ul><h1 id="2-静态库的制作和使用"><a class="markdownIt-Anchor" href="#2-静态库的制作和使用"></a> 2 静态库的制作和使用</h1><p>命名规则：<strong>libxxx.a</strong></p><blockquote><p>lib : 前缀(固定)</p><p>xxx : 库的名字，自己起</p><p>.a : 后缀(固定)</p></blockquote><!-- basicblock-start oid="ObswtJbNRTn86BKCBGkcD1aT" --> <p>静态库的制作::</p><ol><li>gcc -c “文件 1, 文件 2”,  获得 .o 文件</li><li>将 .o 文件打包，使用 ar 工具（archive）</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">ar rcs libxxx.a xxx.o xxx.o<br><span class="hljs-comment">// libxxx: 其中 xxx 是自己命名的</span><br><span class="hljs-comment">// r - 将文件插入备存文件中</span><br><span class="hljs-comment">// c - 建立备存文件</span><br><span class="hljs-comment">// s - 索引</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obsa99kCCBjsR3HuWdEmW9uG" --> <p>静态库的使用::</p><!-- basicblock-end --> ^hr9kzt<p>在这个目录下<br>💡目标把 mian.c 编译成可执行的文件<br>calc 文件夹下是要制作成库的源文件，library 是完整的工程文件库，library 下的 src 文件夹中是制作静态库的源文件。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209062211463.png" alt="|400"><br>^6nlece ^eyzj1l</p><ul><li>&amp; 开始</li></ul><!-- basicblock-start oid="ObskPvKcbu0ivoF9JzGAvkh4" --> <p>-I 是什么意思::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 进入到 src 文件夹中，将源文件编译生成 -o 文件，因为源文件中使用到了 include 下的 head.c 文件(使用里边头文件)，所以用 `-I` 搜索头文件所在目录，如果不加就是在当前目录下搜索：</span><br>gcc -c add.c div.c mult.c sub.c -I ../include/ <span class="hljs-comment">// ../include/ 表示上一层文件夹的 include 目录, ./ : 表示这层</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>生成后的文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">.<br>├── add.c<br>├── add.o<br>├── div.c<br>├── div.o<br>├── mult.c<br>├── mult.o<br>├── sub.c<br>└── sub.o<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsCuiqY5wNUAK7R8ZXgfDWh" --> <p>生成静态库::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将 .o 文件打包，生成 libcalc.a 库：</span><br>ar rcs libsuanshu.a add.o div.o mult.o sub.o <span class="hljs-comment">// libxxx , xxx 是自己命名的</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obsa99kCCBjsR3HuWdEmW9uG"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>移动文件::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将 libcalc.a 移动到 lib 目录下：</span><br>mv libsuanshu.a ../lib/<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="ObsYOxKtGbIpg7Bsjc7x8oe8" --> <p>gcc -I(大 i) ,- L, -l(小 L) 命令是什么意思::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 目标:静态库的使用，编译生成 app：</span><br><span class="hljs-comment">// 先进入到 main.c 的目录下, 然后编译 main.c</span><br>gcc main.c -o app -I ./include/ -L ./lib/ -l suanshu <span class="hljs-comment">// 注意-l后边接的不是libsuanshu，还是lib后边的suanshu</span><br><span class="hljs-comment">// `-I` 为搜索 `head.h` 所在目录，用 `-I` 搜索头文件所在目录，如果不加就是在当前目录下搜索</span><br><span class="hljs-comment">// `-L` 为搜索指定动态库/静态库的名字，-L 用的是自己定义的函数</span><br><span class="hljs-comment">// `-l` 为所使用到的库的名字。(自己创建的静态库/动态库)</span><br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 运行 app</span><br>./app<br></code></pre></td></tr></tbody></table></figure><ul><li>&amp; 结束</li></ul><!-- basicblock-start oid="ObstOe3LHy0hYekMZOxmc3IW"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>linux 怎么创建文件::</p><p>创建文件夹使用   mkdir x<br>创建文件使用       vim xxx  或者 touch x/a.txt<br>删除文件夹使用   rm -rf x/</p><!-- basicblock-end --><!-- basicblock-start oid="Obsax5VF7CBLkyARjpXDGj2M"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"--> <p>怎么安装软件::</p><p>sudo  apt install gcc  安装gcc<br>gcc -v  gcc - - version(更简单一些)查看版本</p><!-- basicblock-end --><h1 id="3-动态库的制作和使用"><a class="markdownIt-Anchor" href="#3-动态库的制作和使用"></a> 3 动态库的制作和使用</h1><!-- basicblock-start oid="ObsZUJVLyxBfLjjfWsXLTl7Y" --> <p>动态库的命名规则::</p><p><strong><a href="http://libxxx.so">libxxx.so</a></strong></p><blockquote><p>lib : 前缀(固定)</p><p>xxx : 库的名字，自己起</p><p>.so : 后缀(固定), 静态库是.a 后缀</p><p>在Linux下是一个可执行文件</p></blockquote><!-- basicblock-end --><!-- basicblock-start oid="ObsVFwW5lvWwpfTmpiTBcQSa" --> <h2 id="31-动态库的制作"><a class="markdownIt-Anchor" href="#31-动态库的制作"></a> 3.1 动态库的制作::</h2><ol><li>gcc 得到 .o 文件，得到和位置无关的代码</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -c –fpic/-fPIC a.c b.c <br><span class="hljs-comment">// -fpic/-fPIC 位置无关, a.c b.c: .c 文件</span><br><span class="hljs-comment">// 单独 gcc -c 是制作.o 文件, 但是与位置有关                 </span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>gcc 得到动态库</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -shared a.o b.o -o libcalc.so<br></code></pre></td></tr></tbody></table></figure><p>[[1.10 - 1.12 makefile#^a51e57]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsMyJ0Wxxext7hatQD3jNuN"  deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.4-1.6  静态库和动态库.md" --> <p>动态库制作实操::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// tree 目录</span><br>.<br>├── calc<br>│&nbsp;&nbsp; ├── add.c<br>│&nbsp;&nbsp; ├── div.c<br>│&nbsp;&nbsp; ├── head.h<br>│&nbsp;&nbsp; ├── main.c<br>│&nbsp;&nbsp; ├── mult.c<br>│&nbsp;&nbsp; └── sub.c<br>└── library<br>    ├── include<br>    │&nbsp;&nbsp; └── head.h<br>    ├── lib<br>    ├── main.c<br>    └── src<br>        ├── add.c<br>        ├── div.c<br>        ├── mult.c<br>        └── sub.c<br></code></pre></td></tr></tbody></table></figure><p>进入到 calc 文件夹下用 .c 文件制作动态库，gcc 得到 .o 文件，得到和位置无关的代码：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -c -fpic add.c div.c mult.c sub.c -I ../include <br><span class="hljs-comment">// ../表示上两层</span><br></code></pre></td></tr></tbody></table></figure><p>gcc 得到动态库：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -shared add.o div.o mult.o sub.o -o libcalc.so<br></code></pre></td></tr></tbody></table></figure><p>ll 查看文件，可以看到 <a href="http://libcalc.so">libcalc.so</a> 是<strong>可执行文件</strong>：<br>库文件是绿色的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ll<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209071610754.png" alt=""></p><h2 id="32-动态库使用"><a class="markdownIt-Anchor" href="#32-动态库使用"></a> 3.2 动态库使用::</h2><!-- basicblock-start oid="ObsMyJ0Wxxext7hatQD3jNuN"  deck = "source::_posts::👨🏻‍💻code::项目::Linux"-->  ^8oo3nd<p>复制文件::<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209071614735.png" alt="|300"></p><p>将动态库 <a href="http://libcalc.so">libcalc.so</a> 复制到 lib 文件下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"> cp libcalc.so ../lib -r<br><span class="hljs-comment">// 因为是目录所以要加上 -r参数让它递归的拷贝</span><br><span class="hljs-comment">// Eg：cp calc library ../lesson06 -r(拷贝calc 和library 到上一级的lesson06 目录)</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>使用动态库，编译生成 main 文件</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc main.c -o main -I ./include/ -L ./lib -l calc<br></code></pre></td></tr></tbody></table></figure><p><code>-I</code> 为搜索 <code>head.h</code> 所在目录，<code>-L</code> 为搜索库所在目录，<code>-l</code> 为所使用到的库的名称。</p><p>执行 main 文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./main<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209071616365.png" alt="|800"></p><p>出现错误，找不到动态库文件：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">./main: error <span class="hljs-keyword">while</span> loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory<br></code></pre></td></tr></tbody></table></figure><ul><li>&amp; 我没出现错误</li></ul><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsbtJlyghK3mR35Dr14SNqp" deck = "👨🏻‍💻code::项目::webserver::1 第一章::1.4-1.6  静态库和动态库.md" --> <p>#历史记录::<br>2022/09/06🌵1.4-1.6  静态库和动态库<br>2022/09/07🌵复习了静态库的制作和使用,[[1.4-1.6  静态库和动态库#^6nlece]]⏱0-8<br>2022/09/07🌵学习了动态库的制作和使用⏱0-41</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>12. 平衡二叉树</title>
    <link href="/posts/19617/"/>
    <url>/posts/19617/</url>
    
    <content type="html"><![CDATA[<h1 id="1-110平衡二叉树"><a class="markdownIt-Anchor" href="#1-110平衡二叉树"></a> 1 110.平衡二叉树</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">力扣题目 链接</a></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点&nbsp;的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><p><img src="https://img-blog.csdnimg.cn/2021020315542230.png" alt="110.平衡二叉树"></p><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><p><img src="https://img-blog.csdnimg.cn/20210203155447919.png" alt="110.平衡二叉树1"></p><p>返回 false 。</p><!-- basicblock-start oid="Obs9XIZAfxIaaCbt7ZqAAAaV" --> <p>怎么去思考递归::<br>![[12. 平衡二叉树 2022-09-07 10.08.26.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsXx4zwKtRu8v4JBaNAXu2B" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>后序遍历<br>分别求出其左右子树的高度，<br>差值小于等于1，则返回当前二叉树的高度，<br>否则则返回-1，表示已经不是二叉平衡树了。</p><!-- basicblock-end --><h2 id="21-代码"><a class="markdownIt-Anchor" href="#21-代码"></a> 2.1 代码</h2><p>v1: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span></span>{<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span>(leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 💡此处不是判断最底层的节点, 而是返回后上一层的节点</span><br>        <span class="hljs-type">int</span> rightHeitht = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeitht) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeitht); <span class="hljs-comment">// 返回上一层</span><br>    }<br><br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeight</span>(root) == <span class="hljs-number">-1</span> ? <span class="hljs-literal">false</span> :&nbsp;<span class="hljs-literal">true</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2: 官方题解, 更容易理解</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">height</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">height</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span> || rightHeight == <span class="hljs-number">-1</span> || <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) { <span class="hljs-comment">// ❗️必须要有前两个判断条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">return</span>  <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">height</span>(root) &gt;= <span class="hljs-number">0</span>;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>![[12. 平衡二叉树 2022-09-11 22.58.07.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsA2gNDFyw1C2sz4lz9tiDA" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::12. 平衡二叉树.md" --> <p>#历史记录::<br>2022/09/06🌵12. 平衡二叉树 : 思路简单, 代码易懂⏱0-26<br>2022/09/11🌵12. 平衡二叉树 : 细节还是有的, <strong>不能漏了剪枝</strong>, 想了一大会⏱0-31</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1-1.2 GCC</title>
    <link href="/posts/11990/"/>
    <url>/posts/11990/</url>
    
    <content type="html"><![CDATA[<h1 id="1-gcc"><a class="markdownIt-Anchor" href="#1-gcc"></a> 1 GCC</h1><h2 id="11-gcc-与-g-的区别"><a class="markdownIt-Anchor" href="#11-gcc-与-g-的区别"></a> 1.1 GCC 与 G++ 的区别</h2><p>gcc 和 g++都是GNU(组织)的一个编译器。</p><pre><code class="hljs">**gcc与g++都能编译c/c++文件，只是gcc不能自动和c++程序的库进行，因此可以使用gcc编译g++链接，也可以直接额全用g++**</code></pre><ul><li>&amp; <strong>全额使用g++就行</strong></li></ul><p><strong>误区一</strong>:gcc 只能编译 c 代码，g++ 只能编译 c++ 代码。两者都可以，请注意：</p><ul><li>后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序。</li><li>后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些。</li><li>编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统 一起见，干脆编译/链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只 能用 g++ 似的。</li></ul><p><strong>误区二</strong>：gcc 不会定义 __cplusplus 宏，而 g++ 会</p><ul><li>实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释。</li><li>如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义。</li></ul><p><strong>误区三</strong>：编译只能用 gcc，链接只能用 g++</p><ul><li>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++。</li><li>gcc 命令不能自动和C<ins>程序使用的库联接，所以通常使用 g</ins> 来完成联接。 但在编译阶段，g++ 会自动调用 gcc，二者等价。</li></ul><table><thead><tr><th>gcc 编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>预处理指定的源文件，不进行编译</td></tr><tr><td>-S</td><td>编译指定的源文件，但是不进行汇编</td></tr><tr><td>-c</td><td>编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td>-o [file1] [file2] / [file2] -o [file1]</td><td>将文件 file2 编译成可执行文件 file1</td></tr><tr><td>-I directory</td><td>指定 include 包含文件的搜索目录</td></tr><tr><td>-g</td><td>在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td>-D</td><td>在程序编译的时候，指定一个宏</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-wall</td><td>生成所有警告信息</td></tr><tr><td>-On</td><td>n的取值范围:0~3。编译器的优化选项的4个级别，-O0表 示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td>-l</td><td>在程序编译的时候，指定使用的库</td></tr><tr><td>-L</td><td>指定编译的时候，搜索的库的路径</td></tr><tr><td>-fPIC/fpic</td><td>生成与位置无关的代码</td></tr><tr><td>-shared</td><td>生成共享目标文件，通常用在建立共享库时</td></tr><tr><td>-std</td><td>指定 c 方言，如：-std=c99，gcc默认的方言是GNU C</td></tr></tbody></table><!-- basicblock-start oid="Obsl8nA1rjcL45Ssgeq34bT8" --> <h2 id="12-gcc-的编译过程"><a class="markdownIt-Anchor" href="#12-gcc-的编译过程"></a> 1.2 GCC 的编译过程::</h2><p>![[GCC 编译过程 .excalidraw]]<br>先进入程序所在目录，然后使用该命令编译: <code>g++ test.cpp -o app</code> :</p><blockquote><p>test.cpp 是文件, app是自己起的名字</p></blockquote><p>用这个形式:  <mark><strong><code>g++ -o&nbsp; app test.cpp</code></strong></mark></p><p><code>./app</code>：执行编译的结果</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsoyz9ehuc6HUjArGzt7ODx"  --> <p>#历史记录::<br>2022/9/5🌵1.1-1.2 GCC : 编译的过程是重点</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>总笔记</title>
    <link href="/posts/4280/"/>
    <url>/posts/4280/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件io"><a class="markdownIt-Anchor" href="#1-文件io"></a> 1 文件IO</h1><p><a href="%E8%AF%BE%E4%BB%B6/1.17%20%E6%96%87%E4%BB%B6IO.pdf">1.17 文件IO</a></p><h2 id="11-标准c库io函数和linux系统io函数对比"><a class="markdownIt-Anchor" href="#11-标准c库io函数和linux系统io函数对比"></a> 1.1 标准C库IO函数和Linux系统IO函数对比</h2><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174357.png" alt="image-20220328130316589"></p><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174406.png" alt="image-20220328130330587"></p><h2 id="12-虚拟地址空间"><a class="markdownIt-Anchor" href="#12-虚拟地址空间"></a> 1.2 虚拟地址空间</h2><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174413.png" alt="image-20220328130352951"></p><p>程序和进程的区别：</p><p>程序是可执行文件，可执行文件只占用磁盘的空间，不占用内存空间。</p><p>当程序运行起来后，操作系统会为程序的启动或运行分配一些资源，这时候操作系统就会创建一个进程，进程就是为程序运行所分配资源的东西。</p><p>进程就是正在运行的程序，进程占用内存空间，一个程序启动以后，会生成一个虚拟地址空间，虚拟地址空间会通过 CPU 当中的 MMU 逻辑管理单元把虚拟地址空间中的数据映射到物理内存中去。</p><h2 id="13-13文件描述符"><a class="markdownIt-Anchor" href="#13-13文件描述符"></a> 1.3 1.3[[文件描述符]]</h2><h2 id="14-linux系统io函数"><a class="markdownIt-Anchor" href="#14-linux系统io函数"></a> 1.4 Linux系统IO函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;<br></code></pre></td></tr></tbody></table></figure><h3 id="141-open函数"><a class="markdownIt-Anchor" href="#141-open函数"></a> 1.4.1 [[open函数]]</h3><h3 id="142-read函数和write函数"><a class="markdownIt-Anchor" href="#142-read函数和write函数"></a> 1.4.2 [[read函数和write函数]]</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">1.4</span><span class="hljs-number">.3</span> lseek函数<br><br>查看说明文档<br><br></code></pre></td></tr></tbody></table></figure><p>man 2 lseek<br>man 3 fseek</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>```c<br><span class="hljs-comment">// 标准C库的函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br><br><span class="hljs-comment">// Linux系统函数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span></span>;<br>- 参数：<br>      - fd: 文件描述符，通过 open 得到的，通过这个 fd 操作某个文件<br>        - offset: 偏移量<br>        - whence: <br>SEEK_SET<br>              设置文件指针的偏移量<br>            SEEK_CUR<br>              设置偏移量：当前位置 + 第二个参数 offset 的值<br>            SEEK_END<br>              设置偏移量：文件大小 + 第二个参数 offset 的值<br>- 返回值：返回文件指针的位置<br>              <br>作用：<br><span class="hljs-number">1.</span> 移动文件指针到头文件<br>    <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_SET);<br><span class="hljs-number">2.</span> 获取当前文件指针的位置<br>    <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_CUR);<br><span class="hljs-number">3.</span> 获取文件的长度<br>   <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">0</span>, SEEK_END);<br><span class="hljs-number">4.</span> 拓展文件的长度，当前文件 <span class="hljs-number">10b</span>，<span class="hljs-number">110b</span>，增加了 <span class="hljs-number">100</span> 个字节<br>    <span class="hljs-built_in">lseek</span>(fd, <span class="hljs-number">100</span>, SEEK_END);<br></code></pre></td></tr></tbody></table></figure><p>拓展文件长度：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lseek.c</span><br><span class="hljs-comment">// 原 hello.txt 为 12 字节，拓展了 100 个字节，写入了 1 个空数据，最后为 113 字节大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 打开文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"hello.txt"</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">//拓展文件</span><br>    <span class="hljs-type">int</span> ret = lseek(fd, <span class="hljs-number">100</span>, SEEK_END);   <span class="hljs-comment">// 从文件末尾开始拓展 100 字节</span><br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"lseek"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 写入一个空数据</span><br>    write(fd, <span class="hljs-string">" "</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么要写入空数据？</p><p>lseek()不是扩展数据的功能，只是可以利用lseek()去扩展文件，lseek()只是单纯的移动文件指针偏移。而写入数据后才能扩展数据大小，显示出字节数。</p><p>拓展文件有什么实际用途？</p><p>在下载文件时，先按照文件大小拓展出来，然后再慢慢往里面下载，以防磁盘空间不足。</p><h3 id="143-stat函数和lstat函数"><a class="markdownIt-Anchor" href="#143-stat函数和lstat函数"></a> 1.4.3 stat函数和lstat函数</h3><p>查看说明文档</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> stat<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br>作用：获取一个文件相关的一些信息<br>    参数：<br>      - pathname：操作的文件的路径<br>        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span> ，设置 errno<br><span class="hljs-type">int</span> <span class="hljs-title function_">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-keyword">struct</span> stat *buf)</span>;<br>作用：获取软链接文件相关的一些信息<br>    参数：<br>      - pathname：操作的文件的路径<br>        - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span> ，设置 errno<br></code></pre></td></tr></tbody></table></figure><p>在 Linux 中也有一个命令 stat ，通过它可以查看一个文件的信息。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> a.txt<br></code></pre></td></tr></tbody></table></figure><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">  文件："a.txt"<br>  大小：13        块：8          IO 块：4096   普通文件<br>设备：fd01h/64769dInode：658603      硬链接：1<br>权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)<br>最近访问：2022<span class="hljs-string">-04</span><span class="hljs-string">-03</span> 16:07:04.823402070 <span class="hljs-string">+0800</span><br>最近更改：2022<span class="hljs-string">-04</span><span class="hljs-string">-03</span> 16:07:04.823402070 <span class="hljs-string">+0800</span><br>最近改动：2022<span class="hljs-string">-04</span><span class="hljs-string">-03</span> 16:07:04.826402123 <span class="hljs-string">+0800</span><br>创建时间：-<br></code></pre></td></tr></tbody></table></figure><p>stat结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> {</span><br><span class="hljs-type">dev_t</span>st_dev;<span class="hljs-comment">// 文件的设备编号</span><br>    <span class="hljs-type">ino_t</span>st_ino;<span class="hljs-comment">// 节点</span><br><span class="hljs-type">mode_t</span>st_mode;<span class="hljs-comment">// 文件的类型和存取的权限</span><br><span class="hljs-type">nlink_t</span>st_nlink;<span class="hljs-comment">// 连到该文件的硬连接数目</span><br>    <span class="hljs-type">uid_t</span>st_uid;<span class="hljs-comment">// 用户ID</span><br>    <span class="hljs-type">gid_t</span>st_gid;<span class="hljs-comment">// 组ID</span><br>    <span class="hljs-type">dev_t</span>st_rdev;<span class="hljs-comment">// 设备文件的设备编号</span><br>    <span class="hljs-type">off_t</span>st_size;<span class="hljs-comment">// 文件字节数(文件大小)</span><br>    <span class="hljs-type">blksize_t</span>st_blksize;<span class="hljs-comment">// 块大小</span><br>    <span class="hljs-type">blkcnt_t</span> st_blocks;<span class="hljs-comment">// 块数</span><br>    <span class="hljs-type">time_t</span> st_atime;<span class="hljs-comment">// 最后一次访问时间</span><br>    <span class="hljs-type">time_t</span> st_mtime;<span class="hljs-comment">// 最后一次修改时间</span><br>    <span class="hljs-type">time_t</span>st_ctime;<span class="hljs-comment">// 最后一次改变时间(指属性)</span><br> };<br></code></pre></td></tr></tbody></table></figure><p>st_mode变量</p><p><img src="https://cdn.jsdelivr.net/gh/huyup1e2n3g/WebServer/img/20220403174524.png" alt="image-20220403162503909"></p><p>获取 a.txt 的信息，返回大小</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">statbuf</span>;</span><br>    <span class="hljs-type">int</span> ret = stat(<span class="hljs-string">"a.txt"</span>, &amp;statbuf);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"stat"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"size: %ld\n"</span>, statbuf.st_size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>创建软链接</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ln -s <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">b</span>.txt<br></code></pre></td></tr></tbody></table></figure><p>创建出软链接 b.txt ，指向了 a.txt</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lrwxrwxrwx</span> <span class="hljs-number">1</span> root root    <span class="hljs-number">5</span> Apr  <span class="hljs-number">3</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span> b.txt -&gt; a.txt<br></code></pre></td></tr></tbody></table></figure><p>用 <code>stat b.txt</code> 查看信息</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">File</span>: ‘b.txt’ -&gt; ‘a.txt’<br>  <span class="hljs-attribute">Size</span>: <span class="hljs-number">5</span>               Blocks: <span class="hljs-number">0</span>          IO Block: <span class="hljs-number">4096</span>   symbolic link<br><span class="hljs-attribute">Device</span>: fd01h/<span class="hljs-number">64769</span>d    Inode: <span class="hljs-number">658601</span>      Links: <span class="hljs-number">1</span><br><span class="hljs-attribute">Access</span>: (<span class="hljs-number">0777</span>/lrwxrwxrwx)  Uid: (    <span class="hljs-number">0</span>/    root)   Gid: (    <span class="hljs-number">0</span>/    root)<br><span class="hljs-attribute">Access</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">03</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">44</span>.<span class="hljs-number">509931636</span> +<span class="hljs-number">0800</span><br><span class="hljs-attribute">Modify</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">03</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">44</span>.<span class="hljs-number">412929931</span> +<span class="hljs-number">0800</span><br><span class="hljs-attribute">Change</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">03</span> <span class="hljs-number">16</span>:<span class="hljs-number">41</span>:<span class="hljs-number">44</span>.<span class="hljs-number">412929931</span> +<span class="hljs-number">0800</span><br> <span class="hljs-attribute">Birth</span>: -<br></code></pre></td></tr></tbody></table></figure><p>用 <code>stat</code> 获取软链接文件的信息，其实获取的是软链接 b.txt 指向的 a.txt 的信息，如果要获取 软链接 b.txt 的信息就要用 <code>lstat</code> 。</p><h3 id="144-模拟实现-ls-l-命令"><a class="markdownIt-Anchor" href="#144-模拟实现-ls-l-命令"></a> 1.4.4 模拟实现 ls -l 命令</h3><p>模拟实现 ls-l 命令的程序代码：</p><p><a href="https://github.com/huyup1e2n3g/WebServer/blob/main/code/lesson1.25/ls-l.c">ls-l.c</a></p><h3 id="145-文件属性操作函数"><a class="markdownIt-Anchor" href="#145-文件属性操作函数"></a> 1.4.5 文件属性操作函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 判断文件的权限或判断文件是否存在</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>;<br><span class="hljs-comment">// 修改文件的权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> mode)</span>;<br><span class="hljs-comment">// 修改文件的所有者或者所在组</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chown</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">uid_t</span> owner, <span class="hljs-type">gid_t</span> group)</span>;<br><span class="hljs-comment">// 缩减或扩展文件的大小</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>;<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> access<br><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> chmod<br><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> chown<br><span class="hljs-attribute">man</span> <span class="hljs-number">2</span> truncate<br></code></pre></td></tr></tbody></table></figure><h4 id="1451-access函数"><a class="markdownIt-Anchor" href="#1451-access函数"></a> 1.4.5.1 access函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> mode)</span>;<br>作用：判断某个文件是否有某个权限，或者判断文件是否存在<br>    参数：<br>      - pathname：判断的文件路径<br>      - mode：<br>      R_OK: 判断是否有读权限<br>        W_OK: 判断是否有写权限<br>        X_OK: 判断是否有执行权限<br>        F_OK: 判断文件是否存在<br>返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// access.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-comment">// 判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">"a.txt"</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"access"</span>);<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"文件存在\n"</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="1452-chmod函数"><a class="markdownIt-Anchor" href="#1452-chmod函数"></a> 1.4.5.2 chmod函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode)</span>;<br>作用：修改文件的权限<br>    参数：<br>      - pathname: 需要修改的文件的路径<br>      - <span class="hljs-type">mode_t</span>: 需要修改的权限值，八进制的数<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span><br>        <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// chmod.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>  <span class="hljs-comment">// 修改文件权限</span><br>    <span class="hljs-type">int</span> ret = chmod(<span class="hljs-string">"a.txt"</span>, <span class="hljs-number">0775</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"chmod"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>修改前：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-r--r--<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 14 </span>Apr <span class="hljs-number"> 4 </span>15:52 a.txt<br></code></pre></td></tr></tbody></table></figure><p>修改后：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rwxrwxr-x<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 14 </span>Apr <span class="hljs-number"> 4 </span>15:52 a.txt<br></code></pre></td></tr></tbody></table></figure><h4 id="1453-truncate函数"><a class="markdownIt-Anchor" href="#1453-truncate函数"></a> 1.4.5.3 truncate函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>;<br>作用：缩减或扩展文件的尺寸至指定的大小<br>    参数：<br>      - path: 需要修改的文件的路径<br>      - length: 需要最终文件变成的大小<br>    返回值：<br>      成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// truncate.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 扩大文件大小</span><br>    <span class="hljs-type">int</span> ret = truncate(<span class="hljs-string">"b.txt"</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"truncate"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>扩展前：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-r--r--<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 13 </span>Apr <span class="hljs-number"> 4 </span>16:03 b.txt<br></code></pre></td></tr></tbody></table></figure><p>扩展后：</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">-rw-r--r--<span class="hljs-number"> 1 </span>root root  <span class="hljs-number"> 20 </span>Apr <span class="hljs-number"> 4 </span>16:03 b.txt<br></code></pre></td></tr></tbody></table></figure><h3 id="146-目录操作函数"><a class="markdownIt-Anchor" href="#146-目录操作函数"></a> 1.4.6 目录操作函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-comment">// 删除空目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rmdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span>;<br><span class="hljs-comment">// 重命名目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>; <br><span class="hljs-comment">// 更改当前的目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><span class="hljs-comment">// 获取当前的路径</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档</p><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">man</span> 2 <span class="hljs-keyword">mkdir</span><br></code></pre></td></tr></tbody></table></figure><h4 id="1461-mkdir函数"><a class="markdownIt-Anchor" href="#1461-mkdir函数"></a> 1.4.6.1 mkdir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br>作用：创建一个目录<br>    参数：<br>      - pathname: 创建的目录的路径<br>      - mode: 权限，八进制的数<br>    返回值：<br>    成功：返回 <span class="hljs-number">0</span><br>      失败：返回 <span class="hljs-number">-1</span>   <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// mkdir.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 创建一个 aaa 目录</span><br>    <span class="hljs-type">int</span> ret = mkdir(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"mkdir"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>生成 aaa 目录：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">drwxr</span>-xr-x <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> Apr  <span class="hljs-number">4</span> <span class="hljs-number">16</span>:<span class="hljs-number">20</span> aaa<br></code></pre></td></tr></tbody></table></figure><h4 id="1462-rename函数"><a class="markdownIt-Anchor" href="#1462-rename函数"></a> 1.4.6.2 rename函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span>;<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// rename.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 将 aaa 目录改名为 bbb</span><br>    <span class="hljs-type">int</span> ret = rename(<span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"rename"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>}<br></code></pre></td></tr></tbody></table></figure><h4 id="1463-chdir函数"><a class="markdownIt-Anchor" href="#1463-chdir函数"></a> 1.4.6.3 chdir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br>作用：修改进程的工作目录<br>    比如在 /home/nowcoder 启动了一个可执行程序 a.out ，进程的工作目录就是 /home/nowcoder<br>    参数：<br>      - path: 需要修改的工作目录<br></code></pre></td></tr></tbody></table></figure><h4 id="1464-getcwd函数"><a class="markdownIt-Anchor" href="#1464-getcwd函数"></a> 1.4.6.4 getcwd函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span>;<br>作用：获取当前工作目录<br>    参数：<br>      - buf: 存储的路径，指向的是一个数组（传出参数）<br>      - size: 数组的大小<br>    返回值：<br>      返回的指向的一块内存，这个数据就是第一个参数<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// chdir.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>{<br>    <span class="hljs-comment">// 获取当前的工作目录</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    getcwd(buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当前的工作目录是：%s\n"</span>, buf);<br><br>    <span class="hljs-comment">// 修改工作目录</span><br>    <span class="hljs-type">int</span> ret = chdir(<span class="hljs-string">"/root/Linux/lesson1.27/bbb"</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"chdir"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 创建一个新的文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"chdir.txt"</span>, O_CREAT | O_RDWR, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 关闭文件</span><br>    close(fd);<br><br>    <span class="hljs-comment">// 获取当前的工作目录</span><br>    <span class="hljs-type">char</span> buf1[<span class="hljs-number">128</span>];<br>    getcwd(buf1, <span class="hljs-keyword">sizeof</span>(buf1));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当前的工作目录是：%s\n"</span>, buf1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="147-目录遍历函数"><a class="markdownIt-Anchor" href="#147-目录遍历函数"></a> 1.4.7 目录遍历函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 打开目录</span><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">// 读取目录里的内容</span><br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br><span class="hljs-comment">// 关闭目录</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br></code></pre></td></tr></tbody></table></figure><p>查看说明文档</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">man</span> <span class="hljs-number">3</span> opendir<br></code></pre></td></tr></tbody></table></figure><h4 id="1471-opendir函数"><a class="markdownIt-Anchor" href="#1471-opendir函数"></a> 1.4.7.1 opendir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br>DIR *<span class="hljs-title function_">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br>参数：<br>      - name: 需要打开的目录的名称<br>    返回值：<br>      DIR * 类型，理解为目录流<br>      错误返回 <span class="hljs-literal">NULL</span><br></code></pre></td></tr></tbody></table></figure><h4 id="1472-readdir函数"><a class="markdownIt-Anchor" href="#1472-readdir函数"></a> 1.4.7.2 readdir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-keyword">struct</span> dirent *<span class="hljs-title function_">readdir</span><span class="hljs-params">(DIR *dirp)</span>;<br>作用：读取目录中的数据‘<br>    参数：dirp 是 opendir 返回的结果<br>    返回值：<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> 代表读取到的文件的信息</span><br><span class="hljs-class">        读取到了末尾或者失败了，返回<span class="hljs-title">NULL</span></span><br></code></pre></td></tr></tbody></table></figure><p>dirent 结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> {</span><br>  <span class="hljs-comment">// 此目录进入点的inode</span><br><span class="hljs-type">ino_t</span>d_ino;       <span class="hljs-comment">/* inode number */</span><br>    <span class="hljs-comment">// 目录文件开头至此目录进入点的位移</span><br>  <span class="hljs-type">off_t</span>   d_off;       <span class="hljs-comment">/* not an offset; see NOTES */</span><br>    <span class="hljs-comment">// d_name 的长度，不包含 NULL 字符</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> d_reclen;    <span class="hljs-comment">/* length of this record */</span><br>    <span class="hljs-comment">// d_name 所指的文件类型</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>  d_type;      <span class="hljs-comment">/* type of file; not supported by all file system types */</span><br>    <span class="hljs-comment">// 文件名</span><br>  <span class="hljs-type">char</span>d_name[<span class="hljs-number">256</span>]; <span class="hljs-comment">/* filename */</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>d_type</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">DT_BLK      This is <span class="hljs-keyword">a</span> block device.块设备<br>DT_CHR      This is <span class="hljs-keyword">a</span> <span class="hljs-keyword">character</span> device.字符设备<br>DT_DIR      This is <span class="hljs-keyword">a</span> <span class="hljs-built_in">directory</span>.目录<br>DT_FIFO     This is <span class="hljs-keyword">a</span> named pipe (FIFO).软连接<br>DT_LNK      This is <span class="hljs-keyword">a</span> symbolic link.管道<br>DT_REG      This is <span class="hljs-keyword">a</span> regular <span class="hljs-built_in">file</span>.件<br>DT_SOCK     This is <span class="hljs-keyword">a</span> UNIX domain <span class="hljs-built_in">socket</span>.套普通文接字<br>DT_UNKNOWN  The <span class="hljs-built_in">file</span> type is unknown.未知<br></code></pre></td></tr></tbody></table></figure><h4 id="1473-closedir函数"><a class="markdownIt-Anchor" href="#1473-closedir函数"></a> 1.4.7.3 closedir函数</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">closedir</span><span class="hljs-params">(DIR *dirp)</span>;<br>作用：关闭目录<br></code></pre></td></tr></tbody></table></figure><p>遍历目录下文件数量程序代码：</p><p><a href="https://github.com/huyup1e2n3g/WebServer/blob/main/code/lesson1.28/readFileNum.c">readFileNum.c</a></p><h3 id="148-dup-dup2-函数"><a class="markdownIt-Anchor" href="#148-dup-dup2-函数"></a> 1.4.8 dup、dup2 函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 复制文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>; <br><span class="hljs-comment">// 重定向文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>; <br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>;<br>作用：复制一个新的文件描述符<br>    fd = <span class="hljs-number">3</span>, <span class="hljs-type">int</span> fd1 = dup(fd);<br>fd 指向的是 a.txt，fd1 也是指向 a.txt<br>    从空闲的文件描述符中找一个最小的，作为新的拷贝的文件描述符<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br>  作用：重定向文件描述符<br>    oldfd 指向 a.txt, newfd 指向 b.txt<br>    调用函数成功后：newfd 和 b.txt 做 close, newfd 指向了 a.txt<br>    oldfd 必须是一个有效的文件描述符<br>    oldfd 和 newfd 值相同，相当于什么都没有做<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dup.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"a.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-type">int</span> fd1 = dup(fd);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"dup"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd : %d , fd1 : %d\n"</span>, fd, fd1);<br>    close(fd);<br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">"hello,world"</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"write"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    close(fd1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// dup2.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"1.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">"2.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span>(fd1 == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd : %d, fd1 : %d\n"</span>, fd, fd1);<br>    <span class="hljs-type">int</span> fd2 = dup2(fd, fd1);<br>    <span class="hljs-keyword">if</span>(fd2 == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"dup2"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">"hello, dup2"</span>;<br>    <span class="hljs-type">int</span> len = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"write"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"fd : %d, fd1 : %d, fd2 : %d\n"</span>, fd, fd1, fd2);<br><br>    close(fd);<br>    close(fd1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h3 id="149-fcntl-函数"><a class="markdownIt-Anchor" href="#149-fcntl-函数"></a> 1.4.9 fcntl 函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>; <br><span class="hljs-comment">// 复制文件描述符</span><br><span class="hljs-comment">// 设置/获取文件的状态标志</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>;<br>    参数：<br>        fd : 表示需要操作的文件描述符<br>        cmd: 表示对文件描述符进行如何操作<br>            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）<br>                <span class="hljs-type">int</span> ret = fcntl(fd, F_DUPFD);<br><br>            - F_GETFL : 获取指定的文件描述符文件状态flag<br>              获取的flag和我们通过open函数传递的flag是一个东西。<br><br>            - F_SETFL : 设置文件描述符文件状态flag<br>              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改<br>              可选性：O_APPEND, O)NONBLOCK<br>                O_APPEND 表示追加数据<br>                NONBLOK 设置成非阻塞<br>        <br>        阻塞和非阻塞：描述的是函数调用的行为。<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fcntl.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.复制文件描述符</span><br>    <span class="hljs-comment">// int fd = open("1.txt", O_RDONLY);</span><br>    <span class="hljs-comment">// int ret = fcntl(fd, F_DUPFD);</span><br><br>    <span class="hljs-comment">// 2.修改或者获取文件状态flag</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">"1.txt"</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"open"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取文件描述符状态flag</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"fcntl"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>    flag |= O_APPEND;   <span class="hljs-comment">// flag = flag | O_APPEND</span><br><br>    <span class="hljs-comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span><br>    <span class="hljs-type">int</span> ret = fcntl(fd, F_SETFL, flag);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"fcntl"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">"nihao"</span>;<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>1 Linux系统编程入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.完全二叉树的节点个数</title>
    <link href="/posts/32913/"/>
    <url>/posts/32913/</url>
    
    <content type="html"><![CDATA[<h1 id="1-222完全二叉树的节点个数"><a class="markdownIt-Anchor" href="#1-222完全二叉树的节点个数"></a> 1 222.完全二叉树的节点个数</h1><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">力扣题目链接</a></p><p>给出一个完全二叉树，求出该树的节点个数。</p><p>示例 1：</p><ul><li>输入：root = [1,2,3,4,5,6]</li><li>输出：6</li></ul><p>示例 2：</p><ul><li>输入：root = []</li><li>输出：0</li></ul><p>示例 3：</p><ul><li>输入：root = [1]</li><li>输出：1</li></ul><p>提示：</p><ul><li>树中节点的数目范围是[0, 5 * 10^4]</li><li>0 &lt;= Node.val &lt;= 5 * 10^4</li><li>题目数据保证输入的树是 完全二叉树</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本篇给出按照普通二叉树的求法以及利用完全二叉树性质的求法。</p><h2 id="21-普通二叉树的解法"><a class="markdownIt-Anchor" href="#21-普通二叉树的解法"></a> 2.1 普通二叉树的解法</h2><p>后序遍历(左右中): 到了最下层 “左右” 后返回 0, 到了"中"时 返回  1 + 左 +<br>右, 然后不断的向上递归返回<br>递归解法</p><!-- basicblock-start oid="ObsOXRInsha0Vue1rp2L1jJl" --> <p>后序遍历, 最后有个 return 操作是怎么回事::<br>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">countNodes</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> count = left + right + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> count; <span class="hljs-comment">// 💡每得到一个节点的 count 值都会返回一次.不断更新处理到最后一个节点</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftcount = <span class="hljs-built_in">countNodes</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightcount = <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> nodecount = leftcount + rightcount + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> nodecount;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>迭代解法</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>只要模板少做改动，加一个变量result，统计节点数量就可以了<br>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                result++;   <span class="hljs-comment">// 每弹出一个节点就记录一下, 这样全都记录了</span><br>                <br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> nodeCount = <span class="hljs-number">0</span>;<span class="hljs-comment">// ❗️需要放到 while 函数外边, 放到里边用完就销毁了</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br><br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                nodeCount++;<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br><br>        }<br>        <span class="hljs-keyword">return</span> nodeCount;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-完全二叉树的解法"><a class="markdownIt-Anchor" href="#22-完全二叉树的解法"></a> 2.2 完全二叉树的解法</h2><p>![[1. 二叉树理论基础#1 2 完全二叉树]]</p><p>整体思路是:<br>先得到每个节点下所的完全二叉树个数,  返回上一层: “左 + 右 + 1”<br>然后不断重复此过程, 直至返回到根节点, 就得到了所有的节点个数</p><p>完全二叉树的节点情况分两种情况: 1. 满二叉树, 2. 非满二叉树</p><ol><li>节点下边是满二叉树可以直接用:  2^树深度 - 1 , 得到该个数.</li><li>非满二叉树, 一直向下递归找满二叉树, 最差找到叶子节点呗, 得到个数.</li><li>上一层的个数是 “左 + 右 + 1”</li></ol><p>v1 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>,  rightDepth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left){<br>            left = left-&gt;left;<br>            leftDepth++;<br>        }<br>        <span class="hljs-keyword">while</span>(right){<br>            right = right-&gt;right;<br>            rightDepth++;<br>        }<br>        <span class="hljs-keyword">if</span>(rightDepth == leftDepth){<br>            <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0, 如果初始化为 1 的话就多了个幂次</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span> ;<span class="hljs-comment">// 求得了一个满二叉树的节点个数</span><br>        }<br>        <span class="hljs-comment">// 该节点下边子树不是满二叉树, 继续递归查找</span><br>        <span class="hljs-comment">// ❓不是很懂</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<span class="hljs-comment">// 返回结果到上一层</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsulZddtgbSOiRG5o1XM7mj" --> <p><code>2&lt;&lt;leftDepth</code> 是什么意思::<br>// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0, 如果初始化为 1 的话就多了个幂次<br><code>2&lt;&lt;leftDepth</code>: 如果 leftDepth = 1 → 2^2, 所以如果想要 2 ^leftDepth, 和 leftDepth 保持一直, 就要初始化为 0<br>例子是上边代码</p><!-- basicblock-end --><p>v2,通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 获取左右子树的长度</span><br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left){<br>            left = left-&gt;left;<br>            leftDepth++;<br>        }<br>        <span class="hljs-keyword">while</span>(right){<br>            right = right-&gt;right;<br>            rightDepth++;<br>        }<br>        <span class="hljs-keyword">if</span>(rightDepth == leftDepth){<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-comment">// 如果不是满二叉树, 递归寻找下两个节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><ul><li>时间复杂度：O(log n × log n)</li><li>空间复杂度：O(log n)</li></ul><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsxAwKJskKRlGQCpHXaufXe" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::11.完全二叉树的节点个数.md" --> <p>#历史记录::<br>2022/09/06🌵11.完全二叉树的节点个数 : 普通解法很简单, 完全二叉树解法还不太懂.⏱1-10<br>2022/09/08🌵三种解法都写了一遍 ,前两个解法很熟练了, 完全二叉树解法最后一步需要背一下⏱0-28</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10 .二叉树的最小深度</title>
    <link href="/posts/11176/"/>
    <url>/posts/11176/</url>
    
    <content type="html"><![CDATA[<h1 id="1-111二叉树的最小深度"><a class="markdownIt-Anchor" href="#1-111二叉树的最小深度"></a> 1 111.二叉树的最小深度</h1><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从<strong>根节点到最近叶子节点的最短路径上的节点数量。</strong></p><p>说明:&nbsp;叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树&nbsp;[3,9,20,null,null,15,7],</p><p><img src="https://img-blog.csdnimg.cn/2021020315582586.png" alt="111.二叉树的最小深度1"></p><p>返回它的最小深度 2.</p><!-- basicblock-start oid="ObsxAijR3dtBDY0TsdiJIFbj" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>![[10 .二叉树的最小深度 2022-09-04 21.13.57.excalidraw]]</p><!-- basicblock-end --><h2 id="21-代码"><a class="markdownIt-Anchor" href="#21-代码"></a> 2.1 代码</h2><p><strong>二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2022/9/4🌵10 .二叉树的最小深度,处理好左子树或者右子树为空的情况就行, 看代码备注</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span></span>{<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;left); <span class="hljs-comment">//   左</span><br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;right);<span class="hljs-comment">//  右</span><br>        <span class="hljs-comment">// 取到了节点的两个孩子的信息,                  中</span><br>        <span class="hljs-keyword">if</span>(node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth; <span class="hljs-comment">// 这里返回的是上一层</span><br>        }<br>        <span class="hljs-keyword">if</span>(node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth;<span class="hljs-comment">// 这里返回的是上一层</span><br>        }<br>        <span class="hljs-comment">// 下面是两个孩子为空, 或者两个孩子都不为空的情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(leftDepth, rightDepth) ;<span class="hljs-comment">// 这里返回的是上一层</span><br><br>        <br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYPyAApLHAakFE2OSvWxJR" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::10 .二叉树的最小深度.md" --> <p>#历史记录::<br>2022/9/4🌵10 .二叉树的最小深度,处理好左子树或者右子树为空的情况就行, 看代码备注⏱1.38<br>2022/09/05🌵: v2, ⏱0-12</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 二叉树的最大深度</title>
    <link href="/posts/25077/"/>
    <url>/posts/25077/</url>
    
    <content type="html"><![CDATA[<h1 id="1-104二叉树的最大深度"><a class="markdownIt-Anchor" href="#1-104二叉树的最大深度"></a> 1 104.二叉树的最大深度</h1><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p><p>返回它的最大深度 3</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-层序遍历"><a class="markdownIt-Anchor" href="#21-层序遍历"></a> 2.1 层序遍历</h2><p>[[5. 二叉树的层序遍历#3 9 104 二叉树的最大深度]]</p><h2 id="22-递归遍历"><a class="markdownIt-Anchor" href="#22-递归遍历"></a> 2.2 递归遍历</h2><!-- basicblock-start oid="Obs9EZaNm8XMZm0YfjfeCoze" --> <p>二叉树的高度和深度::<br>![[9. 二叉树的最大深度 2022-09-04 19.59.06.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObswhABnljcw5OZTk71GpUMW" --> <p>思路::<br>用后序遍历求最大深度, 左中右, 先获取到左右孩子的高度, 那么父节点就是" 1 + max(左右孩子高度) ", 然后逐层返回父节点</p><!-- basicblock-end -->                    <!-- basicblock-start oid="ObsSO8HawpB9c1etxyG3uioF" --> <h3 id="221-代码"><a class="markdownIt-Anchor" href="#221-代码"></a> 2.2.1 代码::</h3><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(treenode* node)</span> </span>{<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 💡因为最后一层的孩子是 NULL, 高度为 0</span><br>        <span class="hljs-type">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);       <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);     <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth); <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> depth;<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(root);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">maxDepth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">maxDepth</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftDepth, rightDepth);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="3-拓展题目"><a class="markdownIt-Anchor" href="#3-拓展题目"></a> 3 拓展题目</h1><h2 id="31-559n叉树的最大深度"><a class="markdownIt-Anchor" href="#31-559n叉树的最大深度"></a> 3.1 559.n叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">力扣题目链接</a></p><p>给定一个 n 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>例如，给定一个 3叉树 :我们应返回其最大深度，3。<br><img src="https://img-blog.csdnimg.cn/2021020315313214.png" alt="559.n叉树的最大深度"></p><!-- basicblock-start oid="ObsFKYfVGEDD0vDqi8Zr81qG" --> <p>N叉树最大深度思路::</p><pre><code class="hljs">二叉树最大深度: 从最下层开始找到左右孩子的高度的最大值, 然后+1 返回给上一层. </code></pre><p>N叉树的最大深度：比较多个孩子的最大值, 然后"+1"返回给上一层</p><!-- basicblock-end --><!-- basicblock-start oid="ObsGWBYwdE46PteMIqVCwmaW" --> <p>如何操做 N叉树的所有孩子::<br>二叉树直接可以用 node-&gt;left, node-&gt;right. 因为只有两孩子. 所以好操作<br>N 叉树</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.size(); i++){ <span class="hljs-comment">// 遍历每个孩子</span><br>node-&gt;children[i] <span class="hljs-comment">// 具体操作每个一个孩子</span><br><br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="ObstwUhG4JxAiSUAPVl4VIBS" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::9. 二叉树的最大深度.md" --> <h2 id="32-代码"><a class="markdownIt-Anchor" href="#32-代码"></a> 3.2 代码::</h2><!-- basicblock-end --><p>通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(Node* node)</span></span>{<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++){<br>            depth = <span class="hljs-built_in">max</span>(depth, <span class="hljs-built_in">getdepth</span>(node-&gt;children[i]));<br>        }<br>        <span class="hljs-keyword">return</span> depth+<span class="hljs-number">1</span>;<br><br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(Node* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(root);<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObssIwbunz9uwD7YWpg3gxSl" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::9. 二叉树的最大深度.md" --> <p>#历史记录::<br>2022/09/04🌵9. 二叉树的最大深度, 用递归(后序遍历)实现, 获取最后一层的节点的高度, 然后"+1"逐层返回到上一层⏱0.68<br>2022/09/12🌵9. 二叉树的最大深度:  正常复习, 不难⏱0-20</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 对称二叉树</title>
    <link href="/posts/32421/"/>
    <url>/posts/32421/</url>
    
    <content type="html"><![CDATA[<ol start="8"><li>对称二叉树::<br>2022/09/03🌵8. 对称二叉树: 学习了同时遍历两个二叉树. ⏱1-12<br>2022/09/12🌵8. 对称二叉树:  有点忘了, 又复习一遍吧, 不算难⏱0-10</li></ol><!-- basicblock-end --> <h1 id="1-对称二叉树"><a class="markdownIt-Anchor" href="#1-对称二叉树"></a> 1: 对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">力扣题目链接</a></p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p><img src="https://img-blog.csdnimg.cn/20210203144607387.png" alt="101. 对称二叉树"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><p>什么类型的函数用后序遍历: 需要收集孩子信息向上一层返回  ^ui0nki</p><p>![[8. 对称二叉树 2022-09-04 16.04.53.excalidraw]]</p><p>为什么要采用后序遍历 ::<br>![[8. 对称二叉树 2022-09-04 16.26.21.excalidraw]]<br>[[前中后序遍历]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>carl</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> {<br>        <span class="hljs-comment">// 首先排除空节点的情况</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 排除了空节点，再排除数值不相同的情况, 不然操作空指针了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-comment">// 💡同时遍历两个二叉树</span><br>        <span class="hljs-type">bool</span> outside = compare(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br>        <span class="hljs-type">bool</span> inside = compare(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中 （逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br><br>    }<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> {<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> compare(root-&gt;left, root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>^4yh3i4</p><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>{<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);<br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);<br>        <span class="hljs-keyword">return</span> outside &amp;&amp; inside; <br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-100-相同的树"><a class="markdownIt-Anchor" href="#4-100-相同的树"></a> 4: [[100. 相同的树]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 反转二叉树</title>
    <link href="/posts/42763/"/>
    <url>/posts/42763/</url>
    
    <content type="html"><![CDATA[<h1 id="1-226翻转二叉树"><a class="markdownIt-Anchor" href="#1-226翻转二叉树"></a> 1: 226.翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/">力扣题目链接</a></p><p>翻转一棵二叉树。</p><p><img src="https://img-blog.csdnimg.cn/20210203192644329.png" alt="226.翻转二叉树|500"></p><p>这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，权当一个乐子哈）</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><!-- basicblock-start oid="ObshhkVMOq4kC0ciGlKLWXHb" --> <h2 id="21-层序遍历广度优先遍历"><a class="markdownIt-Anchor" href="#21-层序遍历广度优先遍历"></a> 2.1: 层序遍历(广度优先遍历)::</h2><p>[[5. 二叉树的层序遍历#2 思路]]</p><p>层序遍历的时候, 逐个弹出元素本层元素的同时, 在把弹出的元素左右孩子做一个交换<br>因为是从第一层开始的, 每一层的节点的左右孩子的都会被交换.</p><h3 id="211-代码"><a class="markdownIt-Anchor" href="#211-代码"></a> 2.1.1: 代码</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="hljs-comment">// 弹出元素的同时, 在把该节点的左右孩子交换一下, 下边然后在加入</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><!-- basicblock-start oid="Obs1K0yTTEWvKbJJunPhh7NM" --> <h2 id="22-深度优先遍历"><a class="markdownIt-Anchor" href="#22-深度优先遍历"></a> 2.2: 深度优先遍历::</h2><!-- basicblock-end --><!-- basicblock-start oid="ObsYblbWEkEb1kEuJd6f8n6R" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::6. 反转二叉树.md"--><ul><li>&amp; <strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong><br>![[6. 反转二叉树 2022-09-05 11.05.02.excalidraw]]</li></ul><!-- basicblock-end --><p><strong>前序遍历过程</strong></p><p>用前序或后序递归遍历, 到中间节点的时候, 把节点的左右孩子给交换一下. <mark>中</mark>左右: <mark>中</mark>其实是处理逻辑, 因为每个节点都会遍历到. 自然交换了所有节点的左右孩子.</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnakm26jtog30e409s4qp.gif" alt="翻转二叉树"></p><p>我们来看一下递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。</p><p>返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为<code>TreeNode*</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">TreeNode* <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode* root)</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>确定终止条件</li></ol><p>当前节点为空的时候，就返回</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>确定单层递归的逻辑</li></ol><p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">swap(root-&gt;left, root-&gt;right);<br>invertTree(root-&gt;left);<br>invertTree(root-&gt;right);<br></code></pre></td></tr></tbody></table></figure><p>基于这递归三步法，代码基本写完，C++代码如下：</p><h3 id="221-代码"><a class="markdownIt-Anchor" href="#221-代码"></a> 2.2.1: 代码</h3><p>carl</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);        <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invert</span> <span class="hljs-params">(TreeNode* node)</span></span>{ <span class="hljs-comment">// ❗️返回类型是 TreeNode*, 不是 void, 💡只是操作树, 不需要返回信息用 TreeNode*</span><br><br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// ❓必须要 return node, 因为返回值是TreeNode 类型</span><br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-built_in">invert</span>(node-&gt;left);<br>        <span class="hljs-built_in">invert</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> node;  <span class="hljs-comment">// ❓这里不懂</span><br>    }<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">invert</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invert</span> <span class="hljs-params">(TreeNode* node)</span></span>{ <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// NULL 意思是空节点呗, ❓然后自动返回上一层</span><br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-built_in">invert</span>(node-&gt;left);<br>        <span class="hljs-built_in">invert</span>(node-&gt;right);<br>        <span class="hljs-comment">//函数返回时就表示当前这个节点，以及它的左右子树</span><br><span class="hljs-comment">//都已经交换完了, ❓然后就到上一层了?</span><br>        <span class="hljs-keyword">return</span> node;  <span class="hljs-comment">// 💡每个节点交换完都返回一次, 直至处理到最后一个节点</span><br>    }<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">invert</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v4, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode*  <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* node)</span></span>{<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span> ;<span class="hljs-comment">// ❗️返回值类型为 TreeNode* 的, 返回值是 node 或者 NULL</span><br>        <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>        <span class="hljs-built_in">invertTree</span>(node-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> node;<br>    }<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obsy1jpTtYeUXshW3JwWnfWQ" --> <p>返回值类型为 TreeNode* 时 ,应当 return 什么::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">TreeNode*  <span class="hljs-title">traversal</span> <span class="hljs-params">(TreeNode* node)</span></span>{<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span> ;<span class="hljs-comment">// ❗️返回值类型为 TreeNode* 的, 返回值起码是 NULL, 普通的就是二叉树指针</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsqQ3qh1SYiiESPsf4ZuD01"  --> <p>2022/09/03🌵6. 反转二叉树:: ⏱1.45<br>1. 用前序或后序递归遍历, 到中间节点的时候, 把节点的左右孩子给交换一下. <mark>中</mark>左右: <mark>中</mark>其实是处理逻辑, 因为每个节点都会遍历到. 自然交换了所有节点的左右孩子.<br>- &amp; 不能用中序遍历, 会导致左右两个孩子交换两次<br>2.  用层序遍历模板, 就是弹出本层元素的同时, 在把该节点的左右孩子互换一下即可<br>2022/09/05🌵6. 反转二叉树: 递归代码v3有疑问待解决 ⏱1-10<br>2022/09/07🌵6. 反转二叉树: anki 复习, v3 还是感觉有点迷糊, 可能动写一下代码就好一些<br>2022/09/07🌵6. 反转二叉树: v4, 进一步熟悉了, ⏱0-14</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 二叉树的层序遍历</title>
    <link href="/posts/11836/"/>
    <url>/posts/11836/</url>
    
    <content type="html"><![CDATA[<h1 id="1-102二叉树的层序遍历"><a class="markdownIt-Anchor" href="#1-102二叉树的层序遍历"></a> 1: 102.二叉树的层序遍历</h1><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">力扣题目链接</a></p><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><img src="https://img-blog.csdnimg.cn/20210203144842988.png" alt="102.二叉树的层序遍历"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><p>[[广度优先遍历]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>其余的十个题</p><h2 id="31-102二叉树的层序遍历本题"><a class="markdownIt-Anchor" href="#31-102二叉树的层序遍历本题"></a> 3.1: 102.二叉树的层序遍历(本题)</h2><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<span class="hljs-comment">// ❓不用 push "-&gt;val"吗, 💡需要-&gt;val</span><br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-107二叉树的层次遍历ii"><a class="markdownIt-Anchor" href="#32-107二叉树的层次遍历ii"></a> 3.2: [[107.二叉树的层次遍历II]]</h2><h2 id="33-199二叉树的右视图"><a class="markdownIt-Anchor" href="#33-199二叉树的右视图"></a> 3.3: [[199.二叉树的右视图]]</h2><h2 id="34-637二叉树的层平均值"><a class="markdownIt-Anchor" href="#34-637二叉树的层平均值"></a> 3.4: [[637.二叉树的层平均值]]</h2><!-- basicblock-start oid="ObsuDmsEzy8x7UlnbeXhtogm" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="35-429n叉树的层序遍历"><a class="markdownIt-Anchor" href="#35-429n叉树的层序遍历"></a> 3.5: 429.N叉树的层序遍历::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">力扣题目链接</a></p><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p><p>例如，给定一个 3叉树 :</p><p><img src="https://img-blog.csdnimg.cn/20210203151439168.png" alt="429. N叉树的层序遍历|500"></p><p>返回其层序遍历:</p><p>[ [1], [3,2,4], [5,6] ]</p><p>思路:</p><p>这道题依旧是模板题，只不过一个节点有多个孩子了<br>把一个节点的所有孩子都加入队列里边就行了</p><!-- basicblock-start oid="ObsbS4edLzulGab31MsUvZ7Z" --> <p>将 n 叉树的所有节点加入到队列中::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 将节点所有孩子加入队列</span><br>              <span class="hljs-keyword">if</span> (node-&gt;children[i]) que.<span class="hljs-built_in">push</span>(node-&gt;children[i]);<span class="hljs-comment">// if(node-&gt;left)</span><br>          }<br></code></pre></td></tr></tbody></table></figure><p>多叉树的孩子用<code>-&gt;children</code>表示, 孩子个数用<code>-&gt;children.size()</code><br>平时是用-&gt;left ,-&gt;right</p><!-- basicblock-end --><p>已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(Node* root) {<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">while</span>(size--){<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++){<br>                    <span class="hljs-keyword">if</span>(node-&gt;children[i]) que.<span class="hljs-built_in">push</span>(node-&gt;children[i]);<br>                }<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(Node* root) {<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;children.<span class="hljs-built_in">size</span>(); i++){<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;children[i]); <span class="hljs-comment">// 💡这个更好 : if (node-&gt;children[i]) que.push(node-&gt;children[i]);</span><br>                }<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    }<br>};```<br><br><br><br><br>## <span class="hljs-number">3.6</span> <span class="hljs-number">515.</span>在每个树行中找最大值<br>[力扣题目链接](https:<span class="hljs-comment">//leetcode.cn/problems/find-largest-value-in-each-tree-row/)</span><br><br><br>您需要在二叉树的每一行中找到最大的值。<br><br>![<span class="hljs-number">515.</span>在每个树行中找最大值](https:<span class="hljs-comment">//img-blog.csdnimg.cn/20210203151532153.png)</span><br><br>思路：<br><br>层序遍历，取每一层的最大值<br><br><br><br>```c++<br><span class="hljs-keyword">class</span> Solution {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">largestValues</span>(TreeNode* root) {<br>        queue&lt;TreeNode*&gt; que;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> maxValue = INT_MIN;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                maxValue = node-&gt;val &gt; maxValue ? node-&gt;val : maxValue; <span class="hljs-comment">// 💡该层的每一个数都来比较</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>            result.<span class="hljs-built_in">push_back</span>(maxValue);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obs4VpTv34hro3xfMo7mbyWl" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="36-116填充每个节点的下一个右侧节点指针"><a class="markdownIt-Anchor" href="#36-116填充每个节点的下一个右侧节点指针"></a> 3.6: 116.填充每个节点的下一个右侧节点指针::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">力扣题目链接</a></p><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span><br>  <span class="hljs-type">int</span> val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br></code></pre></td></tr></tbody></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有&nbsp;next 指针都被设置为 NULL。</p><p><img src="https://img-blog.csdnimg.cn/20210203152044855.jpg" alt="116.填充每个节点的下一个右侧节点指针|600"><br>思路:<br>本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让记录节点的 next 指针指下一个节点就可以了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Node* node = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首元素</span><br>que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 连接</span><br><span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) node-&gt;next = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时的 front 是之前的第二个</span><br></code></pre></td></tr></tbody></table></figure><p>❓那是怎么指向 null 的呢<br>💡初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code>。(题目说的), 本题中最右侧的节点的 next本来就指向 NULL</p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/solution/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-2-4/">力扣官方题解不错, 看第一种</a></p><h3 id="361-使用层次遍历"><a class="markdownIt-Anchor" href="#361-使用层次遍历"></a> 3.6.1: 使用层次遍历</h3><p>没用代码随想录, 用力扣官方题解, 已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>{<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历这一层的所有节点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                Node* node = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 取出队首元素</span><br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 连接</span><br>                <span class="hljs-keyword">if</span> (i &lt; size - <span class="hljs-number">1</span>) node-&gt;next = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时的 front 是之前的第二个, 💡最后一个 node 的 next 本身就是指向 null</span><br>                <span class="hljs-comment">// 扩展下一层节点</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="362-使用已有的-next-指针"><a class="markdownIt-Anchor" href="#362-使用已有的-next-指针"></a> 3.6.2: 使用已有的 next 指针</h3><p>暂时不做</p><!-- basicblock-start oid="ObsHHyGbzS6j99xXRZdsDUR2"  deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md"--> <h2 id="37-117填充每个节点的下一个右侧节点指针ii"><a class="markdownIt-Anchor" href="#37-117填充每个节点的下一个右侧节点指针ii"></a> 3.7: 117.填充每个节点的下一个右侧节点指针II::</h2><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">力扣题目链接</a></p><!-- basicblock-end --><p>思路：</p><p>这道题目说是二叉树，但116题目说是完整二叉树，其实没有任何差别，一样的代码一样的逻辑一样的味道<br>同我上边写的, 编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>{<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i &lt; size - <span class="hljs-number">1</span>) node-&gt;next = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 💡重点</span><br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> root;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObslzGeoh1X4WX2aMKWO18Bd" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="38-104二叉树的最大深度"><a class="markdownIt-Anchor" href="#38-104二叉树的最大深度"></a> 3.8: 104.二叉树的最大深度::</h2><!-- basicblock-end --><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">力扣题目链接</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，<br><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度|600"></p><p>返回它的最大深度 3 。</p><p>最大的深度就是二叉树的层数, 在记录每一层size 的下边在记录层数. <strong>每次弹出完一层就+1</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>          <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>          depth++; <span class="hljs-comment">// 记录深度, for 循环出来就是弹完一层了 </span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) { <br>              TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>              que.<span class="hljs-built_in">pop</span>();<br>              <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>              <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>          }<br></code></pre></td></tr></tbody></table></figure><p>代码如下: 已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(size--){<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> depth;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsNTlSW223rhUXzpmYNUaGz" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::5. 二叉树的层序遍历.md" --> <h2 id="39-111二叉树的最小深度"><a class="markdownIt-Anchor" href="#39-111二叉树的最小深度"></a> 3.9: 111.二叉树的最小深度::</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">力扣题目链接</a></p><p>相对于 104.二叉树的最大深度 ，本题还也<strong>继续使用层序</strong>遍历的方式来解决，思路是一样的。<br>❓不是很懂, 💡画图解决了看下边</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) { <span class="hljs-comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br>    <span class="hljs-keyword">return</span> depth;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><strong>需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点</strong><br>![[5. 二叉树的层序遍历 2022-09-05 22.47.29.excalidraw]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录遍历的层数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) { <span class="hljs-comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br>                    <span class="hljs-keyword">return</span> depth;<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> depth;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start --> <p>如何判断左右节点是否为空::</p><ol><li>不为空: <code>if(node-&gt;left) que.push(node-&gt;left</code>), ❓💡node-&gt;left 如果不是空, 会返回 1</li><li>为空:     <code>if (!node-&gt;left &amp;&amp; !node-&gt;right) return depth</code>, 💡同理</li></ol><!-- basicblock-end --> <!-- basicblock-start oid="ObsrJa0fCCW6D2bZN7WD0iw7"  --> <p>二叉树的层序遍历 ::<br>2022/09/02: 5. <a href="http://xn--4kq24jzfy32af2chru20x4x9b.md">二叉树的层序遍历.md</a>: 思路挺简单的, 多练吧<br>2022/09/05: 比较顺利, 中间干了其他一些事, 所以时间长了, 下次把其余九道题, 单独做成文件 deck (2022/09/08 已做)⏱0-20<br>2022/09/12🌵5. <a href="http://xn--4kq24jzfy32af2chru20x4x9b.md">二叉树的层序遍历.md</a>:  复习, 跟着 anki 过了一遍, 很熟悉了 ⏱0-37</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 二叉树的统一迭代法</title>
    <link href="/posts/7027/"/>
    <url>/posts/7027/</url>
    
    <content type="html"><![CDATA[<p>前中后序遍历可以写出来一个统一的迭代法格式</p><p><strong>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmq3btubg30em09ue82.gif" alt="中序遍历迭代（统一写法）"><br>可以看出我们将访问的节点直接加入到栈中，但如果是处理的节点则后面放入一个空节点， 这样只有空节点弹出的时候，才将下一个节点放进结果集。</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsRm8eBdwkQAzFhq7vFhDhI" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::4. 二叉树的统一迭代法.md" --> <p>#历史记录::<br>2022/9/2: 4. <a href="http://xn--4gq1mwi06ozq3ahlgzjs6xpzg0b.md">二叉树的统一迭代法.md</a>, 第一次创建. 感觉不太好写, 不学这个, 只用递归法就行⏱0.3</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 二叉树的迭代遍历</title>
    <link href="/posts/8180/"/>
    <url>/posts/8180/</url>
    
    <content type="html"><![CDATA[<p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></p><h1 id="1-前序遍历迭代法"><a class="markdownIt-Anchor" href="#1-前序遍历迭代法"></a> 1: 前序遍历(迭代法)::</h1><p>先将根节点放入栈中<strong>后弹出</strong>，然后<strong>先加入右孩子</strong>入栈<strong>后弹出</strong>，<strong>后加入左孩子后弹出</strong>。</p><p>为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。</p><p>动画如下：<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmss7603g30eq0d4b2a.gif" alt="二叉树前序遍历（迭代法）"></p><h2 id="11-代码"><a class="markdownIt-Anchor" href="#11-代码"></a> 1.1: 代码</h2><p>carl: 这其实就是层序遍历嘛</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) {<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()){ <span class="hljs-comment">// 💡用层序遍历但不需要记录每层的个数,即不需要把每层的数据弹出</span><br>            TreeNode* node = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 💡que是 front();</span><br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 先加右孩子</span><br>            <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);   <span class="hljs-comment">// 在加左孩子</span><br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>等等</p><h1 id="2-中序遍历"><a class="markdownIt-Anchor" href="#2-中序遍历"></a> 2: 中序遍历</h1><p>无法与上面的前序遍历通用</p><p>因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbmuj244bg30eq0d4kjm.gif" alt="二叉树中序遍历（迭代法）"></p><h1 id="3-后序遍历"><a class="markdownIt-Anchor" href="#3-后序遍历"></a> 3: 后序遍历</h1><p>再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200808200338924.png" alt="前序到后序"></p><p><strong>所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：</strong></p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obsn0AKlkxnVHJ8jU2mSk6rW" --> <p>#历史记录::<br>2022/09/02: 第一次创建. 感觉不重要, 没有太注重, 重点学习递归法⏱1.28<br>2022/09/05:&nbsp;层序遍历但不需要记录每层的个数, 也不用只把一层的数据弹出. 先只做了前序遍历⏱0-22</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac快捷键</title>
    <link href="/posts/20705/"/>
    <url>/posts/20705/</url>
    
    <content type="html"><![CDATA[<p>![[mac快捷键 2022-09-01 11.49.24.excalidraw]]</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obs3RVbRUxTdUnQWdwOYiwy6" deck = "🚀技能::mac快捷键.md" --> <p>#历史记录::<br>2022/9/1: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PPT 演讲要点</title>
    <link href="/posts/60276/"/>
    <url>/posts/60276/</url>
    
    <content type="html"><![CDATA[<p>2022/08/31: 开题报告感悟::</p><ol><li>分章节页时做一个, 章节导图<ol><li>要有段落感</li><li>增加逻辑性</li></ol></li></ol><p>讲话时要语气随和放松,  这样显示的有自信感</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsN4HF5ARs0gPxNYhRgcokw" deck = "🚀技能::PPT 演讲要点.md" --> <p>#历史记录::<br>2022/8/31: 第一次创建, 开题报告</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整体实验流程</title>
    <link href="/posts/43974/"/>
    <url>/posts/43974/</url>
    
    <content type="html"><![CDATA[<ol><li>设置限位, 放入圆环</li><li>将工件和冲模润滑,  工件放入顶盖的中心孔洞中</li><li>顶盖上方先放垫块,  后放入冲模. 启动液压机下压</li><li>下压到限位停止, 用千斤顶将冲模起开并拿出</li><li>放入第二段冲模, 计算机压力值为 0 时停止.</li><li>取出二段冲模和底部圆棒, 打开顶盖取出圆盘</li></ol><p>工件在通道中被冲模下压后, 到达挤压部件处. 挤压块设计有倒角, 且整体通道直径比上部的通道小. 工件一部分会通过倒角侧向流动变成圆盘. 剩余部分会下压到挤压块通道成为圆棒.</p><p>考虑到冲模下压的过程中, 会跟材料产生粘结. 先用垫板放置冲模下方. 在液压机达到限位时, 方便用千斤顶将第一段冲模起开.<br>放入第二段冲模, 将圆棒压入底部. 后取出</p><p>问松青的问题</p><ol><li>润滑脂是什么:</li><li>液压机的速度: 1mm / s</li><li>通道的直径: 上通道是 10mm ,  挤压块是 6mm</li><li>挤压原理是什么, 为什么会侧向挤出就成了梯度材料 : 看俞宁和邹工的毕业论文</li><li></li></ol><p>![[整体实验流程 2022-08-30 20.06.31.excalidraw]]</p><h1 id="1-铜环的尺寸"><a class="markdownIt-Anchor" href="#1-铜环的尺寸"></a> 1 铜环的尺寸</h1><p>材料: 纯铜 ;<br>厚度: 2mm<br>制作铜环尺寸: 内径mm * 外径mm</p><table><thead><tr><th>内外径差 10</th><th>内外径差 12</th><th>内外径差 14</th></tr></thead><tbody><tr><td>22 * 32</td><td>22  *  34</td><td>22 * 36</td></tr><tr><td>24 * 34</td><td>24  * 36</td><td>24 * 38</td></tr><tr><td>26 * 36</td><td>26  * 38</td><td>26 * 40</td></tr><tr><td>28 * 38</td><td>28  * 40</td><td>28 * 42</td></tr><tr><td>30 * 40</td><td></td><td></td></tr></tbody></table><p>每种尺寸各做3 个</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsmA1UeJy3WYPadethDm7hz" deck = "👨🏻‍🎓科研::整体实验流程.md" --> <p>#历史记录::<br>2022/8/30: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 二叉树的递归遍历</title>
    <link href="/posts/64675/"/>
    <url>/posts/64675/</url>
    
    <content type="html"><![CDATA[<p>此时大家可以做一做leetcode上三道题目，分别是：</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145.二叉树的后序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94.二叉树的中序遍历</a></li></ul><h1 id="1-递归解题方法"><a class="markdownIt-Anchor" href="#1-递归解题方法"></a> 1: [[递归解题方法]]</h1><h1 id="2-前序遍历的递归写法"><a class="markdownIt-Anchor" href="#2-前序遍历的递归写法"></a> 2: 前序遍历的递归写法</h1><ol><li><strong>确定递归函数的参数和返回值</strong>：因为要打印出前序遍历节点的数值，所以参数里需要传入vector在放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>确定终止条件</strong>：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>确定单层递归的逻辑</strong>：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br></code></pre></td></tr></tbody></table></figure><p>完整代码<br>前序遍历：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>那么前序遍历写出来之后，中序和后序遍历就不难理解了，代码如下：</p><p>[[前中后序遍历]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>v2, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Traversal</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span>{ <span class="hljs-comment">// ❗️必须是引用类型才能持续添加</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 直接返回上一层</span><br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// ❗️push_back的是root-&gt;val, 而不是 root, root 是个指针</span><br>        <span class="hljs-built_in">Traversal</span>(root-&gt;left, vec); <span class="hljs-comment">// ❗️函数有两个参数, 不要只传一个</span><br>        <span class="hljs-built_in">Traversal</span>(root-&gt;right, vec);<br><br>    }<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">Traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYYhSQUKMhGa1ZN3yNUWcg"  --> <p>#历史记录::<br>2022/08/29: 第一次创建<br>2022/09/05: v2, ⏱0-20</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前中后序的遍历的方式</title>
    <link href="/posts/59941/"/>
    <url>/posts/59941/</url>
    
    <content type="html"><![CDATA[<p>前中后序遍历::<br>2022/08/29: 第一次创建<br>2022/09/12: anki 复习</p><!-- basicblock-end --> <p>前中后序指的就是<strong>中间节点的位置</strong></p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>![[前中后序的遍历的方式 2022-08-29 16.44.58.excalidraw]]</p><h1 id="1-后序遍历"><a class="markdownIt-Anchor" href="#1-后序遍历"></a> 1: 后序遍历</h1><p>![[8. 对称二叉树#^ui0nki]]</p><h1 id="2-其他"><a class="markdownIt-Anchor" href="#2-其他"></a> 2: 其他</h1><!-- basicblock-start oid="ObstNNjBlLJYieagw6RMA4WP" --> <p>同时遍历两个二叉树::<br>![[8. 对称二叉树#^4yh3i4]] ^4c6589</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 二叉树理论基础</title>
    <link href="/posts/33244/"/>
    <url>/posts/33244/</url>
    
    <content type="html"><![CDATA[<p>二叉树理论基础::<br>2022/8/29: 第一次创建</p><!-- basicblock-end --> <h1 id="1-二叉树的种类"><a class="markdownIt-Anchor" href="#1-二叉树的种类"></a> 1: 二叉树的种类</h1><p>在我们解题过程中二叉树有两种主要的形式：<strong>满二叉树和完全二叉树。</strong></p><!-- basicblock-start oid="ObskteVaQKFKXP6YheO3U5di" --> <h2 id="11-满二叉树"><a class="markdownIt-Anchor" href="#11-满二叉树"></a> 1.1: 满二叉树::</h2><p>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><ul><li>&amp;  度: 节点孩子的个数<br><img src="https://img-blog.csdnimg.cn/20200806185805576.png" alt="|500"></li></ul><!-- basicblock-end --><!-- basicblock-start oid="ObsNzJMUsBYRGzsjCpabCitj" --> <h2 id="12-完全二叉树"><a class="markdownIt-Anchor" href="#12-完全二叉树"></a> 1.2: 完全二叉树::</h2><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~&nbsp;2^(h-1) &nbsp;个节点.<br>![[完全二叉树.excalidraw]]<br><strong>之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong>[[小顶锥和大顶锥的原理]]  ^zkccuh</p><!-- basicblock-end --><!-- basicblock-start oid="Obs7bvG62xLqJrNcziFSYUW5" --> <h2 id="13-二叉搜索树"><a class="markdownIt-Anchor" href="#13-二叉搜索树"></a> 1.3: 二叉搜索树::</h2><p>![[二叉搜索树]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsVtHzP3EQQzapSwfu2jGuz" --> <h2 id="14-平衡二叉搜索树"><a class="markdownIt-Anchor" href="#14-平衡二叉搜索树"></a> 1.4: 平衡二叉搜索树::</h2><p>平衡二叉搜索树(红黑树)：又被称为AVL（Adelson-Velsky and&nbsp;Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>![[1. 二叉树理论基础 2022-08-29 16.19.19.excalidraw]]<br><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn ^bew6dm</p><blockquote><p>[[map(🗃)]]</p></blockquote><!-- basicblock-end --><!-- basicblock-start oid="ObsQfaa14FMYHw83FWKOmdqh" --> <h1 id="2-二叉树的存储方式"><a class="markdownIt-Anchor" href="#2-二叉树的存储方式"></a> 2: 二叉树的存储方式 ::</h1><!-- basicblock-end --><p>链式存储方式就用指针， 顺序存储的方式就是用数组。</p><h2 id="21-链式存储"><a class="markdownIt-Anchor" href="#21-链式存储"></a> 2.1: 链式存储</h2><p><img src="https://img-blog.csdnimg.cn/2020092019554618.png" alt="|600"></p><h2 id="22-顺序存储"><a class="markdownIt-Anchor" href="#22-顺序存储"></a> 2.2: 顺序存储</h2><p>![[二叉树 顺序存储.excalidraw]]</p><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p><p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p><!-- basicblock-start oid="ObsNYOEsmvwlhRsRWieqgHEk" --> <h1 id="3-二叉树的遍历方式"><a class="markdownIt-Anchor" href="#3-二叉树的遍历方式"></a> 3: 二叉树的遍历方式::</h1><p>二叉树主要有两种遍历方式：</p><h2 id="31-深度优先遍历先往深走遇到叶子节点再往回走"><a class="markdownIt-Anchor" href="#31-深度优先遍历先往深走遇到叶子节点再往回走"></a> 3.1: 深度优先遍历：先往深走，遇到叶子节点再往回走。</h2><ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul><p>[[前中后序遍历]]</p><h2 id="32-广度优先遍历一层一层的去遍历"><a class="markdownIt-Anchor" href="#32-广度优先遍历一层一层的去遍历"></a> 3.2: 广度优先遍历：一层一层的去遍历。</h2><ul><li>层次遍历(迭代法)</li></ul><!-- basicblock-end --><!-- basicblock-start oid="ObsmI7M2pZvBxBxvtlaAwJ7h" --> <h1 id="4-遍历的实现方式"><a class="markdownIt-Anchor" href="#4-遍历的实现方式"></a> 4: 遍历的实现方式::</h1><ol><li>深度优先遍历: 优先向下查找, 在返回上一层<br>实现前中后序的遍历都是用的深度优先遍历</li></ol><ul><li>&amp; <strong>栈其实就是递归的一种是实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</li></ul><ol start="2"><li>广度优先遍历: 从左至右的一层层来遍历二叉树<br>用队列<br>由队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树</li></ol><!-- basicblock-end --><!-- basicblock-start oid="Obset5wB2iODDSEmmzMV7TFz" --> <h1 id="5-二叉树的定义"><a class="markdownIt-Anchor" href="#5-二叉树的定义"></a> 5: 二叉树的定义::</h1><p>链式存储的二叉树节点的定义方式。<br>C++代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> {<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) {}<br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>{</span><br><span class="hljs-type">int</span> val;<br>TreeNode* left;<br>TreeNode* right;<br>TreeNode(<span class="hljs-type">int</span> x) : val(x), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) {}<br>}<br></code></pre></td></tr></tbody></table></figure><p>大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p><p>这里要提醒大家要注意二叉树节点定义的书写方式。</p><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p><p>因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识星球</title>
    <link href="/posts/7468/"/>
    <url>/posts/7468/</url>
    
    <content type="html"><![CDATA[<p>卡哥，我想问一下，在面试的时候，面试官问我平时都是怎么学习知识的？这个该怎么回答才合适呢？我一般是这样回答的：主要通过哔哩哔哩，哔哩哔哩上有很多不错的讲解视频，还通过一些书籍等等，然后做项目，在项目中巩固。 因为我是非科班，面试被问好几次了，我也不知道怎么回答才能让面试官满意，还麻烦卡哥指点一下😁。然后还想问科班的同学，你们也会遇到这种提问吗::</p><p>通过 哔哩哔哩 其实体现不出你的自学能力。 而且这种学习速度太慢。 书都是 一门技术成熟好多年了，才会有书，那如果是新技术怎么办。<br>面试官可能换个方式问你，一个项目要立刻开发了，项目使用了你不会的编程语言，要求你快速上手，你怎么做？</p><p>你要是说 去看B站看视频学，那项目可能都凉了。 你可以说：<strong>学习编程语言，应用框架直接看官网，写demo直接github找项目， 遇到不懂的 去查 StackOverflow</strong>。</p><p>这些回答 逼格就比较高，但面试官可能 会进一步说让你 举一个你这么学哪种技术的例子，如果你没有这样的学习经历，很容易翻车。 所以可以适当 参考我的说法，但结合一下自己情况，就怕面试官往深问让你举个例子。</p><ul><li><blockquote><p>评论</p></blockquote></li></ul><ol><li>臻昊：然后说每天都会去看一些博客文章，了解一些新技术，然后去官网详细学习一下</li><li>Forget：原来大佬的学习方法是这样的，直接看官网！以后往这方面靠近<img src="https://wx.zsxq.com/dweb2/assets/images/emoji/expression_31.png" alt="" title="奋斗"></li></ol><!-- basicblock-end --> <!-- basicblock-start oid="Obs0jwYkHQBec0yQg8HnKf61" --> <p>面试时怎么反问::</p><p><strong>技术面反问：</strong></p><ol><li>项目组技术方向，技术栈都有哪些，团队分工。</li><li>例如自己表现的如何，后序学习建议，一般 来说不要问了，面试官也不会说但有的面试官还真会给你点建议，这个分人。</li></ol><p><strong>HR反问：</strong></p><ol><li>部门业务方向，加班情况（也表明一下 自己对加班一点都不反感，可以疯狂加班），</li><li>然后再说说和 技术面面试官聊得很好，夸一夸技术面试官技术很强，部门技术氛围好。</li></ol><p>剩下的也没啥了，不用那么纠结，就了解一下部门情况就可以了，这都不是最重要的环节。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202209010911960.png" alt="|300"></p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsTS0Bw4p8DFvUebm4u07um" deck = "👨🏻‍💻code::0突发奇想::知识星球.md" --> <p>#历史记录::<br>2022/8/29: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>0突发奇想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识星球</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小顶锥和大顶锥的原理</title>
    <link href="/posts/20437/"/>
    <url>/posts/20437/</url>
    
    <content type="html"><![CDATA[<p>📝小顶锥和大顶锥的原理::</p><!-- basicblock-end --><h1 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1: 原理</h1><p>小顶锥和大顶锥的原理<br>两个顶锥本质是由完全二叉树结构储存的<br>小顶锥: 父节点 比 两个子节点都小,  <strong>每次弹出父节点</strong><code>(数值小的)</code><br>大顶锥: 父节点 比 两个子节点都大,  <strong>每次弹出父节点</strong><code>(数值大的)</code></p><blockquote><p>大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），</p></blockquote><p>用 priority_queue 实现大小顶锥,从小到大排就是小顶堆，从大到小排就是大顶堆。</p><blockquote><p>底层实现都是一样的，<br>![[1. 二叉树理论基础#^zkccuh]]</p></blockquote><!-- basicblock-start oid="ObsF6VU6LIvMaliQq6chN6am" --> <p>为什么左 &gt; 右就会建立小顶堆，左 &lt; 右建立大顶堆 ? ::</p><p>我们在写快排的cmp函数的时候，<code>return left&gt;right</code> 是从大到小，<code>return left&lt;right</code> 是从小到大。</p><p>优先级队列的定义正好反过来了，可能和优先级队列的源码实现有关（我没有仔细研究），我估计是底层实现上优先队列队首指向后面，队尾指向最前面的缘故！</p><!-- basicblock-end --><h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2: 代码</h1><p>用 map 结构定义小顶锥</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span>{ <span class="hljs-comment">// 左 &gt; 右 是小顶锥, 与平时的感觉相反</span><br>      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>{<br>          <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>      }<br>  };<br><br><span class="hljs-comment">// 💡定义小顶锥</span><br>  priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br></code></pre></td></tr></tbody></table></figure><p>获取元素<br>获取大小顶锥的首元素的key: <code>pri_que.top().first;</code></p><p>函数<br>pop(),<br>push(), 可用指针指向 map元素, push(* it)</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
      <tag>历史记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 栈与队列总结</title>
    <link href="/posts/41579/"/>
    <url>/posts/41579/</url>
    
    <content type="html"><![CDATA[<p>测试一下</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsyFLyz0FAcU76F13ryLCZD" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::9. 栈与队列总结.md" --> <p>#历史记录::<br>2022/08/23: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8. 前K个高频元素</title>
    <link href="/posts/40341/"/>
    <url>/posts/40341/</url>
    
    <content type="html"><![CDATA[<h1 id="1-347前-k-个高频元素"><a class="markdownIt-Anchor" href="#1-347前-k-个高频元素"></a> 1 347.前 K 个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">力扣题目链接</a></p><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><ul><li>输入: nums = [1,1,1,2,2,3], k = 2</li><li>输出: [1,2]</li></ul><p>示例 2:</p><ul><li>输入: nums = [1], k = 1</li><li>输出: [1]</li></ul><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>将元素存入 map 结构, 得到元素的频率</li><li>用小顶锥结构求出前K个高频元素<ol><li>将所有频率将入到堆中，如果堆的大小大于K了，就将元素从堆顶弹出(<code>每次弹出的是数值小的, 也就是频率低的)</code></li></ol></li><li>倒序输出小顶锥的元素<br>![[8. 前K个高频元素 2022-08-23 18.30.49.excalidraw]]</li></ol><h2 id="21-小顶锥和大顶锥的原理"><a class="markdownIt-Anchor" href="#21-小顶锥和大顶锥的原理"></a> 2.1 ![[小顶锥和大顶锥的原理]]</h2><p>^5fcfcc</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// v1, 对着抄, 熟悉函数 ,未通过</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span>{ <span class="hljs-comment">// 左 &gt; 右 是小顶锥, 与平时的感觉相反</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span></span>{<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        }<br>    };<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>{<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>            map[nums[i]]++;<br>        }<br>        <span class="hljs-comment">/*for(int a : nums){</span><br><span class="hljs-comment">            map[a]++;</span><br><span class="hljs-comment">        }</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">// 💡定义小顶锥</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-comment">// for 循环的一种</span><br>        <span class="hljs-keyword">for</span>(unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; :: iterator it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++){<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k){<br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            }<br>        }<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsSq7XuI4azCAHBSWexq7Y5" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::8. 前K个高频元素.md" --> <p>#历史记录 ::<br>8. 前K个高频元素: 完成思路部分, 期间干了其他事⏱1.73👨🏻‍💻2022/08/23<br>2022/08/24: 完成代码部分,添加了很多函数知识: ⏱0.63</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 滑动窗口最大值</title>
    <link href="/posts/22934/"/>
    <url>/posts/22934/</url>
    
    <content type="html"><![CDATA[<h1 id="1-滑动窗口最大值"><a class="markdownIt-Anchor" href="#1-滑动窗口最大值"></a> 1 滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">力扣题目链接</a></p><p>给定一个数组 nums，有一个大小为&nbsp;k&nbsp;的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k&nbsp;个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt=""></p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>-10^4&nbsp;&lt;= nums[i]&nbsp;&lt;= 10^4</li><li>1 &lt;= k&nbsp;&lt;= nums.length</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>设计一个单调队列 :  每次只维护窗口中的最大值</p><ol><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li><li>getMaxValue: 每次获取滑动窗口的最大值, 即队头元素</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><p>为了更直观的感受到单调队列的工作过程，以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif" alt="239.滑动窗口最大值-2"></p><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsxJKt98XgV1tsTlwG6NK7X" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::7. 滑动窗口最大值.md" --> <p>#历史记录 ::<br>7. 滑动窗口最大值: 抄代码的. ⏱1.38👨🏻‍💻2022/08/23</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.逆波兰表达式求值</title>
    <link href="/posts/18516/"/>
    <url>/posts/18516/</url>
    
    <content type="html"><![CDATA[<h1 id="1-逆波兰表达式求值"><a class="markdownIt-Anchor" href="#1-逆波兰表达式求值"></a> 1 逆波兰表达式求值</h1><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">力扣题目链接</a></p><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括&nbsp;+ ,&nbsp; - ,&nbsp; * ,&nbsp; /&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例&nbsp;1：</p><ul><li>输入: [“2”, “1”, “+”, “3”, " * "]</li><li>输出: 9</li><li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li></ul><p>示例&nbsp;2：</p><ul><li>输入: [“4”, “13”, “5”, “/”, “+”]</li><li>输出: 6</li><li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li></ul><p>示例&nbsp;3：</p><ul><li><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, " * ", “/”, " * ", “17”, “+”, “5”, “+”]</p></li><li><p>输出: 22</p></li><li><p>解释:该算式转化为常见的中缀算术表达式为：</p><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">((10 * (6 / ((9 <span class="hljs-code">+ 3) * -11))) +</span> 17) + 5       <br><span class="hljs-section">= ((10 * (6 / (12 * -11))) + 17) + 5       </span><br><span class="hljs-section">= ((10 * (6 / -132)) + 17) + 5     </span><br><span class="hljs-section">= ((10 * 0) + 17) + 5     </span><br><span class="hljs-section">= (0 + 17) + 5    </span><br><span class="hljs-section">= 17 + 5    </span><br><span class="hljs-section">= 22    </span><br></code></pre></td></tr></tbody></table></figure></li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。</strong><br>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * )</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：<strong>遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</strong></li></ul><ol><li>遇到数字则入栈</li><li>遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"><br>类似于之前的相邻字符串的消除, 只不过本题不要相邻元素做消除了，而是做运算！</p><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsBriKG6hJEoGFTNObFlWSv" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::6.逆波兰表达式求值.md" --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新能源汽车对质保和维修行业的影响</title>
    <link href="/posts/16096/"/>
    <url>/posts/16096/</url>
    
    <content type="html"><![CDATA[<h1 id="1-新能源汽车对汽车质保行业的影响"><a class="markdownIt-Anchor" href="#1-新能源汽车对汽车质保行业的影响"></a> 1 新能源汽车对汽车质保行业的影响</h1><p>燃油车与新能源汽车的争论一直是市场中的热点，对于汽车后市场的从业者而言，燃油车和新能源汽车对于汽车保养的方式有了巨大变化，无论是保养形式和使用的养护用品，都存在巨大的差异。现在市场上中的汽车服务门店几户都是以燃油车养护为主，主要业务也是发动机养护和系统清洗.</p><h2 id="11-新能源汽车与传统汽车的保养区别"><a class="markdownIt-Anchor" href="#11-新能源汽车与传统汽车的保养区别"></a> 1.1 新能源汽车与传统汽车的保养区别</h2><p>现有的汽车服务门店都是对燃油车进行系统保养，新能源汽车保养目前都被主机厂控制，并且新能源汽车与燃油车的构造和动力方式有着本质区别，因此现有的后市场保养产品并不是应用新能源汽车。新能源汽车的组成包括：电力驱动及控制系统、驱动力传动等机械系统、完成既定任务的工作装置等。电力驱动及控制系统是新能源汽车的核心部分，也是区别于燃油车的最大不同点，相当于燃油车的发动机传动系统，这部分也是传统汽车保养的重点项目部分.</p><h2 id="12-新能源汽车的主要部件"><a class="markdownIt-Anchor" href="#12-新能源汽车的主要部件"></a> 1.2 新能源汽车的主要部件</h2><p><strong>电池组</strong>，电池组的电源为新能源汽车驱动电动机提供电能[1]，电动机将电源的电能转化为机械能，通过传动装置或直接驱动车轮和工作装置。目前，新能源汽车上应用最广泛的电源是铅酸蓄电池，但随着电动汽车技术的发展，铅酸蓄电池由于比能量较低，充电速度较慢，寿命较短，逐渐被其他蓄电池所取代。正在发展的电源主要有钠硫电池、镍镉电池、锂电池、燃料电池、飞轮电池等，这些新型电源的应用，为电动汽车的发辟了广阔的前景，也为汽车零部件产业拓宽了应用领域。</p><p><strong>驱动电动机</strong>，驱动电动机的作用是将电源的电能转化为机械能，通过传动装置或直接驱动车轮和工作装置。目前新能源汽车上广泛采用直流串激电动机，这种电机具有"软"的机械特性，与汽车的行驶特性非常相符。但直流电动机由于存在换向火花，比功率较小、效率较低，维护保养工作量大，随着电机技术和电机控制技术的发展，势必逐渐被直流无刷电动机(BCDM)、开关磁阻电动机(SRM)和交流异步电动机所取代[2]。</p><p><strong>电动机调速控制装置</strong>，充电电动机调速控制装置是为新能源汽车的变速和方向变换等设置的，其作用是控制电动机的电压或电流，完成电动机的驱动转矩和旋转方向的控制。</p><p><strong>传动装置</strong>，传动装置的作用是将电动机的驱动转矩传给汽车的驱动轴，因为电动机可以带负载启动，所以电动汽车上无需传统燃油汽车的离合器。因为驱动电机的旋向可以通过电路控制实现变换，所以电动汽车无需内燃机汽车变速器中的倒档[3]。当采用电动机无级调速控制时，电动汽车可以忽略传统汽车的变速器。在采用电动轮驱动时，电动汽车也可以省略传统内燃机汽车传动系统的差速器。</p><p><strong>行驶装置</strong>，行驶装置的作用是将电动机的驱动力矩通过车轮变成对地面的作用力，从而驱动车轮行走，行驶装置基本上和燃油车的结构一致，此类的还有转向装置，制动装置。</p><h2 id="13-新能源汽车的所冲击的行业"><a class="markdownIt-Anchor" href="#13-新能源汽车的所冲击的行业"></a> 1.3 新能源汽车的所冲击的行业</h2><p>传统的易损件领域并不会因为新能源汽车崛起而实去市场和产品应用，新能源汽车崛起对于润滑油、添加剂厂家影响最为大，在保养服务层面，新能源汽车对于传统的汽车门店保养影响也将日趋增加。由于新的售车模式出现，很多主机厂已经抛弃传统4S店形势售车，而是打造官网直营，体验店售后的模式，意指在新能源汽车上面回笼目前的品牌售后渠道，所以新能源汽车在未来留给第三方维保的机构的资源就会持续减少。新能源汽车就如改变汽车行业的催化剂一般，行业模式受其影响，将产生巨变。</p><h1 id="2-新能源汽车对汽车维修行业的影响"><a class="markdownIt-Anchor" href="#2-新能源汽车对汽车维修行业的影响"></a> 2 新能源汽车对汽车维修行业的影响</h1><h2 id="21-新能源汽车与传统燃油车常见故障对比"><a class="markdownIt-Anchor" href="#21-新能源汽车与传统燃油车常见故障对比"></a> 2.1 新能源汽车与传统燃油车常见故障对比</h2><p>新能源汽车维保业务具有独特性，故障方面主要体现在动力电池、驱动电机与电控系统，较为简单集中。与此同时，车载智能中控屏的故障率也较高。基础保养由于结构相对简单，日常保养费用较燃油车有所降低。<br>纯电动汽车没有发动机和变速箱的动力总成，不需要更换火花塞，换机油机滤等。电动汽车核心三电有厂家质保，所有电动车的保养以常规保养为主。<br>其中，和燃油车相同的保养项目主要是空调滤、防冻液、刹车油和玻璃水，独有的保养项目有电池状态监测、全车电路检测、电池平衡和更换齿轮油等。<br>而且，新能源汽车的维修和保养工单比例远远低于传统燃油汽车，但在洗车、美容、轮胎、钣喷业务的工单比例更高。这表明新能源汽车相对传统汽车而言具有维修、保养频率低的特点。</p><h2 id="22-新能源汽车服务链的特点"><a class="markdownIt-Anchor" href="#22-新能源汽车服务链的特点"></a> 2.2 新能源汽车服务链的特点</h2><p>1、主机厂的经营重心逐渐由“产品营销驱动”向“服务运营驱动”转型；</p><p>2、新车营销模式出现了网上销售、新车超市、出行运营等新分销方式，不再仅仅是传统燃油车的4S店渠道；</p><p>3、以三电零部件厂商、智能网联系统开发的全新供应链企业将有更强的产业地位和话语权；</p><p>4、传统燃油车的售后市场除一小部分有远见和魄力的及应变能力的企业顺利实现转型，大部分后知后觉的企业不但将面临更为残酷的传统燃油车服务市场竞争，而且也将在汽车新四化大潮中被边缘化和淘汰。</p><h2 id="23-维修设备更新"><a class="markdownIt-Anchor" href="#23-维修设备更新"></a> 2.3 维修设备更新</h2><p>普通汽车向新能源汽车过渡的主要改变是部件上的改变，使用动力电池作为能源，在所有部件中，技术性最高的就是 动力电池，应用了快速充电技术。新能源汽车对于电池的需求非常高，以燃料电池和锂电池为主[4-5]。因此，在对新 能源汽车进行维修和保养的时候，首先应该检查新能源汽车的电池。随着新能源汽车的发展，汽车维修行业要完善相 关的维修技术，引进全新的维修设备。</p><h2 id="24-人员能力提升"><a class="markdownIt-Anchor" href="#24-人员能力提升"></a> 2.4 人员能力提升</h2><p>随着新能源汽车进入人们的日常生活，以往的汽车维修方法已经不适用于新能源汽车，维修人员的技术也不符合现在<br>的新能源汽车要求。行业对汽车维修人员有了更高要求，需要汽车维修人员具备全新的维修技术，全面学习新能源汽<br>⻋的构造知识。维修人员一定要了解全新的维修技术，熟练地维修新能源汽车，才可以满足现阶段的需求。</p><h1 id="3-汽车业的应对方法"><a class="markdownIt-Anchor" href="#3-汽车业的应对方法"></a> 3 汽车业的应对方法</h1><h2 id="31-不断完善维修设备"><a class="markdownIt-Anchor" href="#31-不断完善维修设备"></a> 3.1 不断完善维修设备</h2><p>现阶段，要更新新能源汽车的维修设备和故障诊断设备，主要有计算机、数据分析软件、汽车解读器等设备。需要使 用信息技术对新能源汽车进行维修，引入对新能源汽车电池的检测设备，使用先进的技术方法来检测新能源汽车的电 池性能，并具备给新能源汽车电池充电的设备[6]。</p><h2 id="32-提升维修人员的能力"><a class="markdownIt-Anchor" href="#32-提升维修人员的能力"></a> 3.2 提升维修人员的能力</h2><p>新能源汽车的维修相对于传统汽车的维修是有区别的，除了常规的检测外，还需要对采购的零件、维修的内容等每个 环节进行检测，特别是新能源汽车的电池续航能力、是否有老化需要更换等，都需要进行重点检测。在对新能源汽车 进行维修的过程中，维修人员一定要具备专业的维修能力，学习新能源汽车构造等专业知识，熟悉可能会出现故障的 部件等。积累更多新的知识，以在维修时快速找到故障位置，进行准确的维修工作，有效提升新能源汽车维修的效 率。除了让维修人员自学一些知识和技能外，汽车维修行业也要对所有的维修人员进行专业培训，通过培训让所有维 修人员了解新设备，熟知维修的专业知识，学习更多新能源汽车的内容[7]。</p><h2 id="33-加强绿色诊断技术的推广"><a class="markdownIt-Anchor" href="#33-加强绿色诊断技术的推广"></a> 3.3 加强绿色诊断技术的推广</h2><p>(1)ECU(Electronic Control Unit，电子控制单元)诊断仪。新能源汽车整个系统都由电控单元控制，且电控单元都 带有一定的自诊断功能。ECU会将此故障以代码形式存储到内部的随机存储器内，仪表板故障指示灯亮起，以此来提 醒驾驶员。维修员能够解读出故障码，结合故障码特征来判断汽车的故障所在，提出科学的故障排除方案。(2)示波 器。示波器直接将测得的信号以波形方式呈现到屏幕上，维修者可直观、科学地观察与判断故障，分析故障产生的原因。(3)尾气分析仪。在汽车尾气排放的过程中，使用专业的检测设备检测汽车尾气成分，主要是对CO、CO2、 CHx与NOx等成分进行检测。虽然新能源汽车有害气体的排放量较少，但是混合动力新能源汽车还是存在各种有害气 体的排放。各种气体在催化器的作用下通过尾气排放，由尾气分析仪进行检测，了解汽车混合燃料燃烧的程度和转化 效率，若尾气成分超标，需要诊断分析其原因，减少尾气排放对环境和⻋辆使用性能的影响。</p><h2 id="34-积极应用智能诊断技术"><a class="markdownIt-Anchor" href="#34-积极应用智能诊断技术"></a> 3.4 积极应用智能诊断技术</h2><p>在科技快速发展的背景下，智能诊断技术应运而生，凭借自身的诸多优势，在多领域内实现了广泛有效的应用，为人 们的生产工作带来了极大便利，促进了我国综合实力的提升。将智能诊断技术应用于汽车检测诊断工作中，促进了汽 ⻋诊断的自动化、智能化发展[8-9]。尤其是在检测诊断汽车底盘及发动机故障的过程中，科学合理地应用智能诊断技 术，能够极大提升检测效率及检测准确性。高科技检测设备及智能化检测技术的应用，对技术人员提出了更高的要 求。要实现更有效的应用，技术人员要全面分析智能检测诊断技术，不断提升<br>自身的专业水平，促进汽车检测诊断技 术的智能化发展，为汽车检测诊断和维修工作的开展提供帮助。</p><h2 id="35-完善维修程序"><a class="markdownIt-Anchor" href="#35-完善维修程序"></a> 3.5 完善维修程序</h2><p>新能源汽车发生故障的概率相对较高，因为相比传统汽车，新能源汽车的发展历程短很多，检测人员需要根据自己的<br>经验和专业知识对故障点进行排查，通过专业的维修提高汽车质量。例如，驱动电机出现电机振动现象，需要首先检<br>查轴承间隙，排除气隙不均匀的情况，重新校对平衡转子，若转子出现断裂则需要进行更换。</p><h1 id="4-参考文献"><a class="markdownIt-Anchor" href="#4-参考文献"></a> 4 参考文献</h1><p>[1]李琳，李冰，孙常林.潍坊市新能源汽车产业发展对策探索[J].产业创新研究，2020(8):34-35.<br>[2]许晓秦，任朝阳.新能源汽车发展现状和趋势分析[J].湖北农机化，2020(2):31.<br>[3]叶芳，颜宇.新能源汽车营销的发展现状及发展建议研究[J].汽车博览，2020(2):73.<br>[4]余颖舜，何升明.新能源汽车的发展现状及趋势[J].现代职业教育，2020(4):196-197.<br>[5]胡素珍.浅谈我国新能源汽车产业发展现状[J].大科技，2020(7):231-232.<br>[6]⻩琰.新能源汽车市场分析及发展预测[J].商情，2020(2):73-74.<br>[7]王鲁东.新时期新能源汽车产业的发展现状及发展前景展望[J].汽车博览，2020(8):161. [8]袁博.新能源汽车产业促进产业融合发展研究[J].管理工程师，2020，25(2):3-7.<br>[9]朱亮.新能源汽车职业教育的发展现状及发展趋势展望[J].商情，2020(19):233.</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsbpn5tOgZvTRCByFnsiczn" --> <p>📝新能源汽车对质保和维修行业的影响::<br>2022/11/3 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 删除字符串中的所有相邻重复项</title>
    <link href="/posts/15/"/>
    <url>/posts/15/</url>
    
    <content type="html"><![CDATA[<blockquote><p>匹配问题都是栈的强项</p></blockquote><h1 id="1-删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#1-删除字符串中的所有相邻重复项"></a> 1 删除字符串中的所有相邻重复项</h1><p>给出由小写字母组成的字符串&nbsp;S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：“abbaca”</li><li>输出：“ca”</li><li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p>提示：</p><ul><li>1 &lt;= S.length &lt;= 20000</li><li>S 仅由小写英文字母组成。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>把字符串顺序放到一个栈中</li><li>相同则弹出</li><li>弹出最后的元素, 在反转一下(因为最后从栈里弹出的元素是倒序)</li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>{<br>        stack&lt;<span class="hljs-type">char</span>&gt; st; <span class="hljs-comment">// ❗️类型可不是一成不变的 int </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : s){<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != c){<br>                st.<span class="hljs-built_in">push</span>(c);<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                st.<span class="hljs-built_in">pop</span>();<br>            }<br>        }<br>        <span class="hljs-comment">// ❗️下边写错了</span><br>        <span class="hljs-comment">/*for(int i = 0; i &lt; s.size(); i++){</span><br><span class="hljs-comment">            st.push(s[i]);</span><br><span class="hljs-comment">            if(st.top() == s[i+1]) st.pop();</span><br><span class="hljs-comment">            }</span><br><span class="hljs-comment">        */</span><br>      <br>        <span class="hljs-type">int</span> len = st.<span class="hljs-built_in">size</span>();<br>        string result ;<br>        <span class="hljs-keyword">while</span>(len--){<br>            result.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());<br>            st.<span class="hljs-built_in">pop</span>();<br>        }<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsXXSNkbbFnCYjGBWHvHhA9" deck= "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::5. 删除字符串中的所有相邻重复项.md" --> <p>#历史记录 ::<br>2022/08/24: 添加deck 数组</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录总结</title>
    <link href="/posts/38592/"/>
    <url>/posts/38592/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dataview">table  tags, date<br><br>from #数组 or #链表 or #哈希表 or #字符串 or #双指针 or #栈与队列 <br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsBcF8Pw6LGxPVA6UjqEWPx" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::总结.md" --> <p>#历史记录 ::<br>2022/08/24: 第一次修改</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 有效的括号</title>
    <link href="/posts/48343/"/>
    <url>/posts/48343/</url>
    
    <content type="html"><![CDATA[<h1 id="1-有效的括号"><a class="markdownIt-Anchor" href="#1-有效的括号"></a> 1 有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣题目链接</a></p><p>给定一个只包括 ‘(’，’)’，’{’，’}’，’[’，’]’&nbsp;的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>示例 1:</p><ul><li>输入: “()”</li><li>输出: true</li></ul><p>示例&nbsp;2:</p><ul><li>输入: “()[]{}”</li><li>输出: true</li></ul><p>示例&nbsp;3:</p><ul><li>输入: “(]”</li><li>输出: false</li></ul><p>示例&nbsp;4:</p><ul><li>输入: “([)]”</li><li>输出: false</li></ul><p>示例&nbsp;5:</p><ul><li>输入: “{[]}”</li><li>输出: true</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li><p>在创建一个栈用来放 右括号</p></li><li><p>创建的栈与原来的栈比较右括号</p></li><li><p>先分析不匹配的情况</p><ol><li>左括号多余导致不匹配</li><li>括号没有多余, 但括号类型不匹配</li><li>右括号多余导致不匹配</li></ol><ul><li><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号|500"></li></ul></li></ol><p>[vs](file:///Users/yibeikongqiu/Desktop/Documents/code/代码随想录/栈与队列/4. 有效的括号.cpp)</p><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsXQ4Otf7c3MKoVHKXI4l2D" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::4. 有效的括号.md" --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列总结</title>
    <link href="/posts/18350/"/>
    <url>/posts/18350/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dataview">table tags,date<br>from #栈与队列<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obszwi46x2QRmzvre0TvhxoC" --> <h1 id="1-队列与栈函数"><a class="markdownIt-Anchor" href="#1-队列与栈函数"></a> 1 队列与栈函数::</h1><p>按熟悉程度排序<br>栈也可以是这样的, que 换成 stack</p><p>定义队列: <code>queue&lt;int&gt; que;</code><br>que.front(): 返回队列的一个元素<br>que.back(): 返回队列的最后一个元素<br>que.push(x): 队头添加元素 ❓应该是队尾添加元素吧<br>que.pop(x): 队头元素弹出<br>que.size(): 返回队列的个数<br>que.empty(): 返回队列是否为空, 返回是 bool 值(true || false)</p><!-- basicblock-end --> #card<h1 id="2-注意"><a class="markdownIt-Anchor" href="#2-注意"></a> 2 注意</h1><p>每次要操作队列前要看是否为空, 不能操作空队列<br>eg: <code>if (!que.empty() &amp;&amp; value == que.front()) {</code></p><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="ObsAGsuQf82L3Fyt8Q9k2z7Z" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::栈与队列总结.md"--> <p>#历史记录 ::<br>2022/08/24: 添加deck 数组</p><!-- basicblock-end --> <p>／</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>算法</tag>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>callout blocks</title>
    <link href="/posts/7909/"/>
    <url>/posts/7909/</url>
    
    <content type="html"><![CDATA[<p>Callout呼出框使用指南</p><p>注：请将本文稿粘贴到Obsidian后阅读</p><p>在Obsidian的0.14版本更新中，官方更新了一个叫“Callout Blocks”的功能。善用这个功能可以让我们把内容编写地更美观，也能在需要的地方给我们提供足够显眼的强调。</p><p>Callout Blocks的基本语法如下：</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!类型] 标题</span><br><br><span class="hljs-quote">&gt; Hello world!</span><br><br><span class="hljs-quote">&gt; 正文</span><br><br><span class="hljs-quote">&gt; 正文<span class="hljs-strong">**依然支持Markdown语法和双链功能**</span></span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!INFO] 标题<br>Hello world!<br>正文<br>正文<strong>依然支持Markdown语法和双链功能</strong></p></blockquote><p>不难发现“Callout Blocks”本质上只是一个<code>&gt; 引用块</code>，并且由三部分组成——类型、标题和正文。</p><h1 id="1-callout-blocks的类型"><a class="markdownIt-Anchor" href="#1-callout-blocks的类型"></a> 1: Callout Blocks的类型</h1><p>Callout Blocks原生支持以下类型——</p><blockquote><p>[!note]</p></blockquote><blockquote><p>[!abstract]</p></blockquote><blockquote><p>[!info]</p></blockquote><blockquote><p>[!tip]</p></blockquote><blockquote><p>[!success]</p></blockquote><blockquote><p>[!question]</p></blockquote><blockquote><p>[!caution]</p></blockquote><blockquote><p>[!fail]</p></blockquote><blockquote><p>[!error]</p></blockquote><blockquote><p>[!bug]</p></blockquote><blockquote><p>[!example]-</p></blockquote><blockquote><p>[!quote]</p></blockquote><ul><li>question</li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-bullet">-</span> note<br><br><span class="hljs-bullet">-</span> abstract/summary/tldr<br><br><span class="hljs-bullet">-</span> info/todo<br><br><span class="hljs-bullet">-</span> tip/hint/important<br><br><span class="hljs-bullet">-</span> success/check/done<br><br><span class="hljs-bullet">-</span> question/help/faq<br><br><span class="hljs-bullet">-</span> warning/caution/attention<br><br><span class="hljs-bullet">-</span> failure/fail/missing<br><br><span class="hljs-bullet">-</span> danger/error<br><br><span class="hljs-bullet">-</span> bug<br><br><span class="hljs-bullet">-</span> example<br><br><span class="hljs-bullet">-</span> quote/cite<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!quote] 标题<br>正文<br>引言</p></blockquote><p>可以自定义新种类的Callout Blocks，但本文不做详细说明。</p><p>在创建Callout Block的时候，我们首先需要按照<code>&gt; 引用块</code>的Markdown格式，在文本编辑器中输入<code>&gt;</code>（<strong>注意别漏了空格</strong>），然后使用<code>[!类型]</code>的语法，在半角方括号中输入半角惊叹号，然后输入我们想要的类型，再空格，写标题。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Tip]</span><br><br><span class="hljs-quote">&gt; 你的大脑更擅长思考，而不是记忆。</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Tip]<br>你的大脑更擅长思考，而不是记忆。</p></blockquote><h1 id="2-callout-blocks的标题"><a class="markdownIt-Anchor" href="#2-callout-blocks的标题"></a> 2: Callout Blocks的标题</h1><p>在指定Callout Block的类型后，再敲击一个空格，然后输入该Callout Block的标题。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Tip] 阅读《搞定》的启示</span><br><br><span class="hljs-quote">&gt; 你的大脑更擅长思考，而不是记忆。</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Tip]- 阅读《搞定》的启示<br>你的大脑更擅长思考，而不是记忆。</p></blockquote><p>除此之外，在<code>&gt; [!类型]</code>和<code>内容</code>之间插入“+”和“-”可以将这个Callout Block变成折叠方块。其中——</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">// 中间无括号<br><span class="hljs-quote">&gt; [!类型]- 标题 %%代表该方块默认折叠</span><br><br><span class="hljs-quote">&gt; [!类型]+ 标题 %%代表该方块默认展开</span><br><br></code></pre></td></tr></tbody></table></figure><p>具体的效果还请各位读者到Obsidian当中自行实践。</p><h1 id="3-callout-blocks的正文"><a class="markdownIt-Anchor" href="#3-callout-blocks的正文"></a> 3: Callout Blocks的正文</h1><p>Callout Blocks内部的正文依然支持Markdown语法和双链功能，各位读者可以在方块内部肆意挥发自己的创意。</p><p>这里需要提醒的一点是，在<code>&gt; 引用块</code>的编辑状态下，如果你想要在下一个段落前额外添加一个空行，那么你很有可能会连续按下两次回车键，但这将退出<code>&gt; 引用块</code>的编辑——在引用块、有序列表、无序列表的空行上再次敲击回车会消除该行的格式。因此正确的做法是“Shift+回车”——这将继续向下创造新的空行，原有的空行将保持原有的格式。</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Tip] 阅读《搞定》的启示</span><br><br><span class="hljs-quote">&gt; 你的大脑更擅长思考，而不是记忆。</span><br><br><span class="hljs-quote">&gt; %% 这里按“Shift+回车”</span><br><br><span class="hljs-quote">&gt; 2分钟之内能搞定的事就不要拖延，马上去做！</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Tip] 阅读《搞定》的启示<br><strong>你的大脑更擅长思考，而不是记忆。</strong></p><p>2分钟之内能搞定的事就不要拖延，马上去做！</p></blockquote><h1 id="4-应用"><a class="markdownIt-Anchor" href="#4-应用"></a> 4: 应用</h1><p>Callout Blocks的基本用法就是这么简单，而关于工具的应用，则完全取决于你的思想、方法和创意。</p><p>你可以像这样做笔记的例题——</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Example]- 例1: 计算行列式 $$\begin{vmatrix}</span><br><br><span class="hljs-quote">&gt; a &amp; b \\</span><br><br><span class="hljs-quote">&gt; c &amp; d \\</span><br><br><span class="hljs-quote">&gt; \end{vmatrix}$$</span><br><br><span class="hljs-quote">&gt; </span><br><span class="hljs-quote"></span><br><span class="hljs-quote">&gt; <span class="hljs-strong">**解:**</span> $$</span><br><br><span class="hljs-quote">&gt; \begin{vmatrix}</span><br><br><span class="hljs-quote">&gt; a &amp; b \\</span><br><br><span class="hljs-quote">&gt; c &amp; d \\</span><br><br><span class="hljs-quote">&gt; \end{vmatrix}</span><br><br><span class="hljs-quote">&gt; =ad-bc</span><br><br><span class="hljs-quote">&gt; $$</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Example]- 例1: 计算行列式 $$\begin{vmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{vmatrix}$$</p><p><strong>解:</strong> $$<br>\begin{vmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{vmatrix}<br>=ad-bc</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p></blockquote><p>也可以做一个这样的总结概括——</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><br><span class="hljs-quote">&gt; [!Summary] 本文主要内容</span><br><br><span class="hljs-quote">&gt; 1. Callout Blocks的基本语法</span><br><br><span class="hljs-quote">&gt; 2. 方块类型</span><br><br><span class="hljs-quote">&gt; 3. 标题与折叠</span><br><br><span class="hljs-quote">&gt; 4. 正文</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>[!Summary] 本文主要内容</p><ol><li>Callout Blocks的基本语法</li><li>方块类型</li><li>标题与折叠</li><li>正文</li></ol></blockquote><p>总之，<strong>工具是次要的，思想和方法才是主要的</strong>。现在你掌握了工具的基本用法，接下来你要思考的是如何利用这些工具去更好的生活、学习和工作。</p><p>祝各位读者在有限的人生中，都能用简单的工具创造无限的可能。 作者：高级玩家_锌一-Strik0r <a href="https://www.bilibili.com/read/cv17972102?from=note">https://www.bilibili.com/read/cv17972102?from=note</a> 出处：bilibili</p><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 用队列实现栈</title>
    <link href="/posts/4522/"/>
    <url>/posts/4522/</url>
    
    <content type="html"><![CDATA[<h1 id="1-225用队列实现栈"><a class="markdownIt-Anchor" href="#1-225用队列实现栈"></a> 1 225.用队列实现栈</h1><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作-- 也就是&nbsp;push to back, peek/pop from front, size, 和&nbsp;is empty&nbsp;这些操作是合法的。</li><li>你所使用的语言也许不支持队列。&nbsp;你可以使用 list 或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>用一个队列来模拟栈</p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p><p>![[3. 用队列实现栈 2022-08-22 09.28.54.excalidraw]]</p><p>![[3. 用队列实现栈.cpp]]</p><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="Obsfym3vu4RzKRrR90p42ZoC" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::栈与队列::3. 用队列实现栈.md" --> <p>#历史记录 ::<br>2022/08/24: 第一次修改</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn Git---2</title>
    <link href="/posts/32208/"/>
    <url>/posts/32208/</url>
    
    <content type="html"><![CDATA[<h1 id="1-git-clone"><a class="markdownIt-Anchor" href="#1-git-clone"></a> 1 git clone</h1><p>直到现在, 教程都聚焦于<strong>本地</strong>仓库的操作（branch、merge、rebase 等等）。但我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 <code>git clone</code>。 从技术上来讲，<code>git clone</code> 命令在真实的环境下的作用是在<strong>本地</strong>创建一个远程仓库的拷贝（比如从 <a href="http://github.com">github.com</a>）。 但在我们的教程中使用这个命令会有一些不同 —— 它会在远程创建一个你本地仓库的副本。显然这和真实命令的意思刚好相反，但是它帮咱们把本地仓库和远程仓库关联到了一起，在教程中就凑合着用吧。</p><p>![[Learn G’i’t—2 2022-08-20 00.14.03.excalidraw]]</p><h1 id="2-git-remote"><a class="markdownIt-Anchor" href="#2-git-remote"></a> 2 git remote</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 删除原有的地址</span><br>git remote rm origin <br><span class="hljs-comment">// 重新添加</span><br>git remote add origin [url]<span class="hljs-comment">// url 要用 SSH 格式的</span><br><span class="hljs-comment">// 查看仓库</span><br>git remote -v<br><br><span class="hljs-comment">// eg</span><br>git remote add origin git@github.com:zeefan1555/obsidian-backup.git<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=8e7c76fb-e269-49fb-b27e-09f50b0da5f0">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 用栈实现队列</title>
    <link href="/posts/1958/"/>
    <url>/posts/1958/</url>
    
    <content type="html"><![CDATA[<blockquote><p>工作上一定没人这么搞，但是考察对栈、队列理解程度的好题</p></blockquote><h1 id="1-232用栈实现队列"><a class="markdownIt-Anchor" href="#1-232用栈实现队列"></a> 1 232.用栈实现队列</h1><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣题目链接</a></p><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p><p>示例:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 返回 false</span><br></code></pre></td></tr></tbody></table></figure><p>说明:</p><ul><li>你只能使用标准的<strong>栈</strong>操作 – 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>用两个栈来实现, 一个输入栈, 一个输出栈</p><ol><li>push 数据时直接放入输入栈</li><li>pop 数据时<ol><li>输出栈如果为空，就把输入栈中的数据<strong>全部导入</strong>进来,，再从输出栈弹出数据，</li><li>如果输出栈不为空，则直接从出栈弹出数据就可以了。为空转 1</li></ol></li><li>如何判断队列为空:  <strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong><br><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2"></li></ol><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsOpBnXkvGy59WE0PV5c1o1"  --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表总结</title>
    <link href="/posts/43768/"/>
    <url>/posts/43768/</url>
    
    <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObseaQ6eQ8nOP5So8eGpBAWU" --> <h1 id="1-移动链表指针的方式"><a class="markdownIt-Anchor" href="#1-移动链表指针的方式"></a> 1 移动链表指针的方式::</h1><ol><li>指针走完整个链表</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 获取长度</span><br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>判断两个指针相遇</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(index1 != index2){<br>index1 = index1-&gt;next;<br>index2 = index2-&gt;next;<br>} <br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=f87c6654-5015-4464-a6b1-47f484927688">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learn Git</title>
    <link href="/posts/43943/"/>
    <url>/posts/43943/</url>
    
    <content type="html"><![CDATA[<p>github git 流程</p><p>git init<br>git add <a href="http://README.md">README.md</a><br>git commit -m “first commit”<br>git branch -M main<br>git remote add origin <a href="https://github.com/zeefan1555/myblog.git">https://github.com/zeefan1555/myblog.git</a></p><p>git push -u origin main<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208192343602.png" alt=""></p><!-- basicblock-start oid="Obso0XVAmfT8aQUtIodnEGAE" --> <h1 id="1-git-add-git-commit"><a class="markdownIt-Anchor" href="#1-git-add-git-commit"></a> 1 git add;  git commit::</h1><!-- basicblock-end --><p>git add 文件 : 加入暂存区<br>git commit -m “提交信息”</p><h2 id="11-原理"><a class="markdownIt-Anchor" href="#11-原理"></a> 1.1 原理</h2><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p><p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。</p><p>Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因 —我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p><p>关于提交记录太深入的东西咱们就不再继续探讨了，现在你可以把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！</p><p>![[Learn Git 2022-08-18 21.36.48.excalidraw]]</p><!-- basicblock-start oid="ObsKeJLyaq1yOseGn8ZnhteZ" --> <h1 id="2-git-branch-git-checkout"><a class="markdownIt-Anchor" href="#2-git-branch-git-checkout"></a> 2 git branch, git checkout::</h1><!-- basicblock-end --><p>git checkout -b “branch name”: 创建分支 , 并切换</p><h2 id="21-原理"><a class="markdownIt-Anchor" href="#21-原理"></a> 2.1 原理</h2><p>Git 的分支也非常轻量。它们只是筒单地指向某个提交纪录仅此而已。所以许多 Git 爱好者传颂：<br><strong>早建分支！多用分支！</strong><br>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p><pre><code class="hljs">在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。</code></pre><p>![[Learn Git 2022-08-18 21.39.58.excalidraw]]</p><!-- basicblock-start oid="ObsVAkLZbaOR71Cub5FUYro8" --> <h1 id="3-git-merge"><a class="markdownIt-Anchor" href="#3-git-merge"></a> 3 git merge::</h1><!-- basicblock-end --><p>git merge xxx: 就把 xxx分支 合并到 当前分支, 即使一个分支包含所有我们修改的内容<br>将 bugFix 合并到 main 中<br>git checkout main<br>git merge bugFix</p><ul><li>相同分支下:<ul><li>当前分支在子分支, git merge 父分支, 子分支多一个指向上边就行</li><li>当前分支在父分支, git merge 子分支 , 两者就合并</li></ul></li></ul><h2 id="31-分支与合并"><a class="markdownIt-Anchor" href="#31-分支与合并"></a> 3.1 分支与合并</h2><p>太好了! 我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。<br>咱们先来看一下第一种方法 —— <code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”<br>通过图示更容易理解一些，咱们到下一页看一下。</p><p>![[Learn Git 2022-08-18 21.57.05.excalidraw]]</p><h1 id="4-git-rebase"><a class="markdownIt-Anchor" href="#4-git-rebase"></a> 4 git rebase</h1><p>Rebase 实际上就是取出一系列的提交记录，"<strong>复制</strong>”它们搞出一个副本，然后在另外一个地方,逐个的放下去。原先本来的会隐藏掉</p><ul><li><strong>不同分支下</strong>: git rebase 谁 , 就移到 “谁” 的底部:<ul><li>eg : 当前分支为 bugFix, 运行git rebase main, 会将 bugFix 放到 main 底部</li></ul></li><li><strong>相同分支下</strong>: 当前分支在父分支, git rebase 子分支 , 两者就合并<ul><li>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git 只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</li></ul></li></ul><h2 id="41-原理"><a class="markdownIt-Anchor" href="#41-原理"></a> 4.1 原理</h2><p>第二种合并分支的方法是 <code>git rebase</code><br>Rebase 实际上就是取出一系列的提交记录，"复制”它们，然后在另外一个地方,逐个的放下去。<br>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交<br>历史将会变得异常清晰。<br>![[Learn Git 2022-08-18 21.07.57.excalidraw]]</p><ul><li>$ 高级篇</li></ul><!-- basicblock-start oid="ObsKcDpYuxBIirA1BDUYdxam" --> <h1 id="5-head"><a class="markdownIt-Anchor" href="#5-head"></a> 5 HEAD::</h1><!-- basicblock-end --><p>通过切换当前对象, 可以改变 HEAD 指针: 用 git checkout xxx</p><p>git checkout HEAD~1 : 单独操作 HEAD 指针往上一位</p><h2 id="51-定义"><a class="markdownIt-Anchor" href="#51-定义"></a> 5.1 定义</h2><p>我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。<br>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。<br>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p><h2 id="52-分离的-head"><a class="markdownIt-Anchor" href="#52-分离的-head"></a> 5.2 分离的 HEAD</h2><p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：</p><p>HEAD -&gt; main -&gt; C1</p><p>HEAD 指向 main， main 指向 C1</p><p>head 指针会默认在当前激活的分支上</p><p>原理<br>![[Learn Git 2022-08-18 22.36.50.excalidraw]]</p><h1 id="6-相对引用"><a class="markdownIt-Anchor" href="#6-相对引用"></a> 6 相对引用</h1><p>![[Learn Git 2022-08-18 22.52.32.excalidraw]]</p><h1 id="7-~操作符"><a class="markdownIt-Anchor" href="#7-~操作符"></a> 7 “~”操作符::</h1><p>单独移动 HEAD 指针: git checkout HEAD~4  (向上移动 4 个节点)</p><p>强制改变分支位置:<br>1. 直接指定分支位置: git branch -f main C6 (可不提前激活 main 位置)<br>1. 并不移动 HEAD 指针<br>2.指定移动几个位置git branch -f main HEAD~3, 前提是先在激活 main 位置(即 HEAD 指针与 main 先结合起来)</p><p><strong>原理</strong><br>![[Learn Git 2022-08-18 23.03.06.excalidraw]]</p><h1 id="8-撤销变更-git-reset-git-revert"><a class="markdownIt-Anchor" href="#8-撤销变更-git-reset-git-revert"></a> 8 撤销变更 :: git reset 🌵 git revert</h1><p>本地版本撤销: git  reset  xxx: 直接回退到xxx 的父节点<br>远程版本撤销: git revert  xxx : 再创建一个新的提交记录, 而这个提交记录是与 xxx 的父节点一样的</p><p>原理<br>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。<br>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。接下来咱们逐个进行讲解。<br>![[Learn Git—1 2022-08-21 23.50.51.excalidraw]]</p><h1 id="9-git-cherry-pick"><a class="markdownIt-Anchor" href="#9-git-cherry-pick"></a> 9 Git Cherry-pick</h1><p>将一些提交复制到当前所在的位置（<code>HEAD</code>）: <code>git cherry-pick &lt;提交号&gt;...</code><br>原理<br>![[Learn Git—1 2022-08-28 20.39.47.excalidraw]]</p><h1 id="10-交互式的-rebase"><a class="markdownIt-Anchor" href="#10-交互式的-rebase"></a> 10 交互式的 rebase</h1><p>将一些提交复制到当前所在的位置:<br>这个位置可用头指针来表示:<br>1. HEAD~4(当前位置往上数 4 位)<br>2. Cx: 指定的位置</p><p>git rebase -i HEAD~x: 可以用当前指针的前几位来复制<br>git rebase -i Cx : 也可以指定到某次提交记录</p><p>原理<br>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。<br>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了<br>咱们具体来看一下……<br>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code><br>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。<br>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。<br>当 rebase UI界面打开时, 你能做3件事:<br>-   调整提交记录的顺序（通过鼠标拖放来完成）<br>-   删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）<br>-   合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。<br>- ![[Learn Git—1 2022-08-28 20.44.54.excalidraw]]</p><h1 id="11-本地栈式提交"><a class="markdownIt-Anchor" href="#11-本地栈式提交"></a> 11 本地栈式提交</h1><p>将两个提交记录复制合并一个新记录</p><ol><li>git rebase -i 截止位置  (在挑选不要的, 和调整顺序)</li><li>git rebse 当前位置 合并位置(" * "号会自动跑到合并位置处)</li></ol><p>题目<br>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p><p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p><p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……<br>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p><ul><li><code>git rebase -i</code></li><li><code>git cherry-pick</code></li></ul><p>来达到目的。<br>由于我们刚刚闯过类似的关卡，所以要不要再尝试一次就看你自己了。但是如果你想试一把的话，确保 <code>main</code> 分支能得到 <code>bugFix</code> 分支上的相关提交。<br>![[Learn Git—1 2022-08-28 21.07.11.excalidraw|600]]</p><h1 id="12-提交的技巧-1"><a class="markdownIt-Anchor" href="#12-提交的技巧-1"></a> 12 提交的技巧 #1</h1><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p><p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p>我们可以通过下面的方法来克服困难：</p><ul><li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li><li>然后用 <code>git commit --amend</code> 来进行一些小修改</li><li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li><li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li></ul><p>当然完成这个任务的方法不止上面提到的一种（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。 最后有必要说明一下目标状态中的那几个<code>'</code> —— 我们把这个提交移动了两次，每移动一次会产生一个 <code>'</code>；而 C2 上多出来的那个是我们在使用了 amend 参数提交时产生的，所以最终结果就是这样了。</p><p>也就是说，我在对比结果的时候只会对比提交树的结构，对于 <code>'</code> 的数量上的不同，并不纳入对比范围内。只要你的 <code>main</code> 分支结构与目标结构相同，我就算你通过。<br>![[Learn Git—1 2022-08-28 21.35.35.excalidraw]]</p><h1 id="13-提交的技巧-2"><a class="markdownIt-Anchor" href="#13-提交的技巧-2"></a> 13 提交的技巧 #2</h1><p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p><p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 <code>git cherry-pick</code> 是怎么做的吧</p><p><strong>要在心里牢记 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。</strong></p><p>![[Learn Git—1 2022-08-28 21.50.49.excalidraw]]</p><h1 id="14-git-tags"><a class="markdownIt-Anchor" href="#14-git-tags"></a> 14 Git Tags</h1><p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p><p>你可能会问了：有没有什么可以_永远_指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p><p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p><p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p><p>咱们来看看标签到底是什么样<br>![[Learn Git—1 2022-08-28 22.12.15.excalidraw]]</p><h1 id="15-git-describe"><a class="markdownIt-Anchor" href="#15-git-describe"></a> 15 Git Describe</h1><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p><p><code>git describe</code> 语法是：</p><p><code>git describe &lt;ref&gt;</code></p><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><p><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><p>![[Learn Git—1 2022-08-28 22.20.04.excalidraw]]</p><h1 id="16-多分支-rebase"><a class="markdownIt-Anchor" href="#16-多分支-rebase"></a> 16 多分支 rebase</h1><p>哥们儿，我们准备了很多分支！咱们把这些分支 rebase 到 main 上吧。</p><p>但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 <code>C6'</code> 在 <code>C7'</code> 上面， <code>C5'</code> 在 <code>C6'</code> 上面，依此类推。</p><p>即使你搞砸了也没关系，用 <code>reset</code> 命令就可以重新开始了。记得看看我们提供的答案，看你能否使用更少的命令来完成任务！<br>![[Learn Git—1 2022-08-28 22.24.22.excalidraw]]</p><h1 id="17-参考资料"><a class="markdownIt-Anchor" href="#17-参考资料"></a> 17 参考资料</h1><p><a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 栈与队列理论基础</title>
    <link href="/posts/64870/"/>
    <url>/posts/64870/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsWq2mgFS7FgFOnIMQTTp3Y" --> <p>#历史记录::<br>2022/8/24: 第一次创建</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>栈与队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/posts/23871/"/>
    <url>/posts/23871/</url>
    
    <content type="html"><![CDATA[<h1 id="1-通过快慢指针给新数组赋值快指针指向元素-慢指针指向下标"><a class="markdownIt-Anchor" href="#1-通过快慢指针给新数组赋值快指针指向元素-慢指针指向下标"></a> 1 <strong>通过快慢指针给新数组赋值</strong>(快指针指向元素, 慢指针指向下标)::</h1><ol><li>快指针找新数组的元素 (查找 n 次, 即 O(n)的时间复杂度)</li><li>快指针给<strong>慢指针对应的新数组的下标</strong>赋值<ol><li>常规赋值: [[4. 有序数组的平方]] [[3. 移除元素]]</li><li>需要给新数组扩容的, 在赋值: [[3. 替换空格]]</li></ol></li></ol><!-- basicblock-end --><h1 id="2-通过双指针构建滑动窗口"><a class="markdownIt-Anchor" href="#2-通过双指针构建滑动窗口"></a> 2 <strong>通过双指针构建滑动窗口</strong></h1><pre><code class="hljs">- .  起始指针 i , 终止指针 j, 通过操作 i 与 j 之间值来达到所需目的. eg: 求窗口之间的元素和 [[5. 长度最小的子数组]]</code></pre><h1 id="3-反转元素"><a class="markdownIt-Anchor" href="#3-反转元素"></a> 3 <strong>反转元素</strong></h1><pre><code class="hljs">1. 常规反转 reverse 原理: [[1. 反转字符串]]2. 多一些复杂规则的翻转 [[4. 翻转字符串里的单词]]3. 两个指针挨着的翻转链表[[4. 翻转链表]]</code></pre><h1 id="4-其他"><a class="markdownIt-Anchor" href="#4-其他"></a> 4 <strong>其他</strong></h1><pre><code class="hljs">1. [[6.删除链表的倒数第N个节点]]: 通过两指针移动的步数不同, 来达到, slow 指针想到移动到的位置, 来实现删除链表元素2. [[7. 链表相交]]: 两个数组用两个指针来判断是不是有元素相同3. </code></pre><p>题目目录</p><ol><li>[[3. 移除元素]]</li><li>[[1. 反转字符串]]</li><li>[[3. 替换空格]]</li><li>[[4. 翻转字符串里的单词]]</li><li>[[4. 反转链表]]</li><li>[[6.删除链表的倒数第N个节点]]</li><li>[[7. 链表相交]]</li><li>[[8. 环形链表II]]: 通过两个指针的移动来判断是否达到题意, 需要一定的数学推导</li><li>[[8. 三数之和]]:</li><li>[[9. 四数之和]]: 不会</li></ol><p>除了链表一些题目一定要使用双指针，其他题目都是使用双指针来提高效率，一般是将O(n^2)的时间复杂度，降为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>双指针法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 重复的子字符串</title>
    <link href="/posts/63102/"/>
    <url>/posts/63102/</url>
    
    <content type="html"><![CDATA[<h1 id="1-459重复的子字符串"><a class="markdownIt-Anchor" href="#1-459重复的子字符串"></a> 1 459.重复的子字符串</h1><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">力扣题目链接</a><br>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>示例 2:<br>输入: “aba”<br>输出: False</p><p>示例 3:<br>输入: “abcabcabcabc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-kmp-算法"><a class="markdownIt-Anchor" href="#21-kmp-算法"></a> 2.1 kmp 算法</h2><ol><li><p>找到最小重复子串长度</p><ol><li>next[len - 1] != 0</li><li>len - next[len - 1]</li></ol></li><li><p>用总长度 / 最小重复子串的长度, 如果能整除, 即 == 0 就说明该字符串有重复的子字符串</p></li></ol><p>解:</p><ol><li>找到最小重复子串长度</li></ol><p>在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，这里那字符串s：abababab 来举例，ab就是最小重复单位，如图所示：<br>![[7. 重复的子字符串 2022-08-17 11.06.50.excalidraw]]<br>[[KMP 算法理论篇 2022-08-16 15.46.14.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-kmp"><a class="markdownIt-Anchor" href="#31-kmp"></a> 3.1 kmp</h2><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span> ( j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]){<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span>(s[i] == s[j]){<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> next [len];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        std::cout&lt;&lt;next;<br>        <span class="hljs-type">int</span> Df = len - next[len - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % Df == <span class="hljs-number">0</span>){ <span class="hljs-comment">// ❗️是取余 不是 除</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=61a275a8-7cd1-44d9-9a0c-bf87fa7206e4">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 实现strStr()</title>
    <link href="/posts/59030/"/>
    <url>/posts/59030/</url>
    
    <content type="html"><![CDATA[<h1 id="1-实现-strstr"><a class="markdownIt-Anchor" href="#1-实现-strstr"></a> 1 实现 strStr()</h1><p><a href="https://leetcode.cn/problems/implement-strstr/">力扣题目链接</a></p><p>实现&nbsp;strStr()&nbsp;函数。</p><p>给定一个&nbsp;haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回&nbsp; -1。</p><p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p><p>示例 2: 输入: haystack = “aaaaa”, needle = “bba” 输出: -1</p><p>说明: 当&nbsp;needle&nbsp;是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当&nbsp;needle&nbsp;是空字符串时我们应当返回 0 。这与C语言的&nbsp;strstr()&nbsp;以及 Java的&nbsp;indexOf()&nbsp;定义相符。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>先求 next 数组: [[KMP 算法理论篇]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>不懂 主函数里的操作</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>{<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]){<br>                j = next[j - <span class="hljs-number">1</span>];<br>            }<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]){<br>                j++;<br>            }<br>            next[i] = j;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>(), h = haystack.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>        <span class="hljs-type">int</span> next[n];<br>        <span class="hljs-built_in">getNext</span>(next, needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❓下边跟 next 数组的逻辑一样</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h; i++){<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]){<br>                j = next[j<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 找前一位的 next 数值</span><br>            }<br>            <span class="hljs-keyword">if</span>(haystack[i] == needle[j]){<br>            j++;<br>        }<br>        <span class="hljs-keyword">if</span>(j == n){ <span class="hljs-comment">// ❓</span><br>            <span class="hljs-keyword">return</span>(i - n + <span class="hljs-number">1</span>);<br>        }<br>      }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=c3492942-c29c-459c-8a33-e13b9179eaea">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP 算法理论篇</title>
    <link href="/posts/27202/"/>
    <url>/posts/27202/</url>
    
    <content type="html"><![CDATA[<p>题目: 要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</p><p>暴力匹配: for 循环发现不匹配, 则从头匹配.<br>暴力的解法显而易见是O(n × m)<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208161707423.gif" alt="|600"> ^zyqb9e</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>{<br>        <span class="hljs-type">int</span> n = haystack.<span class="hljs-built_in">size</span>(), m = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + m &lt;= n; i++) {<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {<br>                <span class="hljs-keyword">if</span> (haystack[i + j] != needle[j]) {<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>            }<br>            <span class="hljs-keyword">if</span> (flag) {<br>                <span class="hljs-keyword">return</span> i;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>KMP: 使用前缀表, 就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1"></p><p>什么是前缀和后缀<br>![[KMP 算法理论篇 2022-08-16 15.46.14.excalidraw]]</p><p><strong>为什么要对 next 数组进行一些变化</strong> ::<br>![[KMP 算法理论篇 2022-08-17 17.45.43.excalidraw]]</p><p>看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：<br><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2"><br>找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。<br>为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。</p><blockquote><p>为什么前一位就是就是最长相等前后缀的数值? #疑问</p></blockquote><p>所以要看前一位的 前缀表的数值。<br>前一个字符的前缀表的数值是2， 所有把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。<br>最后就在文本串中找到了和模式串匹配的子串了。</p><h1 id="1-时间复杂度分析"><a class="markdownIt-Anchor" href="#1-时间复杂度分析"></a> 1 时间复杂度分析</h1><p>其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。暴力的解法显而易见是O(n × m)，所以<strong>KMP在字符串匹配中极大的提高的搜索的效率。</strong><br>为了和力扣题目28.实现strStr保持一致，方便大家理解，以下文章统称haystack为文本串, needle为模式串。</p><p>都知道使用KMP算法，一定要构造next数组</p><h1 id="2-构造-next-数组"><a class="markdownIt-Anchor" href="#2-构造-next-数组"></a> 2 构造 next 数组</h1><p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p><ol><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况<br>循环不变量: 遇见冲突看前一位的 next 数值, 然后回退到下标为 next 数值的位置继续比较<br>![[KMP 算法理论篇 2022-08-16 17.16.15.excalidraw]]<br><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif" alt="KMP精讲3"></li></ol><blockquote><p>注意next数组是新前缀表（旧前缀表统一减一了）。</p></blockquote><p><strong>背住过程</strong></p><ul><li><p>起始时，next[0]=0，j从0位置开始，i从1位置开始</p></li><li><p>如果s[i] != s[j] ：将j指针指向前一位置的 next 数组所对应的值，即j = next[j - 1]<br>这个过程是循环进行，直到s[i] == s[j] 或者 j=0<br>如果j == 0, s[i] 和 s[j] 还是不相等，则next[i] =0，i往后移动, j 不变</p></li><li><p>如果s[i] == s[j]：next[i] =j+1;  i和j同时后移（这个过程一直同样循环进行）</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>{<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) { <span class="hljs-comment">// 💡j要保证大于0，因为下面有取j-1作为数组下标的操作</span><br>            j = next[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 注意这里，是要找前一位的对应的回退位置了</span><br>        }<br>        <span class="hljs-keyword">if</span> (s[i] == s[j]) {<br>            j++;<br>        }<br>        next[i] = j;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>总结<br>KMP 算法的应用范围要比 Manacher 算法广，Manacher 算法只能应用于「回文串」问题，相对比较局限，而「子串匹配」问题还是十分常见的。</p><p>背过这样的算法的意义在于：相当于大脑里有了一个时间复杂度为 O(n)的 api 可以使用，这个 api 传入一个原串和匹配串，返回匹配串在原串的位置。</p><p>因此，三叶十分建议大家在「理解 KMP」的基础上，对模板进行背过 ~</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=a778a134-dfdf-4f33-b8c0-164b33e56de4">ob</a><br><a href="https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=f2340d96e99780a96b50d8096ffaaf1a">帮你把KMP算法学个通透！（理论篇）_哔哩哔哩_bilibili</a><br><a href="https://leetcode.cn/problems/implement-strstr/solution/shua-chuan-lc-shuang-bai-po-su-jie-fa-km-tb86/">【宫水三叶】简单题学 KMP 算法 - 实现 strStr() - 力扣（LeetCode）</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KMP算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 左旋转字符串</title>
    <link href="/posts/528/"/>
    <url>/posts/528/</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目剑指offer58-ii左旋转字符串"><a class="markdownIt-Anchor" href="#1-题目剑指offer58-ii左旋转字符串"></a> 1 题目：剑指Offer58-II.左旋转字符串</h1><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣题目链接</a></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。</p><p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出:&nbsp;“cdefgab”</p><p>示例 2：<br>输入: s = “lrloseumgh”, k = 6<br>输出:&nbsp;“umghlrlose”</p><p>限制：<br>1 &lt;= k &lt; s.length &lt;= 10000</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>[[4. 翻转字符串里的单词]]使用整体反转+局部反转就可以实现，反转单词顺序的目的。</p><p>这道题目也非常类似，依然可以通过局部反转+整体反转 达到左旋转的目的。</p><p>具体步骤为：</p><ol><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><p>最后就可以得到左旋n的目的，而不用定义新的字符串，完全在本串上操作。</p><p>![[5. 左旋转字符串 2022-08-18 15.02.36.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end ; i &lt; j; i++, j--){<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]); <span class="hljs-comment">// ❗️ swap 后边记得有括号</span><br>        }<br>    }<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, n, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--){<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br><br><br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-comment">// reverse(s, s.begin(), s.begin() + n); ❗️这个是自带的库函数 与自己定义的冲突, 因为传入的参数是 int 型</span><br>        <span class="hljs-comment">// reverse(s, s.begin() + n, s.end());</span><br>        <span class="hljs-comment">// reverse(s, s.begin(), s.end());</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, n, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=4e9e41d7-1d6c-4069-b3d1-42fb0059d68d">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4. 翻转字符串里的单词</title>
    <link href="/posts/18478/"/>
    <url>/posts/18478/</url>
    
    <content type="html"><![CDATA[<h1 id="1-151翻转字符串里的单词"><a class="markdownIt-Anchor" href="#1-151翻转字符串里的单词"></a> 1 151.翻转字符串里的单词</h1><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出:&nbsp;“blue is sky the”</p><p>示例 2：<br>输入: " &nbsp;hello world! &nbsp;"<br>输出:&nbsp;“world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good &nbsp; example”<br>输出:&nbsp;“example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>移除多余空格  :<ol><li>移除所有的空格, 思想参考:[[3. 移除元素]]</li><li>除了第一个元素外, 在每个单词前边再加上一个空格</li></ol></li><li>将整个字符串反转</li><li>将每个单词反转</li></ol><p>举个例子，源字符串为："the sky is blue "</p><ol><li>移除多余空格 : “the sky is blue”</li><li>字符串整体反转：“eulb si yks eht”</li><li>单词反转：“blue is sky the”</li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷 : 未通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span> <span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--){<br>            <span class="hljs-type">char</span> temp = s[i];<span class="hljs-comment">// 这里用 swap 显示不行</span><br>            s[i] = s[j];<br>            s[j] = temp;<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEtraSpace</span><span class="hljs-params">(string&amp; s)</span></span>{<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(; fast &lt; s.<span class="hljs-built_in">size</span>(); fast++){<br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>                <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>){<span class="hljs-comment">// 2️⃣除了第一个单词外, 在单词前边加空格</span><br>                    s[slow] = <span class="hljs-string">' '</span>; <br>                    slow++;<br>                }<br>                <span class="hljs-keyword">while</span>(s[fast] != <span class="hljs-string">' '</span> &amp;&amp; fast &lt; s.<span class="hljs-built_in">size</span>()){ <span class="hljs-comment">// 1️⃣ 添加单词</span><br>                    s[slow] = s[fast];<br>                    fast++;<br>                    slow++;<br>                }<br>            }<br>        }<br>        s.<span class="hljs-built_in">resize</span>(slow - <span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">removeEtraSpace</span>(s);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">' '</span>){ <span class="hljs-comment">// 找到单词后的空格</span><br>            <span class="hljs-built_in">reverse</span>(s, start, i);<br>            start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 下个单词的首元素下标</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>     <br>};<br><br></code></pre></td></tr></tbody></table></figure><p>一刷: 编译未通过<br>#疑问</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{ <span class="hljs-comment">// ❗️返回值是 void 即可, 因为是引用&amp;s, 所以 s 被修改了</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; i++, j--){<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remeveExtraSpaces</span><span class="hljs-params">(string&amp; s)</span></span>{<br>        <span class="hljs-type">int</span> fast; <br>        <span class="hljs-type">int</span> slow;<br>        <span class="hljs-keyword">for</span>(fast = <span class="hljs-number">0</span>; fast &lt; s.<span class="hljs-built_in">size</span>(); fast++){<br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">if</span>(slow != <span class="hljs-number">0</span>){<br>                    s[slow] = <span class="hljs-string">' '</span>;<br>                    slow++;<br>                }<br>                <span class="hljs-keyword">while</span>(fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast]!=<span class="hljs-string">' '</span>){<br>                    s[slow] = s[fast];<br>                    slow++;<br>                    fast++;<br>                }<br>            }<br>        }<br>    }<br>    <br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">remeveExtraSpaces</span>(s);<br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">' '</span> || i == s.<span class="hljs-built_in">size</span>()){<br>                <span class="hljs-built_in">reverse</span>(s, start, i<span class="hljs-number">-1</span>);<br>                start = i+<span class="hljs-number">1</span>;<br><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>carl 代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>{ <span class="hljs-comment">//翻转，区间写法：左闭又闭 []</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>{<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>; fast &lt; s.<span class="hljs-built_in">size</span>(); fast++) { <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (s[fast] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>                <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) {<br>                    s[slow] = <span class="hljs-string">' '</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>                    slow++;<br>                }<br>                <span class="hljs-keyword">while</span> (fast &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fast] != <span class="hljs-string">' '</span>) { <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                    s[slow] = s[fast];<br>                    slow++;<br>                    fast++;<br>                }<br>            }<br>        }<br>        s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>    }<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-built_in">removeExtraSpaces</span>(s); <span class="hljs-comment">// 去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">// removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i) {<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">' '</span>) { <span class="hljs-comment">// 到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 翻转，注意是左闭右闭 []的翻转。</span><br>                start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新下一个单词的开始下标start</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=28a95bf0-8bc7-43c5-866d-a1721df3d4f0">ob</a><br>[[库函数]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 替换空格</title>
    <link href="/posts/27162/"/>
    <url>/posts/27162/</url>
    
    <content type="html"><![CDATA[<h1 id="1-剑指offer05替换空格"><a class="markdownIt-Anchor" href="#1-剑指offer05替换空格"></a> 1 剑指offer05.替换空格</h1><p>请实现一个函数，把字符串 s 中的每个空格替换成"%20"。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：“We%20are%20happy.”</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>![[数组扩容]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>三刷: [[05. 替换空格#2 双指针]]</p><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> a : s){<br>            <span class="hljs-keyword">if</span>(a == <span class="hljs-string">' '</span>) count++;<br>        }<br>        <span class="hljs-type">int</span> fast = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * count);<br>        <span class="hljs-type">int</span> slow = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <br><br>        <span class="hljs-keyword">for</span>(;fast &gt;= <span class="hljs-number">0</span>; fast--){ <span class="hljs-comment">// ❗️应该 &gt;= 0 不是 &gt; 0, 因为 0 元素ize()</span><br>            <span class="hljs-keyword">if</span>(s[fast] != <span class="hljs-string">' '</span>){<br>                s[slow] = s[fast];<br>                slow--; <span class="hljs-comment">// 💡也可以在 内部控制 slow 的移动而不在 for 循环的条件中</span><br>            }<br>            <span class="hljs-keyword">else</span>{<br>                s[slow] = <span class="hljs-string">'0'</span>;<br>                s[slow - <span class="hljs-number">1</span>] = <span class="hljs-string">'2'</span>;<br>                s[slow - <span class="hljs-number">2</span>] = <span class="hljs-string">'%'</span>;<br>                slow -= <span class="hljs-number">3</span>; <br><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>{<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">' '</span>) {<br>                count++;<br>            }<br>        }<br>        <span class="hljs-type">int</span> sOldSize = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// ❗️要有减 1 操作啊</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">2</span> * count);<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[库函数]]">[1]</span></a></sup></span><br>        <span class="hljs-type">int</span> sNewSize = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = sOldSize, j = sNewSize; i &gt;= <span class="hljs-number">0</span>; i--, j--){ <span class="hljs-comment">// ❗️是 &gt;= 不是&gt; 因为第一个元素也要赋值</span><br>            <span class="hljs-keyword">if</span>(s[i] != <span class="hljs-string">' '</span>) s[j] = s[i];<br>            <span class="hljs-keyword">else</span>{<br>                s[j] = <span class="hljs-string">'0'</span>; <span class="hljs-comment">// ❗️不是数组 0, 是'0', 下边同理</span><br>                s[j<span class="hljs-number">-1</span>] = <span class="hljs-string">'2'</span>;<br>                s[j<span class="hljs-number">-2</span>] = <span class="hljs-string">'%'</span>;<br>                j -= <span class="hljs-number">2</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs3rIVuyZtglXOFzefr2UXI" --> <p>📝3. 替换空格::<br>2022/11/3 : 第一次创建</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[库函数]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 反转字符串II</title>
    <link href="/posts/62802/"/>
    <url>/posts/62802/</url>
    
    <content type="html"><![CDATA[<h1 id="1-反转字符串ii"><a class="markdownIt-Anchor" href="#1-反转字符串ii"></a> 1 反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣题目链接</a></p><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>平时 for 循环中我们习惯写for(int i = 0; i &lt; nums.size(); i++) , 此时的 i 是一格格的移动, 但是此题可以让 i 每次移动 2k 个格子,然后判断是否需要有反转的区间。for(int i = 0; i &lt; nums.size(); <strong>i += 2k</strong>) ^6aghnj</p><p>因为要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。</p><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[for 循环]]">[1]</span></a></sup><br>![[2. 反转字符串II 2022-08-15 23.08.30.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) {<br>            <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) {<br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + i + k );<span class="hljs-comment">// <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[有关字符要想到的操作]]">[2]</span></a></sup></span><br>            } <span class="hljs-keyword">else</span> {<br>                <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">end</span>());<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> s;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="31-错误代码"><a class="markdownIt-Anchor" href="#31-错误代码"></a> 3.1 错误代码</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; s.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>; i++, j--) {<br>                <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        }<br>    }<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i += <span class="hljs-number">2</span>*k){<br>            <span class="hljs-keyword">if</span>(i + k &lt;= s.<span class="hljs-built_in">length</span>()){<br>                <span class="hljs-built_in">reverse</span>(s, s[i], s[i+k]);<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                <span class="hljs-built_in">reverse</span>(s,s[i], s.<span class="hljs-built_in">end</span>());<br>            }<br>        }<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=da9f17e9-4db1-4c4f-84f7-794f88491943">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[for 循环]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[有关字符要想到的操作]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>库函数</title>
    <link href="/posts/49880/"/>
    <url>/posts/49880/</url>
    
    <content type="html"><![CDATA[<h1 id="1-reverse-反转字符串"><a class="markdownIt-Anchor" href="#1-reverse-反转字符串"></a> 1 reverse 反转字符串</h1><p>原理</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>           <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>       }<br>   }<br></code></pre></td></tr></tbody></table></figure><h1 id="2-swapa-b-交换元素"><a class="markdownIt-Anchor" href="#2-swapa-b-交换元素"></a> 2 swap(a, b) 交换元素</h1><p>swap可以有两种实现。</p><p>一种就是常见的交换数值：</p><figure class="highlight abnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int tmp <span class="hljs-operator">=</span> s[i]<span class="hljs-comment">;</span><br>s[i] <span class="hljs-operator">=</span> s[j]<span class="hljs-comment">;</span><br>s[j] <span class="hljs-operator">=</span> tmp<span class="hljs-comment">;</span><br><br></code></pre></td></tr></tbody></table></figure><p>一种就是通过位运算：</p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">s<span class="hljs-comment">[i]</span> ^= s<span class="hljs-comment">[j]</span>;<br>s<span class="hljs-comment">[j]</span> ^= s<span class="hljs-comment">[i]</span>;<br>s<span class="hljs-comment">[i]</span> ^= s<span class="hljs-comment">[j]</span>;<br></code></pre></td></tr></tbody></table></figure><h1 id="3-resize-扩充数组-字符串的大小"><a class="markdownIt-Anchor" href="#3-resize-扩充数组-字符串的大小"></a> 3 resize, 扩充数组, 字符串的大小</h1><p>s.resize(s.size() +2) 扩充两个单位</p><h1 id="4-split-分隔单词"><a class="markdownIt-Anchor" href="#4-split-分隔单词"></a> 4 split 分隔单词</h1><h1 id="5-erase-移除元素"><a class="markdownIt-Anchor" href="#5-erase-移除元素"></a> 5 erase 移除元素</h1><p>时间复杂度 O(n)</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=1b4c552e-2bb7-4beb-899e-15ea5b950631">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 反转字符串</title>
    <link href="/posts/16762/"/>
    <url>/posts/16762/</url>
    
    <content type="html"><![CDATA[<h1 id="1-344反转字符串"><a class="markdownIt-Anchor" href="#1-344反转字符串"></a> 1 344.反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,“e”,“l”,“l”,“o”]<br>输出：[“o”,“l”,“l”,“e”,“h”]</p><p>示例 2：<br>输入：[“H”,“a”,“n”,“n”,“a”,“h”]<br>输出：[“h”,“a”,“n”,“n”,“a”,“H”]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><ol><li>可以使用 reverse [[库函数]]</li></ol><blockquote><p>如果实现的主要功能的是库函数则不要使用</p></blockquote><ol start="2"><li>双指针法<br>fast从字符串前面，slow 从字符串后面，两个指针同时向中间移动，并交换元素。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gp0fvi91pfg30de0akwnq.gif" alt="344.反转字符串"></li></ol><p>![[1. 反转字符串 2022-08-15 22.52.30.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> slow = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[有关字符要想到的操作#^ouvyxy]]">[2]</span></a></sup></span><br>        <span class="hljs-keyword">for</span>(; fast &lt; slow; fast++, slow--){<br>            <span class="hljs-built_in">swap</span>(s[fast], s[slow]);<span class="hljs-comment">//❗️ s[fast] = s[slow];</span><br>            <br>        }<br>        <span class="hljs-comment">// return s;, 不用 return, 因为是引用的, 直接就把 s 给修改了</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--){ <span class="hljs-comment">// 终止条件也可以是 i &lt; j  <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[库函数]]">[1]</span></a></sup></span><br>            <span class="hljs-type">char</span> temp = s[i]; <span class="hljs-comment">// = swap(s[i] , s[j])</span><br>            s[i] = s[j];<br>            s[j] = temp;<span class="hljs-comment">// ❗️不是 s[j]= s[i]</span><br>        }<br>        <span class="hljs-comment">// return  s;❗️ 不需要 return</span><br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=836daa91-d685-4c82-9bf2-7cbca40d039b">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[库函数]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[有关字符要想到的操作#^ouvyxy]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9. 四数之和</title>
    <link href="/posts/1490/"/>
    <url>/posts/1490/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第18题-四数之和"><a class="markdownIt-Anchor" href="#1-第18题-四数之和"></a> 1 第18题. 四数之和</h1><p><a href="https://leetcode.cn/problems/4sum/">力扣题目链接</a></p><p>题意：给定一个包含&nbsp;n 个整数的数组&nbsp;nums&nbsp;和一个目标值&nbsp;target，判断&nbsp;nums&nbsp;中是否存在四个元素 a，b，c&nbsp;和 d&nbsp;，使得&nbsp;a + b + c + d&nbsp;的值与&nbsp;target&nbsp;相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><blockquote><p>[[8. 三数之和]]一样的道理，能解决四数之和 那么五数之和、六数之和、N数之和</p></blockquote><p>都是一用双指针法, 就是在[[8. 三数之和]]的基础上在嵌套一个 for 循环</p><p>但是有一些细节需要注意，例如： 不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。<br>但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。target &gt; 0不牵扯负数就可以进行剪枝</p><p>[[8. 三数之和]]的双指针解法是一层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] + nums[left] + nums[right] == 0。</p><p>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] == target的情况，三数之和的时间复杂度是O(n<sup>2)，四数之和的时间复杂度是O(n</sup>3) 。</p><p>那么一样的道理，五数之和、六数之和等等都采用这种解法。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>没有自己写, 对着抄的</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; nums.<span class="hljs-built_in">size</span>(); k++) {<br>            <span class="hljs-comment">// 剪枝处理</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="hljs-number">0</span> &amp;&amp; target &gt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>            }<br>            <span class="hljs-comment">// 对nums[k]去重</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) {<br>                <span class="hljs-comment">// 2级剪枝处理</span><br>                <span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; target &gt;= <span class="hljs-number">0</span>) {<br>                    <span class="hljs-keyword">break</span>;<br>                }<br><br>                <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">if</span> (i &gt; k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) {<br>                    <span class="hljs-keyword">continue</span>;<br>                }<br>                <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (right &gt; left) {<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) {<br>                        right--;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span><br>                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) {<br>                        left++;<br>                    } <span class="hljs-keyword">else</span> {<br>                        result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[k], nums[i], nums[left], nums[right]});<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                        <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                        right--;<br>                        left++;<br>                    }<br>                }<br><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=7c214b0c-3f43-4175-a620-53bc3e93119a">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8. 三数之和</title>
    <link href="/posts/7672/"/>
    <url>/posts/7672/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第15题-三数之和"><a class="markdownIt-Anchor" href="#1-第15题-三数之和"></a> 1 第15题. 三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接</a></p><p>给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> <strong>答案中不可以包含重复的三元组</strong>。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-哈希法"><a class="markdownIt-Anchor" href="#21-哈希法"></a> 2.1 哈希法</h2><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，<br>但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组</p><p><strong>哈希结构里都只是单元素的去重, 无法实现集合形式的去重</strong> ^l8megb</p><h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p><ol><li>首先将<strong>数组排序</strong>，</li><li>然后有一层for循环，i从下标0的地方开始，同时定一个下left 定义在i+1的位置上(第二小的数)，定义下标right 在数组结尾的位置上(最大的数)</li><li>映射a = nums[i]，b = nums[left]，c = nums[right], 依然还是在数组中找到 abc 使得a + b +c =0</li><li>如果整体大了<code>nums[i] + nums[left] + nums[right] &gt; 0</code> , 说明加的数需要<strong>变小</strong>(left 指向的元素无法再小), 即 right 指针左移;</li><li>如果整体小了 <code>nums[i] + nums[left] + nums[right] &lt; 0</code>, 说明加的数需要<strong>变大</strong>(right 指向的元素无法再大), left 指针右移</li><li>考虑 a 的去重<code>nums[i] == nums[i - 1] continue</code>;  bc 的去重: 向中间收缩时, 不能与之前的数相等,否则就重复了</li><li>循环往复, 直到left与right相遇为止(但不能相等, 因为相等就成两个数了)。</li></ol><p>时间复杂度：O(n^2)<br>![[8. 三数之和 2022-08-15 10.25.32.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++){<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// ❗️去重 a 放上边</span><br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = len <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left &lt; right){ <span class="hljs-comment">// ❗️整体要在 while 循环的包裹下</span><br>           <br>            <span class="hljs-keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>){<br>                right--;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>){<br>                left++;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                result.<span class="hljs-built_in">push_back</span>({nums[i], nums[left], nums[right]});<br>                <span class="hljs-comment">// 💡去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[right] == nums[right<span class="hljs-number">-1</span>]) right--;<br>                <span class="hljs-keyword">while</span>(left &lt; right&amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) left++;<br>                <span class="hljs-comment">// 找到答案时，双指针同时收缩, 如果同时收缩的同时,不去重的话, 就会导致相同的结果集</span><br>                left++;<br>                right--;<br>            }<br>    }<br>            <br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<span class="hljs-comment">// ❓为什么是二元数组💡题目定义的<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector (🗃)#^1wjjr0]]">[2]</span></a></sup></span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">return</span> result;<br>            }<br>            <span class="hljs-comment">// 去重a</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left =i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <br>            <span class="hljs-keyword">while</span>(left &lt; right){<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>            <span class="hljs-keyword">else</span> {<br>                result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i], nums[left], nums[right]});<br>                  <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--; <span class="hljs-comment">// 已经找到了, 符合结果的 b c , 在有相同的 b c 也就重复了, 所以继续移动不添加</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩, 如果同时收缩的同时,不去重的话, 就会导致相同的结果集</span><br>                    right--;<br>                    left++;<br>            }<br>            <br>            <br>            }<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=cce04a65-4b7a-4cf7-a9db-d2259157b250">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[1. 哈希表理论基础]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[vector (🗃)#^1wjjr0]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 赎金信</title>
    <link href="/posts/10848/"/>
    <url>/posts/10848/</url>
    
    <content type="html"><![CDATA[<h1 id="1-赎金信"><a class="markdownIt-Anchor" href="#1-赎金信"></a> 1 赎金信</h1><p><a href="https://leetcode.cn/problems/ransom-note/">力扣题目链接</a></p><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成，但是这里需要注意两点。</p><ul><li><p>第一点“为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思”&nbsp; 这里_说明杂志里面的字母<strong>不可重复使用</strong>。</p></li><li><p>第二点 “你可以假设两个字符串均只含有小写字母。” 说明只有<strong>小写字母</strong>，这一点很重要</p></li></ul><p>![[7. 赎金信 2022-08-15 16.34.44.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>{<br>        <span class="hljs-type">int</span> array[<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>};<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; magazine.<span class="hljs-built_in">length</span>(); i++){ <span class="hljs-comment">// ❗️字符串长度用的是 length</span><br>            array[magazine[i] - <span class="hljs-string">'a'</span>]++;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ransomNote.<span class="hljs-built_in">length</span>(); i++){<br>            array[ransomNote[i] - <span class="hljs-string">'a'</span>]--;<br>            <span class="hljs-keyword">if</span> (array[ransomNote[i] - <span class="hljs-string">'a'</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 💡直接将 if 语句放入这里, 不用在用一个 for 循环了</span><br>        }<br>     <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一些同学可能想，用数组干啥，都用map完事了，<strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong></p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=49ada40c-372a-4b11-8d1f-35c9917e32e0">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6. 四数相加II</title>
    <link href="/posts/56281/"/>
    <url>/posts/56281/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第454题四数相加ii"><a class="markdownIt-Anchor" href="#1-第454题四数相加ii"></a> 1: 第454题.四数相加II</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><p>给定四个包含整数的数组列表&nbsp;A , B , C , D ,计算有多少个元组 (i, j, k, l)&nbsp;，使得&nbsp;A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度&nbsp;N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过&nbsp;2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>解释:</strong></p><p>两个元组如下:</p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><p>本题解题步骤：</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><p>![[6. 四数相加II 2022-08-14 17.20.57.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>{<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums1){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : nums2){<br>                map[a+b]++;<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[map(🗃)]]">[1]</span></a></sup></span><br>            }<br>        }<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : nums3){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d: nums4){<br>                <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-c-d) != map.<span class="hljs-built_in">end</span>()){<br>                    count += map[<span class="hljs-number">0</span>-c-d]; <span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[map(🗃)]]">[1]</span></a></sup></span><br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=77c9599b-05e7-4360-a3de-f8d766f09304">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[map(🗃)]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/posts/43450/"/>
    <url>/posts/43450/</url>
    
    <content type="html"><![CDATA[<p>📝map::<br>2022/10/24 : 第一次创建</p><!-- basicblock-end --><blockquote><p>[!example]<br>[[6. 四数相加II]]<br>[[39. 数组中出现次数超过一半的数字]]</p></blockquote><h1 id="1-map定义"><a class="markdownIt-Anchor" href="#1-map定义"></a> 1: [[map定义]]</h1><h1 id="2-map-的实现"><a class="markdownIt-Anchor" href="#2-map-的实现"></a> 2: [[map 的实现]]</h1><h1 id="3-16-map插入方式有哪几种"><a class="markdownIt-Anchor" href="#3-16-map插入方式有哪几种"></a> 3: [[16、map插入方式有哪几种？]]</h1><h1 id="4-c中-map如何通过-key-来返回-value"><a class="markdownIt-Anchor" href="#4-c中-map如何通过-key-来返回-value"></a> 4: [[C++中 map如何通过 key 来返回 value]]</h1><h1 id="5-19-map下标运算符中与find的区别"><a class="markdownIt-Anchor" href="#5-19-map下标运算符中与find的区别"></a> 5: [[19、map下标运算符中与find的区别？]]</h1><h1 id="6-其他"><a class="markdownIt-Anchor" href="#6-其他"></a> 6: 其他::</h1><p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p><p>实际上功能都是一样一样的， 但是unordered_set在C<ins>11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C</ins>11标准之前民间高手自发造的轮子。<br><img src="https://img-blog.csdnimg.cn/20210104235134572.png" alt="哈希表6"></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>set(🗃)</title>
    <link href="/posts/44251/"/>
    <url>/posts/44251/</url>
    
    <content type="html"><![CDATA[<p>📝set::<br>2022/10/27 : 第一次创建</p><!-- basicblock-end --><h1 id="set的实现"><a class="markdownIt-Anchor" href="#set的实现"></a> [[set的实现]]</h1><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1><p>当我们要使用集合来解决哈希问题的时候，<br><strong>优先使用 unordered_set</strong>，因为它的查询和增删效率是最优的，<br>如果需要集合是有序的，那么就用 set，<br>如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><ul><li>数据范围大(上亿)的时候用 set</li><li>要查询的有: 0 , 5, 100000 . 此时如果用数组的就要开一个 100000 大小的,其实就查询 3 个数,这也是不合适的会造成空间浪费,这种情况也用 set</li></ul><p>局限: set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。:</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208121701377.png" alt="|600"></p><h1 id="1-unordered_set"><a class="markdownIt-Anchor" href="#1-unordered_set"></a> 1: unordered_set</h1><p>unoredered_set<br>在 set 的三种类型中查找效率最高, 映射效率最高, 取值操作效率也是最高的,<br>不需要对数据排序, 并且不会让数组重复(<strong>自带去重</strong>)</p><h2 id="11-性质"><a class="markdownIt-Anchor" href="#11-性质"></a> 1.1: 性质</h2><ul><li>插入元素后自带去重. <code>eg:插入 100 个 2 , 最后也是一个 2.</code></li><li>无自动排序</li></ul><h2 id="12-操作"><a class="markdownIt-Anchor" href="#12-操作"></a> 1.2: 操作</h2><p>结构: <code>nums_set: {[0] = 2, [1] = 1}</code>, [[3. 两个数组的交集]]</p><ul><li><p>插入操作: <code>unordered_set result; result.insert();</code></p><ul><li>每往里 insert 一个值, 对该值进行一个哈希运算,转变成另一个它内部存储的一个值, 然后还要开辟一个新的空间</li></ul></li><li><p>寻找操作:</p><ul><li><code>set1. find(2);</code>, 查找2，找到返回迭代器，失败返回set1.end()</li><li>时间复杂度为 O(m * n) [[KMP 算法理论篇#^zyqb9e]]</li></ul></li><li><p>初始化</p><ol><li>创建空的 set :<code>unordered_set&lt;int&gt; set1;</code></li><li>拷贝创建: <code>unordered_set&lt;int&gt; set2(set1);</code></li><li><strong>使用其他结构创建</strong>: <code>unordered_set&lt;int&gt; set3(set1.begin(), set1.end());</code></li></ol></li><li><p><code>unorder_set&lt;string&gt; first</code>容器定义</p></li><li><p><code>first.empty()</code>判断容器是否是空，是空返回<code>true</code>，反之为<code>false</code></p></li><li><p><code>first.size()</code>返回容器大小</p></li><li><p><code>first.maxsize()</code>返回容器最大尺寸</p></li><li><p><code>first.begin()</code>返回迭代器开始</p></li><li><p><code>first.end()</code>返回迭代器结束</p></li><li><p><code>first.find(value)</code>返回value在迭代器的位置</p></li><li><p><code>first.count(key)</code>返回key在容器的个数</p></li><li><p><code>first.insert(value)</code>将value插入到容器中</p></li><li><p><code>first.erase(key)</code>通过key删除</p></li><li><p><code>first.clear()</code>清空容器</p></li></ul><h1 id="2-set-multiset"><a class="markdownIt-Anchor" href="#2-set-multiset"></a> 2: set multiset</h1><p>set 和 multiset 因为底层实现是红黑树, 查找元素的之前还要进行向下寻找的操作, 所以效率低</p><ul><li>自动排序(红黑树具有自动排序的功能)<br>multiset 里边的元素可以重复</li></ul><p>红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><h1 id="3-案例"><a class="markdownIt-Anchor" href="#3-案例"></a> 3: 案例</h1><p>[[14. 递增子序列]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>🗃️</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 两数之和</title>
    <link href="/posts/34993/"/>
    <url>/posts/34993/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1: 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p><p>给定一个整数数组 nums&nbsp;和一个目标值 target，请你在该数组中找出和为目标值的那&nbsp;两个&nbsp;整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1: 暴力解法</h2><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。<br>i 查找第一个数, j 查找第二个数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target &amp;&amp; i != j){<br>                    <span class="hljs-keyword">return</span> {i,j};<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> {};<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-哈希表"><a class="markdownIt-Anchor" href="#22-哈希表"></a> 2.2: 哈希表</h2><p>将遍历的数组元素存入 map , 下一次遍历的时候在 map 中查找差值</p><p>![[5. 两数之和 2022-08-13 22.10.31.excalidraw]]</p><p>本题: 我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<br><strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong><br>判断元素是否出现，这个元素就要作为key(查找的主要元素作为 key)，有key对应的就是value，value用来存下标。</p><p>map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target -nums[i]); <span class="hljs-comment">// 提前把变量设好, 为了获取 value 值</span><br>            <span class="hljs-keyword">if</span> ( iter != map.<span class="hljs-built_in">end</span>()){<br>                <span class="hljs-keyword">return</span> {iter-&gt;second, i};<br>            }<br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i));<br>        } <br>        <span class="hljs-keyword">return</span> {};<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=d64073dd-55d1-4f4b-829a-8680ac0b146e">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关数值要想到的操作</title>
    <link href="/posts/38142/"/>
    <url>/posts/38142/</url>
    
    <content type="html"><![CDATA[<h1 id="1-取各个位数"><a class="markdownIt-Anchor" href="#1-取各个位数"></a> 1 取各个位数</h1><p>取余_数是指整数除法中被除数未被除尽部分<br>eg: 199, 取<strong>其个位(%10</strong>), <s><strong>十位(%100)</strong>, <strong>百位(%1000)</strong></s><br>取十位可让, (199/10) %10</p><p>#疑问<br>![[有关数值要想到的操作 2022-08-13 10.19.03.excalidraw]]</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=2d35b970-9351-48dc-a461-bcf79e0d9ff3">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 快乐数</title>
    <link href="/posts/35816/"/>
    <url>/posts/35816/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第202题-快乐数"><a class="markdownIt-Anchor" href="#1-第202题-快乐数"></a> 1 第202题. 快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接</a></p><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 可以变为&nbsp; 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现</strong>, 重复出现就代表着无法找到 sum = 1</p><p>用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p>[[有关数值要想到的操作]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span> <span class="hljs-params">(<span class="hljs-type">int</span> n )</span></span>{<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n){ <span class="hljs-comment">// ❓为什么不会死循环 💡 n &lt; 1 即为 0,<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]]">[1]</span></a></sup></span><br>                sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>                n /= <span class="hljs-number">10</span>;<br>            }<br>            <span class="hljs-keyword">return</span> sum;<br>        }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(sum) != set.<span class="hljs-built_in">end</span>()){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                set.<span class="hljs-built_in">insert</span>(sum);<br>            }<br>            n = sum; <span class="hljs-comment">// 更新 sum</span><br>        }<br><br>    }<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=84d58a22-ffee-4e83-8c37-a0bd4cedbcb5">ob</a><br><a href="https://www.programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 两个数组的交集</title>
    <link href="/posts/13727/"/>
    <url>/posts/13727/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两个数组的交集"><a class="markdownIt-Anchor" href="#1-两个数组的交集"></a> 1 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接</a></p><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p><img src="https://img-blog.csdnimg.cn/20200818193523911.png" alt="349. 两个数组的交集"></p><p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>![[3. 两个数组的交集 2022-08-12 18.44.19.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; result_set;<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">nums_set</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(nums2[i]) != nums_set.<span class="hljs-built_in">end</span>()){ <span class="hljs-comment">// ❓为什么是!=呢 💡如果找不到则返回 num_set.end()</span><br>                result_set.<span class="hljs-built_in">insert</span>(nums2[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector]]">[1]</span></a></sup></span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#_349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[vector]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关字符要想到的操作</title>
    <link href="/posts/30423/"/>
    <url>/posts/30423/</url>
    
    <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObsgS7hxap8HZGP55ZRbToXQ" --> <h1 id="1-取到字母字符对应数组下标值"><a class="markdownIt-Anchor" href="#1-取到字母字符对应数组下标值"></a> 1 取到字母字符对应数组下标值 ::</h1><p>![[c++中 - ‘0’ 以及 -‘a’ 的相减操作解释#1 取到字母字符对应的数字：a→0，b→1]]</p><!-- basicblock-end --><h1 id="2-找到字符下标对应的元素"><a class="markdownIt-Anchor" href="#2-找到字符下标对应的元素"></a> 2 找到字符下标对应的元素</h1><p>数组类的用的是 <code>nums[i]</code>, 最后一个元素: <code>nums[nums.size()- 1]</code><br>字符类的要用<code>s.begin() + i</code>,  最后一个元素用 <code>s.end()</code></p><h1 id="3-string"><a class="markdownIt-Anchor" href="#3-string"></a> 3 string</h1><p>在C语言中，把一个字符串存入一个数组时，也把结束符 '\0’存入数组，并以此作为该字符串是否结束的标志。<br>例如这段代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> a[<span class="hljs-number">5</span>] = <span class="hljs-string">"asd"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; a[i] != <span class="hljs-string">'\0'</span>; i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>string 类会提供 size 接口, 用来判断 string 类字符是否结束, 不用’/0’来判断是否结束 , char 类型的也可用 .size(); ^ouvyxy</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">string a = <span class="hljs-string">"asd"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) {<br>}<br></code></pre></td></tr></tbody></table></figure><p>那么vector&lt; char &gt; 和 string 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。</p><p>所以想处理字符串，我们还是会定义一个string类型。</p><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 有效的字母异位词</title>
    <link href="/posts/33343/"/>
    <url>/posts/33343/</url>
    
    <content type="html"><![CDATA[<h1 id="1-242有效的字母异位词"><a class="markdownIt-Anchor" href="#1-242有效的字母异位词"></a> 1 242.有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例&nbsp;1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><p>#card</p><!-- basicblock-start oid="ObsBzRRXarQbR2XJrzGJdVyg" --> <p>字母异位词::<br>由相同的字母组成, 但位置可以不同</p><!-- basicblock-end --><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>将 s 的字母的对应的下标值变为 1 存入哈希表中(数组),<br>通过 t 对应的下标值在减 1 , 看数组是否全为0</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govxyg83bng30ds09ob29.gif" alt="242.有效的字母异位词"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[容器的使用]]<br>#疑问<br>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>{<br>        <span class="hljs-type">int</span> hash [<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// ❗️0 得有大括号</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            hash[s[i] - <span class="hljs-string">'a'</span>]++; <br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; t.<span class="hljs-built_in">size</span>(); j++){<br>            hash[t[j] - <span class="hljs-string">'a'</span>]--; <span class="hljs-comment">// ❗️不是 s 哦, 是 t 的字符串</span><br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++){ <span class="hljs-comment">// ❓为什么不能用i &lt; hash.size()💡还是用提前定义好变量, 思想:用空间换时间</span><br>            <span class="hljs-keyword">if</span> (hash[i] != <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#_242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 哈希表理论基础</title>
    <link href="/posts/3799/"/>
    <url>/posts/3799/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1: 定义</h1><p><strong>哈希表是根据关键码的值而直接进行访问的数据结构</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>其实数组就是一张哈希表。<br>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210104234805168.png" alt="哈希表1|600"></p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><h1 id="2-哈希函数"><a class="markdownIt-Anchor" href="#2-哈希函数"></a> 2: 哈希函数</h1><p><img src="https://img-blog.csdnimg.cn/2021010423484818.png" alt="哈希表2|600"><br>通过 hashCode 将名字转换为数值, 这样就把学生名字映射为哈希表的索引数字了<br>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>如果学生的数量大于哈希表的大小, 会出现几位同学同时映射到哈希表的同一个索引下标位置<br>就此引出哈希碰撞</p><h1 id="3-哈希碰撞"><a class="markdownIt-Anchor" href="#3-哈希碰撞"></a> 3: 哈希碰撞</h1><p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p><img src="https://img-blog.csdnimg.cn/2021010423494884.png" alt="哈希表3|600"><br>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h2 id="31-拉链法"><a class="markdownIt-Anchor" href="#31-拉链法"></a> 3.1: 拉链法</h2><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被<strong>存储在链表</strong>中。<br>这样我们就可以通过索引找到小李和小王了<br><img src="https://img-blog.csdnimg.cn/20210104235015226.png" alt="哈希表4|600"></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h2 id="32-线性探测法"><a class="markdownIt-Anchor" href="#32-线性探测法"></a> 3.2: 线性探测法</h2><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210104235109950.png" alt="哈希表5|500"></p><h1 id="4-常见的三种哈希结构"><a class="markdownIt-Anchor" href="#4-常见的三种哈希结构"></a> 4: 常见的三种哈希结构</h1><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p>这里数组就没啥可说的了，我们来看一下set。</p><h2 id="41-array"><a class="markdownIt-Anchor" href="#41-array"></a> 4.1: array</h2><p>数据范围不大的时候用数组, 能用数组都用数组<br>局限: 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</p><h2 id="42-set"><a class="markdownIt-Anchor" href="#42-set"></a> 4.2: [[set(🗃)]]</h2><h2 id="43-map"><a class="markdownIt-Anchor" href="#43-map"></a> 4.3: [[map(🗃)]]</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 环形链表II</title>
    <link href="/posts/51653/"/>
    <url>/posts/51653/</url>
    
    <content type="html"><![CDATA[<h1 id="1-42环形链表ii"><a class="markdownIt-Anchor" href="#1-42环形链表ii"></a> 1 42.环形链表II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。&nbsp;如果链表无环，则返回&nbsp;null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><p><img src="https://img-blog.csdnimg.cn/20200816110112704.png" alt="循环链表|600"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>#card</p><!-- basicblock-start oid="Obss3RRsOmOqv7rvijEgiIq0" --> <p>环型链表思路::</p><ol><li>fast slow 指向头结点, fast 每次走两步, slow 每次走一步.  记相遇节点  (Index1)</li><li>相遇节点(Index1) 与 头结点(Index2)在<strong>同步</strong>走, 在相遇便是入口节点</li></ol><!-- basicblock-end --><h2 id="21-判断是否有环"><a class="markdownIt-Anchor" href="#21-判断是否有环"></a> 2.1 判断是否有环</h2><p><strong>定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</strong></p><p>原因:</p><ol><li><strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的</strong>。</li><li>fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo4xglk9yg30fs0b6u0x.gif" alt="141.环形链表"></li></ol><h2 id="22-如何找入口"><a class="markdownIt-Anchor" href="#22-如何找入口"></a> 2.2 如何找入口</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif" alt="142.环形链表II（求入口）"></p><p>![[8. 环形链表II 2022-08-12 10.28.07.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head; <span class="hljs-comment">// ❗️要赋值啊</span><br>        ListNode* slow = head;<br>        ListNode* index1;<br>        ListNode* index2 = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️要把 fast != NULL 放到前边, 因为如果链表是空指针, 要先判断这个</span><br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow){<br>                index1 = fast;<br>                <span class="hljs-keyword">while</span>(index1 != index2){<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                }<br>                <span class="hljs-keyword">return</span> index1;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>一刷:已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>){<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow){<br>                ListNode* index1 = fast; <span class="hljs-comment">// 定义相遇节点</span><br>                ListNode* index2 = head; <span class="hljs-comment">// 定义头结点</span><br>            <span class="hljs-keyword">while</span>(index1 != index2){ <span class="hljs-comment">// 💡让他俩同时出发,相遇时即为入口❗️index1 != NULL &amp;&amp; index1-&gt;next != NULL</span><br>            index1 = index1-&gt;next;  <br>            index2 = index2-&gt;next;<br>            }<br>            <span class="hljs-keyword">return</span> index1;<br>    }<br>}<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 链表相交</title>
    <link href="/posts/8965/"/>
    <url>/posts/8965/</url>
    
    <content type="html"><![CDATA[<h1 id="1-面试题-0207-链表相交"><a class="markdownIt-Anchor" href="#1-面试题-0207-链表相交"></a> 1 面试题 02.07. 链表相交</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接</a></p><p>给你两个单链表的头节点&nbsp;headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png" alt=""></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>示例 1：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png" alt=""></p><!-- basicblock-start oid="ObsIj67S95DLXBLeahoOf5qB" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><ol><li>获取两个链表长度, 长度长的在上面, 长度短的在下面</li><li>求出两个链表长度差, 使A 走到重合处. 即末端对齐</li><li>A 和 B 向后比较, 寻找相同的元素</li></ol><p>![[7. 链表相交 2022-08-12 16.32.24.excalidraw]]</p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lenB = <span class="hljs-number">0</span>;<br>        ListNode* curA = headA; <span class="hljs-comment">// 操作 headA</span><br>        ListNode* curB = headB;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 获取长度<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=": 获取链表长度::12345678// 不要操作原指针, 重新定义一个指针, 因为指针会不断的变化, 如果用原来的指针就破坏了原来的结构了        ListNode* curA = headA; // 操作 headA        int lenA = 0;        while(curA != NULL){   // 获取长度            curA = curA->next;            lenA++;        }">[1]</span></a></sup></span><br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>){ <br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        curA = headA;         <span class="hljs-comment">// 重新操作 headA</span><br>        curB = headB;<br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA){     <span class="hljs-comment">// 固定长度长的</span><br>            <span class="hljs-built_in">swap</span>(curA, curB);<br>            <span class="hljs-built_in">swap</span>(lenA, lenB);<br>        }<br>        <span class="hljs-type">int</span> gap = lenA - lenB; <span class="hljs-comment">// 获取差值</span><br>        <span class="hljs-keyword">while</span>(gap--){          <span class="hljs-comment">// 长短对齐 </span><br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 寻找相同</span><br>            <span class="hljs-keyword">if</span>(curA == curB){<br>                <span class="hljs-keyword">return</span> curA;<br>            }<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){<br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>){<br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-keyword">if</span>(lenB &gt; lenA){<br>            <span class="hljs-built_in">swap</span>(curB, curA);<span class="hljs-comment">// 反过来换也行, 因为是两两互换</span><br>            <span class="hljs-built_in">swap</span>(lenB, lenA);<br>        }<br>        <span class="hljs-type">int</span> gap = lenA - lenB; <span class="hljs-comment">// 换过之后一定是大的减小的</span><br>        <span class="hljs-keyword">while</span>(gap--){<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(lenB--){<br>            <span class="hljs-keyword">if</span>(curA != curB){ <span class="hljs-comment">// ❗️不用 curA-&gt;val != curB-&gt;val, 因为是指针指向同一个元素是相等的</span><br>                curA = curA-&gt;next;<br>                curB = curB-&gt;next;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                <span class="hljs-keyword">return</span> curB; <span class="hljs-comment">// 如果有交点, 后边也全相等 ❗️不用 curB-&gt;val</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3通过: 整体简单</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode* dummyHeadA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* dummyHeadB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHeadA-&gt;next = headA;<br>        dummyHeadB-&gt;next = headB;<br>        ListNode* curA = dummyHeadA;<br>        ListNode* curB = dummyHeadB;<br>        <span class="hljs-type">int</span> LenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA-&gt;next){<br>            curA = curA-&gt;next;<br>            LenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB-&gt;next){<br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        <span class="hljs-keyword">if</span>(LenA &lt; lenB){<br>            <span class="hljs-built_in">swap</span>(dummyHeadA, dummyHeadB);<br>            <span class="hljs-built_in">swap</span>(LenA, lenB);<br>        }<br>        <span class="hljs-type">int</span> gap = LenA - lenB;<br>        ListNode* curA2 = dummyHeadA;<br>        ListNode* curB2 = dummyHeadB;<br>        <span class="hljs-keyword">while</span>(gap--){<br>            curA2 = curA2-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(curA2){<br>            <span class="hljs-keyword">if</span>(curA2 == curB2) <span class="hljs-keyword">return</span> curA2; <span class="hljs-comment">// 💡这里 return 会直接跳出 while 循环</span><br>            curA2 = curA2-&gt;next;<br>            curB2 = curB2-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// ❗️不要忘了 NULL 的情况</span><br><br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v4</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode* dummyHeadA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode* dummyHeadB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHeadA-&gt;next = headA;<br>        dummyHeadB-&gt;next = headB;<br>        ListNode* curA = dummyHeadA;<br>        ListNode* curB = dummyHeadB;<br><br>        <br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA-&gt;next){<br>            curA= curA-&gt;next;<br>            lenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB-&gt;next){<br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        curA = headA;<span class="hljs-comment">// ❗️不要重新定义</span><br>        curB = headB;<br><br>        <span class="hljs-keyword">if</span>(lenA &lt; lenB){<br>            <span class="hljs-built_in">swap</span>(lenA, lenB);<br>            <span class="hljs-built_in">swap</span>(curA, curB);<br>        }<br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br><br>        <span class="hljs-keyword">while</span>(gap--){<br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(lenB--){ <span class="hljs-comment">// ❗️curB-&gt;next!= NULL, 不知道为啥这样不可以</span><br>            <span class="hljs-keyword">if</span>(curA == curB) <span class="hljs-keyword">return</span> curA;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p><!-- basicblock-start oid="ObsdrGEjg402bVGB7cFhuXak" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::7. 链表相交.md" --> <p>#历史记录::<br>2022/9/13🌵7. 链表相交 : v3通过: 整体简单⏱0-17</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>:<!-- basicblock-start oid="ObsHkPOI5H0zCs3HXDaIsScl" --> <p>获取链表长度::<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 不要操作原指针, 重新定义一个指针, 因为指针会不断的变化, 如果用原来的指针就破坏了原来的结构了</span><br>        ListNode* curA = headA; <span class="hljs-comment">// 操作 headA</span><br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 获取长度</span><br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.删除链表的倒数第N个节点</title>
    <link href="/posts/26499/"/>
    <url>/posts/26499/</url>
    
    <content type="html"><![CDATA[<p>6.删除链表的倒数第N个节点::<br>2022/9/13🌵 :v3通过: 进一步理解了⏱0-49</p><!-- basicblock-end --><h1 id="1-19删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#1-19删除链表的倒数第n个节点"></a> 1: 19.删除链表的倒数第N个节点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接</a></p><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210510085957392.png" alt="19.删除链表的倒数第N个节点"></p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：</p><p>输入：head = [1], n = 1 输出：[]</p><p>示例 3：<br>输入：head = [1,2], n = 1 输出：[1]</p><!-- basicblock-start oid="ObsGBeuVT8skd0OCjzxKXOoD" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路::</h1><ol><li>删除准备: 找到倒数第 n 个节点的前一个节点<ul><li>$ 用双指针: 让fast先移动n+1步，</li><li>$ 然后让fast和slow同时移动，直到fast指向<strong>NULL</strong>, 此时 slow 就指向了要删除结点的前一个节点</li></ul></li><li>删除操作: 前一个节点 next 指针指向 后边第二个节点</li></ol><ul><li>&amp;  这个总结的不如直接看 carl 的, 总结的不好<br>![[6.删除链表的倒数第N个节点 2022-09-25 11.45.47.excalidraw]]</li></ul><!-- basicblock-end --><p>![[6.删除链表的倒数第N个节点 2022-08-12 09.22.22.excalidraw|1500]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>一刷:编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// [^1]</span><br>        dummyHead-&gt;next = head;<br>        ListNode* fast = dummyHead;<span class="hljs-comment">// <sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label=": 创建链表指针::">[2]</span></a></sup></span><br>        ListNode* slow = dummyHead; <br>        n++;<br>        <span class="hljs-keyword">while</span> (n-- &amp;&amp; fast != <span class="hljs-literal">nullptr</span>){<br>            fast = fast-&gt;next;<br>        }<br>        <span class="hljs-comment">// 如果在上面不用 n++, 在这里多写一个fast-&gt;next ,让 fast 多走一步</span><br>        <span class="hljs-comment">// 结果: n 若为 1000, 上面的 fast 就已经是空了, 而上一行让他多走一步就是操作空指针了</span><br>        <span class="hljs-comment">// 所以安全起见先 n++. 💡另外一个思路: 用空间换时间, 提前都把变量定义好</span><br>        <br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>){<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        ListNode* temp = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* fast = dummyHead;<br>        ListNode* slow = dummyHead;<br>        ListNode* temp;<br>        n += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n){<br>            fast = fast-&gt;next;<br>            n--; <span class="hljs-comment">// ❗️不要忘了控制 n, 也可以写成 while(n--)</span><br>        }<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>){<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        temp = slow-&gt;next ; <span class="hljs-comment">//❗️ 写反了</span><br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp; <span class="hljs-comment">// ❗️不需要括号 delete(temp)</span><br><br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3通过: 进一步理解了<br>v4, 通过, 较熟练</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <br>        dummyHead-&gt;next = head;<br>        ListNode* fast = dummyHead;<span class="hljs-comment">// ❗️不要 fast = head, 统一用虚拟头节点</span><br>        ListNode* slow = dummyHead;<br>        n += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️v4没有写 fast != NULL 条件, 💡这样也通过了</span><br>            fast = fast-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(fast){ <span class="hljs-comment">// 💡此时跳出循环的 fast 已经在 NULL 指针上了</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        }<br>        ListNode* temp = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <br>        <span class="hljs-built_in">delete</span>(temp); <span class="hljs-comment">// 💡可用括号, 可不用</span><br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next; <span class="hljs-comment">// ❗️不要返回 head, 要返回 dummyHead-&gt;next</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><p>ListNode* Index<br>创建二叉树也是一样的<br>TreeNode* node</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:2" class="footnote-text"><span>:<!-- basicblock-start oid="Obsnv2tHjP49t8ASdRAMsF5a" --> 创建链表指针::<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 两两交换链表中的节点</title>
    <link href="/posts/58812/"/>
    <url>/posts/58812/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#1-两两交换链表中的节点"></a> 1 两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="24.两两交换链表中的节点-题意|500"></p><!-- basicblock-start oid="Obsm7Zbax7XAcUZ1TeeM3sor" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>使用虚拟头结点</p><p>要想交换两个节点, 首先要把 cur 指针指向两节点的前一个节点</p><p>![[5. 两两交换链表中的节点 2022-08-11 23.49.26.excalidraw]]<br>有关 while 终止条件的判断<br>![[5. 两两交换链表中的节点 2022-08-12 00.20.24.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❗️dummyHead 前需要 ListNode*</span><br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next!=<span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>){ <br>        <span class="hljs-comment">// 💡如果是链表是偶数,最后cur跑到的下一位是 null,如果是奇数位,cur-&gt;next-&gt;next是 null. </span><br>        <span class="hljs-comment">// 两者的位置不能换,如果把 cur-&gt;next-&gt;next!=nullptr, 有可能忽视 cur-&gt;next!=nullptr 的情况</span><br><br>            ListNode* temp1 = cur-&gt;next;<br>            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next;<br><br>            cur-&gt;next = cur-&gt;next-&gt;next; <span class="hljs-comment">// ❗️不需要-&gt;val,cur-&gt;next-&gt;next-&gt;val 💡cur 连到 2</span><br>            cur-&gt;next-&gt;next = temp1;<span class="hljs-comment">// 💡2 连到 1</span><br>            temp1-&gt;next= temp2;<span class="hljs-comment">// ❗️1 连到 3,不能用 </span><br><br>            cur = cur-&gt;next-&gt;next; <span class="hljs-comment">// 移动两位 准备下一轮交换</span><br>        }<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过, 赋值的时候用 tem1. tem2 也行<br>v3, 通过 在纸上画出来那个图, 就好写</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp;&nbsp;cur-&gt;next-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// 这样也可以: while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next){</span><br>            ListNode* temp1 = cur-&gt;next;<br>            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next;<br>            <br>            cur-&gt;next = temp1-&gt;next;<br>            temp1-&gt;next-&gt;next = temp1;<br>            temp1-&gt;next = temp2;<br>            <br>            cur = cur-&gt;next-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p> <!-- basicblock-start oid="Obst2RY54cHyIFOBYSYzWBnP" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::5. 两两交换链表中的节点.md" --> <p>#历史记录::<br>2022/9/13🌵5. 两两交换链表中的节点 :v2通过, 赋值的时候用 tem1. tem2 也行⏱0-17</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 反转链表</title>
    <link href="/posts/32071/"/>
    <url>/posts/32071/</url>
    
    <content type="html"><![CDATA[<h1 id="1-206反转链表"><a class="markdownIt-Anchor" href="#1-206反转链表"></a> 1: 206.反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路::</h1><p>定义一个 cur 指针指向头结点<br>定义一个 pre 指针初始化为 null</p><p>把 cur-&gt;next的指针用 tmp 保存一下::<br>不保存的话一会操作 cur-&gt;next 指针, 原来 cur-&gt;next 连接的元素就会找不到</p><ol><li>改变方向<ol><li>cur-&gt;next =  pre;# 2 思路:</li></ol></li><li>while 循环,.移动下一个位置, 直至cur 指向NULL(💡为了让 pre 走到最后一个元素)<ol><li>pre = cur;</li><li>cur = tmp<br>最后，cur 指针已经指向了null，💡pre 指向了最后一个元素(即是第一个节点)循环结束，return pre</li></ol></li></ol><p>![[4. 翻转链表.excalidraw]]</p><ul><li>时间复杂度：O(n)，其中 nnn 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：O(1)。</li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><h2 id="31-迭代法"><a class="markdownIt-Anchor" href="#31-迭代法"></a> 3.1: 迭代法</h2><p>v1通过,  双指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* tmp;<br><br>        <span class="hljs-keyword">while</span>(cur){<br>            tmp = cur-&gt;next; <span class="hljs-comment">// ❗️cur-&gt;next = tmp; 目的要把 cur-&gt;next 指针先保存下来,而不是改变他</span><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head; <span class="hljs-comment">// ❗️链表指针的定义: ListNode*</span><br>        ListNode* pre = <span class="hljs-literal">NULL</span>;<br>        ListNode* temp;<br>        <span class="hljs-keyword">while</span>(cur){ <span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]] #历史记录::2022/9/13🌵4. 翻转链表 :“v3: 通过”, “递归法也看了, 很秒, 中间有疑问的” ⏱0-50">[1]</span></a></sup></span><br>            temp = cur-&gt;next; <span class="hljs-comment">// ❗️写反了, 是赋值操作</span><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre; <span class="hljs-comment">// ❗️pre 最后走到了第一个元素, cur 走向了 null</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><s>v3: 没通过, 思路是的对的, 力扣上的参数好像变了,  💡模式是 java 模式</s>~~~~~~~~<br>v3: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>: <br>     <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<span class="hljs-comment">// ❗️不需要虚拟头指针</span><br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur){<br>            ListNode* temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v4:  while 循环里怎么走又忘了, 总结在图里了, 2022/09/25</p><h2 id="32-递归法"><a class="markdownIt-Anchor" href="#32-递归法"></a> 3.2: 递归法</h2><p>递归写法<br>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, tmp);<span class="hljs-comment">// ❗️前边还有 return, 把参数返回给下一层</span><br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">nullptr</span>, head);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过::在递归中要想返回 if语句中的返回值, 就在递归前直接加 return, 不要在下边再加操作(会导致回溯)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, temp);<span class="hljs-comment">// 💡没有回溯过程 直接执行的是 if 语句里的操作就退出了</span><br>        <br>        <span class="hljs-comment">// ❗️return pre; 放到 reverse 下边就回溯了, 会不断的回退 pre 指针 </span><br>        <span class="hljs-comment">// ❓有关栈中的操作还不太明白</span><br>        <br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">nullptr</span>, cur);<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<!-- basicblock-start oid="ObsPTlHFiqnNhfmgjUwEkUPi"  --> #历史记录::<br>2022/9/13🌵4. 翻转链表 :“v3: 通过”, “递归法也看了, 很秒, 中间有疑问的” ⏱0-50<!-- basicblock-end --><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3. 设计链表</title>
    <link href="/posts/40651/"/>
    <url>/posts/40651/</url>
    
    <content type="html"><![CDATA[<h1 id="1-707设计链表"><a class="markdownIt-Anchor" href="#1-707设计链表"></a> 1 707.设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第&nbsp;index&nbsp;个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为&nbsp;val&nbsp;的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为&nbsp;val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第&nbsp;index&nbsp;个节点<strong>之前</strong>添加值为&nbsp;val&nbsp; 的节点。如果&nbsp;index&nbsp;等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引&nbsp;index 有效，则删除链表中的第&nbsp;index 个节点。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200814200558953.png" alt="707示例"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>[[1.  链表理论基础#4 链表的操作]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1: 看 v2</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> {<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span>{<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>){}<br>    };<br><br>    <span class="hljs-built_in">MyLinkedList</span>() {<br>        _dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❗️不需要用 linkedHead* _dummyHead</span><br>        _size = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❓</span><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; (_size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>){ <span class="hljs-comment">// ❗️不懂_size-1, size 为链表的长度</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>        LinkedNode* cur = _dummyHead-&gt;next; <span class="hljs-comment">// 💡直接指向真实结点的第一个节点</span><br>        <span class="hljs-keyword">while</span>(index--){<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = _dummyHead-&gt;next;<span class="hljs-comment">// 💡虚拟节点的后一个节点才是第一个真实节点</span><br>        _dummyHead-&gt;next = newNode;<br>        _size++;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 添加节点连接后一个节点</span><br>        LinkedNode* cur = _dummyHead; <span class="hljs-comment">// 💡等于_dummyHead-&gt;next也无所谓,目的是找最后一个节点</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){ <span class="hljs-comment">// 找到最后一个节点</span><br>            cur = cur-&gt;next;<br>        }<br>        cur-&gt;next = newNode;<br>        _size++; <span class="hljs-comment">// ❗️不要忘了总长度+1</span><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>{ <span class="hljs-comment">// 是在第 index 前插入一个节点</span><br>        <span class="hljs-keyword">if</span> (index &gt; _size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead; <span class="hljs-comment">// 💡是在第 index 前插入一个节点,所以找的是 index 前的节点,如果是 dummyHead-&gt;next, 就找到了第 Index 的位置</span><br>        <span class="hljs-keyword">while</span>(index--){ <span class="hljs-comment">// 找到第 index 前号元素<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]] #历史记录::2022/9/13🌵3. 设计链表 :v2: 调整了一下顺序, 改变了了一下变量名字, 使代码更加好读了, 没有动手写一遍⏱0-25">[1]</span></a></sup></span><br>            cur = cur-&gt;next;<br>        }<br>        newNode-&gt;next = cur-&gt;next;<span class="hljs-comment">// ❗️注意不是 cur-&gt;next-&gt;next</span><br>        cur-&gt;next = newNode;<br>        _size++;<br><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>          <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* cur = _dummyHead;<span class="hljs-comment">// ❓</span><br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur -&gt;next;<br>        }<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        _size--;<br>    }<br><br>    <br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span> </span>{<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;<br>            cur = cur-&gt;next;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">private</span>: <span class="hljs-comment">// 放到 public 上面则编译不通过</span><br>    <span class="hljs-type">int</span> _size;<br>    LinkedNode* _dummyHead;<br><br>};<br></code></pre></td></tr></tbody></table></figure><p>v2: 调整了一下顺序, 改变了了一下变量名字, 使代码更加好读了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> {<br><span class="hljs-keyword">private</span>:<br><br>        <span class="hljs-comment">// 定义链表节点结构体</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span> {<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>){}<br>    };<br><br>    <span class="hljs-type">int</span> size;<br>    LinkedNode* dummyHead;<br><br><br><span class="hljs-keyword">public</span>:<br><br><br>    <span class="hljs-comment">// 初始化链表</span><br>    <span class="hljs-built_in">MyLinkedList</span>() {<br>        dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span><br>        size = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; (size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>        LinkedNode* cur = dummyHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(index--){ <span class="hljs-comment">// 如果--index 就会陷入死循环</span><br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    }<br><br>    <span class="hljs-comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = dummyHead-&gt;next;<br>        dummyHead-&gt;next = newNode;<br>        size++;<br>    }<br><br>    <span class="hljs-comment">// 在链表最后面添加一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){<br>            cur = cur-&gt;next;<br>        }<br>        cur-&gt;next = newNode;<br>        size++;<br>    }<br><br>    <span class="hljs-comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span><br>    <span class="hljs-comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span><br>    <span class="hljs-comment">// 如果index大于链表的长度，则返回空</span><br>    <span class="hljs-comment">// 如果index小于0，则置为0，作为链表的新头节点。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur-&gt;next;<br>        }<br>        newNode-&gt;next = cur-&gt;next;<br>        cur-&gt;next = newNode;<br>        size++;<br>    }<br><br>    <span class="hljs-comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt;= size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur -&gt;next;<br>        }<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        size--;<br>    }<br><br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span> </span>{<br>        LinkedNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;<br>            cur = cur-&gt;next;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<!-- basicblock-start oid="ObsMSRQ9GYQ6MckHgJGq5DWz" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::链表::3. 设计链表.md" --> #历史记录::<br>2022/9/13🌵3. 设计链表 :v2: 调整了一下顺序, 改变了了一下变量名字, 使代码更加好读了, 没有动手写一遍⏱0-25<!-- basicblock-end --><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 移除链表元素</title>
    <link href="/posts/25411/"/>
    <url>/posts/25411/</url>
    
    <content type="html"><![CDATA[<p>2.移除链表元素:: v2, 熟悉一下⏱0-25</p><!-- basicblock-end --><h1 id="1-203移除链表元素"><a class="markdownIt-Anchor" href="#1-203移除链表元素"></a> 1: 203.移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1：<br>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p><p>示例 2：<br>输入：head = [], val = 1<br>输出：[]</p><p>示例 3：<br>输入：head = [7,7,7,7], val = 7<br>输出：[]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路::</h1><p>删除普通元素<br>使用 C, C++语言记得要清理删除的内存<br><img src="https://img-blog.csdnimg.cn/20210316095351161.png" alt="203_链表删除元素1|600"></p><p>删除头结点</p><ul><li><strong>设置一个虚拟头结点在进行删除操作。</strong>(不需要额外的操作)</li><li>直接使用原来的链表来进行删除操作。(需要额外的操作)</li></ul><p>![[移除链表元素.excalidraw|1500]]</p><h2 id="21-总结"><a class="markdownIt-Anchor" href="#21-总结"></a> 2.1: 总结</h2><p>[[虚拟头结点]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>v1</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>        ListNode* dummyHead  = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <br>        dummyHead-&gt;next = head; <br>        ListNode* cur  = dummyHead; <span class="hljs-comment">// 💡用了一个指针指向了 dummyHead 用来操作 dummyHead 中元素</span><br>        <span class="hljs-comment">// ❗️不能直接用 dummyHead-&gt;next, 因为只要就把 dummyHead 的链表改变了</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val){<span class="hljs-comment">// ❗️是cur-&gt;next-&gt;val,不是 cur-&gt;next</span><br>                ListNode* temp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> temp;<span class="hljs-comment">// 💡💡删除的是 dummyHead 的元素,因为操作的是指针</span><br>            }<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;next;<span class="hljs-comment">// 将下一个元素做为头结点</span><br><br>        } <br>        <span class="hljs-comment">// return cur // ❗️因为 cur 的链表是越来越小的</span><br>        head = dummyHead-&gt;next;<span class="hljs-comment">// 💡因为dummyHead 的一个元素是创造出来的</span><br>        <span class="hljs-keyword">delete</span> dummyHead;<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过::</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 构造虚拟头结点:   </span><br>ListNode* dummyHead = new ListNode(<span class="hljs-number">0</span>);<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️❗️不是 cur != NULL, 💡因为 往后移动是cur = cur-&gt;next, cur-&gt;next已经是 NULL 的时候就是到了最后一个元素了</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val){<br>                ListNode* temp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next; <span class="hljs-comment">// 💡也可以这样:cur-&gt;next = temp-&gt;next;</span><br>                <span class="hljs-keyword">delete</span> temp;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                cur = cur-&gt;next;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obsobgw1VATI68hRHB2QcVsT" --> <p>while(cur-&gt;next == NULL), 说明 cur到了链表的最后一个元素::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>    ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    dummyHead-&gt;next = head;<br>    ListNode* cur = dummyHead;<br>    <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span>){ <span class="hljs-comment">// ❗️❗️不是 cur != NULL, 💡因为 往后移动是cur = cur-&gt;next, cur-&gt;next已经是 NULL 的时候💡表明 cur已经到了最后一个元素了</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[C++ new的用法]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.  链表理论基础</title>
    <link href="/posts/22854/"/>
    <url>/posts/22854/</url>
    
    <content type="html"><![CDATA[<h1 id="1-链表的类型"><a class="markdownIt-Anchor" href="#1-链表的类型"></a> 1 链表的类型::</h1><p><strong>链表由数据域和指针域组成</strong></p><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链接的入口节点称为链表的头结点也就是head。</p><p>![[1.  链表理论基础 2022-08-11 09.54.44.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="Obs6RXwhjLDgRAOHUFiOci9w" --> <h1 id="2-链表的存储方式"><a class="markdownIt-Anchor" href="#2-链表的存储方式"></a> 2 链表的存储方式::</h1><!-- basicblock-end --><p>数组是在内存中是连续分布的，<strong>链表是随机分布的,</strong> 他们通过指针来连接彼此,<br>散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。<br>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200806194613920.png" alt="链表3"><br>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p><!-- basicblock-start oid="ObsHVTAYsxhrbeARWSl3ATOM" --> <h1 id="3-链表的定义"><a class="markdownIt-Anchor" href="#3-链表的定义"></a> 3 链表的定义::</h1><!-- basicblock-end --><p>在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p><p>而在面试的时候，一旦要自己手写链表，就写的错漏百出</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) {}  <span class="hljs-comment">// 💡自己节点的构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>{</span><br><span class="hljs-type">int</span> val;<br>ListNode *next;<br>ListNode(<span class="hljs-type">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>){}<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。<br>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p><p>通过自己定义构造函数初始化节点：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></tbody></table></figure><p>使用默认构造函数初始化节点：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</strong></p><h1 id="4-链表的操作"><a class="markdownIt-Anchor" href="#4-链表的操作"></a> 4 链表的操作</h1><!-- basicblock-start oid="ObsgnxP8Llhuq4SUf4kQxCT7" --> <h2 id="41-删除结点"><a class="markdownIt-Anchor" href="#41-删除结点"></a> 4.1 删除结点::</h2><!-- basicblock-end --><p><img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"><br>将 C 的 next 指针指向 E💡将要删除的元素的一个 next 指针指向下下个元素</p><blockquote><p>提前保存 D, 不然找不到了</p></blockquote><p>时间复杂度: O(n)💡如果删除最后一个元素则需要从头结点查找到第 n - 1 个元素修改其 next 指针</p><p>D 节点依然留在内存里<br>在C++里最好是再手动释放这个D节点，释放这块内存。<br>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p><!-- basicblock-start oid="ObsB8Ic2s4aidibg9H5W3Vrz" --> <h2 id="42-添加节点"><a class="markdownIt-Anchor" href="#42-添加节点"></a> 4.2 添加节点::</h2><!-- basicblock-end --><p>![[1.  链表理论基础 2022-08-11 18.07.26.excalidraw]]<br>时间复杂度 O(1), 链表直接能够通过指针查找到元素. 相当于数组通过下标直接找到元素, 找到元素的操作只进行一次所以是 O(1)的时间复杂度</p><!-- basicblock-start oid="ObsU2bUkgfucsnlo2MMrjtJB" --> <h2 id="43-性能分析总结"><a class="markdownIt-Anchor" href="#43-性能分析总结"></a> 4.3 性能分析总结::</h2><!-- basicblock-end --><p>![[1.  链表理论基础 2022-09-20 09.59.14.excalidraw]]</p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7. 总结篇</title>
    <link href="/posts/60314/"/>
    <url>/posts/60314/</url>
    
    <content type="html"><![CDATA[<p>![[7. 总结篇 2022-09-13 09.36.58.excalidraw]]</p><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环不变量原则</title>
    <link href="/posts/53061/"/>
    <url>/posts/53061/</url>
    
    <content type="html"><![CDATA[<p>循环不变量, 不变量: 每次处理的规则::<br>[[2.  二分查找]] : 每次 for 循环中的处理区间都要按照原区间的方式, 那么左闭右闭, 那么左闭右开</p><blockquote><p>在循环中坚持对区间的定义</p></blockquote><p>[[6.螺旋矩阵II]]: 每次赋值的数量: 从起始元素到最后一个元素的前一个元素. 属于是左闭右开类型</p><!-- basicblock-end --><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.螺旋矩阵II</title>
    <link href="/posts/2078/"/>
    <url>/posts/2078/</url>
    
    <content type="html"><![CDATA[<p>2022/9/12🌵6.螺旋矩阵II::v2: 思路好理解, 代码忘了, 又重新总结了一遍⏱0-37</p><!-- basicblock-end --><h1 id="1-59螺旋矩阵ii"><a class="markdownIt-Anchor" href="#1-59螺旋矩阵ii"></a> 1: 59.螺旋矩阵II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p>给定一个正整数&nbsp;n，生成一个包含 1 到&nbsp;n^2&nbsp;所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p>如果输入 4 , 则输出 4 * 4的矩阵, 输出的是正方形的螺旋矩阵.</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路::</h1><p>大家还记得我们在这篇文章<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">数组：每次遇到二分法，都是一看就会，一写就废</a><br>中讲解了二分法，提到如果要写出正确的二分法一定要坚持[[循环不变量原则]]。<br>循环不变量:  不变量是我们队每条边的一个处理规则</p><p>而求解本题依然是要坚持循环不变量原则。<br>不变量: <strong>每次只处理第一个元素到最后元素的前一个</strong></p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。<br>![[6.螺旋矩阵II 2022-08-10 16.27.14.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>v1</p><pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generateMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid  = n / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来控制长度</span>        <span class="hljs-keyword">int</span> loop  = n / <span class="hljs-number">2</span>;         <span class="hljs-keyword">while</span>(loop--){            <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// 设置成全局变量, 因为下面也要用</span>            <span class="hljs-keyword">int</span> j;             <span class="hljs-keyword">for</span>(j = startx; j &lt; n - offset; j++){                res[startx][j] = count;<span class="hljs-comment">// 可以成一行 count++</span>                count++;             }            <span class="hljs-keyword">for</span>(i = starty; i&lt; n - offset; i++){<span class="hljs-comment">// 💡上面 j已经+1 跳出了循环. 已经在边界了</span>                res[i][j] = count++;             }            <span class="hljs-keyword">for</span>(; j &gt; startx; j--){<span class="hljs-comment">// 要大于 startx 而不是 0, 因为下一层循环还要用</span>                res[i][j] = count++;             }             <span class="hljs-keyword">for</span>(; i &gt; starty; i--){                res[i][j] = count++;             }            startx++;             starty++;             offset += <span class="hljs-number">1</span>;         }         <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {            res[mid][mid] = count;        }        <span class="hljs-keyword">return</span> res;    }```v2: 思路好理解, 代码忘了, 又重新总结了一遍```c++<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generateMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>(n, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = n/<span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> loop = n/<span class="hljs-number">2</span>;        <span class="hljs-comment">// eg 3 * 3 矩阵</span>        <span class="hljs-keyword">while</span>(loop--){            <span class="hljs-keyword">int</span> i , j ;            <span class="hljs-keyword">for</span>(j = starty; j &lt; n - offset; j++){                res[startx][j] = count++; <span class="hljs-comment">// i: 第一行, j: 0 → 1 列 </span>            }            <span class="hljs-keyword">for</span>(i = startx; i &lt; n - offset; i++){                res[i][j] = count++; <span class="hljs-comment">// i: 0 → 1 行, j: 第2 列</span>            }            <span class="hljs-keyword">for</span>(; j &gt; starty; j--){                res[i][j] = count++; <span class="hljs-comment">// i:第 2 行, j: 2 → 1 列</span>            }            <span class="hljs-keyword">for</span>(; i  &gt; startx; i--){                res[i][j] = count++;<span class="hljs-comment">// i: 2 → 1 行, j: 0 列</span>            }            startx++;            starty++;            offset++;        }        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){            res[mid][mid] = count;        }        <span class="hljs-keyword">return</span> res;    }};```![[<span class="hljs-number">6.</span>螺旋矩阵II <span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-20</span> <span class="hljs-number">09.42</span><span class="hljs-number">.34</span>.excalidraw]]</code></pre>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 长度最小的子数组</title>
    <link href="/posts/31461/"/>
    <url>/posts/31461/</url>
    
    <content type="html"><![CDATA[<h1 id="1-209长度最小的子数组"><a class="markdownIt-Anchor" href="#1-209长度最小的子数组"></a> 1 209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p>给定一个含有&nbsp;n&nbsp;个正整数的数组和一个正整数&nbsp;s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组&nbsp;[4,3]&nbsp;是该条件下的长度最小的子数组。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p>两个 for 循环不断寻找符合条件的子序列, 时间复杂度: O(n^2), 空间复杂度 O(1)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">// 最终的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的数值之和</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 设置子序列起点为i</span><br>            sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) { <span class="hljs-comment">// 设置子序列终止位置为j</span><br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= s) { <span class="hljs-comment">// 一旦发现子序列和超过了s，更新result</span><br>                    subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 取子序列的长度</span><br>                    result = result &lt; subLength ? result : subLength;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br>                }<br>            }<br>        }<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-滑动窗口"><a class="markdownIt-Anchor" href="#22-滑动窗口"></a> 2.2 滑动窗口</h2><p>滑动窗口的本质还是双指针, 因为只取起始指针和终止指针范围内的值,所以称为滑动窗口</p><p>滑动窗口: <strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>只用一个 for 循环解决暴力循环中两个 for 循环的操作</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。<br>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？<br>此时难免再次陷入 暴力解法的怪圈。<br>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p><!-- basicblock-start oid="ObsWSJkFvX4JeAi5ct8r48Lr" --> <p>s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程::</p><ol><li>j指针去右边, i 不动; 找到符合条件的 i 向右, j 不动, 如果还符合条件, i 继续向右, 直至破坏条件啊改革￥</li><li>不符合条件，j 向右, 重复 1</li><li>直到找到最短的窗口长度<br><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></li></ol><p><img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209|600"></p><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)</strong></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>            sum += nums[j];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target){<br>                subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>                result = subLength &lt; result ? subLength : result;<br>                sum -= nums[i]; <span class="hljs-comment">// 缩短一个数之后的和</span><br>                i++; <span class="hljs-comment">// 缩短区间,💡i不断的++,直至能sum &lt; target 跳出 while 循环</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">0</span> : result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p><p>v2, 通过, 代码忘了, 重新抄了一遍</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>             sum += nums[j];<br>             <span class="hljs-keyword">while</span>(sum &gt;= target){<br>                 subLength = j - i + <span class="hljs-number">1</span>;<br>                 result = subLength &lt; result ? subLength : result;<br>                 sum -= nums[i];<br>                 i++;<br>             }<br>        }<br>        <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">0</span> : result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录</a></p><!-- basicblock-start oid="ObssZGKpwsPauoiKJmWNZfye" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::5. 长度最小的子数组.md" --> <p>#历史记录::<br>2022/09/12🌵5. 长度最小的子数组 : v2, 通过, 代码和思路都忘了, 重新抄了一遍</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器的使用</title>
    <link href="/posts/21713/"/>
    <url>/posts/21713/</url>
    
    <content type="html"><![CDATA[<h1 id="1-vector"><a class="markdownIt-Anchor" href="#1-vector"></a> 1 vector</h1><p>![[vector (🗃)#1 1 初始化]]</p><h1 id="2-array"><a class="markdownIt-Anchor" href="#2-array"></a> 2 array</h1><p>int arrayName [arraySize] :<br>其中 arraySize <strong>不能是变量</strong>,必须是整型常数(如1 0 )或const值,也可以是常量表达式(如8 * sizeof ( int)</p><p>eg : int a [10] = {0}; // ❗️不是一个数的一个要有大括号</p><h1 id="3-deque"><a class="markdownIt-Anchor" href="#3-deque"></a> 3 deque</h1><p>![[容器的使用 2022-08-23 16.53.55.excalidraw]]<br>函数:<br>push_back(); 加到尾部<br>pop_front(); 弹出头部<br>pop_back(); 弹出尾部<br>deque.pop(); 首部元素</p><hr><p><strong>参考资料</strong>—</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 有序数组的平方</title>
    <link href="/posts/34285/"/>
    <url>/posts/34285/</url>
    
    <content type="html"><![CDATA[<h1 id="1-977有序数组的平方"><a class="markdownIt-Anchor" href="#1-977有序数组的平方"></a> 1 977.有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObsrBtXgtkLp1sP3ZfK1ov7B"  --> <h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法::</h2><p>每个数平方之后，排个序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) {<br>            A[i] *= A[i];<br>        }<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 快速排序</span><br>        <span class="hljs-keyword">return</span> A;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>for 循环中乘了 n 次, 时间复杂度为 O(n), <strong>sort 快速排序<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[时间复杂度分析]]">[1]</span></a></sup>O(nlogn)</strong>, 两个函数取大者,总体的时间复杂度为 O(nlogn)</p><blockquote><p>这个时间复杂度本质是 O(n + nlogn)， 取完大头为 O(nlogn)</p></blockquote><!-- basicblock-end --><!-- basicblock-start oid="ObsvJq0mwTJDUyANI6CdXJWo" --> <h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法::</h2><p>数组有序,数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>用两个指针指向头尾, 逐步向中间靠拢, 不断的寻找: <code>数组元素平方的第一大,</code> <code>第二大</code>, …<br>因为每次找的是最大值, 所以结果集中,从后往前赋值. 因为题目要求返回的是递增数组</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt=""></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[容器的使用]]<br>v1</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">sortedSquares</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> {<br>        <span class="hljs-comment">// int i = 0;</span><br>        <span class="hljs-comment">// int j = nums.size() - 1;</span><br>        <span class="hljs-comment">//💡 i 和 j 是要不断循环动的,要写在 for 循环中</span><br>    <br>        <span class="hljs-type">int</span> k = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">result</span><span class="hljs-params">(k+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        <span class="hljs-comment">// i 指向头, j 指向尾</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j = nums.size()<span class="hljs-number">-1</span>; i &lt;= j; ){ <span class="hljs-comment">// 要在元素平方的大小,控制 i,j 的移动</span><br>            <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j] ){<br>                result[k] = nums[i]*nums[i];<br>                k--;<span class="hljs-comment">// 以后要更新结果集的前一个数了,可以在上边直接写成 result[k--]</span><br>                i++;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                result[k] = nums[j]*nums[j];<br>                k--;<br>                j--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>v2,通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(k+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt;= j; ){ <span class="hljs-comment">// 💡在下边控制变量</span><br>            <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j]){<br>                vec[k] = nums[i] * nums[i];<br>                k--;<br>                i++;<br>            }<br>            <span class="hljs-keyword">else</span> {  <span class="hljs-comment">// ❗️不是 else if</span><br>                vec[k] = nums[j] * nums[j];<br>                k--;<br>                j--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> vec;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><!-- basicblock-start oid="ObsXDGFP98ixtrzW0eTavVbh" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::4. 有序数组的平方.md" --> <p>#历史记录::<br>2022/9/11🌵4. 有序数组的平方v2: 复习了一下, 重点是在 for 循环语句里, 控制控制变量的大小⏱0-19</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[时间复杂度分析]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 移除元素</title>
    <link href="/posts/37506/"/>
    <url>/posts/37506/</url>
    
    <content type="html"><![CDATA[<h1 id="1-移除元素"><a class="markdownIt-Anchor" href="#1-移除元素"></a> 1 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><p>给你一个数组 nums&nbsp;和一个值 val，你需要 原地 移除所有数值等于&nbsp;val&nbsp;的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例&nbsp;2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObsQdeRr1Pcsq043uh3NKoQm" --> <p>为什么数组元素不能删除? ::</p><ul><li>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。</li><li>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。[[vector (🗃)]]</li></ul><!-- basicblock-end --><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p><strong>发现需要移除的元素,就将数组集体向前移动一位</strong><br>两层 for 循环, 一个遍历数组,一个更新数组</p><p>时间复杂度: O(n^2) : 第一层for 循环找 n 次, 第二层 for 循环更新n 次, 总时间复杂度为 O(n^2)<br>空间复杂度:O(1): 没有新增空间</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif" alt="27.移除元素-暴力解法"><br>暴力解法</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++){ <span class="hljs-comment">// ❗️如果 i &lt; nums.size() 会导致超时, 还是能用常量用常量</span><br>           <span class="hljs-keyword">if</span>(nums[i] == val){<br>               <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;nums.<span class="hljs-built_in">size</span>(); j++){<br>                   nums[j<span class="hljs-number">-1</span>] =nums[j]; <span class="hljs-comment">// 💡从 i 后边的元素都往前覆盖</span><br>               }<br>                i--; <span class="hljs-comment">// ❓💡因为下标i以后的数值都向前移动了一位，所以i也向前移动一位, 会指向了移动后的元素, 继续判断</span><br>                len--;<br>           }<br><br>    }<br>    <span class="hljs-keyword">return</span> len;<br><br>    }  <br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="Obssbrg6qzSFSKw0WwpEgsBQ" --> <h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法::</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>快指针: 寻找新数组的元素 (查找 n 次, 即 O(n)的时间复杂度)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label=": [[1.  链表理论基础#4 3 性能分析]]">[1]</span></a></sup><br>慢指针: 新数组的下标值<br>总结: 将快指针或者的元素赋给, 慢指针的所对应的下标值<br>![[双指针#1 通过快慢指针给新数组赋值 快指针指向元素 慢指针指向下标]]</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>一刷: 通过<br>双指针</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++){ <span class="hljs-comment">// 类似 int i ,i在不断的跑起来</span><br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val){<br>                nums[slowIndex] = nums[fastIndex]; <span class="hljs-comment">// 给新数组的下标赋值</span><br>                slowIndex++; <span class="hljs-comment">// 下次更新下一个位置</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> slowIndex;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2二刷: 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; <br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(fastIndex; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++){<br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val){<br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            }<br>        }<br>        <span class="hljs-comment">// ❗️不能返回slowIndex + 1, 每添加一个元素 slow 就会 +1 , 最后当slow 就是新数组的长度</span><br>        <span class="hljs-keyword">return</span> slowIndex;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v3, 通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(fastIndex; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++){<br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val){<br>                nums[slowIndex] = nums[fastIndex];<br>                slowIndex++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> slowIndex; <span class="hljs-comment">// 💡每加一个元素都+1, 即最后 slowIndex 就是长度</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p><!-- basicblock-start oid="ObshZuJ6iOHEpWtCNkhtdFTs" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::3. 移除元素.md" --> <p>#历史记录::<br>2022/9/11🌵3. 移除元素 : v3, 有点忘了, 又熟悉了一下⏱0-15</p><!-- basicblock-end --><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>: [[1.  链表理论基础#4 3 性能分析]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 二分查找</title>
    <link href="/posts/42878/"/>
    <url>/posts/42878/</url>
    
    <content type="html"><![CDATA[<h1 id="1-704二分查找"><a class="markdownIt-Anchor" href="#1-704二分查找"></a> 1 704二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>给定一个&nbsp;n&nbsp;个元素有序的（升序）整型数组&nbsp;nums 和一个目标值&nbsp;target &nbsp;，写一个函数搜索&nbsp;nums&nbsp;中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [-1,0,3,5,9,12], target =<span class="hljs-number"> 9 </span>    <br>输出:<span class="hljs-number"> 4 </span>      <br>解释:<span class="hljs-number"> 9 </span>出现在 nums 中并且下标为<span class="hljs-number"> 4 </span>    <br></code></pre></td></tr></tbody></table></figure><p>示例&nbsp;2:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="hljs-section">输出: -1        </span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1        </span><br></code></pre></td></tr></tbody></table></figure><p>提示：</p><ul><li>你可以假设 nums&nbsp;中的所有元素是不重复的。</li><li>n&nbsp;将在&nbsp;[1, 10000]之间。</li><li>nums&nbsp;的每个元素都将在&nbsp;[-9999, 9999]之间。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>二分法使用的前提::</p><ol><li>有序数组<ol><li>能够循环在左右区间内查找</li></ol></li><li>无重复的元素<ol><li>有重复的元素返回的下标不唯 1,</li></ol></li></ol><p>区间的定义决定了二分法的代码怎么写,<br><strong>记住一个原则更新区间端点的时候要保持同步,</strong></p><ul><li>左闭右闭要一直保持左闭右闭</li><li>左闭右开要一直保持左闭右开</li></ul><h2 id="21-数组为左闭右闭区间-a-g"><a class="markdownIt-Anchor" href="#21-数组为左闭右闭区间-a-g"></a> 2.1 数组为左闭右闭区间: [a, … ,g] ::</h2><p>![[二分查找法.excalidraw|1500]]</p><p><strong>定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (target &lt; nums[middle] ) ,right 赋值middle - 1，因为当前这个nums[middle]一定不是target(已经大于了,当然不是) ，那么接下来要查找的左区间(小区间), 结束下标位置就是 middle - 1</li></ul><h2 id="22-数组为左闭右开"><a class="markdownIt-Anchor" href="#22-数组为左闭右开"></a> 2.2 数组为左闭右开</h2><p>target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li><p>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</p></li><li><p>if (nums[middle] &gt; target) right 更新为 middle，因为是左闭右开区间,target 取不到 middle ,最多取到 middle 前一个值 ,因为 [left, middle)</p></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-左闭右闭"><a class="markdownIt-Anchor" href="#31-左闭右闭"></a> 3.1 左闭右闭</h2><p>v1,左闭右闭编译已通过,</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right){<br>            <span class="hljs-type">int</span> middle =  left + (right - left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//❗️ middle 要不断的更新所以要放到while里边去</span><br>            <span class="hljs-keyword">if</span> (target &lt; nums[middle]) { <span class="hljs-comment">// 在左区间里,更新右边界</span><br>            right = middle <span class="hljs-number">-1</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[middle]){ <span class="hljs-comment">// 在右区间里更新,更新左边界</span><br>            left = middle +<span class="hljs-number">1</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<span class="hljs-comment">// ❗️返回下标值,前边要加 else 不然直接返回 middle 了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right){<br>            <span class="hljs-type">int</span> middle = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[middle]) left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// ❗️不是 target &lt; middle 哦</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[middle]) right = middle - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 💡最后一个就是 target = middle 的情况</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-左开右开"><a class="markdownIt-Anchor" href="#32-左开右开"></a> 3.2 左开右开</h2><p>左闭右开的无法填入示例</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 整体区间要一直保持左闭右开</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right){<br>            <span class="hljs-type">int</span> middle =  left + (right - left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//💡 middle 要不断的更新所以要放到里边去</span><br>            <span class="hljs-keyword">if</span> (target &lt; nums[middle]) { <span class="hljs-comment">// 在左区间里,更新右边界</span><br>            right = middle; <span class="hljs-comment">// 保持右开</span><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[middle]){ <span class="hljs-comment">// 在右区间里更新,更新左边界</span><br>            left = middle +<span class="hljs-number">1</span>; <span class="hljs-comment">//保持左闭</span><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<span class="hljs-comment">// 💡返回下标值,前边要加 else 不然直接返回 middle 了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsjIzNqB6ALbk7VC1vTeqQq" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::2.  二分查找.md" --> <p>#历史记录::<br>2022/9/11🌵2. 二分查找 : 只看了左闭右闭 , 完成v2 代码⏱0-37</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/posts/35590/"/>
    <url>/posts/35590/</url>
    
    <content type="html"><![CDATA[<ul><li>10 进制逢 10 进 1,</li><li>2 进制逢 2 进 1</li><li>16 进制逢 16 进 1</li></ul><p>![[进制转换 2022-08-08 10.12.38.excalidraw]]</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208081030695.png" alt=""></p><hr><p><strong>参考资料</strong><br><a href="https://www.bilibili.com/video/BV1PK411g7vy/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">【最强干货】详解二进制，八进制，十进制，十六进制的相互转换_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 数组理论基础</title>
    <link href="/posts/52749/"/>
    <url>/posts/52749/</url>
    
    <content type="html"><![CDATA[<h1 id="1-一维数组"><a class="markdownIt-Anchor" href="#1-一维数组"></a> 1 一维数组::</h1><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong><br>数组可以方便的通过下标索引的方式获取到下标下对应的数据。<br><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png" alt="算法通关数组"></p><ul><li><mark><strong>数组下标都是从0开始的。</strong></mark></li><li><mark><strong>数组内存空间的地址是连续的</strong>, <strong>数组的元素是不能删的，只能覆盖。</strong></mark></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong><br>进行删除操作,后边的数据整体移动到了前边<br>❓移动数据的复杂度是多少 💡: O(n) [[1.  链表理论基础#4 3 性能分析总结]]</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png" alt="算法通关数组1|700"></p><p>而且大家如果使用C++的话，要注意vector 和 array(数组)的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector (🗃)]]">[1]</span></a></sup></p><!-- basicblock-end --><!-- basicblock-start oid="ObsWUSn32Fd2altPLt8ZcpVE" --> <h1 id="2-二维数组"><a class="markdownIt-Anchor" href="#2-二维数组"></a> 2 二维数组::</h1><h2 id="21-c"><a class="markdownIt-Anchor" href="#21-c"></a> 2.1 C++</h2><p><strong>C++中二维数组是连续分布</strong>的</p><p>我们来做一个实验，C++测试代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_arr</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = {<br>{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>},<br>{<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}<br>    };<br>    cout &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] &lt;&lt; endl;<br>    cout &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_arr</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>测试地址为</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x7ffee4065820</span> <span class="hljs-number">0x7ffee4065824</span> <span class="hljs-number">0x7ffee4065828</span><br><span class="hljs-number">0x7ffee406582c</span> <span class="hljs-number">0x7ffee4065830</span> <span class="hljs-number">0x7ffee4065834</span><br></code></pre></td></tr></tbody></table></figure><p>注意地址为16进制<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label="[[进制转换]]</a></sup></p><a href="#fn:2" rel="footnote"></a><p><a href="#fn:2" rel="footnote">#历史记录::<br>2022/9/11: 第一次创建<br>"&gt;[2]</a>，可以看出二维数组地址是连续一条线的。</p><p>![[数组理论基础 2022-08-08 10.31.06.excalidraw]]</p><!-- basicblock-end --><!-- basicblock-start oid="ObsTa39d5VcQuvvfcvNEhPZP" --> <h2 id="22-java中的数据存放"><a class="markdownIt-Anchor" href="#22-java中的数据存放"></a> 2.2 java中的数据存放::</h2><!-- basicblock-end --><p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p><p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_arr</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span>[][] arr = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>}, {<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>}};<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    System.out.println(arr[<span class="hljs-number">1</span>]);<br>    System.out.println(arr[<span class="hljs-number">2</span>]);<br>    System.out.println(arr[<span class="hljs-number">3</span>]);<br>}<br></code></pre></td></tr></tbody></table></figure><p>输出的地址为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[I@<span class="hljs-number">7852e922</span><br>[I@<span class="hljs-number">4e25154f</span><br>[I@70dea4e<br>[I@5c647e05<br></code></pre></td></tr></tbody></table></figure><p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p><p>所以Java的二维数组可能是如下排列的方式：</p><p><img src="https://img-blog.csdnimg.cn/20201214111631844.png" alt="算法通关数组3|600"></p><p>这里面试中数组相关的理论知识就介绍完了。</p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[vector (🗃)]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[进制转换]]<!-- basicblock-start oid="ObsjNmD39YUkPHmsEn4iue5d" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::数组::1. 数组理论基础.md" --> #历史记录::<br>2022/9/11: 第一次创建<!-- basicblock-end --><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码内存消耗</title>
    <link href="/posts/60393/"/>
    <url>/posts/60393/</url>
    
    <content type="html"><![CDATA[<h1 id="1-不同语言的内存管理"><a class="markdownIt-Anchor" href="#1-不同语言的内存管理"></a> 1: 不同语言的内存管理</h1><p>不同的编程语言各自的内存管理方式。</p><p><strong>-   C/C++这种内存堆空间的申请和释放完全靠自己管理</strong></p><ul><li>Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出</li><li>Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。</li></ul><p>例如Python万物皆对象，并且将内存操作封装的很好，<strong>所以python的基本数据类型所用的内存会要远大于存放纯数据类型所占的内存</strong>，例如，我们都知道存储int型数据需要四个字节，但是使用Python 申请一个对象来存放数据的话，所用空间要远大于四个字节。</p><h1 id="2-c的内存管理"><a class="markdownIt-Anchor" href="#2-c的内存管理"></a> 2: [[C++的内存管理]]</h1><h1 id="3-如何计算程序占用多大内存"><a class="markdownIt-Anchor" href="#3-如何计算程序占用多大内存"></a> 3: 如何计算程序占用多大内存</h1><p>想要算出自己程序会占用多少内存就一定要了解自己定义的数据类型的大小，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200804193045440.png" alt="C++数据类型的大小"><br><strong>Byte :字节</strong></p><p>注意图中有两个不一样的地方，为什么64位的指针就占用了8个字节，而32位的指针占用4个字节呢？</p><p><strong>1个字节占8个比特</strong>，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是4G空间的大小，即：<strong>4个Byte可以寻找4G空间大小的内存地址。</strong></p><p>大家现在使用的计算机一般都是64位了，所以编译器也都是64位的。</p><p>注意2^64是一个非常巨大的数，对于寻找地址来说已经足够用了。</p><h2 id="31-总结"><a class="markdownIt-Anchor" href="#31-总结"></a> 3.1: 总结</h2><p>1 字节 = 8 比特</p><p>1 字节 = 8 比特(1 Byte = 8 bit), 4字节 = 32比特, 能够存放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个数据即4G内存, 就能够当寻址内存存放指针<br>安装64位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，<strong>就已经不能寻址全部的内存地址</strong>，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。</p><h1 id="4-内存对齐目录"><a class="markdownIt-Anchor" href="#4-内存对齐目录"></a> 4: [[内存对齐目录]]</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归思想</title>
    <link href="/posts/8679/"/>
    <url>/posts/8679/</url>
    
    <content type="html"><![CDATA[<p>递归思想是：分而治之</p><p>简单的递归：阶乘<br>将大问题不断的拆分为子问题拆到不可拆分之后，自底向上放入栈中<br>在自顶向下不断计算子问题，返回结果给下一层在计算，直至计算出最后一层</p><p>![[递归思想 2022-08-05 15.45.22.excalidraw|1100]]</p><p>使用递归相当于，程序为我们创建了一个栈，我们只需拆分问题放入栈，在分而治之<br>阶乘是线性结构可以直接自底向上的解决而不使<br>但是树的递归就不是了线性了，递归的思想是拆分子问题放入栈，在解决子问题在传递给下一层直至计算完毕<br><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是<code>Segmentation fault</code>（当然不是所有的<code>Segmentation fault</code> 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。</p><p>而且**在企业项目开发中，尽量不要使用递归！**在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong><br>![[递归思想 2022-08-05 17.04.12.excalidraw|1100]]</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV11h411h7nT?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">1-2 栈与深度优先遍历_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>M1 macbook 罗技G502鼠标 g hub显示停用的解决办法</title>
    <link href="/posts/32256/"/>
    <url>/posts/32256/</url>
    
    <content type="html"><![CDATA[<p><mark>与karabiner原有冲突：就是这个原因！！！</mark></p><p>将karabiner中禁用掉G502即可</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">// 其他的错误尝试<br>解决办法<br>1. 卸载原有的g hub 应用<br>2. 在google 里搜索 g hub(最新版)下载。不在火狐里下载是因为中文的可能滞后<br><br><br>1. 本质原因是罗技驱动(g hub)没有做好苹果电脑的适配<br>比如苹果更新系统后，看似给了 g hub 辅助功能的权限实际没给<br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1ri4y1V7cf?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">M1 Mac 装罗技 Logitech G Hub 有问题? Mac OS 中罗技G502和G815在 G Hub中可以显示但不能设置？MacBook_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ new的用法</title>
    <link href="/posts/36172/"/>
    <url>/posts/36172/</url>
    
    <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObsReOPlSEcMgnDTfMU2S00r" --> <p>C++ new的用法 ::<br>new返回的都是指针(指向第一个元素)<br>eg：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">new <span class="hljs-type">int</span>;    <span class="hljs-comment">//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即**指针**）</span><br>new <span class="hljs-type">int</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个**指向该存储空间的地址**</span><br>new <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址</span><br>new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>);<span class="hljs-comment">//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址</span><br>new linklist; <span class="hljs-comment">//申请表头空间 </span><br><span class="hljs-type">float</span> *p=new <span class="hljs-type">float</span> (<span class="hljs-number">3.14159</span>);/开辟一个存放单精度数的空间，并指定该实数的初值为/<span class="hljs-number">3.14159</span>，将返回的该空间的地址赋给指针变量p.<br>   <br><span class="hljs-comment">// 💡例子</span><br><span class="hljs-number">1.</span>new <span class="hljs-type">int</span>[] 是创建一个<span class="hljs-type">int</span>型数组，数组大小是在[]中指定<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//申请一个整型数组，数组的长度为[]中的值</span><br><span class="hljs-number">2.</span>new <span class="hljs-title function_">int</span><span class="hljs-params">()</span>是创建一个<span class="hljs-type">int</span>型数，并且用<span class="hljs-params">()</span>括号中的数据进行初始化,例如：<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// p指向一个值为10的int数。</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空间复杂度分析</title>
    <link href="/posts/11552/"/>
    <url>/posts/11552/</url>
    
    <content type="html"><![CDATA[<h1 id="1-空间复杂度"><a class="markdownIt-Anchor" href="#1-空间复杂度"></a> 1 空间复杂度</h1><p>空间复杂度(Space Complexity)记作S(n)：S(n)=O(f(n))。依然使用大O来表示</p><ol><li>空间复杂度是考虑程序（可执行文件）的大小么？</li></ol><p><strong>空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。</strong><br>利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。</p><ol start="2"><li>空间复杂度是准确算出程序运行时所占用的内存么？<br>不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。</li></ol><p>所以空间复杂度是预先大体评估程序内存使用的大小。</p><p>空间复杂度O(1)： 所开辟的内存空间不会随着n的变化而变化，即空间复杂度为一个常量O(1)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) { <span class="hljs-comment">// n别超过 2^32 - 1就行。(int 的取值范围)</span><br>    j++;<br>}<br></code></pre></td></tr></tbody></table></figure><p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。<br>空间复杂度O(n)：消耗空间和输入参数n保持线性增长</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* a = new <span class="hljs-type">int</span>(n); <span class="hljs-comment">// a指向值为n的int数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    a[i] = i; <span class="hljs-comment">// 不断的扩大a的数组长度</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>new 函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>new <span class="hljs-type">int</span>[] 是创建一个<span class="hljs-type">int</span>型数组，数组大小是在[]中指定<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//申请一个整型数组，数组的长度为[]中的值</span><br><span class="hljs-number">2.</span>new <span class="hljs-title function_">int</span><span class="hljs-params">()</span>是创建一个<span class="hljs-type">int</span>型数，并且用<span class="hljs-params">()</span>括号中的数据进行初始化,例如：<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// p指向一个值为10的int数。</span><br></code></pre></td></tr></tbody></table></figure><p>这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)<br>O(n^2)， O(n^3)：即2 * 2,   3 * 3 矩阵</p><p>空间复杂度是<strong>logn</strong>的情况确实有些特殊，其实是在<strong>递归的时候，会出现空间复杂度为logn的情况</strong>。</p><h1 id="2-总结"><a class="markdownIt-Anchor" href="#2-总结"></a> 2 总结</h1><p>算法的世界里用空间换时间</p><ul><li>用户只关心程序的响应速度</li><li>程序运行完成以后空间可以重复使用</li></ul><p><strong>将经常使用的数据存成变量</strong></p><p>发现时间复杂度很高空间复杂度很低, 就是系统没有记住一些信息, 将常用的信息设置为变量. 以降低时间复杂度<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208111052182.png" alt=""></p><hr><p>[[C++ new的用法]]<br>[[时间复杂度分析]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归算法的复杂度</title>
    <link href="/posts/9398/"/>
    <url>/posts/9398/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!参考资料]<br><a href="https://leetcode.cn/leetbook/read/di-gui-yu-fen-zhi/wrktcd/">登录/注册 - 力扣（LeetCode）</a></p></blockquote><p>![[递归算法的复杂度 .excalidraw]]</p><h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1:</h1><p>递归算法的空间复杂度 = 递归深度N * 每次递归所要的辅助空间</p><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2:</h1><p>递归算法的时间复杂度怎么算？<br>递归函数调用的次数x 每个递归函数本身的复杂度</p><p>递归函数递归的次数是多少？<br>就是递归树上节点的个数，每个节点就代表依次递归调用</p><p><strong>同一道题目，同样使用递归算法，有的同学会写出了O(n)的代码，有的同学就写出了O(logn)的代码</strong>。<br>如果对递归的时间复杂度理解的不够深入的话，就会这样！</p><p>题目： 求x的n次方</p><p>for循环暴力求解</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求x的n次方</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意 任何数的0次方等于1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        result = result * x; <span class="hljs-comment">// result = x，x * x, x^2 * x, ........</span><br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>待解决</tag>
      
      <tag>复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法为什么会超时</title>
    <link href="/posts/26126/"/>
    <url>/posts/26126/</url>
    
    <content type="html"><![CDATA[<h1 id="从硬件配置看计算机的性能"><a class="markdownIt-Anchor" href="#从硬件配置看计算机的性能"></a> 从硬件配置看计算机的性能</h1><p>计算机的运算速度主要看CPU的配置，以2015年MacPro为例<br>CPU配置：2.7 GHz Dual-Core Intel Core i5 。<br>也就是 2.7 GHz 奔腾双核，i5处理器，GHz是指什么呢</p><ul><li>1GHz（兆赫）= 1000MHz（兆赫）</li><li>1MHz（兆赫）= 1百万赫兹</li></ul><p>1Hz = 1/s，<br>1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期）称之为为赫兹，</p><p>所以 <strong>1GHz = 10亿Hz</strong>，表示CPU可以一秒脉冲10亿次（有10亿个时钟周期），这里不要简单理解一个时钟周期就是一次CPU运算。</p><p>例如1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。</p><p>而且计算机的cpu也不会只运行我们自己写的程序上，同时cpu也要执行计算机的各种进程任务等等，我们的程序仅仅是其中的一个进程而已。</p><p><mark>Apple M1具有Apple M-Series的 L1 缓存，基本/<strong>最大CPU频率</strong>为2.06 - 3.20 GHz</mark><br>“英特尔发布 i9-12900KS：最高睿频 5.5GHz，全大核 5.2 GHz”</p><h1 id="测试1s能处理多少个数据"><a class="markdownIt-Anchor" href="#测试1s能处理多少个数据"></a> 测试1s能处理多少个数据</h1><p>算法4里面的一段话：</p><ul><li>火箭科学家需要大致知道一枚试射火箭的着陆点是在大海里还是在城市中；</li><li>医学研究者需要知道一次药物测试是会杀死还是会治愈实验对象；<br><strong>任何开发计算机程序员的软件工程师都应该能够估计这个程序的运行时间是一秒钟还是一年</strong>。</li></ul><p>在写测试程序测1s内处理多大数量级数据的时候，有三点需要注意：</p><ul><li>CPU执行每条指令所需的时间实际上并不相同，例如CPU执行加法和乘法操作的耗时实际上都是不一样的。</li><li>现在大多计算机系统的内存管理都有缓存技术，所以频繁访问相同地址的数据和访问不相邻元素所需的时间也是不同的。</li><li>计算机同时运行多个程序，每个程序里还有不同的进程线程在抢占资源。</li></ul><p>实现三个函数，时间复杂度分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，使用加法运算来统一测试。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> chrono;<br><span class="hljs-comment">// O(n) 简单的for循环加法 0-n</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        k++;<br>    }<br>}<br><br><span class="hljs-comment">// O(n^2) for循环嵌套：循环体内部复杂度相乘 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {<br>            k++;<br>        }<br>    }<br><br>}<br><span class="hljs-comment">// O(nlogn)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> j = <span class="hljs-number">1</span>; j &lt; n; j = j*<span class="hljs-number">2</span>) { <span class="hljs-comment">// 注意这里j=1；j = 1，2,4,8,16(两倍递增)</span><br>            k++;<br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n; <span class="hljs-comment">// 数据规模</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>        cout &lt;&lt; <span class="hljs-string">"输入n："</span>;<br>        cin &gt;&gt; n;<br>        milliseconds start_time = <span class="hljs-built_in">duration_cast</span>&lt;milliseconds &gt;(<br>            system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()<br>        );<br>        <span class="hljs-built_in">function1</span>(n);<br><span class="hljs-comment">//        function2(n);</span><br><span class="hljs-comment">//        function3(n);</span><br>        milliseconds end_time = <span class="hljs-built_in">duration_cast</span>&lt;milliseconds &gt;(<br>            system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()<br>        );<br>        cout &lt;&lt; <span class="hljs-string">"耗时:"</span> &lt;&lt; <span class="hljs-built_in">milliseconds</span>(end_time).<span class="hljs-built_in">count</span>() - <span class="hljs-built_in">milliseconds</span>(start_time).<span class="hljs-built_in">count</span>()<br>            &lt;&lt;<span class="hljs-string">" ms"</span>&lt;&lt; endl;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>O(n)：1s大概能处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">1^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>  的数据，O(n<sup>2)的数量级为O(n)开根号，O(nlogn)比O(n</sup>2)多一点，因为复杂度比它小一点。但比O(n)还是<strong>少一个</strong>数量级<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021618668.png" alt=""></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/On%E7%9A%84%E7%AE%97%E6%B3%95%E5%B1%85%E7%84%B6%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%9A%84n%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A4%9A%E5%A4%A7%EF%BC%9F.html#%E5%81%9A%E4%B8%AA%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C">On的算法居然超时了，此时的n究竟是多大？ | 代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex 环境配置</title>
    <link href="/posts/1424/"/>
    <url>/posts/1424/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><h3 id="latex-数学公式"><a class="markdownIt-Anchor" href="#latex-数学公式"></a> LaTeX 数学公式</h3><p>Hexo 5.0 以上，可尝试 Hexo 官方的 <a href="https://github.com/hexojs/hexo-math">hexo-math</a><br>插件，支持更多定制化参数，使用方式参照仓库内的文档，以下介绍的是主题内置的 LaTeX 功能。</p><p>当需要使用 <a href="https://www.latex-project.org/help/documentation/">LaTeX</a><br>语法的数学公式时，可手动开启本功能，需要完成三步操作：</p><p><strong>1. 设置主题配置</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></tbody></table></figure><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p><code>engine</code>: 公式引擎，目前支持 <code>mathjax</code> 或 <code>katex</code>。</p><p><strong>2. 更换 Markdown 渲染器</strong></p><p>由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。</p><p>先卸载原有渲染器：</p><p><code>npm uninstall hexo-renderer-marked --save</code></p><p>然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p><p>mathjax（可选）:<code>npm install hexo-renderer-pandoc --save</code> <strong>并且还需<a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">安装 Pandoc</a></strong></p><p>katex（必须）: <code>npm install @upupming/hexo-renderer-markdown-it-plus --save</code></p><p><strong>3. 安装完成后执行 <code>hexo clean</code></strong></p><p>书写公式的格式：</p><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>E=mc^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></tbody></table></figure><p>WARNING</p><p>如果公式没有被正确渲染，请仔细检查是否符合上面三步操作。</p><p>不可以同时安装多个渲染插件，包括 <code>hexo-math</code> 或者 <code>hexo-katex</code> 这类插件，请注意检查 <code>package.json</code>。</p><p>如果更换公式引擎，对应渲染器也要一并更换。</p><p>另外不同的渲染器，可能会导致一些 Markdown 语法不支持。</p><p>自定义页面默认不加载渲染，如需使用，需在 Front-matter 中指定 <code>math: true</code></p><p>不同的公式引擎有不同的优缺点。</p><p><strong>MathJax</strong></p><p>优点</p><ul><li>对 LaTeX 语法支持全面</li><li>右键点击公式有扩展功能</li></ul><p>缺点</p><ul><li>需要加载 JS，页面加载会比较慢</li></ul><p><strong>KaTeX</strong></p><p>优点</p><ul><li>没有 JS 不会影响页面加载</li></ul><p>缺点</p><ul><li>小部分 LaTeX 不支持</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">配置指南 | Hexo Fluid 用户手册</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex公式</title>
    <link href="/posts/4371/"/>
    <url>/posts/4371/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p>​ <a href="https://so.csdn.net/so/search?q=LaTeX&amp;spm=1001.2101.3001.7020">LaTeX</a>是一种基于ΤΕΧ的排版系统，而TeX是由著名的计算机科学家<a href="https://baike.baidu.com/item/%E5%94%90%E7%BA%B3%E5%BE%B7%C2%B7%E5%85%8B%E5%8A%AA%E7%89%B9?fromtitle=Donald+E.+Knuth&amp;fromid=2509519">Donald E. Knuth</a>发明的排版系统,可以了解一下他，LaTeX能够优美地生成数学公式且质量极高，本文简要记录其常用公式，以备自查。</p><h1 id="行内公式与行间公式及编号"><a class="markdownIt-Anchor" href="#行内公式与行间公式及编号"></a> 行内公式与行间公式及编号</h1><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span>f(x) = a+b<span class="hljs-built_in">$</span><br><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>f(x)=a+b+c<span class="hljs-keyword">\tag</span>{1.1}<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x) = a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">f(x)=a+b+c\tag{1.1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p>效果显然，使用<code>\tag{}</code> 对公式进行标号</p><h1 id="多项式上下标-根号-分式-对数"><a class="markdownIt-Anchor" href="#多项式上下标-根号-分式-对数"></a> 多项式（上下标）、根号、分式、对数</h1><p>上下标分别用 _{ }和 ^{ } 来标记，{}内为值，可以是公式等等</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span>f(x)=a<span class="hljs-built_in">_</span>{1}<span class="hljs-built_in">^</span>{1-x}+a<span class="hljs-built_in">^</span>{2-x}<span class="hljs-built_in">_</span>{2}+a<span class="hljs-built_in">^</span>{3-x}<span class="hljs-built_in">_</span>{3}<span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>a</mi><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>x</mi></mrow></msubsup><mo>+</mo><msubsup><mi>a</mi><mn>2</mn><mrow><mn>2</mn><mo>−</mo><mi>x</mi></mrow></msubsup><mo>+</mo><msubsup><mi>a</mi><mn>3</mn><mrow><mn>3</mn><mo>−</mo><mi>x</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">f(x)=a_{1}^{1-x}+a^{2-x}_{2}+a^{3-x}_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>\sqrt{ }</strong> 表示平方根，<strong>\sqrt[n]{ }</strong> 表示n次方根，<strong>\frac{ }{ }</strong> 表示分式，两个{}先分子，后分母，对数用 <strong>\log_{2}{343}</strong> 表示</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-keyword">\sqrt</span>{x}+<span class="hljs-keyword">\sqrt</span>[3]{2-x}-<span class="hljs-keyword">\sqrt</span>[x]{<span class="hljs-keyword">\frac</span>{a<span class="hljs-built_in">^</span>x}{b<span class="hljs-built_in">^</span>x}}+<span class="hljs-keyword">\frac</span>{1}{x}+<span class="hljs-keyword">\log</span><span class="hljs-built_in">_</span>{2}{x}<span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mroot><mrow><mn>2</mn><mo>−</mo><mi>x</mi></mrow><mn>3</mn></mroot><mo>−</mo><mroot><mfrac><msup><mi>a</mi><mi>x</mi></msup><msup><mi>b</mi><mi>x</mi></msup></mfrac><mi>x</mi></mroot><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><mo>+</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">\sqrt{x}+\sqrt[3]{2-x}-\sqrt[x]{\frac{a^x}{b^x}}+\frac{1}{x}+\log_{2}{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.17444499999999996em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.736886em;"><span style="top:-2.914666em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8655550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span><span style="top:-2.825555em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17444499999999996em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.62276em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.571968em;"><span style="top:-2.856688em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.21724em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.80948em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.17724em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width="400em" height="1.8800000000000001em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10zM1001 80H400000v40H1013z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.62276em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span></span></p><h3 id="常用符号"><a class="markdownIt-Anchor" href="#常用符号"></a> 常用符号</h3><p><strong>+ - * /</strong> 等可以直接打出</p><p>乘号用\times,点乘用\cdot，除号用\div，不等号用\ne，恒等或同余号用\equiv，整除用\mid,取模用\mod，上取整用\lfloor x \rfloor，下取整用\lceil x \rceil</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\times</span>乘号 <span class="hljs-keyword">\cdot</span>点乘  <span class="hljs-keyword">\div</span>除号  <span class="hljs-keyword">\ne</span>不等号<span class="hljs-keyword">\equiv</span>恒等或同余号 <br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\mid</span>整除 <span class="hljs-keyword">\mod</span> 取模   <span class="hljs-keyword">\lfloor</span> x <span class="hljs-keyword">\rfloor</span> 和 <span class="hljs-keyword">\lceil</span> x <span class="hljs-keyword">\rceil</span><br></code></pre></td></tr></tbody></table></figure><p>\times乘号 \cdot点乘  \div除号  \ne不等号\equiv恒等或同余号<br>\mid整除 \mod 取模   \lfloor x \rfloor 和 \lceil x \rceil</p><p><strong>ps</strong>: \ \ 是分行</p><p>小于号用\lt，大于号用\gt，小于等于号用\le，大于等于号用\ge</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\lt</span>小于号     <span class="hljs-keyword">\gt</span>大于号    <span class="hljs-keyword">\le</span>小于等于号    <span class="hljs-keyword">\ge</span>大于等于号<br></code></pre></td></tr></tbody></table></figure><p>&lt; 小 于 号 &gt; 大 于 号 ≤ 小 于 等 于 号 ≥ 大 于 等 于 号 \lt小于号 \gt大于号 \le小于等于号 \ge大于等于号 &lt;小于号&gt;大于号≤小于等于号≥大于等于号</p><p>集合运算符号</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cup</span>并运算 <span class="hljs-keyword">\quad</span>  <span class="hljs-keyword">\cap</span>交运算 <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\subset</span> 和 <span class="hljs-keyword">\supset</span>  <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\subseteq</span> 和 <span class="hljs-keyword">\supseteq</span> <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\in</span> 和 <span class="hljs-keyword">\notin</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\emptyset</span> 空集<br></code></pre></td></tr></tbody></table></figure><p>∪ 并 运 算 ∩ 交 运 算 ⊂ 和 ⊃ ⊆ 和 ⊇ ∈ 和 ∉ ∅ 空 集 \ \cup并运算 \quad \cap交运算 \qquad \subset 和 \supset \ \subseteq 和 \supseteq \qquad \in 和 \notin \qquad \emptyset 空集 ∪并运算∩交运算⊂和⊃⊆和⊇∈和∈/​∅空集</p><p><strong>ps</strong>: \qquad是空格</p><p>三角符号用\bigtriangleup，三角符号类似\sin,度数用上标^{\cric}表示，角用\angle</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\bigtriangleup</span>三角 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\angle</span> 角<br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\tan</span>90<span class="hljs-built_in">^</span>{<span class="hljs-keyword">\circ</span>}和<span class="hljs-keyword">\sin</span> x和<span class="hljs-keyword">\cos</span> x三角函数及度数表示 <br></code></pre></td></tr></tbody></table></figure><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span><span class="hljs-keyword">\rightarrow</span>和<span class="hljs-keyword">\Rightarrow</span><br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\leftrightarrow</span>和<span class="hljs-keyword">\Leftrightarrow</span><br><span class="hljs-keyword">\\</span><span class="hljs-keyword">\vee</span>和<span class="hljs-keyword">\wedge</span><br><span class="hljs-keyword">\\</span><span class="hljs-keyword">\because</span>和<span class="hljs-keyword">\therefore</span><br><span class="hljs-keyword">\\</span>因为所以<br></code></pre></td></tr></tbody></table></figure><p>→ 和 ⇒ ↔ 和 ⇔ ∨ 和 ∧ ∵ 和 ∴ 因 为 所 以 \ \rightarrow和\Rightarrow \ \leftrightarrow和\Leftrightarrow \ \vee和\wedge \ \because和\therefore \ 因为所以 →和⇒↔和⇔∨和∧∵和∴因为所以</p><p>特殊符号</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\otimes</span>和<span class="hljs-keyword">\oplus</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\nearrow</span>和<span class="hljs-keyword">\searrow</span> <span class="hljs-keyword">\qquad</span><br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\sim</span>和<span class="hljs-keyword">\approx</span>  <span class="hljs-keyword">\qquad</span><span class="hljs-keyword">\ldots</span>和<span class="hljs-keyword">\cdots</span> 不同对齐的省略号<br></code></pre></td></tr></tbody></table></figure><p>⊗ 和 ⊕ ↗ 和 ↘ ∼ 和 ≈ … 和 ⋯ 不 同 对 齐 的 省 略 号 \ \otimes和\oplus \qquad \nearrow和\searrow \qquad \ \sim和\approx \qquad \ldots和\cdots 不同对齐的省略号 ⊗和⊕↗和↘∼和≈…和⋯不同对齐的省略号</p><h3 id="积分-极限-求和-乘积-求导"><a class="markdownIt-Anchor" href="#积分-极限-求和-乘积-求导"></a> 积分、极限、求和、乘积、求导</h3><p>\int表示积分，\lim表示极限， \sum表示求和，\prod表示乘积，<em>’</em> 表示求导，微分中的dx用\mathrm{d}x表示，\to表示箭头，\infty表示无穷</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>{0}<span class="hljs-built_in">^</span>{x}{x<span class="hljs-built_in">^</span>2}<span class="hljs-keyword">\mathrm</span>{d}x +<span class="hljs-keyword">\lim</span><span class="hljs-built_in">_</span>{x <span class="hljs-keyword">\to</span> <span class="hljs-keyword">\infty</span>}{<span class="hljs-keyword">\frac</span>{<span class="hljs-keyword">\sin</span> x}{x}}<br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>{i=1}<span class="hljs-built_in">^</span>{n}{a<span class="hljs-built_in">_</span>ib<span class="hljs-built_in">_</span>i}+<span class="hljs-keyword">\prod</span><span class="hljs-built_in">_</span>{i=1}<span class="hljs-built_in">^</span>{n}{(a<span class="hljs-built_in">_</span>i+b<span class="hljs-built_in">_</span>i)}+f(x)''<br></code></pre></td></tr></tbody></table></figure><p>∫ 0 x x 2 d x + lim ⁡ x → ∞ sin ⁡ x x ∑ i = 1 n a i b i + ∏ i = 1 n ( a i + b i ) + f ( x ) ′ ′ \ \int_{0}<sup>{x}{x</sup>2}\mathrm{d}x +\lim_{x \to \infty}{\frac{\sin x}{x}} \ \sum_{i=1}<sup>{n}{a_ib_i}+\prod_{i=1}</sup>{n}{(a_i+b_i)}+f(x)’’ ∫0x​x2dx+x→∞lim​xsinx​i=1∑n​ai​bi​+i=1∏n​(ai​+bi​)+f(x)′′</p><h3 id="向量-组合数-矩阵"><a class="markdownIt-Anchor" href="#向量-组合数-矩阵"></a> 向量、组合数、矩阵</h3><p>向量用 <strong>\overrightarrow{ }</strong> 表示，组合数用 <strong>\binom{ }{ }</strong> ，其类似于分式</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\overrightarrow</span>{AB} <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\binom</span>{1}{2}<br></code></pre></td></tr></tbody></table></figure><p>A B → ( 1 2 ) \overrightarrow{AB} \qquad \binom{1}{2} AB</p><p>(21​)</p><p>矩阵以起始来规定，内部以&amp;分列，以\分行，括号里可填matrix，bmatrix，pmatrix，vmatrix，分别对应示例(1)(2)(3)(4)</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span> <span class="hljs-keyword">\begin</span>{matrix}<br>0 <span class="hljs-built_in">&amp;</span> 1 <span class="hljs-keyword">\\</span><br>1 <span class="hljs-built_in">&amp;</span> 0 <br><span class="hljs-keyword">\end</span>{matrix} <span class="hljs-built_in">$</span>   <br></code></pre></td></tr></tbody></table></figure><p>0 1 1 0</p><p>01​10​ [ 0 1 1 0 ]</p><p>[01​10​] ( 0 1 1 0 )</p><p>(01​10​) ∣ 0 1 1 0 ∣</p><p>∣∣∣∣​01​10​∣∣∣∣​</p><p>( 1 ) ( 2 ) ( 3 ) ( 4 ) (1)\qquad(2)\qquad(3)\qquad(4) (1)(2)(3)(4)</p><h3 id="方框加粗-上下标记-空格-更大更小的字符"><a class="markdownIt-Anchor" href="#方框加粗-上下标记-空格-更大更小的字符"></a> 方框加粗、上下标记、空格、更大更小的字符</h3><p>\boxed命令给公式加一个方框，\mathbf将字体加粗，\overline, \underline 分别在表达式上、下方画出水平线，\quad和\qquad是空格，\large 或 \small能使字符变大变小</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\boxed</span>{<span class="hljs-keyword">\large</span>{<span class="hljs-keyword">\mathbf</span>{E=mc<span class="hljs-built_in">^</span>2}}}<br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\overline</span>{a+<span class="hljs-keyword">\underline</span>{b+<span class="hljs-keyword">\small</span>{N}}}<br></code></pre></td></tr></tbody></table></figure><p>E = m c 2 a + b + N ‾ ‾ \ \boxed{\large{\mathbf{E=mc^2}}} \ \overline{a+\underline{b+\small{N}}} E=mc2​a+b+N​​</p><h3 id="希腊字母"><a class="markdownIt-Anchor" href="#希腊字母"></a> 希腊字母</h3><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\alpha</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\beta</span>  <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Delta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\zeta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\varepsilon</span> <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\eta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\theta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\lambda</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\mu</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\xi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\pi</span>  <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\rho</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\sigma</span>  <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\upsilon</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Phi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\phi</span> <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\Psi</span>  <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\psi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\omega</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Omega</span> <span class="hljs-keyword">\qquad</span> O<br></code></pre></td></tr></tbody></table></figure><p>α β Δ ζ ε η θ λ μ ξ π ρ σ υ Φ ϕ Ψ ψ ω Ω O \ \alpha \qquad \beta \qquad \Delta \qquad \zeta \qquad \varepsilon \ \eta \qquad \theta \qquad \lambda \qquad \mu \qquad \xi \qquad \pi \ \rho \qquad \sigma \qquad \upsilon \qquad \Phi \qquad \phi \ \Psi \qquad \psi \qquad \omega \qquad \Omega \qquad O αβΔζεηθλμξπρσυΦϕΨψωΩO</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>​ LaTeX是非常有用的，是非常严谨优美的， 在此对<a href="https://baike.baidu.com/item/%E5%94%90%E7%BA%B3%E5%BE%B7%C2%B7%E5%85%8B%E5%8A%AA%E7%89%B9?fromtitle=Donald+E.+Knuth&amp;fromid=2509519">Donald E. Knuth</a>表示敬意。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://blog.csdn.net/weixin_42755533/article/details/113132619?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165940495016781683972226%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165940495016781683972226&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113132619-null-null.142%5Ev37%5Epc_search_v2&amp;utm_term=latex%20%E5%85%AC%E5%BC%8F&amp;spm=1018.2226.3001.4187">LaTeX常用公式_ywlcode的博客-CSDN博客_latex 整除</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技能</tag>
      
      <tag>已迁移</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《C++零基础99题》</title>
    <link href="/posts/57305/"/>
    <url>/posts/57305/</url>
    
    <content type="html"><![CDATA[<p>文章简介：学习资源来自B站UP主：英雄哪里出来</p><span id="more"></span><h1 id="开根号"><a class="markdownIt-Anchor" href="#开根号"></a> 开根号</h1><p>(int) sqrt(x)：函数前面加(int) 就是强转，注意()<br>sqrt平方根函数</p><h1 id="367有效的完全平方数"><a class="markdownIt-Anchor" href="#367有效的完全平方数"></a> 367.有效的完全平方数</h1><p>完全平方数：该数能开根号<br>不能用sqrt，从0开始找数一个个遍历，相乘是否等于num，<br>两数相乘的强转不能加括号，eg：(long long) (i * i)  最后会编译出错<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021728939.png" alt=""></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1da411M798?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">01 函数_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>英雄哪里出来</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用hexo s 引发的一些错误</title>
    <link href="/posts/54162/"/>
    <url>/posts/54162/</url>
    
    <content type="html"><![CDATA[<h1 id="1-不要把没有ymal-字段-的文章放入post文件夹中否则会编译出错"><a class="markdownIt-Anchor" href="#1-不要把没有ymal-字段-的文章放入post文件夹中否则会编译出错"></a> 1 不要把没有ymal 字段 的文章放入post文件夹中，否则会编译出错</h1><p>此处把零散笔记文件夹放入post中<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281050271.png" alt="|600"></p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281055164.png" alt="|600"><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021056860.png" alt=""><br>source 文件夹中的md文件都会被hexo s 编译，所以杂项也不能放入source 文件夹中</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281115268.png" alt="|400"></p><p>用hexo s 时，在myblog(存放hexo整体的文件中)进行命令操作</p><h1 id="2-validationerror-null-is-not-a-string"><a class="markdownIt-Anchor" href="#2-validationerror-null-is-not-a-string"></a> 2 <strong>ValidationError: ‘null’ is not a string!</strong></h1><p>错误说明<br>一般都是因为文章无内容，可能是因为在这篇博客文章中，有某些属性没有填写，比如author属性，tag属性，categories属性等，导致该属性是空的，即<code>null</code>，所以报错。</p><hr><p>自用ob链接：<a href="obsidian://advanced-uri?vault=myblog&amp;uid=858032de-484b-4d7f-a45f-5bab2ca7bb2b">obsidian</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网易云本地音乐怎么添加歌词</title>
    <link href="/posts/27260/"/>
    <url>/posts/27260/</url>
    
    <content type="html"><![CDATA[<p>准备本地的.mp3文件<br>和.mp3文件同名的.lrc文件<br>两者放在一个文件夹中，然后用网抑云云盘上传</p><p>如何制作lrc文件</p><ol><li>将MP3文件导入剪映，智能制作srt文件并导出</li><li>将srt转成lrc文件。转换网站：<a href="http://www.lrccon.com/convert.php">歌词字幕在线转换器 - 支持LRC SRT UTF KSC SSA ASS SMI SNC TXT格式在线转换</a></li></ol><p>问题<br>在手机端看不到歌词，在电脑端可以</p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19.零钱兑换II</title>
    <link href="/posts/48085/"/>
    <url>/posts/48085/</url>
    
    <content type="html"><![CDATA[<h1 id="1-518零钱兑换-ii"><a class="markdownIt-Anchor" href="#1-518零钱兑换-ii"></a> 1 518零钱兑换 II</h1><p><a href="https://leetcode.cn/problems/coin-change-2/">力扣题目链接</a></p><p>难度：中等</p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额)&nbsp;&lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>数量无限→立即想完全背包<br>本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总价值 ，而本题是要求凑成总金额的个数！</strong></p><p>组合不强调顺序，排列强调顺序<br>5 = 2 + 2 + 1<br>5 = 2 + 1 + 2<br>这是一种组合，都是 2 2 1。</p><p>弄清排列和组合问题与遍历顺序息息相关</p><h2 id="21-动归五部曲"><a class="markdownIt-Anchor" href="#21-动归五部曲"></a> 2.1 动归五部曲</h2><ol><li><p>dp[j] 的含义<br>凑成总金额j的货币<strong>组合</strong>数为dp[j]<br>j背包恰好有dp[j]种组合装满：即装满背包有几种方法</p></li><li></li></ol><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#_518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.零钱兑换II</title>
    <link href="/posts/48085/"/>
    <url>/posts/48085/</url>
    
    <content type="html"><![CDATA[<h1 id="1-518零钱兑换-ii"><a class="markdownIt-Anchor" href="#1-518零钱兑换-ii"></a> 1 518零钱兑换 II</h1><p><a href="https://leetcode.cn/problems/coin-change-2/">力扣题目链接</a></p><p>难度：中等</p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额)&nbsp;&lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>数量无限→立即想完全背包<br>本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总价值 ，而本题是要求凑成总金额的个数！</strong></p><p>组合不强调顺序，排列强调顺序<br>5 = 2 + 2 + 1<br>5 = 2 + 1 + 2<br>这是一种组合，都是 2 2 1。</p><p>弄清排列和组合问题与遍历顺序息息相关</p><h2 id="21-动归五部曲"><a class="markdownIt-Anchor" href="#21-动归五部曲"></a> 2.1 动归五部曲</h2><ol><li><p>dp[j] 的含义<br>凑成总金额j的货币<strong>组合</strong>数为dp[j]<br>j背包恰好有dp[j]种组合装满：即装满背包有几种方法</p></li><li></li></ol><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#_518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18.完全背包理论基础</title>
    <link href="/posts/10752/"/>
    <url>/posts/10752/</url>
    
    <content type="html"><![CDATA[<p>01背包：每个物品只有一个(即只能被添加一次)<br>核心代码：先物品后背包，内层倒序(保证物品只被添加一次)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>完全背包：每个物品有无数个(即可以被添加多次)<br>核心代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<span class="hljs-comment">// j从weight[i]开始+，j- weight[]肯定是成立的</span><br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/oly9hwp3.bmp" alt="|500"><br>![[18.完全背包理论基础 2022-07-21 15.39.33.excalidraw|600]]</p><p>是否可以物品和背包的顺序颠倒 #card  #疑问<br>01背包中：先物品在背包，背包for循环倒序。只能<strong>先物品在背包</strong>的和<strong>倒序</strong>的原因是，要保证每一个物品只被添加一次<br>🌵<br>完成背包的含义是物品有无限一个，能够被多次放入。之前的01背包中的限制条件就消失了。即可以先遍历背包后遍历物品，内层for循环也不需要倒序。</p><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.一和零</title>
    <link href="/posts/31990/"/>
    <url>/posts/31990/</url>
    
    <content type="html"><![CDATA[<h1 id="1-474一和零"><a class="markdownIt-Anchor" href="#1-474一和零"></a> 1 474.一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接</a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/"></a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4</p><p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2： 输入：strs = [“10”, “0”, “1”], m = 1, n = 1 输出：2 解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><p>提示：</p><ul><li>1 &lt;= strs.length &lt;= 600</li><li>1 &lt;= strs[i].length &lt;= 100</li><li>strs[i]&nbsp;仅由&nbsp;‘0’ 和&nbsp;‘1’ 组成</li><li>1 &lt;= m, n &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>strs 数组里的元素就是物品，每个物品都是一个！</strong><br><strong>而m 和 n相当于是一个背包，两个维度的背包</strong>。<br>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。但本题是01背包</p><p>动归五部曲</p><ol><li><p>确定dp[j]含义<br><code>dp[i][j]</code>：最多有 i个0 和 j个1的strs的<strong>最大子集的大小</strong>为<code>dp[i][j]</code><br>两个背包，一个i，一个j</p></li><li><p>确定递推公式<br><code>dp[i][j]</code> 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p></li></ol><p><code>dp[i][j]</code> 就可以是 <code>dp[i - zeroNum][j - oneNum]</code> + 1。<br>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code><br>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。后边1 就是多了所求数组中又多一个元素</p><ol start="3"><li><p>dp数组初始化<br>物品价值不会是负数，初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</p></li><li><p>遍历顺序<br>先物品在背包<br>物品就是strs里的字符串，背包容量就是题目描述中的m和n。<br>这个题是背包有两个维度，内层的for循环有两个，还是倒序遍历</p></li><li><p>打印dp数组<br>以输入：[“10”,“0001”,“111001”,“1”,“0”]，m = 3，n = 3为例</p></li></ol><p>最后dp数组的状态如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" alt="474.一和零"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>参考：[[for 循环]]<br>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs){ <span class="hljs-comment">// 遍历改位置的字符串</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 保证到下一个位置的字符，这些one zero还会初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str){ <span class="hljs-comment">// 遍历字符串的每个字符 此时应该是str,而不是strs</span><br>            <span class="hljs-keyword">if</span> ( c == <span class="hljs-string">'0'</span>) zeroNum ++;<br>            oneNum++; <span class="hljs-comment">// 得到了该字符串的01数量</span><br>            }<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--){ <span class="hljs-comment">// 最多能装多少个1</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--){ <span class="hljs-comment">// 最多能装多少个0</span><br>                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-built_in">cout</span>&lt;&lt;dp[i][j];<br>                }<br>            }<br>           <br>            <br>        }<br>  <br>        <span class="hljs-keyword">return</span> dp[m][n];<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721151503.png" alt=""></p><p><strong>参考资料</strong></p><p><a href="https://www.programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#_474-%E4%B8%80%E5%92%8C%E9%9B%B6">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.一和零</title>
    <link href="/posts/31990/"/>
    <url>/posts/31990/</url>
    
    <content type="html"><![CDATA[<h1 id="1-474一和零"><a class="markdownIt-Anchor" href="#1-474一和零"></a> 1 474.一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接</a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/"></a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4</p><p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2： 输入：strs = [“10”, “0”, “1”], m = 1, n = 1 输出：2 解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><p>提示：</p><ul><li>1 &lt;= strs.length &lt;= 600</li><li>1 &lt;= strs[i].length &lt;= 100</li><li>strs[i]&nbsp;仅由&nbsp;‘0’ 和&nbsp;‘1’ 组成</li><li>1 &lt;= m, n &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>strs 数组里的元素就是物品，每个物品都是一个！</strong><br><strong>而m 和 n相当于是一个背包，两个维度的背包</strong>。<br>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。但本题是01背包</p><p>动归五部曲</p><ol><li><p>确定dp[j]含义<br><code>dp[i][j]</code>：最多有 i个0 和 j个1的strs的<strong>最大子集的大小</strong>为<code>dp[i][j]</code><br>两个背包，一个i，一个j</p></li><li><p>确定递推公式<br><code>dp[i][j]</code> 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p></li></ol><p><code>dp[i][j]</code> 就可以是 <code>dp[i - zeroNum][j - oneNum]</code> + 1。<br>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code><br>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。后边1 就是多了所求数组中又多一个元素</p><ol start="3"><li><p>dp数组初始化<br>物品价值不会是负数，初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</p></li><li><p>遍历顺序<br>先物品在背包<br>物品就是strs里的字符串，背包容量就是题目描述中的m和n。<br>这个题是背包有两个维度，内层的for循环有两个，还是倒序遍历</p></li><li><p>打印dp数组<br>以输入：[“10”,“0001”,“111001”,“1”,“0”]，m = 3，n = 3为例</p></li></ol><p>最后dp数组的状态如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" alt="474.一和零"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>参考：[[for 循环]]<br>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs){ <span class="hljs-comment">// 遍历改位置的字符串</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 保证到下一个位置的字符，这些one zero还会初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str){ <span class="hljs-comment">// 遍历字符串的每个字符 此时应该是str,而不是strs</span><br>            <span class="hljs-keyword">if</span> ( c == <span class="hljs-string">'0'</span>) zeroNum ++;<br>            oneNum++; <span class="hljs-comment">// 得到了该字符串的01数量</span><br>            }<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--){ <span class="hljs-comment">// 最多能装多少个1</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--){ <span class="hljs-comment">// 最多能装多少个0</span><br>                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-built_in">cout</span>&lt;&lt;dp[i][j];<br>                }<br>            }<br>           <br>            <br>        }<br>  <br>        <span class="hljs-keyword">return</span> dp[m][n];<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721151503.png" alt=""></p><p><strong>参考资料</strong></p><p><a href="https://www.programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#_474-%E4%B8%80%E5%92%8C%E9%9B%B6">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16.目标和</title>
    <link href="/posts/60439/"/>
    <url>/posts/60439/</url>
    
    <content type="html"><![CDATA[<h1 id="1-目标和"><a class="markdownIt-Anchor" href="#1-目标和"></a> 1 目标和</h1><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号&nbsp;+&nbsp;和&nbsp;-。对于数组中的任意一个整数，你都可以从&nbsp;+&nbsp;或&nbsp;-中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>假设加法总和为x， → 减法总和 = sum - x。<br>目标和 = 加法总和 - 减法总和 → S = x - (sum - x)<br>→ x = (S + sum) / 2</p><p>此时化为 ：就是从数组中挑几个数加起来正好等于x</p><p><strong>特例判断</strong></p><ol><li>假设加法和是非整数，即 (S + sum) / 2 除不尽，说明有余数，又因为加法和是整数，有余数不可能符合等号条件。所以：</li></ol><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">0</span>; // 此时没有方案<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</li></ol><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>动归五部曲</p><ol><li><p>确定dp[j]的含义<br>恰好装满背包容量为j的背包，一共有dp[j]种方法</p></li><li><p>确定递推公式<br>先记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为： #card #疑问</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[j] = dp[j] + dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><p>dp数组的初始化<br>dp[0] = 1，显然装满容量为0的背包，有1种方法，就是装0件物品。<br>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出<code>dp[j] = dp[j] + dp[j - nums[i]];</code>，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p></li><li><p>确定遍历顺序<br>先物品在背包，背包for循环倒序</p></li><li><p>举例推导dp数组</p></li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> {<br>        <span class="hljs-type">int</span> bagsize;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br>        bagsize = (sum + target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagsize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagsize; j &gt;= nums[i]; j--){<br>                dp[j] = dp[j] + dp[j - nums[i]];<br>        <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[target];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720234829.png" alt=""></p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16.目标和</title>
    <link href="/posts/60439/"/>
    <url>/posts/60439/</url>
    
    <content type="html"><![CDATA[<h1 id="1-目标和"><a class="markdownIt-Anchor" href="#1-目标和"></a> 1 目标和</h1><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号&nbsp;+&nbsp;和&nbsp;-。对于数组中的任意一个整数，你都可以从&nbsp;+&nbsp;或&nbsp;-中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>假设加法总和为x， → 减法总和 = sum - x。<br>目标和 = 加法总和 - 减法总和 → S = x - (sum - x)<br>→ x = (S + sum) / 2</p><p>此时化为 ：就是从数组中挑几个数加起来正好等于x</p><p><strong>特例判断</strong></p><ol><li>假设加法和是非整数，即 (S + sum) / 2 除不尽，说明有余数，又因为加法和是整数，有余数不可能符合等号条件。所以：</li></ol><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">0</span>; // 此时没有方案<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</li></ol><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>动归五部曲</p><ol><li><p>确定dp[j]的含义<br>恰好装满背包容量为j的背包，一共有dp[j]种方法</p></li><li><p>确定递推公式<br>先记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为： #card #疑问</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[j] = dp[j] + dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><p>dp数组的初始化<br>dp[0] = 1，显然装满容量为0的背包，有1种方法，就是装0件物品。<br>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出<code>dp[j] = dp[j] + dp[j - nums[i]];</code>，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p></li><li><p>确定遍历顺序<br>先物品在背包，背包for循环倒序</p></li><li><p>举例推导dp数组</p></li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> {<br>        <span class="hljs-type">int</span> bagsize;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br>        bagsize = (sum + target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagsize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagsize; j &gt;= nums[i]; j--){<br>                dp[j] = dp[j] + dp[j - nums[i]];<br>        <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[target];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720234829.png" alt=""></p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.动归周总结</title>
    <link href="/posts/47640/"/>
    <url>/posts/47640/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> <strong>参考资料</strong></h2><p>自用跳转链接：🈚</p><p>也添加在11-14的文档中</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian flashcard 插件</title>
    <link href="/posts/11266/"/>
    <url>/posts/11266/</url>
    
    <content type="html"><![CDATA[<p>插件：flashcard的使用方法：<a href="https://github.com/reuseman/flashcards-obsidian/wiki">Home · reuseman/flashcards-obsidian Wiki · GitHub</a></p><h1 id="1-简单配置"><a class="markdownIt-Anchor" href="#1-简单配置"></a> 1 简单配置</h1><p>anki connect 添加</p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c">{<br>    <span class="hljs-string">"apiKey"</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">"apiLogPath"</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">"webBindAddress"</span>: <span class="hljs-string">"127.0.0.1"</span>,<br>    <span class="hljs-string">"webBindPort"</span>: <span class="hljs-number">8765</span>,<br>    <span class="hljs-string">"webCorsOrigin"</span>: <span class="hljs-string">"http://localhost"</span>,<br>    <span class="hljs-string">"webCorsOriginList"</span>: [<br>        <span class="hljs-string">"http://localhost"</span>,<br>        <span class="hljs-string">"app://obsidian.md"</span>   <span class="hljs-meta">## 添加这一个</span><br>    ] <br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-无法添加的解决方法"><a class="markdownIt-Anchor" href="#2-无法添加的解决方法"></a> 2 无法添加的解决方法</h1><ol><li>anki 不能在浏览页面</li><li>删除id后，anki牌组不能有之前文件</li><li>问题前面加一个标题，添加后，然后在删掉就行</li><li>yaml字段自动生成的card-deck 字段，相对(valut)的路径不应太长，否则就只能添加Default</li></ol><p>小问题<br>根据文件夹创建目录，如果文件夹的层级太多就会失效</p><h1 id="3-使用"><a class="markdownIt-Anchor" href="#3-使用"></a> 3 使用</h1><h2 id="31-分隔符"><a class="markdownIt-Anchor" href="#31-分隔符"></a> 3.1 分隔符</h2><ol><li>::</li></ol><center> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721165055.png"> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721165345.png"> </center><center> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721164811.png"> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721164922.png"> </center><ol start="2"><li>:::<br><img src="" alt=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.最后一块石头的重量 II</title>
    <link href="/posts/62628/"/>
    <url>/posts/62628/</url>
    
    <content type="html"><![CDATA[<h1 id="1-11049最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1-11049最后一块石头的重量-ii"></a> 1 11049.最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;x 和&nbsp;y，且&nbsp;x &lt;= y。那么粉碎的可能结果如下：</p><p>如果&nbsp;x == y，那么两块石头都会被完全粉碎； 如果&nbsp;x != y，那么重量为&nbsp;x&nbsp;的石头将会完全粉碎，而重量为&nbsp;y&nbsp;的石头新重量为&nbsp;y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>1049.最后一块石头的重量 II 为什么能转化为 01背包问题 #card #疑问 #已解决<br>自顶向下的考虑，算出所有石头的重量和，如果能分成一半一半，那说明正好可以撞完<br>如果不能恰好分成一半一半，让分成的两大块尽量靠近一半。一边大一边小，相减也得到碰撞后的最小重量<br>问题就变成了：创造一个sum/2的背包。在这个背包里尽量装满。<br>如果背包装的满即表示能分成一半一半，也就是最后能撞完。<br>如果没装完，(sum- 装的重量) - 装的重量= half<sup>+</sup>  - half<sup>-</sup> = 相撞后的重量<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720164608.png" alt=""></p><p>本题物品的重量为store[i]，物品的价值也为store[i]。重量和价值是一样的<br>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p><ol><li><p>确定dp[j]的含义<br>j背包下最多可以装dp[j]的重量</p></li><li><p>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li><p>dp数组的初始化 #card #疑问<br>为什么要要一半<br>题目如下要求，最多重量是30000</p></li></ol><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000<br>我们只需要计划总重量的一半<br>dp数组的大小为15000，都初始化为0：<code>vector&lt;int&gt; dp(15001, 0);</code> 从0开始，要多一位</li></ul><ol start="4"><li><p>遍历顺序<br>先物品在背包，背包循环倒序</p></li><li><p>打印dp数组<br>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：<br>用store[1]遍历时<br>dp[4] = max(dp[4], dp[4 - store[1]]+ store[1]) =max(2, 2+2)<br><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p></li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> {<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>,<span class="hljs-number">0</span>)</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            sum += stones[i];<br>        }<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--){<br>                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> (sum - dp[target]) - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>本题与[[13.分割等和子集]]一个类型，不同之处是前者要求能装多少装多，后者要求正好装满</p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1G3411E7oX?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode1049 最后一块石头的重量II 题解_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.最后一块石头的重量 II</title>
    <link href="/posts/62628/"/>
    <url>/posts/62628/</url>
    
    <content type="html"><![CDATA[<h1 id="1-11049最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1-11049最后一块石头的重量-ii"></a> 1 11049.最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;x 和&nbsp;y，且&nbsp;x &lt;= y。那么粉碎的可能结果如下：</p><p>如果&nbsp;x == y，那么两块石头都会被完全粉碎； 如果&nbsp;x != y，那么重量为&nbsp;x&nbsp;的石头将会完全粉碎，而重量为&nbsp;y&nbsp;的石头新重量为&nbsp;y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>1049.最后一块石头的重量 II 为什么能转化为 01背包问题 #card  #已解决<br>自顶向下的考虑，算出所有石头的重量和，如果能分成一半一半，那说明正好可以撞完<br>如果不能恰好分成一半一半，让分成的两大块尽量靠近一半。一边大一边小，相减也得到碰撞后的最小重量<br>问题就变成了：创造一个sum/2的背包。在这个背包里尽量装满。<br>如果背包装的满即表示能分成一半一半，也就是最后能撞完。<br>如果没装完，(sum- 装的重量) - 装的重量= half<sup>+</sup>  - half<sup>-</sup> = 相撞后的重量<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720164608.png" alt=""></p><p>本题物品的重量为store[i]，物品的价值也为store[i]。重量和价值是一样的<br>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p><ol><li><p>确定dp[j]的含义<br>j背包下最多可以装dp[j]的重量</p></li><li><p>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li><p>dp数组的初始化 #card #疑问<br>为什么要要一半<br>题目如下要求，最多重量是30000</p></li></ol><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000<br>我们只需要计划总重量的一半<br>dp数组的大小为15000，都初始化为0：<code>vector&lt;int&gt; dp(15001, 0);</code> 从0开始，要多一位</li></ul><ol start="4"><li><p>遍历顺序<br>先物品在背包，背包循环倒序</p></li><li><p>打印dp数组<br>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：<br>用store[1]遍历时<br>dp[4] = max(dp[4], dp[4 - store[1]]+ store[1]) =max(2, 2+2)<br><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p></li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> {<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>,<span class="hljs-number">0</span>)</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            sum += stones[i];<br>        }<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--){<br>                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> (sum - dp[target]) - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>本题与[[13.分割等和子集]]一个类型，不同之处是前者要求能装多少装多，后者要求正好装满</p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1G3411E7oX?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode1049 最后一块石头的重量II 题解_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图床的设置</title>
    <link href="/posts/25586/"/>
    <url>/posts/25586/</url>
    
    <content type="html"><![CDATA[<p>前期设置参考以下文章<br><a href="https://blog.csdn.net/qq_38163244/article/details/110637898?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165814246716781790729080%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165814246716781790729080&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-110637898-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Etag_show&amp;utm_term=%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">阿里云搭建图床_理科男同学的博客-CSDN博客_阿里云图床</a></p><p>picgo如何添加设置<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220718191920.png" alt=""><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/cf534d30e5f74c2b2bbf1545bfb68f3.png" alt=""></p><p>LTAI5tLUoXsgd7XWbdxf9ig2<br>lRXSiwrDFzVeqOsECPaIH9viKeof3p</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.分割等和子集</title>
    <link href="/posts/38902/"/>
    <url>/posts/38902/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分割等和子集"><a class="markdownIt-Anchor" href="#1-分割等和子集"></a> 1 分割等和子集</h1><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接</a></p><p>题目难易：中等</p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p><p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例&nbsp;2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>1 &lt;= nums[i] &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p><p>只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p><p>背包的总容量为 sum/2，每个物品的价值就是他们数组值(应该是这样咯)</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的物品（集合里的元素）重量为 元素的数值，价值也为元素的数值(重量与价值相等)</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。(01背包：每个物品只放一次)</li></ul><ol><li><p>确定dp数组以及下的含义<br>01背包中，dp[j] 表示： 容量为j的背包，所背的物品最大价值为dp[j]。<br><strong>套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]</strong></p></li><li><p>确定递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p></li><li><p>dp数组如何初始化<br>全部初始化为0</p></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br><span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序<br>先物品在背包，for循环第二层倒序</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 开始 01背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>dp[j]的数值一定是小于等于j的。因为dp[j]是价值，j是背包容量</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，即价值=容量，理解这一点很重要。</strong></p><blockquote><p>因为按本题来说：价值等于背包容量</p></blockquote><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210110104240545.png" alt="416.分割等和子集2"></p><p>一层一层的，从后往前赋值的</p><p>最后dp[11] == 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> target;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){<br>            sum += nums[i];<br>        }<br>        target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;=nums[i]; j--){<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-nums[i]]+nums[i]); <br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (dp[target]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[13.mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/动态规划/13.分割等和子集.mp4)</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.0-1背包理论基础（二）</title>
    <link href="/posts/38995/"/>
    <url>/posts/38995/</url>
    
    <content type="html"><![CDATA[<h1 id="1-滚动数组思路"><a class="markdownIt-Anchor" href="#1-滚动数组思路"></a> 1 滚动数组思路</h1><p>滚动数组，就是把二维dp降为一维dp<br><strong>如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p><blockquote><p>上一次的i,j 的值存在max里边，不断的比较得到最大值</p></blockquote><p>滚动数组：在同一层中，不断的进行覆盖然后刷新</p><p>动规五部曲分析如下：</p><h2 id="11-确定dp数组的定义"><a class="markdownIt-Anchor" href="#11-确定dp数组的定义"></a> 1.1 确定dp数组的定义</h2><p>dp[j]：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><h2 id="12-一维dp数组的递推公式"><a class="markdownIt-Anchor" href="#12-一维dp数组的递推公式"></a> 1.2 一维dp数组的递推公式</h2><p>整体思路： 想想如何从前面的数推过来</p><p>dp[j]有两个选择，<br>不放物品i：dp[j]， 未覆盖的值</p><p>放物品i：dp[j - weight[i]] + value[i]，覆盖后的值<br>(总重量 - 要放物品的重量)的最大价值+要放物品的价值<br>除去要放物品的背包 的价值 + 要放物品的价值<br>Q：万一放不了呢，之前二维数组是有一个判断语句，一维中没有啊？<br>A：<code>for(int j = bagWeight; j &gt;= weight[i]; j--)</code>。一维中也有判断语句，进入for循环的条件是背包容量大于所放物品i的重量</p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[j]</span> = max(dp<span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[j - weight<span class="hljs-comment">[i]</span>]</span> + value<span class="hljs-comment">[i]</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="13-一维dp数组如何初始化"><a class="markdownIt-Anchor" href="#13-一维dp数组如何初始化"></a> 1.3 一维dp数组如何初始化</h2><p>dp[0]=0：背包容量为0所背的物品的最大价值是0<br>其他的值都初始为0就行，因为递推公式中会赋值<br>不能初始化太大的值，防止取最大值的时候覆盖掉真实结果<br><strong>总结</strong>：其实全部初始化为0即可</p><h2 id="14-一维dp数组遍历顺序"><a class="markdownIt-Anchor" href="#14-一维dp数组遍历顺序"></a> 1.4 一维dp数组遍历顺序</h2><p><strong>只能先物品后背包</strong><br>如果顺序被颠倒，那么dp数组中记录的都是一个物品的数值了<br><strong>倒序遍历：保证物品只放入一次</strong><br>看下面的例子</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品，二维数组的行，反复覆盖</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// j = 背包容量，也不要忘了=（背包容量等于重量时也可以加入的）</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<span class="hljs-comment">// 不断更新该行的列向量</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么不能正序遍历：例子<br>?<br><code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code><br>物品0的重量<strong>weight[0] = 1</strong>，价值<strong>value[0] = 15</strong><br>如果正序遍历，此时//  [[for 循环]]</p><p>正序循环中的第二for循环的条件应该怎么写  #card #已解决</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 先遍历物品，再遍历背包，内层for循环正序遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>dp[1] = dp[1 - weight[0]] + value[0] = 15<br>dp[2] = dp[2 - weight[0]] + value[0] = 30<br>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历<br>说白了，当前dp[i]要使用上一层左侧的dp值，正序覆盖了上一层左侧的dp值，倒叙避免了覆盖</p><p>倒序遍历：<br><code>vector&lt;int&gt; dp(bagWeight + 1, 0);</code> 原来的初始化是0<br>dp[2] = dp[2 - weight[0]] + value[0] = 15</p><blockquote><p>倒序计算时，由于 dp 数组初始化为 0，所以 dp[2-1] 为 0，所以 dp[2] 为 15</p></blockquote><p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p><h2 id="15-举例推导dp数组"><a class="markdownIt-Anchor" href="#15-举例推导dp数组"></a> 1.5 举例推导dp数组</h2><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p><h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_1_wei_bag_problem</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    <span class="hljs-built_in">cout</span> &lt;&lt; dp[bagWeight] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    test_1_wei_bag_problem();<br>}<br></code></pre></td></tr></tbody></table></figure><p>一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了，<strong>空间复杂度还降了一个数量级</strong><br>推荐用一维数组</p><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3 总结</h1><h2 id="31-面试问题"><a class="markdownIt-Anchor" href="#31-面试问题"></a> 3.1 面试问题</h2><p>要求先实现一个纯二维的01背包,如果写出来了,然后再问为什么两个for循环的嵌套顺序这么写?反过来写行不行 #card<br>第一种是先物品后背包的遍历，根据状态转移方程可得，当前值由该位置的上方和左上上方来确定，首先初始化了第一行和第一列的值，这种先物品后背包的方式，是从左到右的一个个行遍历赋值。遍历到<code>dp[i][j]</code>时，它的上方和左上方都赋值完毕，可以推导出来<br>第二种是先背包后物品的遍历，遍历方式是从上到下的一列一列的遍历赋值。遍历到<code>dp[i][j]</code>时，它的整个左部分都赋值完毕，上方也赋值了。同理可推导出来。<br>所以反过来写是可以的</p><p>[[讲一讲01背包初始化的逻辑。]]</p><p>一维数组的01背包，两个for循环的顺序反过来写行不行 #card #疑问<br>不行，</p><p>注意以上问题都是在候选人把代码写出来的情况下才问的。</p><hr><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a></p><p>[[测试deck]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名失效问题</title>
    <link href="/posts/62729/"/>
    <url>/posts/62729/</url>
    
    <content type="html"><![CDATA[<p>本地source文件添加一个文件：CNAME文件(不要任何的后缀)</p><p>下一次hexo d 就会传上去</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub如何取消域名绑定</title>
    <link href="/posts/14830/"/>
    <url>/posts/14830/</url>
    
    <content type="html"><![CDATA[<p>删除本地source下的CNAME和GitHub上的CNAME文件<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121716990.png" alt=""></p><p>清楚浏览器缓冲<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121715979.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo如何创建短的url</title>
    <link href="/posts/15258/"/>
    <url>/posts/15258/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/rozbo/hexo-abbrlink2">GitHub - rozbo/hexo-abbrlink2</a></p><p>安装插件→添加config信息</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度分析</title>
    <link href="/posts/30259/"/>
    <url>/posts/30259/</url>
    
    <content type="html"><![CDATA[<p>📝时间复杂度分析::</p><!-- basicblock-end --><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1: 概念</h1><h2 id="11-定义1"><a class="markdownIt-Anchor" href="#11-定义1"></a> 1.1: 定义[^1]</h2><p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。<br>估计程序运行时间：通常会估算算法的<strong>操作单元数量</strong>来代表程序消耗的时间</p><blockquote><p>这里默认CPU的每个单元运行消耗的时间都是相同的。</p></blockquote><p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p><p>时间复杂度对应的是物理上的加速度[^2]<br>![[时间复杂度分析 2022-08-05 17.27.42.excalidraw]]</p><h2 id="12-复杂度分析"><a class="markdownIt-Anchor" href="#12-复杂度分析"></a> 1.2: 复杂度分析</h2><p>复杂度分析只考虑最坏的情况<br><strong>大O用来表示上界的</strong>，它作为算法的最坏情况运行时间的上界</p><p>我们主要关心的还是一般情况下的数据形式。</p><p><strong>面试中说道算法的时间复杂度是多少，指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p><h2 id="13-不同数据规模的差异"><a class="markdownIt-Anchor" href="#13-不同数据规模的差异"></a> 1.3: 不同数据规模的差异</h2><p><img src="https://img-blog.csdnimg.cn/20200728191447384.png" alt="时间复杂度，不同数据规模的差异|500"></p><p><strong>我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^{2})&lt;O(2^{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208051803308.png" alt=""></p><p>但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了<br>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）</p><h2 id="14-ologn中的log是以什么为底"><a class="markdownIt-Anchor" href="#14-ologn中的log是以什么为底"></a> 1.4: O(logn)中的log是以什么为底？</h2><p><strong>logn，也就是忽略底数的描述</strong>。也可以是以10为底n的对数，也可以是以20为底n的对数，等等<br><code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code>。<br>而以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121533152.png" alt="|500"></p><h1 id="计算时间复杂度"><a class="markdownIt-Anchor" href="#计算时间复杂度"></a> [[计算时间复杂度]]</h1><h1 id="2-例子"><a class="markdownIt-Anchor" href="#2-例子"></a> 2: 例子</h1><h2 id="21-找出n个字符串中相同的两个字符串假设这里只有两个相同的字符串"><a class="markdownIt-Anchor" href="#21-找出n个字符串中相同的两个字符串假设这里只有两个相同的字符串"></a> 2.1: 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。</h2><p>先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。</p><p>那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。</p><h2 id="22-01背包"><a class="markdownIt-Anchor" href="#22-01背包"></a> 2.2: 01背包</h2><p>暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里的n表示物品数量。</p><h1 id="3-参考资料"><a class="markdownIt-Anchor" href="#3-参考资料"></a> 3: 参考资料</h1><p>初识时间复杂度_哔哩哔哩_bilibili](<a href="https://www.bilibili.com/video/BV11h411h7nT?p=4&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">https://www.bilibili.com/video/BV11h411h7nT?p=4&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a</a>)</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>11.0-1背包理论基础</title>
    <link href="/posts/8980/"/>
    <url>/posts/8980/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p><h1 id="1-01-背包"><a class="markdownIt-Anchor" href="#1-01-背包"></a> 1 01 背包</h1><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题|600"><br><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p><p>01 背包：一个商品只能放入一次<br>完全背包：即物品无限个，可多次放入背包<br>多重背包：每个物品，数量不同</p><p>原始可用暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><h1 id="2-二维dp数组01背包"><a class="markdownIt-Anchor" href="#2-二维dp数组01背包"></a> 2 二维dp数组01背包</h1><p>背包最大重量为4。</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><ol><li>确定dp数组以及下标的含义<br>对于背包问题，有一种写法， 是使用二维数组，<strong>即<code>dp[i][j]</code> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1|600"></li><li>递推公式<br>有两个方向推出来<code>dp[i][j]</code>，</li></ol><ul><li><strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>、头顶格子</li></ul><blockquote><p>(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)<br>i-1是指：只能选择的物品范围是 i-1，而不是真的放了i-1个物品</p></blockquote><ul><li><strong>放物品i</strong>：<code>dp[i - 1][j - weight[i]] + value[i]</code> ，左上方格子</li></ul><blockquote><p>某一列中缺失掉哪一个物品</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719160159.png" alt=""></p><p>从两个方向推出来：1.头顶上一格  2.左上角的一块地方(不是左上角一格)</p><p>所以递归公式：</p><p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs col">```<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155624.png)<br><br>以`dp[1] [3]`为例<br>`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`<br>`dp[1][3] = max(dp[0][3], dp[0][3 - weight[1]] + value[1]);`<br><br>头顶格子：20之前那的值是15，原因是背包重量不够装物品1，即为`dp[i - 1][j]`，`dp[1 -1= 0][3]` ：即头顶格子<br>左上方格子：`dp[0][3 - weight[1]] + value[1]`=`dp[0][0] + value[1]`：(减去要装的重量)的价值 + 要装的价值<br>为什么要取最大值呢<br>?<br>因为装了物品i，有可能会导致前边的一些物品丢弃掉。而丢弃的物品可能价值很大。所以要比较他们的最大值<br><br><br><br><br><br>3.  dp数组如何初始化<br>初始化第一行，第一列。剩下元素即可都推出来<br>从两个方向推出来：1.头顶上一格  2.左上方(不是左上角)<br><br><br>第一列：背包容量为0，一个也装不了，总价值当然为0<br>第一行：物品0的重量为1，所以背包容量&gt;1都可以装物品0一个，所以价值是15<br>![动态规划-背包问题7|600](https://img-blog.csdnimg.cn/20210110103109140.png)<br>其余未赋值的都保持默认0即可，反正最后都会被覆盖掉<br>[[vector (🗃)]]<br>```c<br>// 初始化 dp<br>vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));<br>for (int j = weight[0]; j &lt;= bagweight; j++) {<br>    dp[0][j] = value[0];<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序<br>有两个遍历的维度：物品与背包重量</li></ol><p><strong>先遍历 物品还是先遍历背包重量都可以</strong><br>先物品在背包，就是一行一行的遍历(从左到右)，遍历到20时，他的左上方和上方都有值<br>先背包在物品，就是一列一列的遍历(从上到下)，遍历到20时，他的左边全部有值(即左上面有值)，上方也全都有值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs col">![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155624.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155536.png)<br></code></pre></td></tr></tbody></table></figure><p><strong>先遍历物品更好理解</strong>，如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];  <span class="hljs-comment">// i的重量太大，放不下</span><br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>先遍历背包</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_2_wei_bag_problem1</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagweight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 二维数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    }<br><br>    <span class="hljs-comment">// weight数组的大小 就是物品个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>        }<br>    }<br><br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_2_wei_bag_problem1</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">带你学透0-1背包问题！| 关于背包问题，你不清楚的地方，这里都讲了！| 动态规划经典问题 | 数据结构与算法_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术蛋老师(git)</title>
    <link href="/posts/29642/"/>
    <url>/posts/29642/</url>
    
    <content type="html"><![CDATA[<p>文章简介：git 怎么用</p><span id="more"></span><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121133310.png" alt=""></p><p>先用git clone 与文件夹创建联系<a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=871.798444">14:31</a><br>git remote add origin <a href="https://gitee.com/liuqingzheng/test.git">https://gitee.com/liuqingzheng/test.git</a> 添加远程仓库<br>git remote -v 查看本地仓库与哪些远程仓库有联系 <a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=914.211131">15:14</a></p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Git工作流和核心原理 | GitHub基本操作 | VS Code里使用Git和关联GitHub_哔哩哔哩_bilibili</a><br>自用跳转连接：🈚️</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.不同的二叉搜索树</title>
    <link href="/posts/45809/"/>
    <url>/posts/45809/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——96.不同的二叉搜索树</p><span id="more"></span><h1 id="1-96不同的二叉搜索树"><a class="markdownIt-Anchor" href="#1-96不同的二叉搜索树"></a> 1 96.不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接</a></p><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121031374.png" alt=""></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>[[二叉搜索树]]</p><p>五部曲</p><ol><li><p>确定dp数组（dp table）以及下标的含义<br><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p></li><li><p>确定递推公式<br>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121051970.png" alt=""></p></li></ol><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量<br>所以是<strong>求和</strong><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121103402.png" alt=""></p><ol start="3"><li><p>dp数组如何初始化<br>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树<br>dp[0] = 1<br>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p></li><li><p>确定遍历顺序<br>顺序遍历<br>dp[i] += dp[j - 1] * dp[i - j]可以看出，<strong>节点数为i的状态是依靠 i之前节点数的状态</strong>。</p></li><li><p>举例推导dp数组<br>n为5时候的dp数组状态如图：</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"><br>[[vector (🗃)]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){ <span class="hljs-comment">// 从3开始赋值,如果没有上面的if就会 i = 3  ，i &lt;= 1，就错了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++){<span class="hljs-comment">// j从第二个数开始才能划分左右部分，所以是1</span><br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Qf4y1K72t?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode96题 不同的二叉搜索树_哔哩哔哩_bilibili</a><br><a href="https://www.programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.整数拆分</title>
    <link href="/posts/5255/"/>
    <url>/posts/5255/</url>
    
    <content type="html"><![CDATA[<h1 id="1-343整数拆分"><a class="markdownIt-Anchor" href="#1-343整数拆分"></a> 1 343.整数拆分</h1><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接</a></p><p>给定一个正整数&nbsp;n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><ul><li>输入: 2</li><li>输出: 1</li><li>解释: 2 = 1 + 1, 1 × 1 = 1。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: 10</li><li>输出: 36</li><li>解释: 10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。</li><li>说明: 你可以假设&nbsp;n&nbsp;不小于 2 且不大于 58。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-动态规划"><a class="markdownIt-Anchor" href="#21-动态规划"></a> 2.1 动态规划</h2><p>将数的拆分想象成块的切分<br>2,3不切分，因为切分来会变小<br>如果不用去写dp初始值，可以在转移方程里面再加上一个和j * i-j的最大值比较<br>两个for循环是标准的动归写法</p><ol><li>确定dp数组（dp table）以及下标的含义<br>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</li><li>确定递推公式<br>下面这样写需要提前定义2,3不可拆定义出来他们的dp值，因为他俩不用拆是最大<br>dp[i] = max({dp[i],dp[j] * dp[i-j] );<br>dp[i]是随着i的值在一直变化的，max 中有dp[i]就是保证，不断变化中的值取最高的那一个<br>j是切的位置，把一个数切成两部分，而这左右两部分又可以在切。也就是dp[j]，dp[i-j]，也是默认将一个数强制拆成4份以及4份以上了。</li></ol><p>或者这样，不用提前定义dp[2]，dp[3]<br>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));<br>3. dp的初始化<br>dp[0] dp[1]无意义，没法拆，所以不赋值。从dp[2] = 1开始，把dp[3] = 2。<br>2，3不用拆是最大的</p><h2 id="22-贪心算法"><a class="markdownIt-Anchor" href="#22-贪心算法"></a> 2.2 贪心算法</h2><p>数学已证明过：<strong>每次拆成n个3，如果剩下是4，则保留4，然后相乘</strong><br>尽量切3，最后切2，2和3是最稳定最稳定不可拆分质数</p><blockquote><p>1，2，3不划分最大，一划分反而变小了</p></blockquote><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-动态规划"><a class="markdownIt-Anchor" href="#31-动态规划"></a> 3.1 动态规划</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){ <span class="hljs-comment">// 应该从数字4开始，对应的下标是5 </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){ <span class="hljs-comment">// 切一半就行，另一半是对称的</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j*(i-j), j*dp[i-j])); <span class="hljs-comment">// 后一个max中是数的相乘 和 数和上一次的最优结果相乘</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 2，3不切分，要这样赋值下面才能通过</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]*dp[i-j]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果递归公式是 dp[i] = max(dp[i], dp[i - j] * dp[j]);，就一定要这么初始化。递推公式没毛病，但初始化解释不通！</p><p>虽然代码在初始位置有一个判断if (n &lt;= 3) return 1 * (n - 1);，保证n&lt;=3 结果是正确的，但代码后面又要给dp[1]赋值1 和 dp[2] 赋值 2，<strong>这其实就是自相矛盾的代码，违背了dp[i]的定义！</strong></p><p>我举这个例子，其实就说做题的严谨性，上面这个代码也可以AC，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112130227.png" alt=""><br>// 错了的原因是dp[1]是0，必须定义dp[1] = 1,另外还有其他的原因</p><h2 id="32-贪心"><a class="markdownIt-Anchor" href="#32-贪心"></a> 3.2 贪心</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 要有 = 4的判断，不然4的没法输出</span><br>                <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;，<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">4</span>){<br>            result *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        }<br>        <span class="hljs-keyword">return</span> result * n;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112032423.png" alt=""></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Nt4y1D7gh?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">LeetCode每日打卡.343.整数拆分_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.不同路径 II</title>
    <link href="/posts/13413/"/>
    <url>/posts/13413/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——63. 不同路径 II</p><span id="more"></span><h1 id="1-63不同路径-ii"><a class="markdownIt-Anchor" href="#1-63不同路径-ii"></a> 1 63.不同路径 II</h1><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑<strong>网格中有障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20210111204901338.png" alt=""></p><p><strong>网格中的障碍物和空位置分别用 1 和 0 来表示。</strong></p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210111204939971.png" alt=""></p><ul><li>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</li><li>输出：2 解释：</li><li>3x3 网格的正中间有一个障碍物。</li><li>从左上角到右下角一共有 2 条不同的路径：<ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/20210111205857918.png" alt=""></p><ul><li>输入：obstacleGrid = [[0,1],[0,0]]</li><li>输出：1</li></ul><p>提示：</p><ul><li>m ==&nbsp;obstacleGrid.length</li><li>n ==&nbsp;obstacleGrid[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>相比[[6.不同路径]]不同的是多了障碍，遇到障碍<code>dp[i][j]</code>保持0就可以了：表示过不去</p><p>两个地方需要跳过赋值</p><ol><li>初始值(第一行第一列)，跳过有障碍的地方在赋值</li><li>递推公式中(除了第一行第一列的)，跳过有障碍的地方在赋值</li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[j][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">0</span>){ <span class="hljs-comment">// if (obstacleGrid[i][j] == 1) continue;</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.不同路径</title>
    <link href="/posts/31702/"/>
    <url>/posts/31702/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——62.不同路径</p><span id="more"></span><h1 id="1-62不同路径"><a class="markdownIt-Anchor" href="#1-62不同路径"></a> 1 62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p><p>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt=""></p><ul><li>输入：m = 3, n = 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m = 2, n = 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m = 7, n = 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m = 3, n = 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-图论"><a class="markdownIt-Anchor" href="#21-图论"></a> 2.1 图论</h2><p>暂定</p><h2 id="22-数论"><a class="markdownIt-Anchor" href="#22-数论"></a> 2.2 数论</h2><p>暂定</p><h2 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h2><p>m✖️n：行✖️列<br>按照动规五部曲来分析：</p><p><strong>1. 确定dp数组（dp table）以及下标的含义</strong><br><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。<br><strong>2. 确定递推公式</strong><br>机器人只能向下或向右移动<br>所以<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。(上面，左面)<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为只能从上面或者左面过来<br><strong>3.  dp数组的初始化</strong><br>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。<br>所以初始化代码为：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>4.  确定遍历顺序</strong><br>这里要看一下递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套</p><p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p><p><strong>5.  举例推导dp数组</strong></p><p>如图所示：<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[2][2] = dp[1][2] + dp[2][1]</code>，<code>dp[3][7] = dp[2][7] + dp[3][6]</code> 上面/左面<br><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-二维数组解法编译已通过"><a class="markdownIt-Anchor" href="#31-二维数组解法编译已通过"></a> 3.1 二维数组解法，编译已通过</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){ <span class="hljs-comment">// 从(1,1)开始的</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>              dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>          }<br>      }<br>      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 因为下标从0开始，所以-1</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-一维数组"><a class="markdownIt-Anchor" href="#32-一维数组"></a> 3.2 一维数组</h2><p>编译已通过<br>用一维数组的前提是：二维数组的第一行和第一列是相同的值，这样才能保证滚动数组的初始值是一样的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span> <span class="hljs-params">(n,<span class="hljs-number">1</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;m; i++){<span class="hljs-comment">// 为什么要从1开始呢，因为0行全是1(已经赋值了)，所以从第1行开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;n; j++){<span class="hljs-comment">// 因为第一列是1，从第二列开始赋值的</span><br>                dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 从第0行开始的，差了一个1</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>![[6.不同路径 2022-07-13 18.05.50.excalidraw|600]]<br>滚动数组写法模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp********">void test_1_wei_bag_problem() {<br>    vector&lt;int&gt; weight = {1, 3, 4};<br>    vector&lt;int&gt; value = {15, 20, 30};<br>    int bagWeight = 4;<br><br>    // 初始化<br>    vector&lt;int&gt; dp(bagWeight + 1, 0);<br>    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品<br>        for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量<br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br>int main() {<br>    test_1_wei_bag_problem();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a><br>原理 <a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=225.736626">03:45</a></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.不同路径</title>
    <link href="/posts/31702/"/>
    <url>/posts/31702/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——62.不同路径</p><span id="more"></span><h1 id="1-62不同路径"><a class="markdownIt-Anchor" href="#1-62不同路径"></a> 1: 62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p><p>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt=""></p><ul><li>输入：m = 3, n = 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m = 2, n = 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m = 7, n = 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m = 3, n = 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><h2 id="21-图论"><a class="markdownIt-Anchor" href="#21-图论"></a> 2.1: 图论</h2><p>暂定</p><h2 id="22-数论"><a class="markdownIt-Anchor" href="#22-数论"></a> 2.2: 数论</h2><p>暂定</p><h2 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3: 动态规划</h2><p>m✖️n：行✖️列<br>按照动规五部曲来分析：</p><p><strong>1. 确定dp数组（dp table）以及下标的含义</strong><br><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。<br><strong>2. 确定递推公式</strong><br>机器人只能向下或向右移动<br>所以<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。(上面，左面)<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为只能从上面或者左面过来<br><strong>3.  dp数组的初始化</strong><br>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。<br>所以初始化代码为：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>4.  确定遍历顺序</strong><br>这里要看一下递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套</p><p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p><p><strong>5.  举例推导dp数组</strong></p><p>如图所示：<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[2][2] = dp[1][2] + dp[2][1]</code>，<code>dp[3][7] = dp[2][7] + dp[3][6]</code> 上面/左面<br><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><h2 id="31-二维数组解法编译已通过"><a class="markdownIt-Anchor" href="#31-二维数组解法编译已通过"></a> 3.1: 二维数组解法，编译已通过</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){ <span class="hljs-comment">// 从(1,1)开始的</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>              dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>          }<br>      }<br>      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 因为下标从0开始，所以-1</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-一维数组"><a class="markdownIt-Anchor" href="#32-一维数组"></a> 3.2: 一维数组</h2><p>编译已通过<br>用一维数组的前提是：二维数组的第一行和第一列是相同的值，这样才能保证滚动数组的初始值是一样的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span> <span class="hljs-params">(n,<span class="hljs-number">1</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;m; i++){<span class="hljs-comment">// 为什么要从1开始呢，因为0行全是1(已经赋值了)，所以从第1行开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;n; j++){<span class="hljs-comment">// 因为第一列是1，从第二列开始赋值的</span><br>                dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 从第0行开始的，差了一个1</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>![[6.不同路径 2022-07-13 18.05.50.excalidraw|600]]<br>滚动数组写法模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp********">void test_1_wei_bag_problem() {<br>    vector&lt;int&gt; weight = {1, 3, 4};<br>    vector&lt;int&gt; value = {15, 20, 30};<br>    int bagWeight = 4;<br><br>    // 初始化<br>    vector&lt;int&gt; dp(bagWeight + 1, 0);<br>    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品<br>        for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量<br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br>int main() {<br>    test_1_wei_bag_problem();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a><br>原理 <a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=225.736626">03:45</a></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4: 参考资料</h1><p><a href="https://www.programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.使用最小花费爬楼梯</title>
    <link href="/posts/27967/"/>
    <url>/posts/27967/</url>
    
    <content type="html"><![CDATA[<h1 id="1-使用最小花费爬楼梯"><a class="markdownIt-Anchor" href="#1-使用最小花费爬楼梯"></a> 1: 使用最小花费爬楼梯</h1><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接</a></p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值&nbsp;cost[i]（下标从 0 开始）。</p><p><strong>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</strong></p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例&nbsp;1：</p><p>输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 &nbsp;示例 2：</p><blockquote><p>第一次不要钱，爬上了15，支付15后可以爬一层到楼顶，那我从10开始支付10爬两层不是更好吗</p></blockquote><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>提示：</p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><p><strong>注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong></p><p>动归五部曲</p><p><font color="#F36208">1.  确定dp数组以及下标的含义</font><br><strong>dp[i]的定义：到达第i个台阶所花费的最<br>少体力为dp[i]</strong>。<br>注意这里认为是第一步一定是要花费：<br>dp[0] = cost[0];<br>dp[1] = cost[1];<br><strong>dp[2] = min(dp[0], dp[1]) + cost[2];</strong><br><font color="#F36208">2.  确定递推公式</font><br><strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong>。</p><blockquote><p>一旦支付当前下边相应的体力值，就可向上爬一个或者两个楼梯</p></blockquote><p><strong>dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</strong><br>爬上台阶i，可能是从 i - 1 层，i-2层爬上来的，然后在离开台阶i 又在需要花费cost[i]<br><font color="#F36208">3. dp数组初始化</font><br>题目说：可以选择从下标为 0 或 1 的元素作为初始阶梯。<br>从下标0处离开需要cost[0]，下标1同理</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br></code></pre></td></tr></tbody></table></figure><p><font color="#F36208">4. 遍历顺序</font><br>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。<br><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。<br><font color="#F36208">5. 举例推导dp数组</font></p><table><thead><tr><th>cost</th><th>10</th><th>15</th><th>20</th></tr></thead><tbody><tr><td>dp[i]</td><td>10</td><td>15</td><td>30</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2021010621363669.png" alt="746.使用最小花费爬楼梯"><br>为什么选择最后两位的最小值呢<br>?<br>最后两位支付该值都可以到下一层，假设所求是第N层的最小开销，只需要计算min(谁能到N层)，到了N层后又不到下一层，所以相当于最后一步不用花费，就停止到那了，不用+cost[i]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++){<span class="hljs-comment">// 这里不用&lt;=，因为下标从0开始，取不到cost.size()||从第三个元素开始，下标是2</span><br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[cost.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>], dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4: 参考资料</h1><p><a href="https://www.programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1fq4y1T7Uo?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode-746.使用最小花费爬楼梯_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.爬楼梯</title>
    <link href="/posts/34749/"/>
    <url>/posts/34749/</url>
    
    <content type="html"><![CDATA[<p>📝3.爬楼梯::</p><!-- basicblock-end --><h1 id="1-爬楼梯"><a class="markdownIt-Anchor" href="#1-爬楼梯"></a> 1: 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。<strong>你有多少种不同的方法</strong>可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><ul><li>输入： 2</li><li>输出： 2</li><li>解释： 有两种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶</li><li>2 阶</li></ul></li></ul><p>示例 2：</p><ul><li>输入： 3</li><li>输出： 3</li><li>解释： 有三种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul></li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2: 思路</h1><p>第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。<br>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。<br>第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。<br>dp[3] = dp[2] + dp[1] = 2+1 =3</p><p>动归五部曲：</p><ol><li>确定dp数组以及下标的含义<br>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li><li>确定递推公式<br>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。<br>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么<br>dp[i] = dp[i - 1] + dp[i - 2] 。</li><li>dp数组如何初始化<br>不考虑dp[0]，dp[1] = 1， dp[2] = 2</li></ol><blockquote><p>dp[0]没有意义，i从3 开始递推</p></blockquote><ol start="4"><li>确定遍历顺序<br>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</li><li>举推导dp数组<br>举例当n为5的时候，dp table（dp数组）应该是这样的<br><img src="https://img-blog.csdnimg.cn/20210105202546299.png" alt="70.爬楼梯"></li></ol><blockquote><p>本质就是斐波那契数列，就是没有讨论dp[0] 的情况</p></blockquote><p>#面试<br>有的题解是把dp[0]初始化为1，然后遍历的时候i从2开始遍历，这样是可以解题的，然后强行解释一波dp[0]应该等于1的含义。<br>一个严谨的思考过程，应该是初始化dp[1] = 1，dp[2] = 2，然后i从3开始遍历，<br>这个可以是面试的一个小问题，考察候选人对dp[i]定义的理解程度。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3: 代码</h1><p>优化一下空间复杂度</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">2</span>] + dp [<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">2</span>] = sum;<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>]; <br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-加强版爬楼梯"><a class="markdownIt-Anchor" href="#4-加强版爬楼梯"></a> 4: 加强版爬楼梯</h1><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 把m换成2，就可以AC爬楼梯这道题</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试，哈哈</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。</p><p>我在<a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html">通过一道面试题目，讲一讲递归算法的时间复杂度！</a><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html"></a><br>中，以我自己面试别人的真实经历，通过求x的n次方 这么简单的题目，就可以考察候选人对算法性能以及递归的理解深度，录友们可以看看，绝对有收获！</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5: 参考资料</h1><p><a href="https://www.programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.斐波那契数</title>
    <link href="/posts/33325/"/>
    <url>/posts/33325/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode 题解 ——509. 斐波那契数</p><span id="more"></span><h1 id="1-509-斐波那契数"><a class="markdownIt-Anchor" href="#1-509-斐波那契数"></a> 1 509. 斐波那契数</h1><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接</a></p><p>斐波那契数，通常用&nbsp;F(n) 表示，形成的序列称为 斐波那契数列 。该数列由&nbsp;0 和 1 开始，<strong>后面的每一项数字都是前面两项数字的和</strong>。也就是： F(0) = 0，F(1)&nbsp;= 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1：</p><ul><li>输入：2</li><li>输出：1</li><li>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</li></ul><p>示例 2：</p><ul><li>输入：3</li><li>输出：2</li><li>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</li></ul><p>示例 3：</p><ul><li>输入：4</li><li>输出：3</li><li>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</li></ul><p>提示：</p><ul><li>0 &lt;= n &lt;= 30</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 因为下标从0开始，要总长度所以+1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++){ <span class="hljs-comment">// 是≤，要把n也算上，因为最后输出的是n</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<span class="hljs-comment">// vector的返回和使用都要用[]</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=9fc19dba-4edb-4f3d-8d7e-22b7c2462fc7">obsidian</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.动态规划理论基础</title>
    <link href="/posts/31296/"/>
    <url>/posts/31296/</url>
    
    <content type="html"><![CDATA[<p>📝1. 动态规划理论基础:: <a href="https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">代码随想录</a></p><!-- basicblock-end --><blockquote><p>[!summary] 动态规划，英文：Dynamic Programming，简称 DP<br><strong>动态规划中每一个状态一定是由上一个状态推导出来的</strong>，贪心是局部最优推导全局最优</p></blockquote><h1 id="1-解决的问题"><a class="markdownIt-Anchor" href="#1-解决的问题"></a> 1: 解决的问题</h1><ul><li>背包问题</li><li>正则<strong>字符串匹配</strong></li></ul><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><h1 id="2-动态规划解题步骤"><a class="markdownIt-Anchor" href="#2-动态规划解题步骤"></a> 2: 动态规划解题步骤</h1><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组<br><strong>一些情况是递推公式决定了dp数组要如何初始化！</strong></li></ol><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。<br>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。<br><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><h1 id="3-debug"><a class="markdownIt-Anchor" href="#3-debug"></a> 3: debug</h1><p><strong>如果代码写出来了，一直AC不了，灵魂三问：</strong></p><ol><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ol><p>哈哈，专治各种代码写出来了但AC不了的疑难杂症。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>24.监控二叉树</title>
    <link href="/posts/43575/"/>
    <url>/posts/43575/</url>
    
    <content type="html"><![CDATA[<p>文章简介：968.监控二叉树</p><span id="more"></span><h1 id="1-968监控二叉树"><a class="markdownIt-Anchor" href="#1-968监控二叉树"></a> 1 968.监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20201229175736596.png" alt=""></p><ul><li>输入：[0,0,null,0,0]</li><li>输出：1</li><li>解释：如图所示，一台摄像头足以监控所有节点。</li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/2020122917584449.png" alt=""></p><ul><li>输入：[0,0,null,0,null,0,null,null,0]</li><li>输出：2</li><li>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</li></ul><p>提示：</p><ul><li>给定树的节点数的范围是 [1, 1000]。</li><li><strong>每个节点的值都是 0</strong>。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>为什么不从头结点开始看起呢，为啥要从叶子节点看呢<br>?<br>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。<br><strong>局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，<br>整体最优：全部摄像头数量所用最少！</strong></p><p>大体思路就是：从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点</p><p>每个节点可能有几种状态：<br>有如下三种：</p><ul><li>该节点无覆盖</li><li>本节点有摄像头</li><li>本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051425661.png" alt=""></p><h1 id="3-参考资料"><a class="markdownIt-Anchor" href="#3-参考资料"></a> 3 参考资料</h1><p><a href="https://www.programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转连接：🈚️</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验设计</title>
    <link href="/posts/65372/"/>
    <url>/posts/65372/</url>
    
    <content type="html"><![CDATA[<p>镁合金设置温度分布<br>挤压角度：100°，110，120，130，140</p><blockquote><p>110， 120 的圆盘成形效果最好，140的圆棒成形效果最好<br>因为110°的倾角小</p></blockquote><p>![[实验设计 2022-07-09 16.42.40.excalidraw|600]]</p><p>镁合金AZ31B 直径：9.90~9.95，长度40mm<br>![[退火#^ckuxll]]<br>考虑到现场加热会导致热胀, 不一定能够放入模具中, 先订购一批不同尺寸的工件来试试</p><p>我现在有16个镁合金圆棒<br>7月份的实验</p><ul><li><p>控制角度变温度</p><ul><li>110°挤压块性能最好 100°→400°的做7个</li><li>120°挤压块同理7个</li><li>在做一个无加热的，对比实验，主要是拍照片</li><li>综上测出性能最好的角度和温度，确定好最合适的温度</li></ul></li><li><p>控制温度变角度</p><ul><li>先确定一个最合适的温度</li><li>在用该温度做其他挤压块的角度 (5个：100°→140°)</li><li></li></ul></li></ul><p><a href="https://zeefan.notion.site/b7ef71846ce04735a7c3319ea5143a18?v=c8f779be7dee48979931444cb7d77ada">Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.</a></p><hr><p>试验温度为室温和100, 150, 200, 250, 300, 350, 400 ℃<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[1]</span></a></sup><br>200°时，得到最好的性能</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/F62253DC-5296-4BB8-A7BF-97F9BD2553CF">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23.买卖股票的最佳时机含手续费</title>
    <link href="/posts/9689/"/>
    <url>/posts/9689/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解：714. 买卖股票的最佳时机含手续费</p><span id="more"></span><h1 id="1-买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#1-买卖股票的最佳时机含手续费"></a> 1 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接</a></p><p>给定一个整数数组&nbsp;prices，其中第&nbsp;i&nbsp;个元素代表了第&nbsp;i&nbsp;天的股票价格 ；非负整数&nbsp;fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。<strong>如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</strong></p><p><strong>返回获得利润的最大值。</strong></p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><blockquote><p>相当于买入和卖出</p></blockquote><p>示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8</p><p>解释: 能够达到的最大利润: 在此处买入&nbsp;prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润:&nbsp;((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p><p>注意:</p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-6-买卖股票的最佳时机ii"><a class="markdownIt-Anchor" href="#21-6-买卖股票的最佳时机ii"></a> 2.1 [[6. 买卖股票的最佳时机II]]</h2><p>![[6. 买卖股票的最佳时机II#2 思路]]<br>与 6的区别是多了个手续费<br>有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。<br>用贪心策略，就是最低值买，最高值（减去手续费还盈利）就卖。</p><p>找到两个点</p><ul><li>买入日期：其实很好想，遇到更低点就记录一下。</li><li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li></ul><p>做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（<strong>不是真正的卖出，相当于持有股票</strong>），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><h3 id="211-思路总结"><a class="markdownIt-Anchor" href="#211-思路总结"></a> 2.1.1 思路总结</h3><ol><li>不断的寻找最低点，在最低点时买入</li><li>寻找有利润的时候买入，更新下一次的买入位置在循环卖出</li><li>对所有利润加和</li></ol><h2 id="22-断点调试"><a class="markdownIt-Anchor" href="#22-断点调试"></a> 2.2 断点调试</h2><p>[23.买卖股票的最佳时机含手续费](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4)</p><p>[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=10.471542) 情况三：现在的价格不是最低的，并且卖出的话亏本</p><p>[00:28](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=28.795416)<br>#疑问 #已解决<br>为什么要minPrice = prices[i]- fee呢，如果去掉了- fee 则结果不对<br><s>因为在该下标处已经交过了一次手续费，不需要在交了？？？</s></p><p>输入：prices = [1,3,7,5,10,3], fee = 3<br>输出：6<br>相当于：1时买入，10时卖出(10-1-3 = 6)<br>并不是：1时买入，7时卖出，5时买入，10时卖出(7-1-3  +  10 - 5 -3 = 5)<br>minprice = price[i] - fee  有正利润就假装卖了，先收集利润，- fee 的作用是如果后边的还有利润更高的，则这次其实是不卖的<br>eg：7时有正利润的先收集起来(7-1-3=3)<br>但此时的minPrice = 7-3  =&nbsp;4， 4是后边的最小的，接下来的利润是10-4-3= 3<br>总利润就是3+3 = 6，而不是像上边计算的5，这个作用就是，看似在7处卖了，实际没卖，最后是在10的位置卖的</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =&nbsp;<span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];<br>            <span class="hljs-keyword">if</span> (prices[i] &gt; minPrice &amp;&amp; prices[i] - minPrice - fee &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (prices[i] - minPrice - fee &gt; <span class="hljs-number">0</span>){<br>                result += prices[i] -minPrice - fee;<br>                minPrice = prices[i] - fee; <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-知识点"><a class="markdownIt-Anchor" href="#4-知识点"></a> 4 知识点</h1><p>[[continue]]</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22.单调递增的数字</title>
    <link href="/posts/17411/"/>
    <url>/posts/17411/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解： 738.单调递增的数字</p><span id="more"></span><h1 id="1-738单调递增的数字"><a class="markdownIt-Anchor" href="#1-738单调递增的数字"></a> 1 738.单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接</a></p><p>给定一个非负整数&nbsp;N，找出小于或等于&nbsp;N&nbsp;的最大的<strong>整数</strong>，同时这个整数需要满足其<strong>各个位数上</strong>的数字是单调递增。</p><p>（当且仅当每<strong>个相邻位数上的数字&nbsp;x&nbsp;和&nbsp;y&nbsp;满足&nbsp;x &lt;= y</strong>&nbsp;时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>输入: N = 10</li><li>输出: 9</li></ul><p>示例 2:</p><ul><li>输入: N = 1234</li><li>输出: 1234</li></ul><p>示例 3:</p><ul><li>输入: N = 332</li><li>输出: 299</li></ul><p>说明: N&nbsp;是在&nbsp;[0, 10^9]&nbsp;范围内的一个整数。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>找≤ N，的最大单增的整数<br>如果不递增，就把除最后一位每一位都减1，这样保证了减过数比原数小。然后在把除了第一个位(因为第一个位最大不能变，变了会使得比原来的数大)，后边的位数全部令为9，这样就得到了最大的整数。<br>代码：一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9</p><p>例如<br>332 → 222→299<br>753 → 643 → 699</p><h2 id="21-断点调试"><a class="markdownIt-Anchor" href="#21-断点调试"></a> 2.1 断点调试</h2><p>[22.单调递增的数字(carl:332).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl).mp4)<br>[00:07](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=7.519521) 前一个数大于后一个数则让前一个数减1</p><blockquote><p>从后往前遍历，for (i = num.size () - 1; i &gt; 0; i–) [[for 循环]]</p></blockquote><p>flag至少是1，因为i 不会取到0。这样就报证了至少从第二个2数开始赋9，直到到最后一个数</p><p>[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=10.337641) 只需要减1的原因是：让他的每一个位都比原来的数小，在把除了第一个位(因为第一个位最大)，后边的位数全部令为9，这样就得到了最大的整数</p><p>[22.单调递增的数字(carl/1234)](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl:1234).mp4)<br>1234 本身都是递增的，所以第一个for循环会跳过，第二for循环也不会执行</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        string strNum = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>() ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--){<br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>]&gt; strNum[i]){<br>                flag = i;<br>                strNum[i<span class="hljs-number">-1</span>]--;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++){<br>            strNum[i] = <span class="hljs-string">'9'</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span> (strNum);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>stoi函数 #flashcards/代码随想录<br>?<br>将数字字符串转为数字：“2147482” → 2147482</p><!--SR:!2022-07-07,3,250--><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">代码随想录</a><br>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=49dde99d-8015-4224-9c0b-96d9d0dae41a">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>材料内部结构</title>
    <link href="/posts/65236/"/>
    <url>/posts/65236/</url>
    
    <content type="html"><![CDATA[<p>滑移性能最好的晶格为：面心立方 &gt; 体心立方 &gt; 密排六方</p><blockquote><p>(塑性性能指标)</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206281433535.png" alt=""></p><blockquote><p>BCC是体心立方，上边写错了</p></blockquote><p>面心立方材料：铝（Al）、铜（Cu）、镍（Ni）、金（Au）、银（Ag）、γ-铁（γ-Fe,912℃~1394℃)</p><p>密排六方材料：Mg， Zn，铍<br>镁合金等密排六方晶格金属在 250~400℃之间成形,密排六方(hcp)金属滑移系少,主要靠孪生变形</p><p>V体：Fe Cr Mo</p><blockquote><p>V体是什么，等查一查</p></blockquote><p>自用跳转连接：<a href="marginnote3app://note/D9087A24-CEF0-4136-B1D1-42F789B404D2">黄珍媛老师</a>，<a href="marginnote3app://note/40F63EDC-2FA9-46FE-BC55-141C72946015">夏琴香老师讲塑性变形</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=b9ec2231-bc80-4831-9b86-5e112ada3bfb">ob</a>，<a href="http://localhost:4000/2022/06/28/ke-yan/cai-liao-nei-bu-jie-gou/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代制造工程</title>
    <link href="/posts/64386/"/>
    <url>/posts/64386/</url>
    
    <content type="html"><![CDATA[<p>[[现代制造工程–周驰]]</p><p><strong>2022-06-29(后记)：</strong></p><p><strong>简答题</strong>：5 * 5  =25</p><ol><li><p>电火花的原理是什么，不可缺少什么，适用于什么材料。</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291624610.png" alt="|600"></li></ol></li><li><p>化学沉积和物理沉积的定义与区别</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291626815.png" alt="|600"></li></ol></li><li><p>画个六点定位原理图</p></li><li><p>坐标变换(周驰作业题)</p></li><li><p>金属材料加热发生的变化(答5点)</p></li></ol><p><strong>辨析题</strong>：15+15 = 30</p><ol><li><p>从“生产规模，资源配置，生产技术”三方面来说现代制造工程的发展</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291622155.png" alt="|600"></li></ol></li><li><p>金属塑性成形的两种方式，冷塑性对金属材料内部和性能的影响</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291623008.png" alt="|600"></li></ol></li></ol><p>其余的都是选择(20个 1.5分)和判断(15个 15分)</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>notion函数详解</title>
    <link href="/posts/49277/"/>
    <url>/posts/49277/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.csdn.net/tags/NtzaggysMDE2OTctYmxvZwO0O0OO0O0O.html">notion多条件formula - CSDN</a></p><h1 id="1-一-属性列名-properties"><a class="markdownIt-Anchor" href="#1-一-属性列名-properties"></a> 1 一、属性（列名-properties）</h1><ol><li><p>prop(“属性”) 返回每个条目的“属性值”，点击即可用对应的格式插入到公式中。</p></li><li><p>公式中的四种方式</p><p>四 种 格 式 { 数 字 日 期 字 符 串 复 选 框 四种格式\begin{cases} 数字 &amp; \ 日期 &amp; \字符串 &amp;\复选框 &amp; \end{cases} 四种格式⎩⎪⎪⎪⎨⎪⎪⎪⎧​数字日期字符串复选框​​</p></li></ol><p>floor((prop(“小时”) + prop(“分钟”) / 60) * 100) / 100</p><h1 id="2-二-常量constants"><a class="markdownIt-Anchor" href="#2-二-常量constants"></a> 2 二、常量（constants）</h1><p>常 量 { e 自 然 对 数 的 底 数 p i 圆 周 率 t r u e 真 f l a s e 假 常量\begin{cases} e &amp;自然对数的底数 \ pi &amp;圆周率 \true &amp;真\flase &amp;假 \end{cases} 常量⎩⎪⎪⎪⎨⎪⎪⎪⎧​epitrueflase​自然对数的底数圆周率真假​</p><h1 id="3-三-基本运算"><a class="markdownIt-Anchor" href="#3-三-基本运算"></a> 3 三、基本运算</h1><ol><li><p>if语法（“<code>if</code>”）：进行条件判断，在两个选项（要为同一格式）中选择一个。</p><p>语法：</p><ul><li><code>boolean?value:value</code></li><li><code>if(boolean,value,value)</code></li></ul><p>补充：在"boolean"不能填写0或者1；value中，true（真）为1，false（假）为0；</p></li><li><p>加法（"<code>+</code>“或"<code>add</code>"）：把两个数字或字符串相加，并返回它们的值</p><p>语法：</p><ul><li><code>value+value</code></li><li><code>add(value,value)</code></li></ul><p>说明：value可以是数字或字符串，为字符串时要加上双引号</p></li><li><p>减法（”<code>-</code>“或“<code>subtract</code>”）：将两个数字相减，并返回它们的值</p><p>语法：</p><ul><li><code>number-number</code></li><li><code>subtract(number,number)</code></li></ul></li><li><p>乘法（”<code>*</code>“或“<code>multiply</code>”）：将两个数字相乘，并返回它们的值</p><p>语法：</p><ul><li><code>number*number</code></li><li><code>multiply(number,number)</code></li></ul></li><li><p>除法（”<code>/</code> “或"<code>divide</code>"）：将两个数字相乘，并返回他们的值</p><p>语法：</p><ul><li><code>number/number</code></li><li><code>divide(number,number)</code></li></ul></li><li><p>绝对值（"<code>abs</code>"）：返回数的绝对值</p><p>语法：<code>abs(number)</code></p></li><li><p>求余运算（”<code>%</code>“或"<code>mod</code>"）：把两个数进行求余运算，并返回它们的值</p><p>语法：</p><ul><li><code>number%number</code></li><li><code>mod(number,number)</code></li></ul></li><li><p>”四舍五入“（”<code>round</code>“）：对数字进行”四舍五入“</p><p>语法：<code>round(number)</code></p><p>说明：默认情况下只保留整数。要保留n位小数时，应使用</p><p>r o u n d ( n u m b e r ∗ 1 0 n ) / 1 0 n round(number*10<sup>n)/10</sup>n round(number∗10n)/10n</p></li><li><p>一元负数（”<code>unaryminus</code>“或“<code>-</code>”）：对一个数进行取它的负数</p><p>语法：</p><p><code>-number</code></p><p><code>unaryminus(number)</code></p><p>如：-3==unaryminus(3)</p></li><li><p>一元加号（“<code>+</code>”或“<code>unaryPlus</code>”）：将参数转化为数字。</p></li></ol><pre><code class="hljs">语法：`+value``unaryPlus(value)`补充：可以将true转化为1，false转化为0</code></pre><h1 id="4-四-关系逻辑判断"><a class="markdownIt-Anchor" href="#4-四-关系逻辑判断"></a> 4 四、关系逻辑判断</h1><ol><li>关系判断<ul><li>大于 &gt;</li><li>小于 &lt;</li><li>等于 ==</li><li>大于等于 &gt;=</li><li>小于等于 &lt;=</li><li>不等于 !=</li></ul></li><li>逻辑判断<ul><li><p>逻辑“<code>非</code>”：对逻辑参数进行否定</p><p>语法：</p><p><code>not boolean</code></p><p><code>not (boolean)</code></p></li><li><p>逻辑“<code>与</code>”：对逻辑参数进行“与”运算，<code>“一假全假”</code></p><p>语法：</p><p><code>boolean and boolean</code></p><p><code>and(boolean,boolean)</code></p></li><li><p>逻辑“或”：对逻辑参数进行“或”运算，<code>“一真全真”</code></p><p>语法：</p><p><code>boolean or boolean</code></p><p><code>or(boolean,boolean)</code></p></li></ul></li></ol><h1 id="5-五-字符串函数"><a class="markdownIt-Anchor" href="#5-五-字符串函数"></a> 5 五、字符串函数</h1><ol><li><p>连接函数（“<code>concat</code>”）：将字符串进行连接</p><p>语法：</p><p><code>concat(text...)</code></p><p><code>text+text+...</code></p></li><li><p>插符函数（“<code>join</code>”）：插入字符函数，在其余叁数之间插入第一个参数并返回它们的连接字符串</p><p>语法：<code>join(text...)</code></p><p>例如：join("-",“a”,“b”,“c”)==“a-b-c”</p></li><li><p>切片函数（”<code>slice</code>“）：从字符串中提取子字符串（包括开头索引，不包括结尾索引[start,end)）</p><p>语法：</p><ul><li><code>slice(text,number)</code></li><li><code>slice(text,number1,number2)</code></li></ul><p>说明:只有一个数字时，就是从这个索引数字开始到结束；当有两个数字时（第二个数要大于第一个数，不然不会显示），从字符串中提取子字符串，包含开头索引，不包含结束索引。</p><p>注意：字符串的索引值是从0开始的</p></li><li><p>长度函数（”<code>length</code>“）：返回字符串的长度，返回值是一个数值。</p><p>语法：<code>length(text)</code></p></li><li><p>转化函数（”<code>format</code>“）：将其他格式的参数转化为字符串。</p><p>语法：<code>format(value)</code></p></li><li><p>转化函数（”<code>toNumber</code>“）：将其他格式的参数转化数字</p><p>语法：<code>toNumber(value)</code></p><p>说明：</p><ul><li>可以把字符串类型转化为数字，如："123"到数字123</li><li>可以把日期类型转化时间戳，Jan 18, 2021 7:28 PM→1610969340000</li><li>可以把复选框类型转化为数字，true为1，false为0</li><li>也可以把数字类型转化为数字</li></ul></li><li><p>包含判断函数（”<code>contains</code>“）：包含判断函数，返回一个boolean值，</p><p>语法：<code>contains(text1,text2)</code></p><p>说明：如果text1中包含text2，则返回true；反之，返回false</p></li><li><p>替代函数：</p><ul><li><p>“<code>replace</code>”：用新值替换正则表达式的第一个匹配项</p><p>语法：<code>replace(number/text/boolean,text1,text2)</code></p><p>说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</p></li><li><p>"<code>replaceAll</code>”：用新值代替正则表达式的所有匹配项</p><p>语法：<code>replaceAll(number/text/boolean,text1,text2)</code></p><p>说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</p></li></ul></li><li><p>检验函数（“<code>test</code>”）：判断一个字符串是否与正则表达式匹配，返回一个boolean值</p><p>语法：<code>test(number/text/boolean,text)</code></p></li><li><p>“验空”函数（”<code>empty</code>“）：判断一个值是否为空</p></li></ol><pre><code class="hljs">语法：`empty(number/text/boolean/date)`说明：默认情况下，数字为0表示空，字符串以""表示空值，boolean值以false表示空值</code></pre><h1 id="6-六-数学函数"><a class="markdownIt-Anchor" href="#6-六-数学函数"></a> 6 六、数学函数</h1><ol><li><p>绝对值函数（“<code>abs</code>”)：返回一个数的绝对值</p><p>语法：<code>abs(number)</code></p></li><li><p>开算术平方根运算（”<code>sqrt</code>“）：返回一个数的算术平方根</p><p>语法：<code>sqrt(number)</code></p><p>说明：number要为非负数</p></li><li><p>开立方根（”<code>cbrt</code>“)：返回一个数的立方根</p><p>语法：<code>cbrt(number)</code></p></li><li><p>幂次运算（”<code>^</code>“或"<code>pow</code>"）：将两个数字进行指数运算，并返回它们的值</p><p>语法：</p><ul><li><code>number^number</code></li><li><code>pow(number,number)</code></li></ul><p>补充:</p><p>自然指数运算（”<code>exp</code>“）：返回e^x的值，其中x为参数，e为常数</p><p>语法：<code>exp(number)</code></p></li><li><p>对数运算：notion目前只支持三种对数运算</p><p>三 种 对 数 运 算 { l n ( n u m b e r ) 返 回 一 个 数 的 自 然 对 数 l o g 10 ( n u m b e r ) 返 回 这 个 数 以 10 为 底 对 数 的 值 l o g 2 ( n u m b e r ) 返 回 这 个 数 以 2 为 底 对 数 的 值 三种对数运算\begin{cases}ln(number) &amp;返回一个数的自然对数\log_{10}(number)&amp;返回这个数以10为底对数的值\log_2(number) &amp;返回这个数以2为底对数的值\end{cases} 三种对数运算⎩⎪⎨⎪⎧​ln(number)log10​(number)log2​(number)​返回一个数的自然对数返回这个数以10为底对数的值返回这个数以2为底对数的值​</p></li><li><p>向上取整函数（“<code>ceil</code>”）：返回大于或等于这个数字的最小整数</p><p>语法：<code>ceil(number)</code></p></li><li><p>向下取整函数（“<code>floor</code>”）：返回小于或等于这个数字的最大整数</p><p>语法：<code>floor(number)</code></p></li><li><p>最大/小值函数</p><ul><li><p>最大值函数（“<code>max</code>”）：返回数的最大值</p><p>语法：<code>max(number1,number2,...)</code></p></li><li><p>最小值函数（“<code>min</code>”）：返回数的最小值</p><p>语法：<code>min(number1,number2,...)</code></p></li></ul></li><li><p>符号函数（“<code>sign</code>”）：返回数的符号，指明数的符号是为正、负或零</p><p>语法：<code>sign(number)</code></p><p>说明：数字为正时，返回1；数字为负时，返回-1；数字为0时，返回0</p></li></ol><h1 id="7-七-日期函数"><a class="markdownIt-Anchor" href="#7-七-日期函数"></a> 7 七、日期函数</h1><ol><li><p>返回时间差函数（<code>dateBetween</code>）：返回两个日期之间的时间差，返回值是一个数字。</p><p>语法：<code>dateBetween(date,date,text)</code></p><p>说明：<code>date</code>表示日期；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。</p><p>t e x t 的 取 值 类 型 { " y e a r s " 表 示 以 “ 年 ” 为 基 本 单 位 " q u a r t e r s " 表 示 以 “ 季 ” 为 基 本 单 位 " m o n t h s " 表 示 以 “ 月 " 为 基 本 单 位 " w e e k s " 表 示 以 “ 周 ” 为 基 本 单 位 " d a y s " 表 示 以 “ 天 ” 为 基 本 单 位 " h o u r s " 表 示 以 “ 小 时 ” 为 基 本 单 位 " m i n u t e s " 表 示 以 “ 分 钟 ” 为 基 本 单 位 " s e c o n d s " 表 示 以 “ 秒 ” 为 基 本 单 位 " m i l l i s e c o n d " 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}“years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月"为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​"years"“quarters”“months”“weeks”“days”“hours”“minutes”“seconds”"millisecond"​表示以“年”为基本单位表示以“季”为基本单位表示以“月"为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</p></li><li><p>获取当前日期函数（<code>now</code>):返回当前的日期和时间</p><p>语法：<code>now()</code></p></li><li><p>日期范围开始函数（“<code>start</code>”）：返回一个日期范围的开始</p><p>语法：<code>start(date)</code></p></li><li><p>日期范围结束函数（“<code>end</code>”）：返回一个日期范围的结束</p><p>语法：<code>end(date)</code></p></li><li><p>日期到时间戳函数（“<code>timestamp</code>”）：返回来自Unix毫秒时间戳的整数，对应于自1970年1月1日起的毫秒数，返回值是<code>数值</code></p><p>语法：<code>timestamp(date)</code></p><p>说明：把日期格式的<code>日期转化</code>为数值类型的<code>时间戳</code></p></li><li><p>时间戳到日期函数（“<code>fromTimestamp</code>”）：返回由Unix毫秒时间戳构建的日期，对应于自1970年1月1日起的毫秒数，返回值是<code>日期</code></p><p>语法：<code>fromTimestamp(number)</code></p><p>说明：把数值类型的<code>时间戳转化为日期</code>类型的日期</p></li><li><p>增加日期判据（argument）函数（“<code>dateAdd</code>”）：增加到日期，最后一个是单位判据</p><p>语法：<code>dateAdd(date,number,text)</code></p><p>说明：<code>date</code>表示日期；number表示日期差；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。</p><p>t e x t 的 取 值 类 型 { " y e a r s " 表 示 以 “ 年 ” 为 基 本 单 位 " q u a r t e r s " 表 示 以 “ 季 ” 为 基 本 单 位 " m o n t h s " 表 示 以 “ 月 " 为 基 本 单 位 " w e e k s " 表 示 以 “ 周 ” 为 基 本 单 位 " d a y s " 表 示 以 “ 天 ” 为 基 本 单 位 " h o u r s " 表 示 以 “ 小 时 ” 为 基 本 单 位 " m i n u t e s " 表 示 以 “ 分 钟 ” 为 基 本 单 位 " s e c o n d s " 表 示 以 “ 秒 ” 为 基 本 单 位 " m i l l i s e c o n d " 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}“years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月"为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​"years"“quarters”“months”“weeks”“days”“hours”“minutes”“seconds”"millisecond"​表示以“年”为基本单位表示以“季”为基本单位表示以“月"为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</p></li><li><p>减少日期的日期函数（<code>“dateSubtract</code>”）：减少日期的日期，最后一个是判据</p><p>语法：<code>dateSubtract(date,number,text)</code></p><p>说明：类似上面的dateAdd函数。</p></li><li><p>设置日期格式函数（“<code>formatDate</code>”）：使用“时刻”标准时间格式字符串，设置日期格式，返回的是一个<code>字符串</code></p><p>语法：<code>formatDate(date,text)</code></p><p>例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MMMM D YYYY, HH:mm"</span>) == March <span class="hljs-number">30</span> <span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"YYYY/MM/DD, HH:mm"</span>) == <span class="hljs-number">2010</span>/<span class="hljs-number">03</span>/<span class="hljs-number">30</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MM/DD/YYYY, HH:mm"</span>) == <span class="hljs-number">03</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"HH:mm A"</span>) == <span class="hljs-number">12</span>:<span class="hljs-number">00</span> PM<br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"M/D/YY"</span>) == <span class="hljs-number">3</span>/<span class="hljs-number">30</span>/<span class="hljs-number">10</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>返回”给定日期“所用单位函数下的数字<br>所 用 的 单 位 函 数 { 分 钟 函 数 （ m i n u t e ） { 返 回 一 个 0 到 59 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 分 钟 数 语 法 ： m i n u t e ( d a t e ) 小 时 函 数 （ h o u r ） { 返 回 一 个 0 到 23 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 小 时 数 语 法 ： h o u r ( d a t e ) 星 期 函 数 （ d a y ） { 返 回 一 个 0 到 6 之 间 的 整 数 ， 对 应 于 给 定 的 日 期 。 0 代 表 星 期 日 ， 1 代 表 星 期 一 等 等 语 法 ： d a y ( d a t e ) 日 期 函 数 （ d a t e ） { 返 回 一 个 1 到 31 之 间 的 整 数 , 对 应 于 给 定 日 期 语 法 ： d a t e ( d a t e ) 月 函 数 （ m o n t h ） { 返 回 一 个 0 到 11 之 间 的 整 数 ， 0 对 应 于 1 月 ， 1 对 应 于 2 月 等 等 语 法 ： m o n t h ( d a t e ) 年 份 函 数 （ y e a r ） { 返 回 给 定 日 期 的 年 份 语 法 ： y e a r ( d a t e ) 所用的单位函数\begin{cases} 分钟函数（minute）\begin{cases}返回一个0到59之间的整数，对应于给定日期的分钟数\语法：minute(date)\end{cases}\ 小时函数（hour）\begin{cases}返回一个0到23之间的整数，对应于给定日期的小时数\语法：hour(date)\end{cases}\ 星期函数（day）\begin{cases}返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等\语法：day(date)\end{cases}\ 日期函数（date）\begin{cases}返回一个1到31之间的整数,对应于给定日期\语法：date(date)\end{cases}\ 月函数（month）\begin{cases}返回一个0到11之间的整数，0对应于1月，1对应于2月等等\语法：month(date)\end{cases}\ 年份函数（year）\begin{cases}返回给定日期的年份\语法：year(date)\\end{cases} \end{cases} 所用的单位函数⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​分钟函数（minute）{返回一个0到59之间的整数，对应于给定日期的分钟数语法：minute(date)​小时函数（hour）{返回一个0到23之间的整数，对应于给定日期的小时数语法：hour(date)​星期函数（day）{返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等语法：day(date)​日期函数（date）{返回一个1到31之间的整数,对应于给定日期语法：date(date)​月函数（month）{返回一个0到11之间的整数，0对应于1月，1对应于2月等等语法：month(date)​年份函数（year）{返回给定日期的年份语法：year(date)</p></li></ol><h1 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>notion</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian media 插件</title>
    <link href="/posts/42381/"/>
    <url>/posts/42381/</url>
    
    <content type="html"><![CDATA[<h1 id="1-media-插件"><a class="markdownIt-Anchor" href="#1-media-插件"></a> 1 media 插件</h1><p>本地视频打时间戳：<br>前边+file:// ，第三个"/"是users的,然后在阅读视图中打开，之后可以自动打时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221318976.png" alt="|600"></p><p>不在阅读视图中打开会自动跳转到默认应用打开，这样无法加时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221319732.png" alt="|600"></p><h1 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语口语</title>
    <link href="/posts/13436/"/>
    <url>/posts/13436/</url>
    
    <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/899591b0dea9484cb76d44a26c1c4c61">英语口语考试周主题</a></p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=d3049095-bb89-43d6-872f-f36158106173">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fluid写文章好用的代码</title>
    <link href="/posts/15457/"/>
    <url>/posts/15457/</url>
    
    <content type="html"><![CDATA[<p>网站嵌套<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid">[1]</span></a></sup></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"topFrame"</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"yes"</span>  <span class="hljs-attr">noresize</span>=<span class="hljs-string">"noresize"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"topFrame"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>tag插件</p><iframe src="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6" width="100%" height="1000" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe><hr><p><strong>参考资料</strong>：</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/posts/fluid-write/#iframe-%E9%A1%B5%E9%9D%A2%E9%95%B6%E5%A5%97">搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化</title>
    <link href="/posts/37878/"/>
    <url>/posts/37878/</url>
    
    <content type="html"><![CDATA[<blockquote><p>红色为重点</p></blockquote><p>考试范围：<br>第二章的单纯形法不考</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507551.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507026.png" alt="|600"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507616.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171506250.png" alt="|600"></div></div></div><p>动态规划求解：<a href="https://www.bilibili.com/video/BV1DL4y1G7mp?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化理论与方法-动态规划2_哔哩哔哩_bilibili</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222221137.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227555.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227315.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222228222.png)<br><br></code></pre></td></tr></tbody></table></figure><p>总复习：<a href="https://www.bilibili.com/video/BV1AF411z7hg/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化计算方法计算题复习_哔哩哔哩_bilibili</a></p><hr><p>2022-06-24(后记)：</p><ol><li>实际问题求标准型的问题：把目标函数写出来，约束条件写出来就行</li><li>黄金分割法：但是略微有点不一样，函数值算出来是负的。没关系仍然采用，谁的函数值就删其区间的策略</li><li>K-T条件：常规题</li><li>内点罚函数：注意一下把约束条件化为标准型：&lt;=0</li><li>哈密顿法：书上13-3原题，初始条件变了一点，加粗的看不懂(x(0) = 0，<strong>t<sub>f</sub> = 2，x1(0) + x2(0) =&nbsp;5</strong> )</li><li>共轭梯度法：共有三种方法可以解(牛顿法，最速下降法，共轭梯度法)，但是题目要求共轭梯度法</li><li>遗传算法：要求精确到0.01，简单是初始只有两个变量x1，x2。<ol><li>注意一点：适度函数中的常数要取f(x1)，f(x2)的最大值。本题中x1，x2取负数才是最大值，我写错了</li></ol></li><li>动态规化求线性规化：要求<strong>顺序法</strong>解，逆序法不给分，老师专门在考前1分钟强调。(<font color="#C32E94">15分</font>)</li><li>A* 算法：画格子，只有<font color="#C32E94">5分</font></li><li>神经网络：先由m求W，给了初始的V<sup>T</sup>。求更新状态，求对应的E<ol><li>求W，W12=m1的第一行 * 第二行 + m2的第一行 * 第二行。w13同理…</li><li>求V<sup>T</sup>，更新几，V乘上对应的W列 - θ<sub>i</sub>，没有θ就当成0。如果结果 &gt;= 0 取1，&lt; 0 取0。更新几号只写那个数。其他的初始V<sup>T</sup>照抄<ol><li>如果是二分图的，更新完的话，如果正数和负数的个数不相等的话，还要在随机找一个数变一下。然后使正负的个数相等</li></ol></li></ol></li></ol><blockquote><p>未标注的只有10分</p></blockquote><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转链接：<a href="http://localhost:4000/2022/06/17/zui-you-hua/">blog</a>，<a href="obsidian://advanced-uri?vault=Documents&amp;uid=a70cadd5-066a-4186-a092-69cf233c1b6e">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>退火</title>
    <link href="/posts/16303/"/>
    <url>/posts/16303/</url>
    
    <content type="html"><![CDATA[<h1 id="1-摘要"><a class="markdownIt-Anchor" href="#1-摘要"></a> 1: 摘要</h1><p><strong>是否退火</strong>：能够直接挤出就没必要退火，硬度低，比如纯铝，就没必要退火<br><strong>目的：</strong><br>提高成形后表面质量，<strong>提高它的塑性</strong>，便于改善成形效果，减少表面缺陷<br>退火主要是去应力，使材料组织回到初始状态，这样能保证挤压前每个工件的组织都一样<br>让晶粒均匀，能够好观察以后的梯度样貌<br><strong>成形要求</strong>：表面无缺陷，形状规整，就和松青挤出的纯铜差不多就行</p><h1 id="2-az13b镁合金-退火"><a class="markdownIt-Anchor" href="#2-az13b镁合金-退火"></a> 2: AZ13B镁合金 退火</h1><p><img src="https://s1.vika.cn/space/2022/06/15/07272ec877d24b698c8944d6a1296f0b" alt="|600"><br>150 ℃-240 min 退火后只有部分区域发生了再结晶(这不行)<br>在 300℃退火处理后,晶粒尺寸比较稳定,由平均晶粒尺寸为9.1μm 的再结晶组织组成<br>较高的温度(300℃)能够改善镁合金的塑性<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="margin">[1]</span></a></sup>。<br>AZ31B 镁合金轧制态板材经 300 ℃退火 60 min 后伸长率最高,为 27.3%。<br><img src="https://s1.vika.cn/space/2022/06/15/b41108bd01ba4924a6f8e98e64d285c6" alt="|600"><br><img src="https://s1.vika.cn/space/2022/06/15/d56b14c8de0348a292f42e2572ea922e" alt="|600"></p><h2 id="21-镁合金退火总结"><a class="markdownIt-Anchor" href="#21-镁合金退火总结"></a> 2.1: 镁合金退火总结</h2><p>自己总结: 退火温度升至 300℃, 保温 60min，退火后炉内冷却取出 ^ckuxll<br>30 分钟升到 300 度, 保温 60min</p><p>将锻态镁合金在350°C、2h的条件下进行再结晶退火<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网">[2]</span></a></sup><br>退火处理工艺及参数为：加热温度为260°C，保温15min， 升温速率取 5°C/min，随炉冷却后取出工件<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金表面滚压强化研究 - 中国知网">[3]</span></a></sup><br>镁合金板材<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[4]</span></a></sup>：将A Z 3 1 B镁合金板分别在2 0 0, 3 0 0, 4 0 0 ℃下保温1 0m i n,<br>未 热 处 理 A Z 3 1 B镁 合 金 板的显微组 织 主 要 由 大 小 不 均 匀 的 等 轴 晶 粒 组 成, 晶粒 尺 寸 为1 0~4 0μm, 形 成 的β析 出 相 (M g 1 7 A l 1 2相) 较少[ 1 4]; 2 0 0 ℃热 处 理 后 的 显 微 组 织 变 化不大, 等轴晶粒尺寸仍为1 0~4 0μm, 析出相的 分布也 没 有 明 显 变 化; 当 热 处 理 温 度 达 到 3 0 0, 4 0 0 ℃时, 镁 合 金 板 的 显 微 组 织 发 生 了 明 显 的 变化, 主要表现为大尺寸晶粒的数量明显增 多, 晶 粒的最大尺寸达到了5 0μm, 且析出相的分布更加弥散。对比可知, 2 0 0 ℃为 A Z 3 1 B镁 合 金 板 较 为 理想的加热 温 度, 该 温 度 下 能 够 较 好 地 保 持 细 小 的显微组织。</p><blockquote><p>这个好像是先退火200,300,400后，在挤压后的晶相<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207042001235.png" alt=""></p></blockquote><h1 id="3-19号楼马弗炉加热操作"><a class="markdownIt-Anchor" href="#3-19号楼马弗炉加热操作"></a> 3: 19号楼马弗炉加热操作</h1><h2 id="31-操作文档"><a class="markdownIt-Anchor" href="#31-操作文档"></a> 3.1: 操作文档</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017876.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017391.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162018849.png" alt="|600"></div></div></div><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4: 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/78EE4419-7316-4B0F-9104-116415CFBD95">margin</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021900755.nh&amp;uniplatform=NZKPT&amp;v=5Rx9z0dEkJU4WzR6pCnp0XWyhQb8xRZ5iMRPNdPJBPVDo9CF-RagrxkNh-MQaLMa">AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021155229.nh&amp;uniplatform=NZKPT&amp;v=us7-K1qgCpj5f5QN9eOdchJ9P2om_2zkT5iLqRdK25tWa_Bp7kcv2OYETpRo6scL">AZ31B镁合金表面滚压强化研究 - 中国知网</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="marginnote3app://note/5D3F197F-7FDC-42A0-8C97-2618192A9CC2">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>热处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>while 循环</title>
    <link href="/posts/36389/"/>
    <url>/posts/36389/</url>
    
    <content type="html"><![CDATA[<p>📝while 循环::</p><!-- basicblock-end --><p>链表的指针移动用 while, 没法用 for 循环</p><h1 id="1-与-for-循环对比"><a class="markdownIt-Anchor" href="#1-与-for-循环对比"></a> 1: 与 for 循环对比</h1><p>while循环是if 和 for 循环的结合体，<br>只要在while循环中增加跳出语句就行</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(i){<br> i++<br>}<br><br>等于<br><br><span class="hljs-keyword">if</span>(){<br><span class="hljs-keyword">for</span>()<br>}<br></code></pre></td></tr></tbody></table></figure><p>[[22.链表中倒数第k个节点]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(k--){<br><br>}<br><br>等价于<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++){<br><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-while-x"><a class="markdownIt-Anchor" href="#2-while-x"></a> 2: while (x)</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(i){ <span class="hljs-comment">// i 不能是变量; 可以直接写成 while(i--)</span><br>i--<br>}<br><br><br><span class="hljs-keyword">while</span>(n) <span class="hljs-comment">//  n &lt; 1 即可为 0, eg: n = 0.1 就会跳出循环</span><br></code></pre></td></tr></tbody></table></figure><h1 id="3-嵌套-while"><a class="markdownIt-Anchor" href="#3-嵌套-while"></a> 3: 嵌套 while</h1><p>[[21.调整数组顺序使奇数位于偶数前面]]</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l &lt; r){<br>    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) l++; <span class="hljs-comment">// 因为 l++, r--可能会破坏外层的条件, 所以要重申</span><br>    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) r--;<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20.合并区间</title>
    <link href="/posts/14697/"/>
    <url>/posts/14697/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解： 56. 合并区间</p><span id="more"></span><h1 id="1-56-合并区间"><a class="markdownIt-Anchor" href="#1-56-合并区间"></a> 1 56. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">力扣题目链接</a></p><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>输入: intervals = [ [1,3],[2,6],[8,10],[15,18] ]</li><li>输出: [ [1,6],[8,10],[15,18] ]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><p>示例&nbsp;2:</p><ul><li>输入: intervals = [ [1,4],[4,5] ]</li><li>输出: [ [1,5] ]</li><li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li><li>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</li></ul><p>提示：</p><ul><li>intervals[ i ]  [0] &lt;= intervals[ i ]  [ 1 ]</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>左边界排序后<br>局部最优：每次合并都取<strong>最大的右边界</strong>，这样就可以合并更多的区间了<br>整体最优：合并所有重叠的区间。<br>排序后：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，一定有重叠(包含或者交集)！</p><blockquote><p>第二个数组的头如果小于第一个数组的尾，那么一定有重复<br><img src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p></blockquote><h2 id="21-排序"><a class="markdownIt-Anchor" href="#21-排序"></a> 2.1 排序</h2><p>按左边界排序</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br></code></pre></td></tr></tbody></table></figure><h2 id="22-判断是否重叠-合并区间"><a class="markdownIt-Anchor" href="#22-判断是否重叠-合并区间"></a> 2.2 判断是否重叠 +合并区间</h2><h3 id="221-是否重叠"><a class="markdownIt-Anchor" href="#221-是否重叠"></a> 2.2.1 是否重叠</h3><p>for循环中判断重叠<br>第二个数组的头小于第一个数组的尾即为重叠<br><code>intervals[i][0] &lt;= intervals[i - 1][1]</code><br>定义出来两个数组的头和尾，这样下边写的更简洁</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下标从1开始，因为要比较：intervals[i][0] &lt;= intervals[i - 1][1]</span><br><span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始区间的左边界</span><br><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];   <span class="hljs-comment">// 初始区间的右边界</span><br></code></pre></td></tr></tbody></table></figure><h3 id="222-合并区间"><a class="markdownIt-Anchor" href="#222-合并区间"></a> 2.2.2 合并区间</h3><p>用[[while 循环]]合并区间：while循环是if 和 for 循环的结合体<br>比较第一个数组和第二数组的尾部谁更大，更新数组的尾部就行<br>同时要控制i的增加，如果合并了，那么进行一次i++, 出去while 循环后，for又进行一次i++，这样就控制了跳过了合并区间👉🏻[[20.合并区间#^hcnuf7]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 比较第一个数组和第二数组的尾部</span><br></code></pre></td></tr></tbody></table></figure><p>整体代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) { <span class="hljs-comment">// 判断重叠</span><br>          <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    <span class="hljs-comment">// 初始为i-1区间的左边界</span><br>          <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];      <span class="hljs-comment">// 初始i-1区间的右边界</span><br>          <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end) { <span class="hljs-comment">// 合并区间</span><br>              end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 不断更新右区间</span><br>              <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 最后一个区间也合并了</span><br>              i++;                                <span class="hljs-comment">// 继续合并下一个区间</span><br>          }<br></code></pre></td></tr></tbody></table></figure><h2 id="23-放入result结果集"><a class="markdownIt-Anchor" href="#23-放入result结果集"></a> 2.3 放入result结果集</h2><p>取合并区间的头和尾作为一个新的数组加入到result数组中，<code>result.push_back({start, end});</code><br>如果没有合并就把原数组加入result</p><p><strong>注意</strong>：<br>还要单独判断最后一个数组是否合并了，如果合并了，正常加入就如result就行<br>如果没合并要单独的把最后一个数组加入result</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-代码随想录断点调试"><a class="markdownIt-Anchor" href="#31-代码随想录断点调试"></a> 3.1 代码随想录断点调试</h2><p>carl<br>[20.合并区间(carl).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/20.合并区间(carl).mp4)<br>[00:19](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=19.133532) ：i++<br>如果合并了第二区间，那么自然i不能从第二个区间在开始，要从第三个位置开始，while循环中有个i++，到了for循环中还有个i++, i到时候等于3，就跳过了合并的区间在开始<br>[00:29](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=29.228653)：此时i 等于3，从合并区间的下个区间在开始进行 ^hcnuf7</p><h2 id="32-carl-自写"><a class="markdownIt-Anchor" href="#32-carl-自写"></a> 3.2 carl 自写</h2><p>编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 只比较左位置，所以不用二维数组</span><br>    }<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) {<br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<span class="hljs-comment">// 此时result为空</span><br>        <span class="hljs-type">int</span> length = intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不要定义在for循环中</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++){<br>            <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end){ <span class="hljs-comment">// 不要忘记=，“=”是头尾相等</span><br>                end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;<br>                i++;<br>            }<br>            result.<span class="hljs-built_in">push_back</span> ({start,end}); <span class="hljs-comment">// 如果没合并就是单独的，如果合并了也更新了。</span><br>                                            <span class="hljs-comment">// 每一次的循环都在加入result数组，所以在for循环中</span><br>        }<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>) {<br>            result.<span class="hljs-built_in">push_back</span>({intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]});<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><sub>自用跳转链接</sub>：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=88f96891-7092-4c04-a067-349995d05800">ob</a>，<a href="http://localhost:4000/2022/06/16/20.he-bing-qu-jian/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notion函数公式</title>
    <link href="/posts/11772/"/>
    <url>/posts/11772/</url>
    
    <content type="html"><![CDATA[<p>notion函数公式</p><h1 id="1-时间公式"><a class="markdownIt-Anchor" href="#1-时间公式"></a> 1 时间公式</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">开始的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>))<br>结束的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))<br><br>开始的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br>结束的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br><br><br>相减的分钟数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))<br>相减的小时数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)))<br><br>小时+分钟：<br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span> <br><br><br><span class="hljs-comment">//不借位</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//借位</span><br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span><br><br><br><span class="hljs-comment">//时间计算总函数：已通过</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) + <span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>)<br><br><span class="hljs-comment">//时间范围改造函数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)))+ <span class="hljs-string">"h"</span> + format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))) +<span class="hljs-string">"m"</span> , <span class="hljs-string">"0"</span>)<br></code></pre></td></tr></tbody></table></figure><p>时间范围</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><span class="hljs-comment">//不借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><br><span class="hljs-comment">//借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br></code></pre></td></tr></tbody></table></figure><p>写notion公式的心得：把零件找出来，在组装</p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>notion</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
    <link href="/posts/12294/"/>
    <url>/posts/12294/</url>
    
    <content type="html"><![CDATA[<p>c++中 - ‘0’ 的相减操作解释::</p><p>将数字字符转为整形变量</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将str 字符串"1234"里的各个数字字符转成整型，存入整型数组x：</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"1234"</span>;<br><span class="hljs-type">int</span> x[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++) x[i] = str[i] - <span class="hljs-string">'0'</span>; <br></code></pre></td></tr></tbody></table></figure><blockquote><p>数字字符减去‘0’就得到了该数字。减去字符0，也就是减去0的ASCII码值48。</p></blockquote><!-- basicblock-end --><p>c++中 -‘a’ 的相减操作解释::</p><h1 id="1-取到字母字符对应的数字a0b1"><a class="markdownIt-Anchor" href="#1-取到字母字符对应的数字a0b1"></a> 1: 取到字母字符对应的数字：a→0，b→1…</h1><p><strong>原理：a - ‘a’ = 0, b - ‘a’ = 1 …</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<br>S = <span class="hljs-string">"ababcbacadefegdehijhklij"</span><span class="hljs-comment">// S[0] - 'a'= 0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) { <br>            hash[S[i] - <span class="hljs-string">'a'</span>] = i; <span class="hljs-comment">//</span><br>        }<br></code></pre></td></tr></tbody></table></figure><p>eg :[[19.划分字母区间#^dhg2oc]]  , [[2. 有效的字母异位词]]<br>[01:03](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835)<br>S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - ‘a’=&nbsp;S[6] - ‘a’ = 0</p><h1 id="2-将字母由小写转为大写"><a class="markdownIt-Anchor" href="#2-将字母由小写转为大写"></a> 2: 将字母由小写转为大写</h1><p>字母字符- 'a’得到 该字母下的下标</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 把字符串中字母，小写变大写</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"aBcxYz"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(str); i++)<br><span class="hljs-keyword">if</span> (str[i] &gt;=<span class="hljs-string">'a'</span> &amp;&amp; str[i] &lt;=<span class="hljs-string">'z'</span>) str[i] = str[i] -<span class="hljs-string">'a'</span> + <span class="hljs-string">'A'</span>;<br></code></pre></td></tr></tbody></table></figure><p>本质是减去 a 的 ASII 值, 在加上 A 的 ASII 值. 改变了字母的 起始 ASII 值</p><p>[[有关字符要想到的操作]]</p><h1 id="3-取到数字所对应的字母-这个不好办"><a class="markdownIt-Anchor" href="#3-取到数字所对应的字母-这个不好办"></a> 3: 取到数字所对应的字母, 这个不好办</h1><p>如果你想要获取数字所对应的字母，你可以使用一个数组来存储每个数字对应的字母。例如，你可以创建一个名为 <code>letters</code> 的数组，其中存储了 <code>a</code> 到 <code>z</code> 的所有字母：</p><p>这样就麻烦了</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
    <link href="/posts/12295/"/>
    <url>/posts/12295/</url>
    
    <content type="html"><![CDATA[<p>执行continue 函数相当于又调到了函数的开头[00:04](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=4.619299)<br>作用：能够控制for循环中，跳过一些代码段，然后又使i不断前进<br>[23.买卖股票的最佳时机含手续费](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4)</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.划分字母区间</title>
    <link href="/posts/22082/"/>
    <url>/posts/22082/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解：763.划分字母区间</p><span id="more"></span><h1 id="1-763划分字母区间"><a class="markdownIt-Anchor" href="#1-763划分字母区间"></a> 1 763.划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">力扣题目链接</a></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><ul><li>输入：S = “ababcbacadefegdehijhklij”</li><li>输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</li></ul><p>提示：</p><ul><li>S的长度在[1, 500]之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’ 。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>总共分为两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点<br><img src="https://img-blog.csdnimg.cn/20201222191924417.png" alt="763.划分字母区间|900"></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-carl断点调试"><a class="markdownIt-Anchor" href="#31-carl断点调试"></a> 3.1 carl断点调试</h2><p>[19.划分字母区间(carl).MP4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/19.划分字母区间(carl).mp4)<br>以后可以监听几个变量：S[i]，right - left +1<br>[[c++中 - ‘0’ 以及 -‘a’ 的相减操作解释]]<br>S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>[00:12](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=12.709769)<br>S = “a<mark>b</mark>abcbacadefegdehijhklij”，相当于将b对应1，这个数存在了hash里<br>hash[S[1] - ‘a’] =&nbsp;1，即hash[2] = 1<br>[01:03](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835)<br>S = “==<strong>a</strong><mark>babcbac</mark><strong>a</strong>==defegdehijhklij”<br>将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - ‘a’=&nbsp;S[9] - ‘a’ = 0 (第一个区间)<br>[01:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=70.392045)<br>此使 right = max(0, 8)，之道i 到下标8才会进入if 循环语句，它在下标8之前一直在比较有没有比8更大值，有的话说明第一个分割点更远<br>[01:53](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=113.069755)<br>到达第一分割点下标8(i =&nbsp;8)处，开始push_back结果，并且更新下一个区间<br>right  - left + 1  = 8-0+1= 9 第一个区间相当于：尾 - 头 + 1<br>下个区间要在更新一下头即left = i+1 =&nbsp;9</p><h3 id="311-代码"><a class="markdownIt-Anchor" href="#311-代码"></a> 3.1.1 代码</h3><p>自写 编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>{<br>       <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<span class="hljs-comment">// 数组初始化必须是列表，不能是单纯的0</span><br>       <span class="hljs-comment">//int hash[S.size()] = {0}; // S.size 可变动的，错误：可变大小的对象可能未初始化</span><br><br>       <span class="hljs-comment">//hash数组中写入每个字母的所对应的最远下标值</span><br>       <span class="hljs-comment">//因每个字母的S[i] - 'a'是不变的，所以可以一直更新最远下标</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           hash[S[i] - <span class="hljs-string">'a'</span>] = i;<br>       }<br>       <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>       vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// vector 能够不断往里加数据</span><br>       <span class="hljs-comment">// 不断的找分割区间</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           right = <span class="hljs-built_in">max</span> (right, hash[S[i] - <span class="hljs-string">'a'</span>]); <span class="hljs-comment">// 确定区间的尾部 不是hash[i], 是每个字母对应的最远下标</span><br>           <span class="hljs-keyword">if</span>(i == right){<br>               result.<span class="hljs-built_in">push_back</span>(right - left +<span class="hljs-number">1</span>); <span class="hljs-comment">// 返回是字符串的长度所以+1</span><br>               left = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新下一个区间头部，现在i是上一区间的尾，所以下个头部为 i+1</span><br>           }<br>       }<br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=13b04b05-d8f9-4a57-a909-3b6b3af97825">ob</a>，<a href="http://localhost:4000/2022/06/15/19.hua-fen-zi-mu-qu-jian/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>切割材料+制样</title>
    <link href="/posts/47598/"/>
    <url>/posts/47598/</url>
    
    <content type="html"><![CDATA[<h1 id="1-切割"><a class="markdownIt-Anchor" href="#1-切割"></a> 1: 切割</h1><h2 id="11-圆盘"><a class="markdownIt-Anchor" href="#11-圆盘"></a> 1.1: 圆盘</h2><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208301948279.png" alt="|600"></p><h2 id="12-圆棒"><a class="markdownIt-Anchor" href="#12-圆棒"></a> 1.2: 圆棒</h2><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208301952524.png" alt="|600"></p><h1 id="2-切割"><a class="markdownIt-Anchor" href="#2-切割"></a> 2: 切割</h1><p>切割圆棒和圆盘分离处12mm范围内，<br><img src="https://s1.vika.cn/space/2022/06/14/2d7ff49ea0c8442ab6e80f41c0f30a32" width="500" height="500"></p><h1 id="3-制样"><a class="markdownIt-Anchor" href="#3-制样"></a> 3: 制样</h1><p>第一次溶液做点稀点：一次性杯子，倒4分之一的水(配套粉的)，4勺粉。搅拌至拉丝<br>倒到模具当中，先倒一点(3分之一)，然后用镊子在把材料拿起在压下去</p><blockquote><p>主要让切割材料底下溶液渗透均匀<br><img src="https://s1.vika.cn/space/2022/06/14/7139d0510c9e43e2a3bcc0b7816cfbe8" alt="|200"></p></blockquote><p>第二次溶液做点稠点：一次性杯子，倒3分之一的水(配套粉的)，7勺粉。搅拌至拉丝<br>这次把模具倒满</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PPT技巧-文字高亮</title>
    <link href="/posts/36733/"/>
    <url>/posts/36733/</url>
    
    <content type="html"><![CDATA[<p>注意事项：</p><p>按住Shift 用来垂直或水平移动<br>如果上下两个文字没有在同一位置，无法实现文字滚动效果</p><hr><p>参考资料：<br><a href="https://www.bilibili.com/video/BV1pv4y1G7Qp/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">keynote 教程 有手就行系列 024 苹果发布会分解教学_哔哩哔哩_bilibili</a></p><hr><p>下一篇：[[切割材料+制样]]</p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自然辩证法考试重点</title>
    <link href="/posts/60394/"/>
    <url>/posts/60394/</url>
    
    <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/832c73b10a1849e49262e0d8eb1b505b">自然辩证法重点-notion.</a></p><p><a href="https://skinny-girl-067.notion.site/de438994556a4d8fb3c7aa7cbdec36d9">考前速记+考后整理.</a></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>六级考试时间安排</title>
    <link href="/posts/35757/"/>
    <url>/posts/35757/</url>
    
    <content type="html"><![CDATA[<p>正式时间：15.00-17.25<br>报道时间：14.20</p><p>15.00前：发答题卡</p><p>15.00-15.10：开始发卷子</p><p>15.10-15.40：开始让动笔写作文👉 30分钟</p><p>15.40-16.10：听力👉 30分钟</p><p>16.10-16.15：暂停5分钟收答题卡1(作文和听力)</p><p>16.15-17.25：余下时间写卷至结束</p><p>下一篇：[[自然辩证法考试重点]]</p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>六级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由hexo clean 问题引发的一些学习感想</title>
    <link href="/posts/19528/"/>
    <url>/posts/19528/</url>
    
    <content type="html"><![CDATA[<p>hexo 上传文章的固定流程：</p><p><code>hexo clean</code> → <code>hexo g</code> → <code>hexo s</code> → <code>hexo d</code></p><p>其实网上看了很多人这样写，但我一直把<code>hexo clean</code> 写成 <code>hexo c</code>。其实系统也一直都有在报错，但我从来都没有关注。因为终端窗口小，没能显示出来上边的错误信息，下面一堆英文的也不想看。每次都当成了顺利执行了。自己还沾沾自喜的觉得<code>hexo c</code> 写也可以，网上没人说自己发现了新大陆了。<br><img src="https://s1.vika.cn/space/2022/06/11/9106c9ae345a4543a36819fd0351132c" alt="|600"><br>后来在用hexo写文章的时候，换主主题总是有些问题(见下图)，自己困扰了很多天，每天拿出来很多时间来尝试解决问题，但都无果。其实就是因为没有用hexo clean 清除缓存导致的<br><img src="https://s1.vika.cn/space/2022/06/11/d2d6e3f8df354e7cad5a8cfa1b5d2983" alt="|800"></p><p>我为什么一直固执写 <code>hexo c</code> 呢，<br>我认为有以下方面原因：</p><ol><li><strong>自以为是</strong>。觉得很多都可以简写，那这个命令应该也可以。自己试了试看到终端输出信息了。就觉得可以了，但其实根本没认真看出来的信息</li><li><strong>嫌麻烦</strong>。觉得是英文的，根本静不下来心去看。</li></ol><p>希望以后在这两方面加强自己</p><p>下一篇：[[六级考试时间安排]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>0突发奇想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo 问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科研材料总结</title>
    <link href="/posts/52144/"/>
    <url>/posts/52144/</url>
    
    <content type="html"><![CDATA[<p>硬度单位<br>洛氏硬度：HR；布氏硬度：HB；维氏硬度：HV</p><p>自用<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="ob">[2]</span></a></sup></p><h1 id="1-镁合金"><a class="markdownIt-Anchor" href="#1-镁合金"></a> 1 镁合金</h1><h2 id="11-硬度"><a class="markdownIt-Anchor" href="#11-硬度"></a> 1.1 硬度</h2><p>镁合金型号：<strong>AZ31B(HR70)</strong> AZ61 AZ91  ZK60 WE40<br>镁合金的hv：45~75不等</p><p>纯铜：HB85，50~65HV<br>纯铝：HB28<br>7075铝合金：退火后的HV140</p><p><strong>硬度低于纯铜的材料：</strong><br><strong>纯铜</strong>：HB：85，HV：50~65<br>退火(软)铜硬度为：50HV</p><p>304不锈钢：<br>淘宝：硬度在HBW85左右(淘宝)<br>网上：HB187，HRB90，HV200</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207041914021.png" alt=""></p><h1 id="2-模具材料硬度"><a class="markdownIt-Anchor" href="#2-模具材料硬度"></a> 2 模具材料硬度</h1><p>skh51 热处理淬火后硬度可以达到64HRC</p><p>skd11 热处理后硬度58~60HRC</p><h1 id="3-退火"><a class="markdownIt-Anchor" href="#3-退火"></a> 3 [[退火]]</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:2" class="footnote-text"><span><a href="obsidian://advanced-uri?vault=Documents&amp;uid=c94962a5-c07b-4fe5-b5c1-4d72c4fb033a">ob</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18.无重叠区间</title>
    <link href="/posts/34584/"/>
    <url>/posts/34584/</url>
    
    <content type="html"><![CDATA[<p>文章简介：<br>力扣题解：435. 无重叠区间</p><span id="more"></span><h1 id="1-无重叠区间"><a class="markdownIt-Anchor" href="#1-无重叠区间"></a> 1 无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">力扣题目链接</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><blockquote><p>返回需要移除的区间个数(交叉区间 = 总个数-非交叉区间的个数)</p></blockquote><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><ul><li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li><li>输出: 1</li><li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li></ul><p>示例 2:</p><ul><li>输入: [ [1,2], [1,2], [1,2] ]</li><li>输出: 2</li><li>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</li></ul><p>示例 3:</p><ul><li>输入: [ [1,2], [2,3] ]</li><li>输出: 0</li><li>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>从左向右遍历，优先选择右边界小的数组(因为右边界越小，留给下一个区间的空间就越大)</p><blockquote><p><img src="https://s1.vika.cn/space/2022/06/10/6830dccb02804260a38ac29d8641f9f8" alt="|600"></p></blockquote><p><strong>局部最优</strong>：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。<br><strong>全局最优</strong>：选取最多的非交叉区间。<br><img src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间|600"></p><blockquote><p>选择1就把2，3pass了，选择4就把5pass了</p></blockquote><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-carl"><a class="markdownIt-Anchor" href="#31-carl"></a> 3.1 carl</h2><h3 id="311-解法1"><a class="markdownIt-Anchor" href="#311-解法1"></a> 3.1.1 解法1</h3><p>自写代码已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<span class="hljs-comment">// 按右边界排序</span><br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">//记录非交叉区间的个数</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录第一个区间的尾部</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(end &lt;= intervals[i][<span class="hljs-number">0</span>]){<span class="hljs-comment">// 如果头尾没有重合，即不重叠</span><br>                end = intervals[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新end为下一个没有重合的尾部，不断for循环在</span><br>                count++;<span class="hljs-comment">// 记录不重合的个数</span><br>            }<br>        } <br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count; <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="312-解法2利用17用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#312-解法2利用17用最少数量的箭引爆气球"></a> 3.1.2 解法2：利用[[17.用最少数量的箭引爆气球]]</h3><p>弓箭的数量就相当于是<strong>非交叉区间</strong>的数量(因为交叉区间可以用一支箭射爆)，<br>只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1]，[1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间左边界从大到小排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) { <span class="hljs-comment">// 需要要把&gt; 改成 &gt;= 就可以了</span><br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {<br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1Uh41117SZ?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode  Python版每日一题（20201231）：435. 无重叠区间（想想罗志祥会怎么做）哔哩哔哩_bilibili</a></p><p>自用跳转连接：<a class="btn" href="http://localhost:4000/2022/06/10/18.wu-chong-die-qu-jian/" title="title">blog</a> <a class="btn" href="obsidian://advanced-uri?vault=Documents&amp;uid=6ef3123b-213a-456b-adba-e26f4a9b2215" title="title">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.用最少数量的箭引爆气球</title>
    <link href="/posts/2006/"/>
    <url>/posts/2006/</url>
    
    <content type="html"><![CDATA[<p><strong>文章简介</strong>：<br>力扣题解：452用最少数量的箭引爆气球</p><span id="more"></span><h1 id="1-452用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#1-452用最少数量的箭引爆气球"></a> 1 452用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 &nbsp;xstart&nbsp;≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，<strong>返回引爆所有气球所必须射出的最小弓箭数。</strong></p><p>示例 1：</p><ul><li>输入：points = [ [10,16],[2,8],[1,6],[7,12] ]</li><li>输出：2</li><li>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li></ul><p>示例 2：</p><ul><li>输入：points = [ [1,2],[3,4],[5,6],[7,8] ]</li><li>输出：4</li></ul><p>示例 3：</p><ul><li>输入：points = [ [1,2],[2,3],[3,4],[4,5] ]</li><li>输出：2</li></ul><p>示例 4：</p><ul><li>输入：points = [ [1,2] ]</li><li>输出：1</li></ul><p>示例 5：</p><ul><li>输入：points = [ [2,3],[2,3] ]</li><li>输出：1</li></ul><p>提示：</p><ul><li>0 &lt;= points.length &lt;= 10^4</li><li>points[i].length == 2</li><li>-2^31 &lt;= xstart &lt;&nbsp;xend &lt;= 2^31 - 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-b站参考视频及笔记"><a class="markdownIt-Anchor" href="#21-b站参考视频及笔记"></a> 2.1 b站参考视频及笔记</h2><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br><img src="https://s1.vika.cn/space/2022/06/10/3141cfabb0c94275b7edf999b4b5197f" alt=""></p><p>从这里开始看即可</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=544.080526">09:04</a></p><p>先按左端点先排好序<br>不用管左端点，<strong>只关心右端点就行</strong>，因为只在右端点射击就行了<br>记录射击区间为第一个数组区间：[一左，一右]，<strong>其实只关心右端点就行了</strong></p><p>如果第二个数组的<strong>左端点</strong><mark>小于</mark>第一个数组的<strong>右端点</strong>(两个数组有重叠部分)<br>说明第二个数组在射击区间内，同时将射击区间更新为：[二左，一右] (重叠部分)，右端点无变化</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=617.733348">10:17</a><br>如果第二数组的右端点<mark>小于</mark>第一个数组的右端点 (说明要缩小射击区间)<br>射击区间为：[一左，二右]</p><p>如果第二数组的左端点大于第一个数组的<strong>右端点</strong>(两个数组<strong>没有</strong>重叠部分)，箭数+1(需要另一支箭才可以射完)<br>更新射击区间为：[二左，二右] (第二个数组区间)</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=765.508572">12:45代码结果</a></p><h2 id="22-代码随想录"><a class="markdownIt-Anchor" href="#22-代码随想录"></a> 2.2 代码随想录</h2><p><strong>局部最优</strong>：当气球出现重叠，一起射，所用弓箭最少。</p><p><strong>全局最优</strong>：把所有气球射爆所用弓箭最少。</p><blockquote><p>按照气球的起始位置排序，从前向后遍历气球数组，靠左尽可能让气球重复，重复的用一个箭射</p></blockquote><p><strong>如果气球重叠了，重叠气球中最小右边界， 之前的区间一定需要一个弓箭</strong></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，<br>气球3的<strong>左边界大于</strong>了第一组重叠气球的<strong>最小右边界</strong>，所以再需要一支箭来射气球3了。</p><blockquote><p>此时箭数+1</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="https://img-blog.csdnimg.cn/20201123101929791.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title class_">Solution</span>&nbsp;{<br><br><span class="hljs-keyword">private</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">static</span>&nbsp;<span class="hljs-type">bool</span>&nbsp;<span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;a,&nbsp;<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;b)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;a[<span class="hljs-number">0</span>]&nbsp;&lt;&nbsp;b[<span class="hljs-number">0</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span class="hljs-keyword">public</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">int</span>&nbsp;<span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;&nbsp;points)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points.<span class="hljs-built_in">size</span>()&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-number">0</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),&nbsp;points.<span class="hljs-built_in">end</span>(),&nbsp;cmp);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">int</span>&nbsp;result&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;<span class="hljs-comment">//&nbsp;points&nbsp;不为空至少需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-type">int</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;i&nbsp;&lt;&nbsp;points.<span class="hljs-built_in">size</span>();&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points[i][<span class="hljs-number">0</span>]&nbsp;&gt;&nbsp;points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1不挨着，注意这里不是&gt;=</span><br><span class="hljs-comment">//points: {{1, 6}, {2, 8}, {7, 12}, {10, 16}} if (points[i][0] &gt; points[i - 1][1])</span><br><span class="hljs-comment">//eg：points[1][0] &gt; points[0][1]：第二个元素的第0号位置 &gt;第一个元素的第1号位置 2&gt;6 (if 语句跳过)看图更容易懂</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result++;&nbsp;<span class="hljs-comment">//&nbsp;需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span>&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1挨着</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points[i][<span class="hljs-number">1</span>]&nbsp;=&nbsp;<span class="hljs-built_in">min</span>(points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],&nbsp;points[i][<span class="hljs-number">1</span>]);&nbsp;<span class="hljs-comment">//&nbsp;更新重叠气球最小右边界</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;result;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>图解<br><img src="https://s1.vika.cn/space/2022/06/10/a494349688e74c7ebe4ce80e4b26d1bc" alt="|700"></p><h2 id="31-自写编译已通过b站三天动画版"><a class="markdownIt-Anchor" href="#31-自写编译已通过b站三天动画版"></a> 3.1 自写编译已通过(b站三天动画版)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rarrow = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 射击区间的右端点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= rarrow){ <span class="hljs-comment">// 有重叠部分，这里必须小于等于因为也要找到挨着但不重叠的，最后是用射击右端点来判别的</span><br>                <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">1</span>] &lt; rarrow){ <span class="hljs-comment">// 如果第二数组的右端点比第一个数组的右端点小，就缩小射击区间</span><br>                rarrow = points[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新右端点</span><br>                }<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                rarrow = points[i][<span class="hljs-number">1</span>];<br>                arrow ++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> arrow;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-自写编译已通过carl-推荐"><a class="markdownIt-Anchor" href="#32-自写编译已通过carl-推荐"></a> 3.2 自写编译已通过(carl) 推荐</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">// 有气球至少需要一个箭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>        <span class="hljs-comment">// 如果有重叠或者挨着就可以用一支箭射爆(因为射爆的区间是大区间，重叠的是子区间),右边界就是射爆的位置</span><br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]){<span class="hljs-comment">// 2的左边界比1的右边界小说明重叠了</span><br>                    points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span> (points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新右边界与(变成重叠区间)，与下一个比,看下一个的位置是否在重叠区间内，不在则需要另外的箭</span><br>                }<br><br>            <span class="hljs-keyword">else</span> arrow++;<br>            } <br><br><br>            <span class="hljs-keyword">return</span> arrow;<br>            <br>        }<br>   <br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=ae2b0ee3-99ee-4a44-906e-5a2a66bf5f40">ob</a>，<a href="http://localhost:4000/2022/06/10/17.yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BAB</title>
    <link href="/posts/29968/"/>
    <url>/posts/29968/</url>
    
    <content type="html"><![CDATA[<p>BetterAndBetter手势操作助记<br>右键按压手势<br>![[BAB手势 2022-06-09 17.21.49.excalidraw]]</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=2254a3a7-a5e7-412b-88d2-f1a712755b28">ob</a>，<a href="http://localhost:4000/2022/06/09/bab/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>obsidian templater 插件</title>
    <link href="/posts/36637/"/>
    <url>/posts/36637/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件类"><a class="markdownIt-Anchor" href="#1-文件类"></a> 1 文件类</h1><h2 id="11-获取文件的相对路径"><a class="markdownIt-Anchor" href="#11-获取文件的相对路径"></a> 1.1 获取文件的相对路径</h2><p>eg: card-deck: &lt;% tp.file.path(true) %&gt;<br><a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/file-module.html#tpfilepathrelative-boolean--false"><code>tp.file.path(relative: boolean = false)</code></a><br>检索文件在系统上的绝对路径<br><code>relative</code>：如果设置为 true，则仅检索 Vault 的相对路径。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/file-module.html#arguments-9">tp.file - Templater</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.根据身高重建队列</title>
    <link href="/posts/21392/"/>
    <url>/posts/21392/</url>
    
    <content type="html"><![CDATA[<h1 id="1-406根据身高重建队列"><a class="markdownIt-Anchor" href="#1-406根据身高重建队列"></a> 1 406.根据身高重建队列</h1><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">力扣题目链接</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><ul><li>输入：people = [ [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] ]</li><li>输出：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]</li><li>解释：<ul><li>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</li><li>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</li><li>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>因此 [ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ] 是重新构造后的队列。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：people = [ [6,0],[5,0],[4,0],[3,2],[2,2],[1,4] ]</li><li>输出：[ [4,0],[5,0],[2,2],[3,2],[1,4],[6,0] ]</li></ul><p>提示：</p><ul><li>1 &lt;= people.length &lt;= 2000</li><li>0 &lt;= hi &lt;= 10^6</li><li>0 &lt;= ki &lt; people.length</li></ul><p>题目数据确保队列可以被重建</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。<br><strong>如果两个维度一起考虑一定会顾此失彼</strong></p><p>先按身高h来排序(从大到小)，身高相同的k小的站前面<br>在按k的大小进行<strong>插入</strong>操作，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。<br><img src="https://img-blog.csdnimg.cn/20201216201851982.png" alt="406.根据身高重建队列|800"><br>插入的过程：</p><ul><li>插入[7,0]：[ [7,0] ]// 插入0下标</li><li>插入[7,1]：[ [7,0],[7,1] ]// 插入1下标</li><li>插入[6,1]：[ [7,0],[6,1],[7,1] ]// 插入1下标</li><li>插入[5,0]：[ [5,0],[7,0],[6,1],[7,1] ]// 插入0下标</li><li>插入[5,2]：[ [5,0],[7,0],[5,2],[6,1],[7,1] ]// 插入2下标</li><li>插入[4,4]：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]// 插入4下标</li></ul><p>如果先按k来排序，会发现k的排列不符合条件，身高也不符合条件，两个维度一个也没确定下来</p><p>在按照身高从大到小排序后：<br><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong><br><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><h3 id="211-关联知识点"><a class="markdownIt-Anchor" href="#211-关联知识点"></a> 2.1.1 关联知识点</h3><p>[[vector (🗃)]]，[[sort()函数]]，[[insert函数]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[14.根据身高重建队列(carl链表).mp4]]<br>[[14.根据身高重建队列(carl vector).mp4]]<br>[[14.根据身高重建队列(carl 排序).mp4]]</p><p>vector的代码看懂了</p><p>排序完的people： [ [7,0], [7,1], [6,1], [5,0], [5,2]，[4,4] ]<br><code>people[i][1]</code>：eg <code>people[2][1]</code>=1：第二元素的第一个位置的值即{7, 1}中的1</p><p>自写,编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 没看懂，看视频：传进来的是数组eg[7,0]</span><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people){<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要放到for循环里边</span><br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 要插入的是que里，不要成people.begin()</span><br>        }<br>        <span class="hljs-keyword">return</span> que;<br>      }   <br>};<br><br></code></pre></td></tr></tbody></table></figure><p>链表的代码没看懂  #疑问</p><p>[[科研材料总结]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>begin,end</title>
    <link href="/posts/18356/"/>
    <url>/posts/18356/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>};<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);<br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);<br></code></pre></td></tr></tbody></table></figure><p>begin函数返回指向数组的<strong>首元素的指针</strong>，end函数返回指向数组<strong>尾元素的下一个位置的指针</strong>，<br>这两个函数都被定义在iterator的头文件中。使用begin和end函数就可以很好地处理数组中的元素</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>insert函数</title>
    <link href="/posts/44424/"/>
    <url>/posts/44424/</url>
    
    <content type="html"><![CDATA[<h1 id="1-在字符串中插入"><a class="markdownIt-Anchor" href="#1-在字符串中插入"></a> 1 在字符串中插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"All that exists is what's ahead."</span>)</span></span>;<br>    string a, b;<br>    a = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-string">"sky"</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串sky</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">//输出All skythat exists is what's ahead.</span><br> <br>    str = <span class="hljs-string">"All that exists is what's ahead."</span>;<br>    b = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">'x'</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串5个字符x</span><br>    cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//输出 All xxxxxthat exists is what's ahead.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-在数组下标处插入"><a class="markdownIt-Anchor" href="#2-在数组下标处插入"></a> 2 在数组下标处插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 在下标position处插入people[i]</span><br></code></pre></td></tr></tbody></table></figure><p>[[begin,end]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.分发糖果</title>
    <link href="/posts/43465/"/>
    <url>/posts/43465/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分发糖果"><a class="markdownIt-Anchor" href="#1-分发糖果"></a> 1 分发糖果</h1><p><a href="https://leetcode-cn.com/problems/candy/">力扣题目链接</a></p><p>老师想给孩子们分发糖果，有 N&nbsp;个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例&nbsp;1:</p><ul><li>输入: [1,0,2]</li><li>输出: 5</li><li>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: [1,2,2]</li><li>输出: 4</li><li>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>先比较每一个孩子的右边或者左边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>rate：评分；candyVec：糖果个数</p><p><strong>右边</strong>：从前往后遍历<br>局部最优：如果右比左大，右边孩子就多一个糖果。<br>全局最优：总体中评分高的右孩子比左孩子多一个糖果<br><img src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果|700"><br><strong>左边</strong>：从后往前遍历<br>局部最优：如果左比右大，左边孩子就多一个糖果。<br>全局最优：总体中评分高的左孩子比右孩子多一个糖果<br>#flashcards/代码随想录<br>为什么不能从前往后遍历<br>?<br>因为如果继续从前向后遍历，就无法利用上一次得出的candyVec的数组了</p><!--SR:!2022-07-31,27,250--><p>eg：<br><img src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1|700"><br>如果是图中这样的话，就没必要用max函数了啊 #疑问</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写代码已通过，没有用max函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span></span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>] &gt; ratings[i]) {<br>            candyVec[i+<span class="hljs-number">1</span>] = candyVec[i]+<span class="hljs-number">1</span>;<br>            }<br>       }<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- ) { <span class="hljs-comment">// 从倒数第二位置开始比</span><br>        <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]){<br>            candyVec[i] = candyVec[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            }<br>       }<br>       <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : candyVec) result += a; <span class="hljs-comment">// 分号后边只需要变量名就行</span><br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>参考资料<br>[[for 循环]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.柠檬水找零</title>
    <link href="/posts/52728/"/>
    <url>/posts/52728/</url>
    
    <content type="html"><![CDATA[<h1 id="1-860柠檬水找零"><a class="markdownIt-Anchor" href="#1-860柠檬水找零"></a> 1 860.柠檬水找零</h1><p><a href="https://leetcode-cn.com/problems/lemonade-change/">力扣题目链接</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;5&nbsp;美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回&nbsp;true&nbsp;，否则返回 false&nbsp;。</p><p>示例 1：</p><ul><li>输入：[5,5,5,10,20]</li><li>输出：true</li><li>解释：<ul><li>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</li><li>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</li><li>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</li><li>由于所有客户都得到了正确的找零，所以我们输出 true。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：[5,5,10]</li><li>输出：true</li></ul><p>示例 3：</p><ul><li>输入：[10,10]</li><li>输出：false</li></ul><p>示例 4：</p><ul><li>输入：[5,5,10,10,20]</li><li>输出：false</li><li>解释：<ul><li>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</li><li>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</li><li>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</li><li>由于不是每位顾客都得到了正确的找零，所以答案是 false。</li></ul></li></ul><p>提示：</p><ul><li>0 &lt;= bills.length &lt;= 10000</li><li>bills[i]&nbsp;不是&nbsp;5&nbsp;就是&nbsp;10&nbsp;或是&nbsp;20</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5<br>用新型for循环 for (int bill : bills)，逐一对元素进行判断就行[[for 循环]]</li></ul><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？<br><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>局部最优：逐一对元素进行判断<br>全局最优：完成全部账单的找零</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写，已编译成功</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>{<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>, twenty = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) { <span class="hljs-comment">// 顺序遍历数组,先从第一个元素开始</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>){<br>                five ++;<br>            }<br>            <span class="hljs-comment">// else return false; 不需要这行代码因为5肯定能收</span><br><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>){<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span>) {<br>                    five--;<br>                    ten++;<br>                }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>            }<br><br>            <span class="hljs-keyword">if</span>(bill == <span class="hljs-number">20</span>){<br>                <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>){<br>                    ten--;<br>                    five--;<br>                }<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( five &gt;= <span class="hljs-number">3</span>){ <span class="hljs-comment">// 一定要用else if 下边也用else，这样这三个函数才能成为整体</span><br>                    five -= <span class="hljs-number">3</span>;<br>                }<br>                <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放在整体for循环外</span><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for 循环</title>
    <link href="/posts/28967/"/>
    <url>/posts/28967/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h1><p>for(变量i; 判断条件; 变化变量i)<br>for循环中第二条件是判断条件，破坏了该条件则会退出for循环</p><h1 id="2-遍历函数"><a class="markdownIt-Anchor" href="#2-遍历函数"></a> 2 遍历函数</h1><h2 id="21-基本形式"><a class="markdownIt-Anchor" href="#21-基本形式"></a> 2.1 基本形式</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本 1 </span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){  <span class="hljs-comment">// 从前往后遍历</span><br>   <span class="hljs-comment">// 操作到最后一个元素时不会取到最后一个下标的后一位(也就是长度)</span><br>        }<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = num.<span class="hljs-built_in">size</span> () - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){ <span class="hljs-comment">// 从后往前遍历, 记得有=0</span><br><br>}<br><br></code></pre></td></tr></tbody></table></figure><p>i++是每次移动一个格子, 也可以根据题目的不同每次多移动距离<br>![[2. 反转字符串II#^6aghnj]]</p><h2 id="22-范围-for-循环"><a class="markdownIt-Anchor" href="#22-范围-for-循环"></a> 2.2 [[范围 for 循环]]</h2><h2 id="23-指针形式"><a class="markdownIt-Anchor" href="#23-指针形式"></a> 2.3 指针形式</h2><p>有关 map 结构的遍历: 通过指针来指向元素<br>![[map(🗃)#^drp7wt]]</p><h1 id="3-数组求和"><a class="markdownIt-Anchor" href="#3-数组求和"></a> 3 数组求和</h1><h2 id="31-第一种写法"><a class="markdownIt-Anchor" href="#31-第一种写法"></a> 3.1 第一种写法</h2><p>for (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体<br>应用：对数组求和，a会从第一个元素开始遍历到最后一个元素</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A是数组，for循环对数组求和</span><br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A)  result += a; <span class="hljs-comment">// int a 类似于int i:后只需数组名即可</span><br></code></pre></td></tr></tbody></table></figure><h2 id="32-第二种写法"><a class="markdownIt-Anchor" href="#32-第二种写法"></a> 3.2 第二种写法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br></code></pre></td></tr></tbody></table></figure><p>n%2 == 1什么意思 #card<br>n%2就是对n求：n除以2后的余数，这里余数只有两种情况就是0或者是1<br>eg：5%2=1</p><h1 id="4-其他"><a class="markdownIt-Anchor" href="#4-其他"></a> 4 其他</h1><!-- basicblock-start oid="ObsF4xGaGV2tjW18kQsFj492" --> <p>for 循环比较两个元素值的时候用 i = 1 ::</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// ❗️不能i=0, vec[i] &gt;= vec[i+1], 因为 i+1 已经超过了范围</span><br>    <span class="hljs-keyword">if</span>(vec[i<span class="hljs-number">-1</span>] &gt;= vec[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// ❗️要有'='号</span><br></code></pre></td></tr></tbody></table></figure><p>[[23. 验证二叉搜索树#^44p3md]]</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯铝的性能指标</title>
    <link href="/posts/25410/"/>
    <url>/posts/25410/</url>
    
    <content type="html"><![CDATA[<p><a href="marginnote3app://note/3AE993AE-E623-4E05-BDD8-A7A400FEE1A2">margin</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=1eb5db61-b344-4a33-a07a-7a34f51a00d0">ob</a></p><h1 id="1-梯度结构纯铝的形貌"><a class="markdownIt-Anchor" href="#1-梯度结构纯铝的形貌"></a> 1 梯度结构纯铝的形貌</h1><h2 id="11-成形效果"><a class="markdownIt-Anchor" href="#11-成形效果"></a> 1.1 成形效果</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs col">![](https://s1.vika.cn/space/2022/06/02/bca77150b3084c549a77bf090cb2ce2e)<br>挤出长度跟出口厚度成反比<br><br>![](https://s1.vika.cn/space/2022/06/02/6b18b35cc90944fcb6872a47dc51dec5)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="12-原始纯铝与梯度纯铝的微观组织"><a class="markdownIt-Anchor" href="#12-原始纯铝与梯度纯铝的微观组织"></a> 1.2 原始纯铝与梯度纯铝的微观组织</h2><p><img src="https://s1.vika.cn/space/2022/06/02/e1b9812b60f64c419b2299c54afa3da3" alt="|600"><br><img src="https://s1.vika.cn/space/2022/06/02/a666e2c8fa314ef4b4be704418324067" alt="|600"><br>B侧细化 A侧基本没变，成梯度材料</p><h2 id="13-微观组织演变机制"><a class="markdownIt-Anchor" href="#13-微观组织演变机制"></a> 1.3 微观组织演变机制</h2><p><img src="https://s1.vika.cn/space/2022/06/02/bdf90acd645c4bd490a1c54d6111f285" alt="|600"></p><h1 id="2-梯度结构纯铝的力学性能"><a class="markdownIt-Anchor" href="#2-梯度结构纯铝的力学性能"></a> 2 梯度结构纯铝的力学性能</h1><h2 id="21-梯度结构纯铝的硬度梯度"><a class="markdownIt-Anchor" href="#21-梯度结构纯铝的硬度梯度"></a> 2.1 梯度结构纯铝的硬度梯度</h2><p>原材料32HV，梯度材料44HV<br>B测最高，到A测减少，因为晶粒细化，但靠近A侧硬度平稳且有所提升，是产生了材料硬化<br>金属材料的硬度与其晶粒大小成反比,即<strong>晶粒越细,材料的硬度越高</strong><br><img src="https://s1.vika.cn/space/2022/06/02/d74d109525504da5b0b60ac6c71974c2" alt="|600"></p><h2 id="22-梯度结构纯铝的拉伸性能"><a class="markdownIt-Anchor" href="#22-梯度结构纯铝的拉伸性能"></a> 2.2 梯度结构纯铝的拉伸性能</h2><p>梯度材料拉伸强度达到了160MPa，是原件的一倍多<br><img src="https://s1.vika.cn/space/2022/06/02/6591bb51508e4f82bf050a2253d22844" alt="|600"><br>随着厚度的增加, 梯度样品的抗拉强度逐渐下降,而延展性逐渐增强</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://s1.vika.cn/space/2022/06/02/9d767470c48f4318941bd9b40ca940a4)<br><br>![](https://s1.vika.cn/space/2022/06/02/f98676a6b6414cb4bb655c06d5ecbcb3)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="23-拉伸断口分析"><a class="markdownIt-Anchor" href="#23-拉伸断口分析"></a> 2.3 拉伸断口分析</h2><p>人们希望韧性断裂，而不是脆性断裂。通过观察端口来进行分析</p><p>怎么分析端口是韧性断裂还是塑性断裂<br>?<br>韧窝的尺寸越大,材料的塑性越好，韧窝的尺寸大小也不均匀,既有 10 μm 左右的大韧窝,也有 2 μm 左右的小韧窝,这是由于在拉伸变形过程中,小韧窝不断拉长、聚合成大韧窝,同时也有小韧窝不断萌生</p><p>纯铝原材料的拉伸断口呈现出典型的韧性断裂特征是<strong>韧性断裂</strong></p><p><img src="https://s1.vika.cn/space/2022/06/02/9434e67a2f554ef2a718b05c74d585b1" alt="|600"><br>梯度材料纯铝也是<strong>韧性断裂</strong>，韧窝也主要分布在纤维区和剪切唇的部分区域<br><img src="https://s1.vika.cn/space/2022/06/02/a99078324c754506acf4df4755369ad6" alt="|600"></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材料性能</tag>
      
      <tag>塑性流动挤出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static 关键字</title>
    <link href="/posts/37185/"/>
    <url>/posts/37185/</url>
    
    <content type="html"><![CDATA[<p>📝static 关键字::<br>2022/11/1 : 第一次创建</p><!-- basicblock-end --><p>static 关键字有三种用法</p><ol><li>static 修饰局部变量 → 静态局部变量<ol><li>改变局部变量的生命周期，下次使用该局部变量是上次使用完后的值，而不是初始值</li></ol></li><li>static 修饰全局变量 →静态全局变量<ol><li>只能在本文件内使用，不能在其他文件中访问，extern外边声明也不行(无static时默认是可以被外部访问的)</li></ol></li><li>static 修饰函数 →静态函数<ol><li>只能在本文件中<strong>调用</strong>，同2</li></ol></li></ol><h1 id="1-43-static的用法和作用"><a class="markdownIt-Anchor" href="#1-43-static的用法和作用"></a> 1: [[43、static的用法和作用？]]</h1><h1 id="2-对于面向过程"><a class="markdownIt-Anchor" href="#2-对于面向过程"></a> 2: 对于面向过程：</h1><p>static对应的函数一般都是被放在全域区，他们在程序开始时候就获得，结束的时候销毁</p><h1 id="3-对于面向对象"><a class="markdownIt-Anchor" href="#3-对于面向对象"></a> 3: 对于面向对象</h1><p>初始化<br>static 放入类中，如果不加 const 需要在类外面初始化<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202211012236262.png" alt="|300"><br>加了const可以直接在类内赋值初始化</p><h1 id="4-对于对象"><a class="markdownIt-Anchor" href="#4-对于对象"></a> 4: 对于对象</h1><p>static命名的变量属于是一次定义，全类共享，所有类共享一个公有的static。只是一个“包含关系”，所以他不能被构造函数构造。<br><strong>对于静态成员函数，类可以通过点运算符调用静态成员函数</strong>，但是成员函数本身只能直接调用类内的静态类型的变量或者是成员函数，<br><strong>对于非静态成员或函数是调用不了的</strong></p><ul><li>tip 静态可以不用对象调用，直接类名加点方法，不是静态需要创建对象然后调用, 不用 static 无法创建对象</li></ul><h1 id="5-静态类"><a class="markdownIt-Anchor" href="#5-静态类"></a> 5: 静态类</h1><p>static 修饰的类, 不会随着大类一块加载进内存, 只有当调用的时候, 才会加载进内存[[单例模式的类别#^ougi2n]]</p><p>和变量一样，静态类的生命周期直到程序的结束。在 main 结束后才会调用静态类的析构函数。</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9. K次取反后最大化的数组和</title>
    <link href="/posts/15628/"/>
    <url>/posts/15628/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1005k次取反后最大化的数组和"><a class="markdownIt-Anchor" href="#1-1005k次取反后最大化的数组和"></a> 1 1005.K次取反后最大化的数组和</h1><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接</a></p><p>1131</p><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i&nbsp;并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p>示例 1：</p><ul><li>输入：A = [4,2,3], K = 1</li><li>输出：5</li><li>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</li></ul><p>示例 2：</p><ul><li>输入：A = [3,-1,0,2], K = 3</li><li>输出：6</li><li>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。</li></ul><p>示例 3：</p><ul><li>输入：A = [2,-3,-1,5,-4], K = 2</li><li>输出：13</li><li>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。</li></ul><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>1 &lt;= K &lt;= 10000</li><li>-100 &lt;= A[i] &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>局部最优：让绝对值大的负数变成正数<br>整体最优：整个数组求和变最大</p><p>如果将负数都转变为正数了，K依然大于0，就把绝对值最小的数变为负数</p><p>本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完<ul><li>如果k是偶数则相当于没有变，因为可以对一个数重复两次操作</li><li>如果是奇数，只需要操作一个数，剩下的就是偶数也不用管了<ul><li>即<code>if (K % 2 == 1) A[A.size() - 1] *= -1;</code></li></ul></li></ul></li><li>第四步：求和</li></ul><p>相关知识点<br>[[sort()函数]]<br>[[for 循环]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写：编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);    <br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span></span>{<br>    <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 第一步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i != A.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// 第二步</span><br>        <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>){<br>            A[i] *= <span class="hljs-number">-1</span>;<br>            K--;<br>        }<br>    }<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){ <span class="hljs-comment">// 第三步</span><br>            A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;<br>        }<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a; <span class="hljs-comment">// 注意是小a(A中的每个元素)</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsqKSWuWANGrwYnjt12tsd7" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::贪心算法::9. K次取反后最大化的数组和.md" --> <p>#历史记录::<br>2022/9/23🌵9. K次取反后最大化的数组和 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6. 买卖股票的最佳时机II</title>
    <link href="/posts/38547/"/>
    <url>/posts/38547/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解：</p><span id="more"></span><h1 id="1-122买卖股票的最佳时机ii"><a class="markdownIt-Anchor" href="#1-122买卖股票的最佳时机ii"></a> 1 122.买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接</a></p><p>给定一个数组，它的第&nbsp;i 个元素是一支<strong>给定股票</strong>第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><ul><li>输入: [7,1,5,3,6,4]</li><li>输出: 7</li><li>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</li></ul><p>示例 2:</p><ul><li>输入: [1,2,3,4,5]</li><li>输出: 4</li><li>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</li></ul><p>示例&nbsp;3:</p><ul><li>输入: [7,6,4,3,1]</li><li>输出: 0</li><li>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</li></ul><p>提示：</p><ul><li>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</li><li>0 &lt;= prices[i] &lt;= 10 ^ 4</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>最终利润是可以分解的</strong>，<strong>把利润分解为每天为单位的维度</strong><br>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。<br>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p><p><strong>把整体利润拆为每天的利润</strong><br>每天的利润序列：(prices[i] - prices[i - 1])+…+(prices[1] - prices[0])<br><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II|650"><br>第一天没利润，利润表比股票价格表少一位</p><p>局部最优：求得每天的正利润，</p><p>全局最优：求和每天的正利润</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[for 循环]]</p><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != prices.<span class="hljs-built_in">size</span>(); i++){<br>            result += <span class="hljs-built_in">max</span>(prices[i+<span class="hljs-number">1</span>] - prices[i],<span class="hljs-number">0</span>);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.摆动序列</title>
    <link href="/posts/74/"/>
    <url>/posts/74/</url>
    
    <content type="html"><![CDATA[<h1 id="1-摆动序列"><a class="markdownIt-Anchor" href="#1-摆动序列"></a> 1 摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">力扣题目链接</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如，&nbsp;[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)&nbsp;是正负交替出现的。相反, [1,4,7,2,5]&nbsp;和&nbsp;[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><ul><li>输入: [1,7,4,9,2,5]</li><li>输出: 6</li><li>解释: 整个序列均为摆动序列。</li></ul><p>示例 2:</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例 3:</p><ul><li>输入: [1,2,3,4,5,6,7,8,9]</li><li>输出: 2</li></ul><blockquote><p>后一个数减前一个数的值，正负交替</p></blockquote><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><img src="https://s1.vika.cn/space/2022/05/28/1af591dff4b846a3999e21e948dd6e70" alt=""></p><p>局部最优：变成没有坡度的峰<br>整体最优：尽可能有最多的<strong>没有坡度的峰</strong></p><p>最左面和最右面的峰值不好统计<br>可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0</p><p>定义变量：<br>左坡度：preDiff &gt;= 0 或者preDiff &lt;= 0也行，(等于0是最左面的情况)<br>右坡度：curDiff &lt; 0 或者cur &gt;0,<br>result：统计百度序列的个数</p><blockquote><p>反正左坡度和右坡度需要异号，并且左坡度可以 = 0；<br><img src="https://s1.vika.cn/space/2022/05/28/f1551bf99b894ba08967e7dd87387603" alt=""></p></blockquote><p>result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p><blockquote><p>问：这样话直接把result初始为2不行吗？<br>答：要用到前一对和后一对的差值。只有有两个数就可以有这两个差值，所以nums.size() &lt;= 1 即可返回</p></blockquote><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span>( nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 长度不超过1</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right =&nbsp;<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){ <span class="hljs-comment">// 这样写更好</span><br>            right =&nbsp;nums[i] - nums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt;= <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span> &amp;&amp; left &gt;= <span class="hljs-number">0</span>){ <span class="hljs-comment">// 两边要异号啊</span><br>                result++;<br>                left = right;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心</strong>。<br>有什么方法想到贪心→多做</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brew安装</title>
    <link href="/posts/4339/"/>
    <url>/posts/4339/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s1.vika.cn/space/2022/05/28/0b3ffbfe5ad64d388d02bceff24ab6a0" alt=""></p><p>用官网安装出现以下错误：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">curl: (<span class="hljs-number">7</span>) Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> raw.githubusercontent.com port <span class="hljs-number">443</span>: <span class="hljs-keyword">Connection</span> refused<br></code></pre></td></tr></tbody></table></figure><p>原因是：<strong>github 的一些域名的 DNS 解析被污染</strong>，导致DNS 解析过程无法通过域名取得正确的IP地址</p><p>换成国内下载地址即可</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>zsh -c <span class="hljs-string">"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"</span><br></code></pre></td></tr></tbody></table></figure><p>根据终端反应输入即可，过程中有中文提示</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac下软件安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 生成ssh密钥</title>
    <link href="/posts/18965/"/>
    <url>/posts/18965/</url>
    
    <content type="html"><![CDATA[<p>linux命令<br>查看密钥是否生成：ls -l ~/.ssh</p><p>生成密钥：ssh-keygen&nbsp;-t&nbsp;rsa (一路回车)</p><p>密钥所在目录：<br>cd ~/.ssh</p><p>私钥：id_rsa<br>公钥：id_rsa.pub</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.分发饼干</title>
    <link href="/posts/42003/"/>
    <url>/posts/42003/</url>
    
    <content type="html"><![CDATA[<h1 id="1-455分发饼干"><a class="markdownIt-Anchor" href="#1-455分发饼干"></a> 1 455.分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">力扣题目链接</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值&nbsp;<strong>g[i]</strong>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <strong>s[j]</strong>&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例&nbsp;1:</p><ul><li>输入: g = [1,2,3], s = [1,1]</li><li>输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: g = [1,2], s = [1,2,3]</li><li>输出: 2</li><li>解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</li></ul><p>提示：</p><ul><li>1 &lt;= g.length &lt;= 3 * 10^4</li><li>0 &lt;= s.length &lt;= 3 * 10^4</li><li>1 &lt;= g[i], s[j] &lt;=&nbsp;2^31 - 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>局部最优：大饼干喂给胃口大的孩子(尽量充分利用饼干)<br>全局最优：喂饱尽可能多的小孩</p><p>将饼干数组和小孩数组拍个序<br><strong>从后向前遍历</strong>，即大饼干满足胃口的大孩子，<strong>并</strong>统计满足小孩数量<br><img src="https://s1.vika.cn/space/2022/05/27/1c68ab105c2d4666a72ac61ebbca6600" alt="|700"><br>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><h1 id="3-力扣代码"><a class="markdownIt-Anchor" href="#3-力扣代码"></a> 3 力扣代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 饼干数组的最后一个元素</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计孩子的数</span><br>        <span class="hljs-comment">//因为想从后往前遍历对比，所以用i-- ，而不用i++，g.size() - 1是孩子数组的最后一个元素，</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>  ; i--){ <span class="hljs-comment">// ”=“号为对比到最后一个孩子 </span><br>            <span class="hljs-keyword">if</span> (index  &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]){<br>                result++;<br>                index--;<br>            }<br>        } <br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.贪心算法理论基础</title>
    <link href="/posts/29776/"/>
    <url>/posts/29776/</url>
    
    <content type="html"><![CDATA[<p>[[9. K次取反后最大化的数组和#^fb00f8]]</p><h1 id="1-贪心算法的题目大纲"><a class="markdownIt-Anchor" href="#1-贪心算法的题目大纲"></a> 1 贪心算法的题目大纲</h1><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"> ^d14613</p><h1 id="2-什么是贪心算法"><a class="markdownIt-Anchor" href="#2-什么是贪心算法"></a> 2 什么是贪心算法</h1><p>局部最优推出全局最优<br>eg：一堆钱里只能拿10张，如何拿到最大。每一次都拿的最大(局部最优)→总共拿的最大(全局最优)</p><h1 id="3-什么时候用贪心算法"><a class="markdownIt-Anchor" href="#3-什么时候用贪心算法"></a> 3 什么时候用贪心算法</h1><p>看到题目时，感受到能够：<strong>局部最优→全局最优，且想不到反例</strong>。就试一试贪心.<br>感觉贪心算法更看直觉能不能用</p><h1 id="4-贪心算法的套路"><a class="markdownIt-Anchor" href="#4-贪心算法的套路"></a> 4 贪心算法的套路</h1><ol><li>将总问题划分为子问题</li><li>找到合适的最优解法</li><li>对子问题进行最优求解</li><li>将子问题堆积成总问题</li></ol><p>实际上解题没有这么细，因为贪心算法还与其他知识联合在一起</p><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsPQ6JVnlN6crGDTNlVISLh" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::贪心算法::1.贪心算法理论基础.md" --> <p>#历史记录::<br>2022/9/23🌵1.贪心算法理论基础 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21.解数独</title>
    <link href="/posts/5566/"/>
    <url>/posts/5566/</url>
    
    <content type="html"><![CDATA[<p>N皇后是每一行找一个位置放皇后<br>数独是<strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法</strong></p><p>void backtracking(参数) {<br>startIndex：控制下一层的起始位置<br>去重(从下一层的第一个位置开始：backtracking(…, i+1))<br>排列问题不用startIndex<br>used[]：去重(从下一层的起始位置开始：backtracking(…, 0))<br>if (终止条件) {<br>存放结果;<br>return;<br>要取树上所有节点时不要加return<br>}<br>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>处理节点;<br>backtracking(路径，选择列表); // 递归<br>回溯，撤销处理结果<br>}<br>}</p><h1 id="1-回溯三部曲"><a class="markdownIt-Anchor" href="#1-回溯三部曲"></a> 1 回溯三部曲</h1><p>定义一些变量</p><h2 id="11-确定回溯函数参数返回值"><a class="markdownIt-Anchor" href="#11-确定回溯函数参数返回值"></a> 1.1 确定回溯函数参数返回值</h2><p>数独和N皇后的返回值用bool值</p><h2 id="12-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#12-终止条件-存放结果-return"></a> 1.2 终止条件, 存放结果, return</h2><p>不需要终止条件，等数填满了，棋盘自然终止</p><h2 id="13-单层搜索过程"><a class="markdownIt-Anchor" href="#13-单层搜索过程"></a> 1.3 单层搜索过程</h2><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><h3 id="131-判断棋盘是否合法"><a class="markdownIt-Anchor" href="#131-判断棋盘是否合法"></a> 1.3.1 判断棋盘是否合法</h3><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>#flashcards/代码随想录 #疑问<br>二维数组的行数与列数<br>?<br>int array[2]  [3]；二行三列<br>int row = array.size();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行数&nbsp;&nbsp;&nbsp;<br>int col = array[0].size();  列数</p><!--SR:!2022-08-02,29,250-->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手</title>
    <link href="/posts/61990/"/>
    <url>/posts/61990/</url>
    
    <content type="html"><![CDATA[<p>三次握手的目的是保证双方互相之间建立了连接<br>三次握手发生在客户端连接的时候，当调用connect()函数时，底层会通过TCP协议进行三次握手。</p><p>seq：序号<br>ACK：标志位<br>ack(AcK)：确认序号，只有当 ACK=1 时确认序号才有用<br>TCP是用字节流传输，会为每个字节分配一个序号</p><h1 id="1-三次握手"><a class="markdownIt-Anchor" href="#1-三次握手"></a> 1 三次握手</h1><p>时序图<br><img src="https://s1.vika.cn/space/2022/05/26/9e8848db48ec40d2a865d364ed1dfe16" alt=""></p><p>牛客总结<br>第一次握手：<br>1.客户端将SYN标志位置为1，向服务端请求建立连接，<br>2.生成一个随机(<font color="#F36208">其实是有固定算法的</font>)的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>1.服务端将<font color="#F36208">标志位</font><font color="#F36208">ACK</font>置为1，接收客户端的连接。<br>并且回发一个确认序号：ack=客户端的序号 +  数据长度+ SYN/FIN（按一个字节算）<br>2.服务器端会向客户端发起连接请求：SYN=1<br>3.服务器会生成一个随机序号(<font color="#F36208">其实是有固定算法的</font>)：seq = K<br>第三次握手：<br>1.客户单应答服务器的连接请求：ACK=1<br>2.客户端回复收到了服务器端的数据：ack=服务端的序号 +数据长度 + SYN/FIN（按一个字节算）<br>自己总结<br><font color="#F36208">第一次握手：客户端发起连接</font><br>1.客户端将标志位SYN置位1，表示向服务端请求连接。2.并且根据算法生成一个客户端序号cseq：J<br><font color="#F36208">第二次握手：服务端回复请求，发起连接</font><br>1.服务端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 客户端的序号(J) + 数据字节个数 + SYN/FIN(算一个字节)<br>3.服务端将标志位SYN置位1，表示向客户端请求连接。4.并且根据算法生成一个服务端序号sseq：K<br><font color="#F36208">第三次握手：客户端回复请求</font><br>1.客户端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 服务端的序号(K) + 数据字节个数 + SYN/FIN(算一个字节)</p><p>第一次握手(客户端→服务端)：客户端请求连接<br>客户端与服务端还没有建立连接，不能发数据<br>第二次握手(客户端←服务端)：服务端同意连接+请求与客户端连接<br>第三次握手(客户端→服务端)：客户端同意连接<br>此时客户端已经和服务端已经建立了连接，这次客户端的握手已经可以携带数据了<br>之后服务端与客户端都互相建立了连接，可以互相自由通信</p><h2 id="11-三次握手实例"><a class="markdownIt-Anchor" href="#11-三次握手实例"></a> 1.1 三次握手实例</h2><p><img src="https://s1.vika.cn/space/2022/05/26/e1cbc619a8b445c5a3cb9282c0d21c21" alt=""></p><h2 id="12-为什么不能两次握手"><a class="markdownIt-Anchor" href="#12-为什么不能两次握手"></a> 1.2 为什么不能两次握手</h2><p>因为要确保客户端能<font color="#C32E94">收发</font>消息，服务端能<font color="#C32E94">收发</font>消息，3次握手正好少一次都不行<br><img src="https://s1.vika.cn/space/2022/05/26/7f7c22713cf345368d2778005723b9b1" alt=""></p><p>四次握手也是可以的，服务端的ACK和SYN连在一起发了，拆开发就是四次握手<br>保证可靠连接的最小次数是三次握手</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用</title>
    <link href="/posts/36408/"/>
    <url>/posts/36408/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1 理论::</h1><!-- basicblock-end --><p>I/O 多路复用使得程序能同时监听多个文件描述符,能够提高程序的性能,<br>I：输入，从文件当中把数据写入内存<br>O: 输出，把内存的数据读到文件里去<br>I/O 操作相当于对socket的缓冲区的操作</p><blockquote><p>[!summary] 多路复用：多条路复用成一条</p></blockquote><p>多路复用的意思：之前有100个客户端，检测有无数据就要调用100次的read函数，<br>现在我用一个文件描述符表来委托内核来检测，在统一返回一个文件描述表。<br>这样100路就变成了1路(简称多路复用)</p><blockquote></blockquote><p><strong>Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll</strong>。</p><blockquote><p>[!summary] 阻塞等待<br>![[阻塞等待.excalidraw]]</p></blockquote><h1 id="2-阻塞等待的模型-bio模型"><a class="markdownIt-Anchor" href="#2-阻塞等待的模型-bio模型"></a> 2 阻塞等待的模型： BIO模型</h1><p><a href="marginnote3app://note/71666D96-F61F-43AE-9FC9-F7BC4206964A">margin</a><br>![[705a8cd54a58a4c1cd913f74ceb539d0.png|725]]<br>服务端创建socket，绑定IP和端口→监听→接受连接<br>如果只是一个进程，那么多个客户端来连接就会阻塞。<br>解决办法是：创建多线程来进行连接。accept前面应当有while循环</p><h1 id="3-非阻塞忙轮询"><a class="markdownIt-Anchor" href="#3-非阻塞忙轮询"></a> 3 非阻塞，忙轮询</h1><p><a href="marginnote3app://note/2D2CF553-A636-45BD-B61E-CA006C1D2812"></a><br>![[eb409ec1df657b8f2d1c348b4250884c.png|725]]<br>假设read没读到数据，让while循环一直让read函数去读取读缓冲区的数据</p><h1 id="4-nio模型"><a class="markdownIt-Anchor" href="#4-nio模型"></a> 4 NIO模型</h1><p>![[Pasted image 20220525170732.png|725]]<br>用一个while循环套accpet，用一个while循环套read，<br>让他俩不断循环的看有没有客户端连接进来，有没有数据写入了读缓冲区。<br>缺点：如果是1万个客户端想连接，就要循环1万次<br>如果1万客户端都连接了，其中只有一个客户端有数据发送过来，循环read函数9999次都是无效的</p><h1 id="5-epoll"><a class="markdownIt-Anchor" href="#5-epoll"></a> 5 [[epoll]]</h1><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsQFbMEsgLYIrX0RDC0rZQG" deck = "👨🏻‍💻code::项目::webserver::4 Linux网络编程::IO多路复用.md" --> <p>#历史记录:: <a href="marginnote3app://note/145A1C77-D798-4681-8AAE-0BD2FA6AD727">margin</a><br>2022-05-25🌵IO多路复用 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>20.N皇后</title>
    <link href="/posts/18499/"/>
    <url>/posts/18499/</url>
    
    <content type="html"><![CDATA[<p>[[1.贪心算法理论基础#^d14613]]</p><h1 id="1-第51题-n皇后"><a class="markdownIt-Anchor" href="#1-第51题-n皇后"></a> 1 第51题. N皇后</h1><p><a href="https://leetcode-cn.com/problems/n-queens/">力扣题目链接</a></p><p>n&nbsp;皇后问题 研究的是如何将 n&nbsp;个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的&nbsp;n&nbsp;皇后问题 的解决方案。</p><p>每一种解法包含一个不同的&nbsp;n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例 1：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211020232201.png" alt=""></p><ul><li>输入：n = 4</li><li>输出：[ [".Q…","…Q",“Q…”,"…Q."],["…Q.",“Q…”,"…Q",".Q…"] ]</li><li>解释：如上图所示，4 皇后问题存在两个不同的解法。</li></ul><p>示例 2：</p><ul><li>输入：n = 1</li><li>输出：[ [“Q”] ]</li></ul><p>皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>好吧</p><p>![[20.N皇后 2022-05-25 10.54.39.excalidraw]]</p><!-- basicblock-start oid="Obsw830Wj3I4apZIzvAcoVNG" deck= "❓疑问::👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::20.N皇后.md"--><p>回溯的过程到底是什么样的，录视频 ，找一个简单的题录视频吧<br>目前看来是回溯到代码随想录那种图的第二层然后在往下走吧</p><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="ObsYXSPDjMuVzJRXPo8Ihy5h" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::20.N皇后.md" --> <p>#历史记录::<br>2022/9/23🌵20.N皇后 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>端口复用</title>
    <link href="/posts/55001/"/>
    <url>/posts/55001/</url>
    
    <content type="html"><![CDATA[<p>半关闭：</p><p>tcp_server.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> {<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    <br>    <span class="hljs-comment">//int optval = 1;</span><br>    <span class="hljs-comment">//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span><br><br>    <span class="hljs-type">int</span> optval = <span class="hljs-number">1</span>;<br>    setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="hljs-keyword">sizeof</span>(optval));<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"bind"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 监听</span><br>    ret = listen(lfd, <span class="hljs-number">8</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"listen"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 接收客户端连接</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>    <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"accpet"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取客户端信息</span><br>    <span class="hljs-type">char</span> cliIp[<span class="hljs-number">16</span>];<br>    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="hljs-keyword">sizeof</span>(cliIp));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cliPort = ntohs(cliaddr.sin_port);<br><br>    <span class="hljs-comment">// 输出客户端的信息</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client's ip is %s, and port is %d\n"</span>, cliIp, cliPort );<br><br>    <span class="hljs-comment">// 接收客户端发来的数据</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">int</span> len = recv(cfd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"recv"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"客户端已经断开连接...\n"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, recvBuf);<br>        }<br><br>        <span class="hljs-comment">// 小写转大写，eg：hello -&gt; HELLO</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) { <br>            recvBuf[i] = <span class="hljs-built_in">toupper</span>(recvBuf[i]);<br>        }<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"after buf = %s\n"</span>, recvBuf);<br><br>        <span class="hljs-comment">// 大写字符串发给客户端</span><br>        ret = send(cfd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"send"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>    }<br>    <br>    close(cfd);<br>    close(lfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>tcp_client.c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">seraddr</span>;</span><br>    inet_pton(AF_INET, <span class="hljs-string">"127.0.0.1"</span>, &amp;seraddr.sin_addr.s_addr);<br>    seraddr.sin_family = AF_INET;<br>    seraddr.sin_port = htons(<span class="hljs-number">9999</span>);<br><br>    <span class="hljs-comment">// 连接服务器</span><br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;seraddr, <span class="hljs-keyword">sizeof</span>(seraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>){<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    }<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">char</span> sendBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>        fgets(sendBuf, <span class="hljs-keyword">sizeof</span>(sendBuf), <span class="hljs-built_in">stdin</span>);<br><br>        write(fd, sendBuf, <span class="hljs-built_in">strlen</span>(sendBuf) + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 接收</span><br>        <span class="hljs-type">int</span> len = read(fd, sendBuf, <span class="hljs-keyword">sizeof</span>(sendBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"read buf = %s\n"</span>, sendBuf);<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"服务器已经断开连接...\n"</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br>    }<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>![[Pasted image 20220525154320.png|825]]<br>optval = 1 表示要端口复用，0表示不要端口复用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys /types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys /socket.h&gt;</span></span><br><span class="hljs-comment">//设置套接字的属性（不仅仅能设置端口复用）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">setsockopt</span> <span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> optname， <span class="hljs-type">const</span> <span class="hljs-type">void</span> *optval, <span class="hljs-type">socklen_t</span> opt len)</span>；<br>參数：<br>sockfd：要操作的文件描述符<br>level：级别 - SOL_SOFKET （端口复用的级别）<br>optname：选项的名称<br>SO_REUSEADDR<br>SO_REUSEPORT<br>optval：端口复用的值（整形）<br>- 1：可以复用<br>- 0:不可以复用<br>optlen： optval參数的大小<br>端口复用，设置的时机是在服务器绑定端口之前。<br><span class="hljs-title function_">setsockopt</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 设置端口复用</span><br>bind()；<span class="hljs-comment">// 在进行绑定</span><br></code></pre></td></tr></tbody></table></figure><p>#liunx命令</p><p>常看网络相关信息的命令；net 网络，stat 状态<br>netstat -×<br>参数：<br>-a ：所有的socket<br>-p ：显示正在使用socket的程序的名称<br>-n ：直接使用 IP 地址，而不通过域名服务器</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsh0YpAQUTQKWxin6WcyCYu" --> <p>#历史记录::<br>2022/10/20🌵端口复用 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>socket</title>
    <link href="/posts/58780/"/>
    <url>/posts/58780/</url>
    
    <content type="html"><![CDATA[<h1 id="1-socket"><a class="markdownIt-Anchor" href="#1-socket"></a> 1 socket::</h1><p>在第一个写缓冲区中写然后封装过去，然后在解封装，在读缓冲区读出来<br>我们只用fd来进行写操作和读操作<br>![[socket 2022-10-11 20.37.52.excalidraw]]</p><p>套接字通信分两部分：</p><ul><li>服务器端：被动接受连接，一般不会主动发起连接</li><li>客户端：主动向服务器发起连接</li><li>Socket是一套通信的接口，Linux 和 windows 都有，但是有一些细微的差别。</li></ul><h1 id="2-套接字函数目录"><a class="markdownIt-Anchor" href="#2-套接字函数目录"></a> 2 [[套接字函数(目录)]]</h1><h1 id="3-本地套接字"><a class="markdownIt-Anchor" href="#3-本地套接字"></a> 3 本地套接字</h1><p>tcp, udp 通信都是网络套接字: 不同主机的通信</p><p>本地套接字的作用: 本地的进程间通信 (一个主机上的不同进程间的通信)<br>有关系的进程间的通信 (父子进程)<br>没有关系的进程间的通信</p><p>本地套接字实现流程和网络套接字类似，一般呢采用 TCP 的通信流程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 本地套接字通信的流程 - tcp</span><br><br><span class="hljs-comment">// 服务器端</span><br><span class="hljs-number">1.</span> 创建监听的套接字<br>    <span class="hljs-type">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-number">1.</span> 第一个参数:协议族表示本地 <br>    <span class="hljs-number">2.</span> tcp<br><span class="hljs-number">2.</span>  监听的套接字绑定本地的套接字文件 -&gt; server端<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br>    <span class="hljs-comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span><br>     bind(lfd, addr, len);<br><span class="hljs-number">3.</span> 监听<br>    listen(lfd, <span class="hljs-number">100</span>);<br><span class="hljs-number">4.</span> 等待并接受连接请求<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">cliaddr</span>;</span><br>    <span class="hljs-type">int</span> cfd = accept(lfd, &amp;cliaddr, len);<span class="hljs-comment">// 第二参数是本机的地址</span><br><span class="hljs-number">5.</span> 通信 <br>    <span class="hljs-number">1.</span> 接收数据:read/recv <br>    <span class="hljs-number">2.</span> 发送数据:write/send<br><span class="hljs-number">6.</span> 关闭连接 <br>    <span class="hljs-number">1.</span> close();<br><br><br><br><span class="hljs-comment">// 客户端的流程</span><br><span class="hljs-number">1.</span> 创建通信的套接字<br>    <span class="hljs-type">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="hljs-number">0</span>); <br><span class="hljs-number">2.</span> 监听的套接字绑定本地的IP 端口<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">addr</span>;</span><br>    <span class="hljs-comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 bind(lfd, addr, len);</span><br><span class="hljs-number">3.</span> 连接服务器<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> <span class="hljs-title">serveraddr</span>;</span><br>    connect(fd, &amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br><span class="hljs-number">4.</span> 通信 <br>    <span class="hljs-number">1.</span> 接收数据:read/recv <br>    <span class="hljs-number">2.</span> 发送数据:write/send<br><span class="hljs-number">5.</span> 关闭连接 <br>    <span class="hljs-number">1.</span> close();<br><br><br></code></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 头文件: sys/un.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNIX_PATH_MAX 108 </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> {</span><br><span class="hljs-type">sa_family_t</span> sun_family; <span class="hljs-comment">// 地址族协议 af_local</span><br><span class="hljs-type">char</span> sun_path[UNIX_PATH_MAX]; <span class="hljs-comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0 </span><br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsQHqv2ecPFGd83vlI01tiX"  --> <p>#历史记录::<br>2022-05-23🌵socket : 第一次创建</p><!-- basicblock-end --><p>socket</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字节序</title>
    <link href="/posts/101/"/>
    <url>/posts/101/</url>
    
    <content type="html"><![CDATA[<h1 id="1-理论"><a class="markdownIt-Anchor" href="#1-理论"></a> 1: 理论</h1><p>ff的值为255</p><p>![[大端和小端.excalidraw|1000]]</p><p>^a776d7</p><h2 id="11-测试大端小端代码"><a class="markdownIt-Anchor" href="#11-测试大端小端代码"></a> 1.1: 测试大端小端代码</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 通过代码检测当前主机的字节序</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> {</span><span class="hljs-comment">// 💡联合体: 两个对象共用一个内存, 同一时刻只能使用一个对象</span><br>        <span class="hljs-type">short</span> value;    <span class="hljs-comment">// 2字节</span><br>        <span class="hljs-type">char</span> bytes[<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">short</span>)];  <span class="hljs-comment">// char[2]：数组占两个字节；char是占一个字节</span><br>    } test;<br><br>    test.value = <span class="hljs-number">0x0102</span>;<span class="hljs-comment">// 两个字节：01(高位字节)，02(低位字节)；0x是表示用16进制</span><br>    <span class="hljs-keyword">if</span>((test.bytes[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &amp;&amp; (test.bytes[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>)) { <span class="hljs-comment">// ==1是代表01, 💡[0]表示低位</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"大端字节序\n"</span>);<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((test.bytes[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>) &amp;&amp; (test.bytes[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"小端字节序\n"</span>);<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"未知\n"</span>);<br>    }<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-字节序转换函数"><a class="markdownIt-Anchor" href="#2-字节序转换函数"></a> 2: 字节序转换函数</h1><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时, 接收端必然错误的解释之。<br>解决问题的方法是: 发送端总是把要发送的数据转换成大端字节序数据后再发送, 而接收端知道对方传送过来的数据总是采用大端字节序, 所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换 (小端机转换, 大端机不转换)。</p><blockquote><p>[!cite] 大部分用的是小段字节序，网络字节序是大端</p></blockquote><ul><li>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式, 它与具体的 CPU 类型、操作系统等无关, 从而可以保证数据在不同主机之间传输时能够被正确解释, <strong>网络字节顺序采用大端排序方式。</strong></li><li>BSD Socket 提供了封装好的转换接口, 方便程序员使用。<ul><li>包括从主机字节序到网络字节序的转换函数: htons、htonl;</li><li>从网络字节序到主机字节序的转换函数: ntohs、ntohl。</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">h   - host 主机,主机字节序<br>to  - 转换成什么<br>n   - network  网络字节序<br>s   - <span class="hljs-type">short</span>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <br>l   - <span class="hljs-type">long</span>   <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span> </span><br><span class="hljs-comment">// 转换端口</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;     <span class="hljs-comment">// 主机字节序 -&gt; 网络字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span>;      <span class="hljs-comment">// 网络字节序 -&gt; 主机字节序</span><br><span class="hljs-comment">// 转IP </span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;      <span class="hljs-comment">// 主机字节序 - 网络字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;       <span class="hljs-comment">// 主机字节序 - 网络字节序</span><br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObswQlYY1cSsAQx3SD2vyEQG" --> <p>📝字节序::<br>2022/10/21 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IP地址转换</title>
    <link href="/posts/47652/"/>
    <url>/posts/47652/</url>
    
    <content type="html"><![CDATA[<p>IP地址转换函数</p><p>将点分十进制转换成网络字节序的整数(大端字节序)；将主机字节序转换为网络字节序<br>带点-&gt;不带点</p><p>ipv4是点分十进制，ipv6是用16进制表示<br>![[Pasted image 20220512155003.png|700]]<br>网络字节序的整数：点分十进制不带点</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span>;<br>    af:地址族： AF_INET  AF_INET6<br>    src:需要转换的点分十进制的IP字符串<br>    dst:转换后的结果保存在这个里面<br><br><span class="hljs-comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span>;<br>    af:地址族： AF_INET  AF_INET6<br>    src: 要转换的ip的整数的地址<br>    dst: 转换成IP地址字符串保存的地方<br>    size：第三个参数的大小（数组的大小）<br>    返回值：返回转换后的数据的地址（字符串），和 dst 是一样的<br><br><br></code></pre></td></tr></tbody></table></figure><p>代码实例</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 创建一个ip字符串,点分十进制的IP地址字符串</span><br>    <span class="hljs-type">char</span> buf[] = <span class="hljs-string">"192.168.1.4"</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span><br>    inet_pton(AF_INET, buf, &amp;num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)&amp;num;<span class="hljs-comment">// 要一个字节一个字节来打印</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d %d\n"</span>, *p, *(p+<span class="hljs-number">1</span>), *(p+<span class="hljs-number">2</span>), *(p+<span class="hljs-number">3</span>));<br><br><br>    <span class="hljs-comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span><br>    <span class="hljs-type">char</span> ip[<span class="hljs-number">16</span>] = <span class="hljs-string">""</span>;<span class="hljs-comment">// 用一个数组来保存转换结果</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * str =  inet_ntop(AF_INET, &amp;num, ip, <span class="hljs-number">16</span>);<span class="hljs-comment">// 16也可用sizeof()</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"str : %s\n"</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ip : %s\n"</span>, str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ip == str);<span class="hljs-comment">// 比较了两个是否相同</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>![[Pasted image 20220512161659.png|700]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs3rUOL50tgWxUVcrEyyAUM" --> <p>#历史记录::<br>2022-05-23🌵IP地址转换 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP 状态转换</title>
    <link href="/posts/43055/"/>
    <url>/posts/43055/</url>
    
    <content type="html"><![CDATA[<p>为什么四次挥手中第 2. 3次ACK和FIN不一同发送<br><a href="marginnote3app://note/F69FB942-D510-4A4F-86A5-1092F7D95657">margin</a><br>![[fa69a4bbf2c1b3c47c7227367f60be6f 3.png|475]]<br>因为客户端想跟服务端断开连接，但是服务端不一定想和客户端断开连接<br>服务端也许还想继续给客户端发送数据呢，不一定非要发送FIN<br>这是单方向的意愿<br>而三次握手中为什么能一块发送ACK，SYN是因为，他们两个都想建立连接，就一块发送了</p><p>为什么要有2msl的等待时间</p><p><a href="marginnote3app://note/F69FB942-D510-4A4F-86A5-1092F7D95657">margin</a><br>![[fa69a4bbf2c1b3c47c7227367f60be6f 3.png|475]]<br>因为防止第四次挥手的时候，服务端没有收到客户端的ACK，如果有一个等待时间<br>服务端可以在这个期间，多次发送FIN信号来请求客户端的ACK，以便来完成最后挥手</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsaHkhCWSVQlrxWLLRB2t3h" --> <p>#历史记录::<br>2022-05-23🌵TCP 状态转换 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP通信并发</title>
    <link href="/posts/42719/"/>
    <url>/posts/42719/</url>
    
    <content type="html"><![CDATA[<blockquote><p>暂时没学</p></blockquote><p>并发：多个客户端连接服务器进行通信</p><p>要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。<br>思路：<br>1.一个父进程，多个子进程<br>2.父进程负责等待并接受客户端的连接<br>用父进程用for循环/while循环的调用accpet函数，来建立接受请求<br>![[Pasted image 20220523154757.png|800]]<br>3.子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信<br>![[Pasted image 20220523154846.png|800]]</p><p>只需要修改之前文件的服务端代码，客户端不用变，因为是服务器处理多个服务器的连接<br>第一版文件代码：[[TCP通信代码案例]]<br>server_process</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recyleChild</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> </span>{<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-comment">// 所有的子进程都回收了</span><br>            <span class="hljs-keyword">break</span>;<br>        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 还有子进程活着</span><br>            <span class="hljs-keyword">break</span>;<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>){<br>            <span class="hljs-comment">// 被回收了</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"子进程 %d 被回收了\n"</span>, ret);<br>        }<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> act;<br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;act.sa_mask);<br>    act.sa_handler = recyleChild;<br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    <span class="hljs-built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br>    <br><br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>){<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> saddr;<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">9999</span>);<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(lfd,(<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-built_in">sizeof</span>(saddr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"bind"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 监听</span><br>    ret = <span class="hljs-built_in">listen</span>(lfd, <span class="hljs-number">128</span>); <span class="hljs-comment">// 第二参数给8也足够</span><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">"listen"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// exit(0)也可</span><br>    }<br><br>    <span class="hljs-comment">// 服务端不断循环等待客户端连接</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> cliaddr;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(cliaddr);<br>        <span class="hljs-comment">// 接受连接</span><br>        <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">accept</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);<br>        <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>) {<br>            <span class="hljs-keyword">if</span>(errno == EINTR) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">"accept"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        }<br><br>        <span class="hljs-comment">// 每一个连接进来，创建一个子进程跟客户端通信</span><br>        <span class="hljs-type">pid_t</span> pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 子进程</span><br>            <span class="hljs-comment">// 获取客户端的信息</span><br>            <span class="hljs-type">char</span> cliIp[<span class="hljs-number">16</span>];<br>            <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="hljs-built_in">sizeof</span>(cliIp));<span class="hljs-comment">// 转换为主机字节序</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> cliPort = <span class="hljs-built_in">ntohs</span>(cliaddr.sin_port);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client ip is : %s, prot is %d\n"</span>, cliIp, cliPort);<br><br>            <span class="hljs-comment">// 接收客户端发来的数据</span><br>            <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>                <span class="hljs-type">int</span> len = <span class="hljs-built_in">read</span>(cfd, &amp;recvBuf, <span class="hljs-built_in">sizeof</span>(recvBuf));<br><br>                <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">"read"</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv client : %s\n"</span>, recvBuf);<br>                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client closed....\n"</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                }<br>                <span class="hljs-built_in">write</span>(cfd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf) + <span class="hljs-number">1</span>);<br>            }<br>            <span class="hljs-built_in">close</span>(cfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);    <span class="hljs-comment">// 退出当前子进程</span><br>        }<br><br>    }<br>    <span class="hljs-built_in">close</span>(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>client.c</p><h2 id="-code1-"><a class="markdownIt-Anchor" href="#-code1-"></a> <figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// TCP通信的客户端</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.创建套接字</span><br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 2.连接服务器端</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span><br>    serveraddr.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">"192.168.193.128"</span>, &amp;serveraddr.sin_addr.s_addr);<br>    serveraddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br>    <br>    <span class="hljs-comment">// 3. 通信</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <br>        <span class="hljs-built_in">sprintf</span>(recvBuf, <span class="hljs-string">"data : %d\n"</span>, i++);<br>        <br>        <span class="hljs-comment">// 给服务器端发送数据</span><br>        write(fd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf)+<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">int</span> len = read(fd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv server : %s\n"</span>, recvBuf);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 表示服务器端断开连接</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"server closed..."</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>        sleep(<span class="hljs-number">1</span>);<br>    }<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></h2><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsZtZ1PMQ5Qrpb1fRlbrgGc" --> <p>#历史记录::<br>2022/10/20🌵TCP通信并发 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP四次挥手</title>
    <link href="/posts/13901/"/>
    <url>/posts/13901/</url>
    
    <content type="html"><![CDATA[<p>三次握手是客户端请求的<br>四次挥手是两端都可以主动提出<br>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。<br>客户端和服务器端都可以主动发起断开连接，谁先调用close()谁就是发起。</p><p>四次挥手需要双向断开连接<br>因为在TCP连接的时候，采用三次握手建立的的连接是双向的，在断开的时候需要双向断开。</p><p><a href="marginnote3app://note/E6901E15-6494-4F39-AF33-A4A4ED51F96C">margin</a><br>![[8040067f3329cf2fbc08a2f62b656dae.png|1000]]</p><ol><li>客户端将FIN置为1，向服务端发送断开请求</li><li>服务端将标志位ACK置为1，同意客户端断开请求</li><li>服务端将FIN置为1，向客户端发送断开请求</li><li>客户端将标志位ACK置为1，同意服务端断开请求</li></ol><blockquote><p>至此客户端与服务端双向断开了，完成了四次挥手</p></blockquote><h2 id="01-四次挥手图解"><a class="markdownIt-Anchor" href="#01-四次挥手图解"></a> 0.1 四次挥手图解</h2><p><a href="marginnote3app://note/6BE6AC4F-C374-451D-B1C5-004754636D8C">margin</a></p><p>![[cc43ec85e80ff543de3790b517e6300f.png|1000]]</p><p>详见下面中：第13次到第18次</p><p>[[滑动窗口#^fyk6mo]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsN8qgwcyjyPHBAjF2yYFaL" --> <p>#历史记录::<br>2022/10/20🌵TCP四次挥手 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/posts/60656/"/>
    <url>/posts/60656/</url>
    
    <content type="html"><![CDATA[<p>服务器端根据设置一个接受数据的尺寸来控制客户端的发送<br>TCP 中采用滑动窗口来进行传输控制,滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时,发送方一般不能再发送数据报。<br>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。</p><p>窗口理解为缓冲区的大小<br>滑动窗口的大小会随着发送数据和接收数据而变化。<br>通信的双方都有发送缓冲区和接收数据的缓冲区<br>服务器：<br>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）<br>客户端：</p><p>发送缓冲区（发送缓冲区的窗口）<br>接收缓冲区（接收缓冲区的窗口）</p><p>![[Pasted image 20220520164119.png]]</p><blockquote><p>这个可以不看，看下边的实例就行</p></blockquote><h1 id="1-滑动窗口实例"><a class="markdownIt-Anchor" href="#1-滑动窗口实例"></a> 1 滑动窗口实例</h1><blockquote><p>mss：maximum segment size (一条数据的最大数据量) 。eg：&lt;mss 1460&gt; 一次最多可发送1460字节的数量的数据<br>win：滑动窗口尺寸。eg：win 4096 (客户端/服务端 滑动窗口尺寸为4096)<br>0(0)：随机序号seq(发送的数据量)</p></blockquote><h2 id="11-滑动窗口图解"><a class="markdownIt-Anchor" href="#11-滑动窗口图解"></a> 1.1 滑动窗口图解</h2><p>![[b410e87074b018768803fa755cf0a49d.png]]<a href="marginnote3app://note/DC538902-F13D-465E-AE98-019FC531D786"></a></p><ol><li>客户端向服务器发起连接，客户端的滑动窗口是4096，一次发送的最大数据量是1460</li><li>服务器接收连接请求ack = seq + 数据量 + SYN(1个字节)，ack = 1(表示对SYN的确认，此时没有数据) ，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024</li><li>第三次握手</li><li>4-9 客户端连续给服务器发送了6k的数据，每次发送1k</li><li>第10次，服务器告诉客户端：发送的6k数据以及接收到，存储在缓冲区中，缓冲区数据己经处理了2k，窗口大小是2k</li><li>第11次，服务器告诉客户端：发送的6k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了4k，窗口大小是4k</li><li>第12次，客户端又给服务器发送了1k的数据</li><li>第13次，客户端主动请求和服务器断开连接，并且给服务器发送了1k的数据   ^fyk6mo</li><li>第14次，服务器回复ack 8194 ，win 2048<ol><li>同意断开连接的请求+告诉客户端己经接受到方才发的2k的数据<ol><li>ack = seq + 数据量 + FIN(1个字节)<ol><li>上次是7169(1024)，多一个字节是因为对FIN的确认</li></ol></li><li>客户端发送FIN也是可以携带数据的，因为此时还处于互相连接的状态</li></ol></li><li>滑动窗口2k</li></ol></li><li>第15、16次，通知客户端滑动窗口的大小</li><li>第17次，第三次挥手，服务器端给客户端发送 TN,请求断开连接</li><li>第18次，第四次回收，客户端同意了服务器端的断开请求</li></ol><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsS1jzAUu55L5iZHycN0ilI" --> <p>#历史记录::<br>2022/10/20🌵滑动窗口 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>9.分割回文串</title>
    <link href="/posts/15279/"/>
    <url>/posts/15279/</url>
    
    <content type="html"><![CDATA[<h1 id="1-131分割回文串"><a class="markdownIt-Anchor" href="#1-131分割回文串"></a> 1 131.分割回文串</h1><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣题目链接</a></p><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例: 输入:&nbsp;<span class="hljs-string">"aab"</span> 输出: [ [<span class="hljs-string">"aa"</span>,<span class="hljs-string">"b"</span>], [<span class="hljs-string">"a"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>] ]<br></code></pre></td></tr></tbody></table></figure><p><strong>"回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</strong><br>1. 顾名思义，“回文子串”的意思是一个字符串中的回文串，比如字符串“baba”中t就包含有“bab”和“aba”这两个回文子串<br>2. <strong>单个字母也是回文串</strong></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题这涉及到两个关键问题：</p><ol><li>切割问题，有不同的切割方式</li><li>判断回文</li></ol><p><strong>其实切割问题类似组合问题</strong>。</p><p>例如对于字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…。</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…。</li></ul><p>所以切割问题，也可以抽象为一棵树形结构，如图：<br>![[9.分割回文串 2022-05-20 11.47.01.excalidraw]]<br>切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><p>定义一些变量<br>path，result</p><h2 id="31-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#31-确定回溯函数参数返回值void"></a> 3.1 确定回溯函数参数返回值(void)</h2><p>startIndex：保证下一层for循环的起始位置，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。<br>这个startIndex就是切割线。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;string&gt;&gt; result;<br>vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br></code></pre></td></tr></tbody></table></figure><p>![[Pasted image 20220520092428.png|1000]]</p><h2 id="32-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#32-终止条件-存放结果-return"></a> 3.2 终止条件, 存放结果, return</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。<br>如果起始位置已经大于s的大小，说明已经找到了一组分割方案了<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> startIndex)</span> {<br>    <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了，💡横向遍历完了</span><br>    <span class="hljs-keyword">if</span> (startIndex &gt;= s.size()) {<br>        result.push_back(path);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><h2 id="33-单层搜索过程"><a class="markdownIt-Anchor" href="#33-单层搜索过程"></a> 3.3 单层搜索过程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">截取子串<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.size(); i++)`，我们定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。<br>判断子串是否为回文串： (用一个函数)<br>用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。这里是无所谓顺序的，只要满足条件就跳出函数，否则一直<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>}<br>将回文串加入path<br><span class="hljs-built_in">string</span> str = s.substr(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.push_back(str);<br>递归下去<br>backtracking(s, i + <span class="hljs-number">1</span>); <br>注意切割过的位置，不能重复切割，所以，传入下一层的起始位置为i + <span class="hljs-number">1</span>。<br>弹出回溯<br>path.pop_back(); <span class="hljs-comment">// 回溯过程，弹出本次已经填在的子串</span><br><br></code></pre></td></tr></tbody></table></figure><h2 id="34-c整体代码"><a class="markdownIt-Anchor" href="#34-c整体代码"></a> 3.4 C++整体代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; path; <span class="hljs-comment">// 放已经回文的子串</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span><br>        <span class="hljs-keyword">if</span> (startIndex &gt;= s.<span class="hljs-built_in">size</span>()) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; s.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPalindrome</span>(s, startIndex, i)) {   <span class="hljs-comment">// 是回文子串</span><br>                <span class="hljs-comment">// 获取[startIndex,i]在s中的子串</span><br>                string str = s.<span class="hljs-built_in">substr</span>(startIndex, i - startIndex + <span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">push_back</span>(str);<br>            } <span class="hljs-keyword">else</span> {                                <span class="hljs-comment">// 不是回文，跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-built_in">backtracking</span>(s, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 寻找i+1为起始位置的子串</span><br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯过程，弹出本次已经填在的子串</span><br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) {<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) {<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[9.分割回文串.自写代码]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsLaWYYJ2RF5oMy6ebwp0wc"--> <p>#历史记录::<br>2022/9/30🌵9.分割回文串 :</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>8.组合总和II</title>
    <link href="/posts/21516/"/>
    <url>/posts/21516/</url>
    
    <content type="html"><![CDATA[<h1 id="1-40组合总和ii"><a class="markdownIt-Anchor" href="#1-40组合总和ii"></a> 1 40.组合总和II</h1><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">力扣题目链接</a></p><p>给定一个数组&nbsp;candidates&nbsp;和一个目标数&nbsp;target&nbsp;，找出&nbsp;candidates&nbsp;中所有可以使数字和为&nbsp;target&nbsp;的组合。</p><p>candidates&nbsp;中的每个数字在每个组合中只能使用一次。</p><p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p><p>示例&nbsp;1: 输入: candidates =&nbsp;[10,1,2,7,6,1,5], target =&nbsp;8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p><p>示例&nbsp;2: 输入: candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5, 所求解集为: [ &nbsp; [1,2,2], &nbsp; [5] ]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="Obs8smtYwS0kltN4pmhaNvPe" --> <p>回溯算法去重问题::</p><p>与[[7.组合总和]]区别是：不能重复的使用元素<br>最后也要不能有重复的组合<br><strong>树层去重的话，需要对数组排序！</strong><br><strong>所谓去重，其实就是使用过的元素不能重复选取，使用过”在这个树形结构上是有两个维度的</strong><br>1.  同一树枝上使用过<br>2. 同一<strong>树层</strong>上使用过</p><p>我们要<strong>去重的是同一树层上的<font color="#F36208">使用过</font></strong>，同一树枝上的都是一个组合里的元素(path中的元素)，不用去重。<br>示例&nbsp;1: 输入: candidates =&nbsp;[10,1,2,7,6,1,5], target =&nbsp;8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]<br>![[8.组合总和II 2022-05-19 09.46.46.excalidraw]]</p><!-- basicblock-end --><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><p>定义一些变量<br>bool型数组used，用来记录同一树枝上的元素是否使用过。(去重的关键)<br>可直接放到backtracking中去</p><h2 id="31-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#31-确定回溯函数参数返回值void"></a> 3.1 确定回溯函数参数返回值(void)</h2><p>startIndex和sum都是局部变量</p><h2 id="32-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#32-终止条件-存放结果-return"></a> 3.2 终止条件, 存放结果, return</h2><p>终止条件：path路径和 = 目标和 (sum == target)</p><h2 id="33-单层搜索过程"><a class="markdownIt-Anchor" href="#33-单层搜索过程"></a> 3.3 单层搜索过程</h2><p>[[组合问题模板]]<br>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>处理节点;<br>把元素加进去：path.push_back(×);<br>backtracking(路径，选择列表); // 递归<br>i++：本身就控制了递归到下一层，[[startIndex]]是用来控制下一层开始的起始位置<br>回溯，撤销处理结果<br>path.pop();<br>}<br>去重：要去重的是“同一树层上的使用过”，要先判断同一树层上元素（相同的元素）是否使用过<br>![[8.组合总和II 2022-05-19 09.59.27.excalidraw]]<br>used用来记录数字在本层的位置<br>**如果<code>candidates[i] == candidates[i - 1]</code> <font color="#F36208">(现在的数=前一个数)</font>，<br>并且 <code>used[i - 1] == false</code><font color="#F36208">(在本层的位置不同)</font>，<br>就说明：在本层中两个数是相同的，但是位置不同的，就去重<br>used[i - 1] == false，说明同一树层candidates[i - 1]使用过<br><font color="#F36208">used[i - 1] ：表示的是前一个字符和现在的字符不一样</font><br>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</p><p>for循环里应该做continue的操作，等到破坏条件在退出</p><p>[[8.组合总和II.自写]]</p><h1 id="4-代码"><a class="markdownIt-Anchor" href="#4-代码"></a> 4 代码</h1><p>v1, 编译已通过，2022年05月19日</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used)</span></span>{<span class="hljs-comment">// used数组用vector&lt;bool&gt;</span><br>        <span class="hljs-keyword">if</span>(sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>    <br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){    <br>        <span class="hljs-comment">// 必须要有i &gt; 0, 因为要从第二个下标才可以比较</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>){<span class="hljs-comment">// 剪枝放到for循环中去，注意是usd[i-1] 不可=false ，这里是赋值，要用==</span><br>                <span class="hljs-keyword">continue</span>;<br>            }   <br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            used[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i+<span class="hljs-number">1</span>, used);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            sum -= candidates[i];<br>            used[i] = <span class="hljs-literal">false</span>;<br><br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(), <span class="hljs-literal">false</span>)</span></span>; <span class="hljs-comment">// ❓必须有，不知道为什么放到上边为什么不行</span><br>        path.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//  首先把给candidates排序，让其相同的元素都挨在一起。</span><br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,  used);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过 只用 startIndex 来给树层去重:&nbsp;⏱1-0</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtacking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum +  candidates[i] &lt;= target; i++){<br>            <span class="hljs-comment">// 💡要对同一树层使用过的元素进行去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) {<br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtacking</span>(candidates, target, sum+candidates[i], i+<span class="hljs-number">1</span>);<span class="hljs-comment">// ❗️和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br><br><br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtacking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obssn8rRIikeW5Mxy9vXZl1r" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::8.组合总和II.md" --> <p>#历史记录::<br>2022/9/29🌵8.组合总和II : v2通过 只用 startIndex 来给树层去重:&nbsp;⏱1-0</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP三次握手</title>
    <link href="/posts/7923/"/>
    <url>/posts/7923/</url>
    
    <content type="html"><![CDATA[<p>三次握手的目的是保证双方互相之间建立了连接<br>三次握手发生在客户端连接的时候，当调用connect()函数时，底层会通过TCP协议进行三次握手。</p><p>seq：序号<br>ACK：标志位<br>ack(AcK)：确认序号，只有当 ACK=1 时确认序号才有用<br>TCP是用字节流传输，会为每个字节分配一个序号</p><h1 id="1-三次握手"><a class="markdownIt-Anchor" href="#1-三次握手"></a> 1 三次握手</h1><p>时序图<br><img src="https://s1.vika.cn/space/2022/05/26/9e8848db48ec40d2a865d364ed1dfe16" alt=""></p><p>牛客总结<br>第一次握手：<br>1.客户端将SYN标志位置为1，向服务端请求建立连接，<br>2.生成一个随机(<font color="#F36208">其实是有固定算法的</font>)的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>1.服务端将<font color="#F36208">标志位</font><font color="#F36208">ACK</font>置为1，接收客户端的连接。<br>并且回发一个确认序号：ack=客户端的序号 +  数据长度+ SYN/FIN（按一个字节算）<br>2.服务器端会向客户端发起连接请求：SYN=1<br>3.服务器会生成一个随机序号(<font color="#F36208">其实是有固定算法的</font>)：seq = K<br>第三次握手：<br>1.客户单应答服务器的连接请求：ACK=1<br>2.客户端回复收到了服务器端的数据：ack=服务端的序号 +数据长度 + SYN/FIN（按一个字节算）<br>自己总结<br><font color="#F36208">第一次握手：客户端发起连接</font><br>1.客户端将标志位SYN置位1，表示向服务端请求连接。2.并且根据算法生成一个客户端序号cseq：J<br><font color="#F36208">第二次握手：服务端回复请求，发起连接</font><br>1.服务端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 客户端的序号(J) + 数据字节个数 + SYN/FIN(算一个字节)<br>3.服务端将标志位SYN置位1，表示向客户端请求连接。4.并且根据算法生成一个服务端序号sseq：K<br><font color="#F36208">第三次握手：客户端回复请求</font><br>1.客户端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 服务端的序号(K) + 数据字节个数 + SYN/FIN(算一个字节)</p><p>第一次握手(客户端→服务端)：客户端请求连接<br>客户端与服务端还没有建立连接，不能发数据<br>第二次握手(客户端←服务端)：服务端同意连接+请求与客户端连接<br>第三次握手(客户端→服务端)：客户端同意连接<br>此时客户端已经和服务端已经建立了连接，这次客户端的握手已经可以携带数据了<br>之后服务端与客户端都互相建立了连接，可以互相自由通信</p><h2 id="11-三次握手实例"><a class="markdownIt-Anchor" href="#11-三次握手实例"></a> 1.1 三次握手实例</h2><p><img src="https://s1.vika.cn/space/2022/05/26/e1cbc619a8b445c5a3cb9282c0d21c21" alt=""></p><h2 id="12-为什么不能两次握手"><a class="markdownIt-Anchor" href="#12-为什么不能两次握手"></a> 1.2 为什么不能两次握手</h2><p>因为要确保客户端能<font color="#C32E94">收发</font>消息，服务端能<font color="#C32E94">收发</font>消息，3次握手正好少一次都不行<br><img src="https://s1.vika.cn/space/2022/05/26/7f7c22713cf345368d2778005723b9b1" alt=""></p><p>四次握手也是可以的，服务端的ACK和SYN连在一起发了，拆开发就是四次握手<br>保证可靠连接的最小次数是三次握手</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsmWEKtCEW64t5rDlMr9yns" --> <p>#历史记录::<br>2022/10/20🌵TCP三次握手 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>startIndex</title>
    <link href="/posts/64148/"/>
    <url>/posts/64148/</url>
    
    <content type="html"><![CDATA[<p>来控制for循环的起始位置::<br>如果是用一个集合来求组合就用startIndex: [[2.组合问题|2.组合问题]]<br>如果是多个集合取组合，各个集合之间相互不影响就可以吧不用startIndex: [[5.电话号码的字母组合|5.电话号码的字母组合]]<br><strong>注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍</strong>。</p><!-- basicblock-end --><p>i++：本身就控制了递归到下一层，startIndex是用来控制下一层开始的起始位置</p><p>startIndex是可以自定义从第几个位置开始的，eg：startIndex = 1就是从下一层的[1]位置开始<br>for循环中 i 从下一个时，因为:i++, i 就天生比startIndex大1了</p><p>[[8.组合总和II]]<br>for循环汇总 i 从下一个时，i 就天生比startIndex大1了<br>可以用[[startIndex]]来去重，就不用used数组了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) { <span class="hljs-comment">// 此时的i比startIndex大1，因为for循环中i++了，此时startIndex还未加1，所以</span><br><span class="hljs-keyword">continue</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><p>排列问题不用startIndex</p><p>![[11. 子集问题#^isql7c]]</p><p>在同一的树层上去重：<br>![[13.子集II#^3c5r8l]]</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsMfnz8IFr85iZgPSBe7Ro5"  --> <p>#历史记录::<br>2022/9/29🌵startIndex :</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7.组合总和</title>
    <link href="/posts/2470/"/>
    <url>/posts/2470/</url>
    
    <content type="html"><![CDATA[<h1 id="1-题目描述"><a class="markdownIt-Anchor" href="#1-题目描述"></a> 1 题目描述</h1><p>向一个集合中找出和为n的组合，所有的数字都可以被重复选取<br>示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]</p><!-- basicblock-start oid="Obs9dRGMbbJuMyOi26UHtHvK" --> <h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><!-- basicblock-end --><p>![[7.组合总和 2022-09-29 10.20.32.excalidraw]]<br>sum等于target的时候，需要收集结果，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span> </span>{<br>        <span class="hljs-keyword">if</span> (sum &gt; target) { <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">if</span> (sum == target) {<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) {<br>            sum += candidates[i];<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 不用i+1了，表示可以重复读取当前的数</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>剪枝优化：<br>![[7.组合总和 2022-09-29 10.52.49.excalidraw]]<br>for循环剪枝代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++)<br></code></pre></td></tr></tbody></table></figure><h2 id="21-回溯三部曲"><a class="markdownIt-Anchor" href="#21-回溯三部曲"></a> 2.1 回溯三部曲</h2><p>定义一些变量<br>path<br>result<br>[[startIndex]]::</p><h3 id="211-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#211-确定回溯函数参数返回值void"></a> 2.1.1 确定回溯函数参数返回值(void)</h3><p>candidates：目标和<br>sum：用来和target对比，等于目标和就可以终止<br>startIndex：来控制for循环的起始位置</p><h3 id="212-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#212-终止条件-存放结果-return"></a> 2.1.2 终止条件, 存放结果, return</h3><p>sum=目标和就可以终止</p><h3 id="213-单层搜索过程"><a class="markdownIt-Anchor" href="#213-单层搜索过程"></a> 2.1.3 单层搜索过程</h3><!-- basicblock-start oid="ObsHuryuOlHk6rmYpKeO4HHM" --> <p>如何重复选取元素呢，看代码，注释部分::<br>必须得有 startIndex, 不能没有, startIndex 控制着回溯的下一层的起始位置, 如果没有的话, 那都没法回溯了</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>(); i++) {<br>    sum += candidates[i];<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-built_in">backtracking</span>(candidates, target, sum, i); <span class="hljs-comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span><br>    sum -= candidates[i];   <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>从startIndex开始，搜索sum = 目标和的path集合<br><strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 2022年05月18日，编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span> (sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){ <span class="hljs-comment">// ❗️注意这里的剪枝，自己写错了不是单纯的sum &lt;= traget；数组长度也可以.szie()</span><br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            sum += candidates[i];<br>            <span class="hljs-built_in">backtracking</span>(candidates,  target,  sum, i);<span class="hljs-comment">// startIndex是用来控制下一层的起始位置的</span><br>            sum -= candidates[i];<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br> <br>    <br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过: 看注释: ⏱0-54</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>: <br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtraking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(sum == target){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 把一个符合结果的返回, return 之后, 就开始执行 pop_back 了, 所以又会找下一个递归的元素</span><br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">backtraking</span>(candidates, target, sum + candidates[i], i);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) {<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtraking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obs0sw6w0p8tQRyHhfUIoTar"  --> <p>#历史记录::<br>2022/9/29🌵7.组合总和 : v2通过: 看注释: ⏱0-54</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5.电话号码的字母组合</title>
    <link href="/posts/48297/"/>
    <url>/posts/48297/</url>
    
    <content type="html"><![CDATA[<h1 id="1-17电话号码的字母组合"><a class="markdownIt-Anchor" href="#1-17电话号码的字母组合"></a> 1 17.电话号码的字母组合</h1><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣题目链接</a></p><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合"></p><p>示例: 输入：“23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><!-- basicblock-start oid="ObsEHJO9qGFMW9sUT95OY1GJ" --> <h2 id="21-数字和字母如何映射"><a class="markdownIt-Anchor" href="#21-数字和字母如何映射"></a> 2.1 数字和字母如何映射::</h2><p>可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = {<br>    <span class="hljs-string">""</span>, <span class="hljs-comment">// 0</span><br>    <span class="hljs-string">""</span>, <span class="hljs-comment">// 1</span><br>    <span class="hljs-string">"abc"</span>, <span class="hljs-comment">// 2</span><br>    <span class="hljs-string">"def"</span>, <span class="hljs-comment">// 3</span><br>    <span class="hljs-string">"ghi"</span>, <span class="hljs-comment">// 4</span><br>    <span class="hljs-string">"jkl"</span>, <span class="hljs-comment">// 5</span><br>    <span class="hljs-string">"mno"</span>, <span class="hljs-comment">// 6</span><br>    <span class="hljs-string">"pqrs"</span>,<span class="hljs-comment">// 7</span><br>    <span class="hljs-string">"tuv"</span>, <span class="hljs-comment">// 8</span><br>    <span class="hljs-string">"wxyz"</span>,<span class="hljs-comment">// 9</span><br>};<span class="hljs-comment">// const 变量 后面要加；</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><h2 id="22"><a class="markdownIt-Anchor" href="#22"></a> 2.2</h2><p>![[5.电话号码的字母组合 2022-09-28 22.02.52.excalidraw]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><p>存放结果的：s(类似path)，result<br>类型是string</p><h2 id="31-确定回溯函数参数"><a class="markdownIt-Anchor" href="#31-确定回溯函数参数"></a> 3.1 确定回溯函数参数</h2><p>string digits：题目给的 <code>vector&lt;string&gt; letterCombinations(string digits)</code><br>传入的数字，eg：”2,3“，这里不是int型的，而是数字字符串<br>digits：<br>int index： 用来遍历digits的，记录遍历到第几个数字了，在递归函数中起到深度的作用<br>不是[[2.组合问题]]中的startIndex(用来控制下一层递归的起始位置)</p><h2 id="32-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#32-终止条件-存放结果-return"></a> 3.2 终止条件, 存放结果, return</h2><p>如果index 等于 输入的数字个数（digits.size）了，然后收集结果，结束本层递归。</p><h2 id="33-单层搜索过程"><a class="markdownIt-Anchor" href="#33-单层搜索过程"></a> 3.3 单层搜索过程</h2><p>将index指向的数字转为int，用来找到字符集中对应的字母</p><p>用for循环处理这个字符集<br>目标：取出字母，根据字母个数开始遍历宽度，eg：“abc”，宽度为3(<font color="#F36208">letter.size()</font>)·<br>1. 取出string digits的数字，2. 然后对应letterMap中的字母<br>所有数字型的字符减去字符‘0’，将会得到该字符的绝对值，是一个整数。<br>eg：digits=”<mark>2</mark>3“；digits[0] - ‘0’ = <mark>2</mark>；digits[1] - ‘0’ = 3<br>第几个位置是数字几，最后得出的结果就是几</p><ul><li><p>[x] for循环不是出不去了吗 #疑问 ✅ 2022-05-18</p><ul><li>例如“ad”，到了if终止条件检测(index == digits.size()) 就return了</li></ul><p>下次记得提前监听一下设置全局变量(s，result)</p></li></ul><h1 id="4-代码"><a class="markdownIt-Anchor" href="#4-代码"></a> 4 代码</h1><p>v1, 复习了一遍之前的代码, 没自己写一遍⏱0-38</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    string s;<br>    vector&lt;string&gt; result;<br>    <span class="hljs-type">int</span> index;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> string letterMap[<span class="hljs-number">10</span>] = {<br>        <span class="hljs-string">""</span>, <span class="hljs-comment">// 0</span><br>        <span class="hljs-string">""</span>, <span class="hljs-comment">// 1</span><br>        <span class="hljs-string">"abc"</span>, <span class="hljs-comment">// 2</span><br>        <span class="hljs-string">"def"</span>, <span class="hljs-comment">// 3</span><br>        <span class="hljs-string">"ghi"</span>, <span class="hljs-comment">// 4</span><br>        <span class="hljs-string">"jkl"</span>, <span class="hljs-comment">// 5</span><br>        <span class="hljs-string">"mno"</span>, <span class="hljs-comment">// 6</span><br>        <span class="hljs-string">"pqrs"</span>, <span class="hljs-comment">// 7</span><br>        <span class="hljs-string">"tuv"</span>, <span class="hljs-comment">// 8</span><br>        <span class="hljs-string">"wxyz"</span>, <span class="hljs-comment">// 9</span><br>    };<span class="hljs-comment">// const 变量 后面要加；</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(string digits, <span class="hljs-type">int</span> k)</span></span>{ <span class="hljs-comment">// 我觉得可以不用const string&amp;</span><br>        <span class="hljs-comment">// ❗️要把终止条件放到回溯函数中去,放到外边编译不通过</span><br>        <span class="hljs-keyword">if</span> ( digits.<span class="hljs-built_in">size</span>() == k){<br>        result.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>        <span class="hljs-type">int</span> digit = digits[k] - <span class="hljs-string">'0'</span>;<span class="hljs-comment">// 取digits的一个数字</span><br>        string letter = letterMap[digit];<span class="hljs-comment">// 取出字母</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; letter.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// i不能等于1，这样漏了起始位置0</span><br>            s.<span class="hljs-built_in">push_back</span>(letter[i]);<span class="hljs-comment">// 不是i，要添加s里的是字母</span><br>            <span class="hljs-built_in">backtracking</span>(digits, k + <span class="hljs-number">1</span>);<span class="hljs-comment">// index + 1控制深度</span><br>            s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// pop_back中不需要参数i，自动弹出的是第一个字母</span><br>        }<br>    }<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>{<br>        s.<span class="hljs-built_in">clear</span>();<br>        result.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>){<br>            <span class="hljs-keyword">return</span> result;<span class="hljs-comment">// 不能单独return，return的结果应当和返回值类型一样</span><br>        }<br>        <span class="hljs-built_in">backtracking</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码随想录的代码</p><p>[[自写代码]]</p><h1 id="5-周末总结"><a class="markdownIt-Anchor" href="#5-周末总结"></a> 5 周末总结</h1><p><strong>本题每一个数字代表的是不同集合，也就是求不同集合之间的组合</strong><br>[[2.组合问题]]，[[4.组合总和III]]，是求同一集合中组合</p><ul><li>[ ] 输入1 * # 按键等等异常情况，现在还没有弄</li></ul><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsJDI4SNWRXaFoJ7rGKbf0b" --> <p>#历史记录::<br>2022/9/28🌵5.电话号码的字母组合 : v1, 复习了一遍之前的代码, 没自己写一遍⏱0-38</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法剪枝</title>
    <link href="/posts/3235/"/>
    <url>/posts/3235/</url>
    
    <content type="html"><![CDATA[<h1 id="1-对-for-循环的范围去重"><a class="markdownIt-Anchor" href="#1-对-for-循环的范围去重"></a> 1 对 for 循环的范围去重</h1><p>含起始位置和终止位置</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++){ <br></code></pre></td></tr></tbody></table></figure><p>[[2.组合问题]]</p><p>[[8.组合总和II]]<br>[[4.组合总和III]]</p><h1 id="2-对树层去重"><a class="markdownIt-Anchor" href="#2-对树层去重"></a> 2 对树层去重</h1><h2 id="21-8组合总和ii"><a class="markdownIt-Anchor" href="#21-8组合总和ii"></a> 2.1 [[8.组合总和II]]</h2><p>💡要对同一树层使用过的元素进行去重</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum +  candidates[i] &lt;= target; i++){<br>    <span class="hljs-comment">// 💡要对同一树层使用过的元素进行去重</span><br>    <span class="hljs-keyword">if</span> (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>]) {<br>        <span class="hljs-keyword">continue</span>;<br>    }<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-built_in">backtacking</span>(candidates, target, sum+candidates[i], i+<span class="hljs-number">1</span>);<span class="hljs-comment">// ❗️和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span><br>    path.<span class="hljs-built_in">pop_back</span>();<br></code></pre></td></tr></tbody></table></figure><h1 id="3-对树枝去重"><a class="markdownIt-Anchor" href="#3-对树枝去重"></a> 3 对树枝去重</h1><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsboIJGZMEqUKtpvDngZCIL" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::剪枝.md" --> <p>#历史记录::<br>2022/9/28🌵剪枝 :</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4.组合总和III</title>
    <link href="/posts/62353/"/>
    <url>/posts/62353/</url>
    
    <content type="html"><![CDATA[<h1 id="1-216组合总和iii"><a class="markdownIt-Anchor" href="#1-216组合总和iii"></a> 1 216.组合总和III</h1><p><a href="https://leetcode.cn/problems/combination-sum-iii/">力扣题目链接</a></p><p>找出所有相加之和为&nbsp;n 的&nbsp;k&nbsp;个数的组合。组合中只允许含有 1 -&nbsp;9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例 <span class="hljs-number">1</span>: 输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span> 输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]]<br><br>示例 <span class="hljs-number">2</span>: 输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">9</span> 输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路::</h1><p>eg:<br>在[1,2,3,4,5,6,7,8,9]这个集合中找到<strong>和为n</strong>的<strong>k个数</strong>的组合。<br>输入: n = 4 ，k = 2输出: [ [1,3] ]</p><p>![[4.组合总和III 2022-09-28 16.56.44.excalidraw]]</p><h2 id="21-确定递归函数参数"><a class="markdownIt-Anchor" href="#21-确定递归函数参数"></a> 2.1 确定递归函数参数</h2><p>n：目标和<br>k：要的个数<br>startIndex：下一层for循环搜素的起始位置<br>sum：path中的和，用来和n来比较</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> targetSum, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> startIndex)</span><br></code></pre></td></tr></tbody></table></figure><p>其实这里sum这个参数也可以省略，每次targetSum减去选取的元素数值，然后判断如果targetSum为0了，说明收集到符合条件的结果了，我这里为了直观便于理解，还是加一个sum参数。</p><ul><li>$ 还要强调一下，回溯法中递归函数参数很难一次性确定下来，一般先写逻辑，需要啥参数了，填什么参数。</li></ul><h2 id="22-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#22-终止条件-存放结果-return"></a> 2.2 终止条件, 存放结果, return</h2><p>k限制了深度，在往下就没有意义了：path.size() 和 k相等了，就终止。<br>如果path中的和与目标和相等就放入结果result中</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (path.size() == k) {<br>    <span class="hljs-keyword">if</span> (sum == targetSum) result.push_back(path);<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果path.size() == k 但sum != targetSum 就直接返回</span><br>}<br></code></pre></td></tr></tbody></table></figure><h2 id="23-单层搜索过程"><a class="markdownIt-Anchor" href="#23-单层搜索过程"></a> 2.3 单层搜索过程</h2><p><strong>别忘了处理节点 和 回溯过程是一一对应的，处理有加，回溯就要有减！</strong><br>集合固定的就是9个数[1,…,9]，所以for循环固定i&lt;=9<br>处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span>; i++) {<br>    sum += i;<br>    path.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-built_in">backtracking</span>(targetSum, k, sum, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// i+1调整startIndex，让递归到下一层</span><br>    sum -= i; <span class="hljs-comment">// 回溯</span><br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/2020112319580476.png" alt="216.组合总和III1"></p><ul><li>path中的和大于4就没有意义了：sum &gt; 4</li><li>剪枝的代码，可以把for循环，加上 <code>i &lt;= 9 - (k - path.size()) + 1</code> 的限制！<ul><li>对for循环选择的起始范围的剪枝。</li></ul></li></ul><p>[[回溯算法剪枝]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 还行吧⏱0-28</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> sum)</span></span>{<br>        <span class="hljs-keyword">if</span>(sum &gt; n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝 </span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k){<br>            <span class="hljs-keyword">if</span>(sum == n){<br>                result.<span class="hljs-built_in">push_back</span>(path);<br>            }<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++){ <span class="hljs-comment">// ❗️不要忘记=号</span><br>            <span class="hljs-comment">//sum += i;</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n, k , i+<span class="hljs-number">1</span>, sum + i); <span class="hljs-comment">// 💡sum + i 直接传进这里跟注释的效果一样</span><br>            <span class="hljs-comment">//sum -= i;</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br><br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) {<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>v2通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k ){<br>            <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// ❗️n==0,不能联立放到第一个 if 判断语句中</span><br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= <span class="hljs-number">9</span> - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span>; i++){<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(k, n-i, i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) {<br>        <span class="hljs-built_in">backtracking</span>(k, n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsxQ9tpdYBmzWTfp6cxBGdG" --> <p>#历史记录::<br>2022/9/28🌵4.组合总和III : v1, 还行吧⏱0-28</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法模板</title>
    <link href="/posts/13212/"/>
    <url>/posts/13212/</url>
    
    <content type="html"><![CDATA[<h1 id="1-回溯三部曲"><a class="markdownIt-Anchor" href="#1-回溯三部曲"></a> 1 回溯三部曲::</h1><!-- basicblock-end --><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>startIndex：控制下一层的起始位置<br>去重(从下一层的第一个位置开始：<span class="hljs-built_in">backtracking</span>(...., i+<span class="hljs-number">1</span>))<br>排列问题不用startIndex<br>used[]：去重(从下一层的起始位置开始：<span class="hljs-built_in">backtracking</span>(...., <span class="hljs-number">0</span>))<br><span class="hljs-keyword">if</span> (终止条件) {<br>存放结果;<br><span class="hljs-keyword">return</span>;<br>要取树上所有节点时不要加<span class="hljs-keyword">return</span><br>}<br><br><br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>定义一些变量</p><h2 id="11-确定回溯函数参数返回值void"><a class="markdownIt-Anchor" href="#11-确定回溯函数参数返回值void"></a> 1.1 确定回溯函数参数返回值(void)</h2><h2 id="12-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#12-终止条件-存放结果-return"></a> 1.2 终止条件, 存放结果, return</h2><h2 id="13-单层搜索过程"><a class="markdownIt-Anchor" href="#13-单层搜索过程"></a> 1.3 单层搜索过程</h2><!-- basicblock-start oid="ObsaodmKESNMsc0sTNNBqc8G"  --> <p>2022/9/28🌵回溯算法模板.md::</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3.组合优化</title>
    <link href="/posts/50548/"/>
    <url>/posts/50548/</url>
    
    <content type="html"><![CDATA[<p>[[2.组合问题]]<br><a href="https://leetcode.cn/problems/combinations/submissions/">Loading Question… - 力扣（LeetCode）</a></p><!-- basicblock-start oid="ObsYz3UogGu35JEfq6xUEeLw" --> <h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1 思路::</h1><!-- basicblock-end --><p>![[3.组合优化 2022-09-28 16.11.10.excalidraw]]</p><!-- basicblock-start oid="ObsDbgREId29fWXbspKsmegB" --> <p><strong>剪枝精髓是::</strong></p><p>for循环时候要有一个范围，如果不满足这个范围, 就没有必要搜索了。<br>注意代码中i，就是for循环里选择的起始位置。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++)<br></code></pre></td></tr></tbody></table></figure><p>startIndex是起始位置, n是遍历的终止位置，<br><strong>范围就是[startIndex, n]</strong><br>控制 n 的值就是剪枝</p><!-- basicblock-end --><h2 id="11-举例"><a class="markdownIt-Anchor" href="#11-举例"></a> 1.1 举例</h2><p>n = 4, k = 4：要[1,2,3,4]这种</p><ol><li>已经添加到path(单一数组如[1,2])的个数为：path.size()</li><li>还需要的元素个数：k - path.size()</li><li>终止位置为：<strong>n -  (k - path.size()) + 1</strong> <mark>(总共的元素个数 - 还需要的元素个数 + 1)</mark><ul><li>? 为什么+1: ✅ 是因为要包括起始位置，总体是左闭的区间</li><li>&amp; eg：目前添加path中的元素个数为0，4 - (4 - 0) + 1 = 1 (跟图上一样，最多遍历1个就终止)</li></ul></li></ol><!-- basicblock-start oid="ObsfO9QzrwMZnvqABHlyNk8y" --> <h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码::</h1><!-- basicblock-end --><p>v1, 有点懵吧,还好 ⏱0-37</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 跳出 if 循环</span><br>         }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="hljs-built_in">size</span>()) + <span class="hljs-number">1</span> ; i++){ <span class="hljs-comment">// 💡在这里剪枝</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">backtracking</span>(n, k, i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        }<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) {<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-start oid="ObsGT1INYurrpkRdg7gy9Lhd" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::3.组合优化.md" --> <p>#历史记录::<br>2022/9/28🌵3.组合优化.md:  v1, 有点懵吧,还好 ⏱0-37</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0. 回溯算法集合</title>
    <link href="/posts/18033/"/>
    <url>/posts/18033/</url>
    
    <content type="html"><![CDATA[<p>[[1.回溯算法理论基础]]</p><p>[[2.组合问题]]</p><p>[[3.组合优化]]</p><p>[[4.组合总和III]]</p><p>[[5.电话号码的字母组合]]</p><p>[[6.回溯周末总结]]</p><p>[[7.组合总和]]</p><p>[[8.组合总和II]]</p><p>[[9.分割回文串]]</p><p>[[10.复制IP地址]]</p><p>[[11.子集问题]]</p><p>[[12.回溯周末总结]]</p><p>[[13.子集 II]]</p><p>[[14.递增子序列]]</p><p>[[15.全排列]]</p><p>[[16.全排列II]]</p><p>[[17.回溯算法总结]]</p><p>[[18.回溯算法去重问题的另一种写法]]</p><p>[[19.重新安排行程]]</p><p>[[20.N皇后]]</p><p>[[21.解数独]]</p><p><strong>其他资料</strong></p><!-- basicblock-start oid="Obsm4FhsEgOmu97u2rp8JMVZ" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::回溯算法::0. 回溯算法集合.md" --> <p>#历史记录::<br>2022/9/28🌵0. 回溯算法集合 :</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2.组合问题</title>
    <link href="/posts/61446/"/>
    <url>/posts/61446/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第77题-组合"><a class="markdownIt-Anchor" href="#1-第77题-组合"></a> 1 第77题. 组合</h1><p><a href="https://leetcode.cn/problems/combinations/">力扣题目链接</a></p><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">示例:  <br>输入:&nbsp;n = <span class="hljs-number">4</span>, k = <span class="hljs-number">2</span>  <br>输出:  <br><br>[  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  <br>[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <br>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>],  <br>[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],  <br>]<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>[[回溯法能解决n层for循环的问题]]</p><p>![[2.组合问题 2022-09-28 15.32.18.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>v1, 通过, 算是抄一遍⏱0-46</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> startIndex)</span></span>{<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k){<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt;= n; i++){<span class="hljs-comment">// ❗️ i 是 &lt;= n, ❗️startIndex这里不是下标的意思 </span><br>            path.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">// 加入本层的第一个数</span><br>            <span class="hljs-comment">// 到下一层， 随后又会加入本层的第一个数</span><br>            <span class="hljs-built_in">backtracking</span>(n, k, i+<span class="hljs-number">1</span>);<span class="hljs-comment">// k 控制着递归的层数, ❗️不是startindex+1, 而是 i+1, i 控制着 startIndex</span><br>            <span class="hljs-comment">// 弹出上一层加入的数</span><br>            path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">// ❗️vector 是 pop_back()</span><br><br>        }<br><br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) {<br>        <span class="hljs-built_in">backtracking</span>(n, k, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[[回溯算法模板]]</p><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsmV74o0U0NglfPn3zHTM24"  --> <p>#历史记录::<br>2022/9/28🌵 <a href="http://2.xn--8pr770hlso7nc.md">2.组合问题.md</a>: v1, 通过, 算是抄一遍⏱0-46</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1.回溯算法理论基础</title>
    <link href="/posts/25363/"/>
    <url>/posts/25363/</url>
    
    <content type="html"><![CDATA[<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>：<mark>组合无序，排列有序</mark><br>{1, 2} 和 {2, 1}：组合是一样的，排列是不一样的</p><!-- basicblock-start oid="ObsrusxrXf0Y469dKCkR51pZ" --> <h1 id="1-回溯法能解决的问题"><a class="markdownIt-Anchor" href="#1-回溯法能解决的问题"></a> 1 回溯法能解决的问题::</h1><!-- basicblock-end --><ul><li>组合问题：N个数里面按一定规则找出k个数的集合<ul><li>[[2.组合问题]] [[4.组合总和III]] [[5.电话号码的字母组合]]</li></ul></li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>[[子集问题]]：一个N个数的集合里有多少符合条件的子集</li><li>[[排列问题]]：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li><li>$ [[回溯法能解决n层for循环的问题]]</li></ul><!-- basicblock-start oid="ObsZIjQjSB3eor68dkSy1eOI" --> <h1 id="2-如何理解回溯法"><a class="markdownIt-Anchor" href="#2-如何理解回溯法"></a> 2 如何理解回溯法::</h1><!-- basicblock-end --><ul><li>$ 回溯法解决的问题都可以抽象为树形结构（N叉树）<br><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</li></ul><p>如果把子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。<br>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</p><h1 id="3-回溯三部曲"><a class="markdownIt-Anchor" href="#3-回溯三部曲"></a> 3 回溯三部曲</h1><h2 id="31-回溯函数模板返回值以及参数"><a class="markdownIt-Anchor" href="#31-回溯函数模板返回值以及参数"></a> 3.1 回溯函数模板返回值以及参数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span></span><br></code></pre></td></tr></tbody></table></figure><p>返回值一般为void。<br>参数:  因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><h2 id="32-回溯函数终止条件"><a class="markdownIt-Anchor" href="#32-回溯函数终止条件"></a> 3.2 回溯函数终止条件</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (终止条件) {<br>    存放结果;<br>    <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 结束本轮递归开始回溯</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>终止条件：一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><h2 id="33-回溯搜索的遍历过程"><a class="markdownIt-Anchor" href="#33-回溯搜索的遍历过程"></a> 3.3 回溯搜索的遍历过程</h2><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。<br>![[回溯算法过程.excalidraw|900]]</p><p>回溯函数遍历过程伪代码如下：<br><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>    处理节点;<br>    <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>    回溯，撤销处理结果<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>回溯算法模板框架</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>{<br>    <span class="hljs-keyword">if</span> (终止条件) {<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 结束本轮递归开始回溯</span><br>    }<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsY0FqZyXLZ0e7IoC61Et8q"  --> <p>#历史记录::<br>2022/9/28🌵1.回溯算法理论基础.md: 第一次创建: ⏱0-26</p><!-- basicblock-end --> ]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP通信代码案例</title>
    <link href="/posts/12103/"/>
    <url>/posts/12103/</url>
    
    <content type="html"><![CDATA[<h1 id="1-服务器端通信"><a class="markdownIt-Anchor" href="#1-服务器端通信"></a> 1 服务器端通信</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// TCP 通信的服务器端</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.创建socket(用于监听的套接字)</span><br>    <span class="hljs-type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 2.绑定</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><span class="hljs-comment">// 用sockaddr比较麻烦，sockaddrin是模块化成员的比较好用</span><br>    <span class="hljs-comment">//对成员赋值</span><br>    saddr.sin_family = AF_INET;<br>    <span class="hljs-comment">// inet_pton(AF_INET, "192.168.193.128", saddr.sin_addr.s_addr);// //将网络字节序的整数,转换成点分十进制的IP地址字符串</span><br>    serverad<br>    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="hljs-comment">//这个是可连接的IP地址， 0.0.0.0，定义的这个宏INADDR_ANY就是0，因为只有服务端可以这样写，表示谁的都可以连接</span><br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<span class="hljs-comment">// 主机会随机分配一个端口号，如果只写9999是不对的，因为这是主机字节序，要用网络字节序用到htons函数。</span><br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr)); <span class="hljs-comment">// 转换sockaddr类型指针</span><br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"bind"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 3.监听</span><br>    ret = listen(lfd, <span class="hljs-number">8</span>);<span class="hljs-comment">// 给个8足够了</span><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"listen"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<span class="hljs-comment">// exit(0)也可</span><br>    }<br><br>    <span class="hljs-comment">// 4.接收客户端连接</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">clientaddr</span>;</span><span class="hljs-comment">// 定义客户端的地址信息</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(clientaddr);<span class="hljs-comment">// sizeof的返回值是int 不能用socklen_t，但len的类型应该给是socklen_t的，为了编译通过这样改了，可以强转socklen_t</span><br>    <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clientaddr, &amp;len); <span class="hljs-comment">// accpet函数如果没有客户端连接会阻塞在这里</span><br>    <br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"accept"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 输出客户端的信息</span><br>    <span class="hljs-type">char</span> clientIP[<span class="hljs-number">16</span>];<span class="hljs-comment">// 点分十进制，每个.前是3个字节也就是12个字节，又有三个”.“和最后的结束符，所以定义16</span><br>    inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="hljs-keyword">sizeof</span>(clientIP));<span class="hljs-comment">// 将网络字节序的整数,转换成点分十进制的IP地址字符串(因为接受的网络字节序)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> clientPort = ntohs(clientaddr.sin_port);<span class="hljs-comment">// 获取端口+转换主机字节序的short    </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"client ip is %s, port is %d\n"</span>, clientIP, clientPort);<br><br>    <span class="hljs-comment">// 5.通信</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br>        <br>        <span class="hljs-comment">// 获取客户端的数据</span><br>        <span class="hljs-type">int</span> num = read(cfd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<span class="hljs-comment">// read函数：如果客户端没有发来数据会阻塞在这里</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv client data : %s\n"</span>, recvBuf);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 表示客户端断开连接</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"clinet closed..."</span>);<br>            <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 断开连接就break</span><br>        }<br><br>        <span class="hljs-type">char</span> * data = <span class="hljs-string">"hello,i am server"</span>;<br>        <span class="hljs-comment">// 给客户端发送数据</span><br>        write(cfd, data, <span class="hljs-built_in">strlen</span>(data));<br>    }<br>   <br>    <span class="hljs-comment">// 关闭文件描述符：监听和接受描述符</span><br>    close(cfd);<br>    close(lfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-客户端通信"><a class="markdownIt-Anchor" href="#2-客户端通信"></a> 2 客户端通信</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// [[TCP通信]]的客户端</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>    <span class="hljs-comment">// 1.创建套接字</span><br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"socket"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <span class="hljs-comment">// 2.连接服务器端</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span> <br>    serveraddr.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">"192.168.193.128"</span>, &amp;serveraddr.sin_addr.s_addr);<br>    <span class="hljs-type">int</span> ret = connect(fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="hljs-keyword">sizeof</span>(serveraddr));<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) {<br>        perror(<span class="hljs-string">"connect"</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    }<br><br>    <br>    <span class="hljs-comment">// 3. 通信</span><br>    <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = {<span class="hljs-number">0</span>};<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {<br><br>        <span class="hljs-type">char</span> * data = <span class="hljs-string">"hello,i am client"</span>;<br>        <span class="hljs-comment">// 给客户端发送数据</span><br>        write(fd, data , <span class="hljs-built_in">strlen</span>(data));<br><br>        sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">// 慢一点</span><br>        <br>        <span class="hljs-type">int</span> len = read(fd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">-1</span>) {<br>            perror(<span class="hljs-string">"read"</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"recv server data : %s\n"</span>, recvBuf);<br>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) {<br>            <span class="hljs-comment">// 表示服务器端断开连接</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"server closed..."</span>);<br>            <span class="hljs-keyword">break</span>;<br>        }<br><br>    }<br><br>    <span class="hljs-comment">// 关闭连接</span><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs col">![[Pasted image 20220512220917.png]]<br>第一开始运行服务端会阻塞着(因为accpet函数)，等待的客户端的连接<br><br>![[Pasted image 20220512220948.png]]<br>只通信一次的结果，没有while(1)死循环<br></code></pre></td></tr></tbody></table></figure><p>作业：<br>客户端给服务器发送一个数据，服务器在把它发回客户端 (回射服务器)<br>客户端获取键盘录入的数据给服务器发过去，服务器在随便回个消息</p><hr><p><strong>其他资料</strong></p><!-- basicblock-start oid="ObsTOSfR5ATuNWmO253x1hLS" --> <p>#历史记录::<br>2022-05-12🌵TCP通信代码案例 : 第一次创建</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="/posts/61467/"/>
    <url>/posts/61467/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义::</h1><!-- basicblock-end --><ol><li>左子树比根节点小，右子树比根节点大，(左小右大)</li><li>左右子树也分别是二叉搜索树</li></ol><p><img src="https://img-blog.csdnimg.cn/20200806190304693.png" alt=""></p><ul><li>&amp; 左子树中最大的元素也比根节点小, 右子树中最小的元素也比根节点大<ul><li>$ 这是二叉搜索树的性质决定的</li></ul></li></ul><!-- basicblock-start oid="Obs65oCz6Nl7gX7dcHpKPINZ" --> <h2 id="11-平衡二叉搜索树"><a class="markdownIt-Anchor" href="#11-平衡二叉搜索树"></a> 1.1 平衡二叉搜索树::</h2><!-- basicblock-end --><ol><li><p>平衡二叉搜索数是不是二叉搜索树和平衡二叉树的结合？<br>是的，是二叉搜索树和平衡二叉树的结合。</p></li><li><p>平衡二叉树与完全二叉树的区别在于底层节点的位置？<br>是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。</p></li><li><p>堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？<br>是的, 堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 <strong>但<mark>完全二叉树一定是平衡二叉树</mark>，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树</strong>。</p></li></ol><!-- basicblock-start oid="Obs2EjX4XYMRZCX0rBMJtzm6" --><h1 id="2-性质"><a class="markdownIt-Anchor" href="#2-性质"></a> 2 性质::</h1><p>中序遍历变为顺序数组：<br><strong>左中右：递增数组(由小变大)</strong>&nbsp;<br>右中左：递减数组(由大变小)</p><p>中序遍历二叉搜树代码</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>{<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// ❗️void不需要返回 NULL</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>    （处理节点）                  <span class="hljs-comment">// 中 💡result.push_back(cur-&gt;val) 转化成递增数组</span><br>    <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>    <span class="hljs-keyword">return</span> ;<br>}<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>其他资料</strong></p> <!-- basicblock-start oid="Obstwgv0yLKU0BVSy4zCeGoI" deck = "👨🏻‍💻code::数据结构与算法::代码随想录::二叉树::二叉搜索树.md" --> <p>#历史记录::<br>2022/9/23🌵二叉搜索树 :</p><!-- basicblock-end -->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/3/"/>
    <url>/posts/3/</url>
    
    <content type="html"><![CDATA[<h1 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1</h1><h1 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2</h1><p>[[4.26 select  API介绍]]</p><p>[[4.27select代码编写]]</p><p>4.1 网络结构模式<br>4.2 MAC 地址、IP 地址、端口（1）<br>4.3 MAC地址、1P地址、端口（2）<br>4.4 网络模型<br>4.5 协议<br>4.6 网络通信的过程（1<br>4.7 网络通信的过程 (2)</p><ul><li><p>[[socket 综述]]</p><ul><li>4.8 socket 介绍，</li><li>4.11 socket 地址，</li><li>4.35 本地套接字通信</li><li>4.14 socket 函数</li></ul></li><li><p>[[字节序]]</p><ul><li>4.9 字节序</li><li>4.10 字节序转换函数</li></ul></li></ul><p>[[IP地址转换]]<br>4.12 IP 地址转换函数</p><ul><li>[[TCP 通信流程]]<ul><li>4.13 TCP 通信流程</li><li>4.15 TCP通信实现（服务器端）</li><li>4.16 TCP 通信实现（客户端）</li></ul></li></ul><p>[[TCP三次握手]]<br>4.17 TCP 三次握手</p><p>[[滑动窗口]]<br>4.18 滑动窗口</p><p>[[TCP四次挥手]]<br>4.19 TCP 四次挥手</p><p>[[TCP通信并发]]<br>4.20 多进程实现并发服务器 (1）<br>4.21 多进程实现并发服务器 (2）</p><p>4.22 多线程实现并发服务器</p><p>[[TCP 状态转换]]<br>4.23 TCP状态转换</p><p>[[端口复用]]<br>4.24 半关闭、端口复用</p><p>[[IO多路复用]]<br>4.25 IO 多路复用简介</p><p>4.26 select APl介绍<br>4.27 select代码编写<br>4.28 poll API介绍及代码编写<br>4.29 epoll API介绍<br>4.30 epoll 代码编写<br>4.31 epoll的两种工作模式<br>4.32 UDP通信实现<br>4.33广播|<br>4.34组播</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>webserver</category>
      
      <category>4 Linux网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>memset</title>
    <link href="/posts/46467/"/>
    <url>/posts/46467/</url>
    
    <content type="html"><![CDATA[<p>📝memset::</p><!-- basicblock-end --><h1 id="1-memset"><a class="markdownIt-Anchor" href="#1-memset"></a> 1: memset</h1><p>memset 是 C 语言中的一个函数，它的作用是将指定的内存块设置为指定的值。<br>memset是一个初始化函数，作用是将某一块内存中的全部设置为指定的值。<br>用于数组清空</p><p><code>memset(void *dest, int c, size_t n)</code>。</p><ul><li>第一个参数 dest 是一个指向要设置值的内存块的指针，</li><li>第二个参数 c 是要设置的值，</li><li>第三个参数 n 是内存块的大小，以字节为单位。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *s, <span class="hljs-type">int</span> c, <span class="hljs-type">size_t</span> n)</span></span>; <br>s指向要填充的内存块。<br>    c是要被设置的值。<br>    n是要被设置该值的字符数。<br>    返回类型是一个指向存储区s的指针。<br><br><br><br>eg：<span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp))<br><br></code></pre></td></tr></tbody></table></figure><h1 id="2-列表初始化"><a class="markdownIt-Anchor" href="#2-列表初始化"></a> 2: 列表初始化</h1><p><code>int dp[200][200] = {0}</code></p><p>这种方法的缺点是，如果 <strong>dp 数组非常大</strong>，那么这样写可能会使代码变得很冗长。此时可以使用 memset 函数来替代。例如：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br></code></pre></td></tr></tbody></table></figure><p>这行代码可以将 dp 数组中的所有元素都设为 0。与列表初始化相比，这种写法更简洁、更高效。</p><h1 id="3-区别"><a class="markdownIt-Anchor" href="#3-区别"></a> 3: 区别</h1>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>剑指 offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>疑问</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
