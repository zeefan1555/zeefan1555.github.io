<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/1001/"/>
    <url>/posts/1001/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>8. 三数之和</title>
    <link href="/posts/7672/"/>
    <url>/posts/7672/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第15题-三数之和"><a class="markdownIt-Anchor" href="#1-第15题-三数之和"></a> 1 第15题. 三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/">力扣题目链接</a></p><p>给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> <strong>答案中不可以包含重复的三元组</strong>。</p><p>示例：</p><p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-哈希法"><a class="markdownIt-Anchor" href="#21-哈希法"></a> 2.1 哈希法</h2><p>两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在 数组里出现过，<br>但是我们有一个非常棘手的问题，就是题目中说的不可以包含重复的三元组</p><p><strong>哈希结构里都只是单元素的去重, 无法实现集合形式的去重</strong> ^l8megb</p><h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法</h2><p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p><p>首先将<strong>数组排序</strong>，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止(但不能相等, 因为相等就成两个数了)。<br>时间复杂度：O(n^2)<br>![[8. 三数之和 2022-08-15 10.25.32.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) {<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<span class="hljs-comment">// ❓为什么是二元数组💡题目定义的<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector]]">[2]</span></a></sup></span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">return</span> result;<br>            }<br>            <span class="hljs-comment">// 去重a</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left =i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <br>            <span class="hljs-keyword">while</span>(left &lt; right){<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>            <span class="hljs-keyword">else</span> {<br>                result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;{nums[i], nums[left], nums[right]});<br>                  <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--; <span class="hljs-comment">// 已经找到了, 符合结果的 b c , 在有相同的 b c 也就重复了, 所以继续移动不添加</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩, 如果同时收缩的同时,不去重的话, 就会导致相同的结果集</span><br>                    right--;<br>                    left++;<br>            }<br>            <br>            <br>            }<br><br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=cce04a65-4b7a-4cf7-a9db-d2259157b250">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[1. 哈希表理论基础]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[vector]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 赎金信</title>
    <link href="/posts/10848/"/>
    <url>/posts/10848/</url>
    
    <content type="html"><![CDATA[<hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=49ada40c-372a-4b11-8d1f-35c9917e32e0">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6. 四数相加II</title>
    <link href="/posts/56281/"/>
    <url>/posts/56281/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第454题四数相加ii"><a class="markdownIt-Anchor" href="#1-第454题四数相加ii"></a> 1 第454题.四数相加II</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣题目链接</a></p><p>给定四个包含整数的数组列表&nbsp;A , B , C , D ,计算有多少个元组 (i, j, k, l)&nbsp;，使得&nbsp;A[i] + B[j] + C[k] + D[l] = 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度&nbsp;N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过&nbsp;2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入:</p><ul><li>A = [ 1, 2]</li><li>B = [-2,-1]</li><li>C = [-1, 2]</li><li>D = [ 0, 2]</li></ul><p>输出:</p><p>2</p><p><strong>解释:</strong></p><p>两个元组如下:</p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题解题步骤：</p><ol><li>首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li><li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li><li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li><li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li><li>最后返回统计值 count 就可以了</li></ol><p>![[6. 四数相加II 2022-08-14 17.20.57.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>{<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a : nums1){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : nums2){<br>                map[a+b]++;<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[map]]">[1]</span></a></sup></span><br>            }<br>        }<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c : nums3){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d: nums4){<br>                <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-c-d) != map.<span class="hljs-built_in">end</span>()){<br>                    count += map[<span class="hljs-number">0</span>-c-d];[^<span class="hljs-number">1</span>]<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> count;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=77c9599b-05e7-4360-a3de-f8d766f09304">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[map]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map</title>
    <link href="/posts/43450/"/>
    <url>/posts/43450/</url>
    
    <content type="html"><![CDATA[<p>有 key 和 value 对应的用 map<br>map 能在最快的时间内, 去查找这个 key 是否在 map<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208121703566.png" alt="|600"></p><p>红黑树可以自动排序<br>std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解</p><p>![[8. 三数之和#^l8megb]]</p><h1 id="1-unordered_map"><a class="markdownIt-Anchor" href="#1-unordered_map"></a> 1 unordered_map</h1><p>key 是主要的元素, value 是附属<br>不需要 key 有序的时候效率最高</p><h2 id="11-操作"><a class="markdownIt-Anchor" href="#11-操作"></a> 1.1 操作</h2><ul><li>插入元素:<ul><li>map.insert(<strong>pair&lt;int, int&gt;</strong>(a, b));</li><li><code>map[key]++</code>  //  存在key则 value 值++, 没有 key 则自动创造 key 在 value 值++<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[6. 四数相加II]]">[1]</span></a></sup></li></ul></li><li>获取元素:<ul><li><code>auto iter = map.find(x);</code>, <code>return iter-&gt;second</code> //  获取第二个元素</li><li><code>map[key]</code> = value // 获取第二个元素</li></ul></li></ul><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=4f623914-706e-4174-b798-c6e8b4ee184c">ob</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[6. 四数相加II]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 两数之和</title>
    <link href="/posts/34993/"/>
    <url>/posts/34993/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1 两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">力扣题目链接</a></p><p>给定一个整数数组 nums&nbsp;和一个目标值 target，请你在该数组中找出和为目标值的那&nbsp;两个&nbsp;整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p><p>所以返回 [0, 1]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p>很明显暴力的解法是两层for循环查找，时间复杂度是O(n^2)。<br>i 查找第一个数, j 查找第二个数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>                <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target &amp;&amp; i != j){<br>                    <span class="hljs-keyword">return</span> {i,j};<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> {};<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-哈希表"><a class="markdownIt-Anchor" href="#22-哈希表"></a> 2.2 哈希表</h2><p>将遍历的数组元素存入 map , 下一次遍历的时候在 map 中查找差值</p><p>![[5. 两数之和 2022-08-13 22.10.31.excalidraw]]</p><p>本题: 我们不仅要知道元素有没有遍历过，还有知道这个元素对应的下标，<br><strong>需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适</strong>。</p><p><strong>这道题目中并不需要key有序，选择std::unordered_map 效率更高！</strong><br>判断元素是否出现，这个元素就要作为key(查找的主要元素作为 key)，有key对应的就是value，value用来存下标。</p><p>map中的存储结构为 {key：数据元素，value：数组元素对应的下标}。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        unordered_map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target -nums[i]); <span class="hljs-comment">// 提前把变量设好, 为了获取 value 值</span><br>            <span class="hljs-keyword">if</span> ( iter != map.<span class="hljs-built_in">end</span>()){<br>                <span class="hljs-keyword">return</span> {iter-&gt;second, i};<br>            }<br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i));<br>        } <br>        <span class="hljs-keyword">return</span> {};<br>        <br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=d64073dd-55d1-4f4b-829a-8680ac0b146e">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关数值要想到的操作</title>
    <link href="/posts/38142/"/>
    <url>/posts/38142/</url>
    
    <content type="html"><![CDATA[<h1 id="1-取各个位数"><a class="markdownIt-Anchor" href="#1-取各个位数"></a> 1 取各个位数</h1><p>取余_数是指整数除法中被除数未被除尽部分<br>eg: 199, 取<strong>其个位(%10</strong>), <s><strong>十位(%100)</strong>, <strong>百位(%1000)</strong></s><br>取十位可让, (199/10) %10</p><p>#疑问<br>![[有关数值要想到的操作 2022-08-13 10.19.03.excalidraw]]</p><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=2d35b970-9351-48dc-a461-bcf79e0d9ff3">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 快乐数</title>
    <link href="/posts/35816/"/>
    <url>/posts/35816/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第202题-快乐数"><a class="markdownIt-Anchor" href="#1-第202题-快乐数"></a> 1 第202题. 快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">力扣题目链接</a></p><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 可以变为&nbsp; 1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>题目中说了会 <strong>无限循环</strong>，那么也就是说<strong>求和的过程中，sum会重复出现</strong>, 重复出现就代表着无法找到 sum = 1</p><p>用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p><p>判断sum是否重复出现就可以使用unordered_set。</p><p>[[有关数值要想到的操作]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span> <span class="hljs-params">(<span class="hljs-type">int</span> n )</span></span>{<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n){ <span class="hljs-comment">// ❓为什么不会死循环 💡 n &lt; 1 即为 0,<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]]">[1]</span></a></sup></span><br>                sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>                n /= <span class="hljs-number">10</span>;<br>            }<br>            <span class="hljs-keyword">return</span> sum;<br>        }<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            }<br>            <span class="hljs-keyword">if</span>(set.<span class="hljs-built_in">find</span>(sum) != set.<span class="hljs-built_in">end</span>()){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                set.<span class="hljs-built_in">insert</span>(sum);<br>            }<br>            n = sum; <span class="hljs-comment">// 更新 sum</span><br>        }<br><br>    }<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="obsidian://advanced-uri?vault=myblog&amp;uid=84d58a22-ffee-4e83-8c37-a0bd4cedbcb5">ob</a><br><a href="https://www.programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 两个数组的交集</title>
    <link href="/posts/13727/"/>
    <url>/posts/13727/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两个数组的交集"><a class="markdownIt-Anchor" href="#1-两个数组的交集"></a> 1 两个数组的交集</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣题目链接</a></p><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p><img src="https://img-blog.csdnimg.cn/20200818193523911.png" alt="349. 两个数组的交集"></p><p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>![[3. 两个数组的交集 2022-08-12 18.44.19.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>{<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; result_set;<br>        unordered_set &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">nums_set</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(nums2[i]) != nums_set.<span class="hljs-built_in">end</span>()){ <span class="hljs-comment">// ❓为什么是!=呢 💡如果找不到则返回 num_set.end()</span><br>                result_set.<span class="hljs-built_in">insert</span>(nums2[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector]]">[1]</span></a></sup></span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html#_349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[vector]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有关字符要想到的操作</title>
    <link href="/posts/30423/"/>
    <url>/posts/30423/</url>
    
    <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObsgS7hxap8HZGP55ZRbToXQ" --> <h1 id="1-取到字母字符对应数组下标值"><a class="markdownIt-Anchor" href="#1-取到字母字符对应数组下标值"></a> 1 取到字母字符对应数组下标值 ::</h1><p>![[c++中 - ‘0’ 以及 -‘a’ 的相减操作解释#1 取到字母字符对应的数字：a→0，b→1]]</p><!-- basicblock-end --><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 有效的字母异位词</title>
    <link href="/posts/33343/"/>
    <url>/posts/33343/</url>
    
    <content type="html"><![CDATA[<h1 id="1-242有效的字母异位词"><a class="markdownIt-Anchor" href="#1-242有效的字母异位词"></a> 1 242.有效的字母异位词</h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例&nbsp;1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><p>#card</p><!-- basicblock-start oid="ObsBzRRXarQbR2XJrzGJdVyg" --> <p>字母异位词::<br>由相同的字母组成, 但位置可以不同</p><!-- basicblock-end --><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>将 s 的字母的对应的下标值变为 1 存入哈希表中(数组),<br>通过 t 对应的下标值在减 1 , 看数组是否全为0</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1govxyg83bng30ds09ob29.gif" alt="242.有效的字母异位词"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[容器的使用]]<br>#疑问<br>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>{<br>        <span class="hljs-type">int</span> hash [<span class="hljs-number">26</span>] = {<span class="hljs-number">0</span>}; <span class="hljs-comment">// ❗️0 得有大括号</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++){<br>            hash[s[i] - <span class="hljs-string">'a'</span>]++; <br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; t.<span class="hljs-built_in">size</span>(); j++){<br>            hash[t[j] - <span class="hljs-string">'a'</span>]--; <span class="hljs-comment">// ❗️不是 s 哦, 是 t 的字符串</span><br>        }<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++){ <span class="hljs-comment">// ❓为什么不能用i &lt; hash.size()💡还是用提前定义好变量, 思想:用空间换时间</span><br>            <span class="hljs-keyword">if</span> (hash[i] != <span class="hljs-number">0</span>){<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html#_242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 哈希表理论基础</title>
    <link href="/posts/3799/"/>
    <url>/posts/3799/</url>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a class="markdownIt-Anchor" href="#1-定义"></a> 1 定义</h1><p><strong>哈希表是根据关键码的值而直接进行访问的数据结构</strong></p><p><strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><p>其实数组就是一张哈希表。<br>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210104234805168.png" alt="哈希表1|600"></p><p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><h1 id="2-哈希函数"><a class="markdownIt-Anchor" href="#2-哈希函数"></a> 2 哈希函数</h1><p><img src="https://img-blog.csdnimg.cn/2021010423484818.png" alt="哈希表2|600"><br>通过 hashCode 将名字转换为数值, 这样就把学生名字映射为哈希表的索引数字了<br>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p><p>如果学生的数量大于哈希表的大小, 会出现几位同学同时映射到哈希表的同一个索引下标位置<br>就此引出哈希碰撞</p><h1 id="3-哈希碰撞"><a class="markdownIt-Anchor" href="#3-哈希碰撞"></a> 3 哈希碰撞</h1><p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。</p><p><img src="https://img-blog.csdnimg.cn/2021010423494884.png" alt="哈希表3|600"><br>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p><h2 id="31-拉链法"><a class="markdownIt-Anchor" href="#31-拉链法"></a> 3.1 拉链法</h2><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被<strong>存储在链表</strong>中。<br>这样我们就可以通过索引找到小李和小王了<br><img src="https://img-blog.csdnimg.cn/20210104235015226.png" alt="哈希表4|600"></p><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p><h2 id="32-线性探测法"><a class="markdownIt-Anchor" href="#32-线性探测法"></a> 3.2 线性探测法</h2><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210104235109950.png" alt="哈希表5|500"></p><h1 id="4-常见的三种哈希结构"><a class="markdownIt-Anchor" href="#4-常见的三种哈希结构"></a> 4 常见的三种哈希结构</h1><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map(映射)</li></ul><p>这里数组就没啥可说的了，我们来看一下set。</p><h2 id="41-array"><a class="markdownIt-Anchor" href="#41-array"></a> 4.1 array</h2><p>数据范围不大的时候用数组, 能用数组都用数组<br>局限: 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</p><h2 id="42-set"><a class="markdownIt-Anchor" href="#42-set"></a> 4.2 [[set]]</h2><h2 id="43-map"><a class="markdownIt-Anchor" href="#43-map"></a> 4.3 [[map]]</h2><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8. 环形链表II</title>
    <link href="/posts/51653/"/>
    <url>/posts/51653/</url>
    
    <content type="html"><![CDATA[<h1 id="1-42环形链表ii"><a class="markdownIt-Anchor" href="#1-42环形链表ii"></a> 1 42.环形链表II</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣题目链接</a></p><p>题意： 给定一个链表，返回链表开始入环的第一个节点。&nbsp;如果链表无环，则返回&nbsp;null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><p><img src="https://img-blog.csdnimg.cn/20200816110112704.png" alt="循环链表|600"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>考察点:</p><ol><li>判断链表是否有环</li><li>如果有环, 如何找到这个环的入口</li></ol><h2 id="21-判断是否有环"><a class="markdownIt-Anchor" href="#21-判断是否有环"></a> 2.1 判断是否有环</h2><p><strong>定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</strong></p><p>原因:</p><ol><li><strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的</strong>。</li><li>fast是走两步，slow是走一步，<strong>其实相对于slow来说，fast是一个节点一个节点的靠近slow的</strong>，所以fast一定可以和slow重合。<br><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo4xglk9yg30fs0b6u0x.gif" alt="141.环形链表"></li></ol><h2 id="22-如何找入口"><a class="markdownIt-Anchor" href="#22-如何找入口"></a> 2.2 如何找入口</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif" alt="142.环形链表II（求入口）"><br>#card</p><!-- basicblock-start oid="ObsIFP1PzYnn3E1b6jmD9yRz" --> <p>如何判断环型入口::<br>![[8. 环形链表II 2022-08-12 10.28.07.excalidraw]]</p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>{<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>){<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == slow){<br>                ListNode* index1 = fast; <span class="hljs-comment">// 定义相遇节点</span><br>                ListNode* index2 = head; <span class="hljs-comment">// 定义头结点</span><br>            <span class="hljs-keyword">while</span>(index1 != index2){ <span class="hljs-comment">// 💡让他俩同时出发,相遇时即为入口❗️index1 != NULL &amp;&amp; index1-&gt;next != NULL</span><br>            index1 = index1-&gt;next;  <br>            index2 = index2-&gt;next;<br>            }<br>            <span class="hljs-keyword">return</span> index1;<br>    }<br>}<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7. 链表相交</title>
    <link href="/posts/8965/"/>
    <url>/posts/8965/</url>
    
    <content type="html"><![CDATA[<h1 id="1-面试题-0207-链表相交"><a class="markdownIt-Anchor" href="#1-面试题-0207-链表相交"></a> 1 面试题 02.07. 链表相交</h1><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣题目链接</a></p><p>给你两个单链表的头节点&nbsp;headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png" alt=""></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>示例 1：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png" alt=""></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>![[7. 链表相交 2022-08-12 16.32.24.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>{<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lenB = <span class="hljs-number">0</span>;<br>        ListNode* curA = headA; <span class="hljs-comment">// 操作 headA</span><br>        ListNode* curB = headB;<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 获取长度</span><br>            curA = curA-&gt;next;<br>            lenA++;<br>        }<br>        <span class="hljs-keyword">while</span>(curB != <span class="hljs-literal">NULL</span>){ <br>            curB = curB-&gt;next;<br>            lenB++;<br>        }<br>        curA = headA;         <span class="hljs-comment">// 重新操作 headA</span><br>        curB = headB;<br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA){     <span class="hljs-comment">// 固定长度长的</span><br>            <span class="hljs-built_in">swap</span>(curA, curB);<br>            <span class="hljs-built_in">swap</span>(lenA, lenB);<br>        }<br>        <span class="hljs-type">int</span> gap = lenA - lenB; <span class="hljs-comment">// 获取差值</span><br>        <span class="hljs-keyword">while</span>(gap--){          <span class="hljs-comment">// 长短对齐 </span><br>            curA = curA-&gt;next;<br>        }<br>        <span class="hljs-keyword">while</span>(curA != <span class="hljs-literal">NULL</span>){   <span class="hljs-comment">// 寻找相同</span><br>            <span class="hljs-keyword">if</span>(curA == curB){<br>                <span class="hljs-keyword">return</span> curA;<br>            }<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.删除链表的倒数第N个节点</title>
    <link href="/posts/26499/"/>
    <url>/posts/26499/</url>
    
    <content type="html"><![CDATA[<h1 id="1-19删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#1-19删除链表的倒数第n个节点"></a> 1 19.删除链表的倒数第N个节点</h1><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣题目链接</a></p><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>进阶：你能尝试使用一趟扫描实现吗？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210510085957392.png" alt="19.删除链表的倒数第N个节点"></p><p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：</p><p>输入：head = [1], n = 1 输出：[]</p><p>示例 3：<br>输入：head = [1,2], n = 1 输出：[1]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>问题关键: 如何找到倒数第 n 个节点的前一个节点</p><p>用双指针:<br>让fast移动n+1步，然后让fast和slow同时移动，直到fast指向链表末尾, 此时 slow 就指向了要删除结点的前一个节点</p><p>![[6.删除链表的倒数第N个节点 2022-08-12 09.22.22.excalidraw|1500]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* fast = dummyHead;<br>        ListNode* slow = dummyHead; <br>        n++;<br>        <span class="hljs-keyword">while</span> (n-- &amp;&amp; fast != <span class="hljs-literal">nullptr</span>){<br>            fast = fast-&gt;next;<br>        }<br>        <span class="hljs-comment">// 如果在上面不用 n++, 在这里多写一个fast-&gt;next ,让 fast 多走一步</span><br>        <span class="hljs-comment">// 结果: n 若为 1000, 上面的 fast 就已经是空了, 而上一行让他多走一步就是操作空指针了</span><br>        <span class="hljs-comment">// 所以安全起见先 n++. 💡另外一个思路: 用空间换时间, 提前都把变量定义好</span><br>        <br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>){<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        }<br>        ListNode* temp = slow-&gt;next;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>        <br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 两两交换链表中的节点</title>
    <link href="/posts/58812/"/>
    <url>/posts/58812/</url>
    
    <content type="html"><![CDATA[<h2 id="01-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#01-两两交换链表中的节点"></a> 0.1 两两交换链表中的节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣题目链接</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg" alt="24.两两交换链表中的节点-题意|500"></p><h1 id="1-思路"><a class="markdownIt-Anchor" href="#1-思路"></a> 1 思路</h1><p>使用虚拟头结点</p><p>要想交换两个节点, 首先要把 cur 指针指向两节点的前一个节点</p><p>![[5. 两两交换链表中的节点 2022-08-11 23.49.26.excalidraw]]<br>有关 whil 终止条件的判断<br>![[5. 两两交换链表中的节点 2022-08-12 00.20.24.excalidraw]]</p><h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❗️dummyHead 前需要 ListNode*</span><br>        dummyHead-&gt;next = head;<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next!=<span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>){ <br>        <span class="hljs-comment">// 💡如果是链表是偶数,最后cur跑到的下一位是 null,如果是奇数位,cur-&gt;next-&gt;next是 null. </span><br>        <span class="hljs-comment">// 两者的位置不能换,如果把 cur-&gt;next-&gt;next!=nullptr, 有可能忽视 cur-&gt;next!=nullptr 的情况</span><br><br>            ListNode* temp1 = cur-&gt;next;<br>            ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next;<br><br>            cur-&gt;next = cur-&gt;next-&gt;next; <span class="hljs-comment">// ❗️不需要-&gt;val,cur-&gt;next-&gt;next-&gt;val 💡cur 连到 2</span><br>            cur-&gt;next-&gt;next = temp1;<span class="hljs-comment">// 💡2 连到 1</span><br>            temp1-&gt;next= temp2;<span class="hljs-comment">// ❗️1 连到 3,不能用 </span><br><br>            cur = cur-&gt;next-&gt;next; <span class="hljs-comment">// 移动两位 准备下一轮交换</span><br>        }<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 翻转链表</title>
    <link href="/posts/32071/"/>
    <url>/posts/32071/</url>
    
    <content type="html"><![CDATA[<h1 id="1-206反转链表"><a class="markdownIt-Anchor" href="#1-206反转链表"></a> 1 206.反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>定义一个 cur 指针指向头结点<br>定义一个 pre 指针初始化为 null<br>把 cur-&gt;next的指针用 tmp 保存一下</p><ol><li>改变方向<ol><li>cur-&gt;next =  pre;</li></ol></li><li>移动下一个位置<ol><li>pre = cur;</li><li>cur = tmp<br>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。</li></ol></li></ol><p>![[4. 翻转链表 2022-08-11 21.51.33.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><h2 id="31-双指针"><a class="markdownIt-Anchor" href="#31-双指针"></a> 3.1 双指针</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* tmp;<br><br>        <span class="hljs-keyword">while</span>(cur){<br>            tmp = cur-&gt;next; <span class="hljs-comment">// ❗️cur-&gt;next = tmp; 目的要把 cur-&gt;next 指针先保存下来,而不是改变他</span><br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        }<br>        <span class="hljs-keyword">return</span> pre;<br>    <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-递归写法"><a class="markdownIt-Anchor" href="#32-递归写法"></a> 3.2 递归写法</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* pre, ListNode* cur)</span></span>{<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> pre;<br>        ListNode* tmp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(cur, tmp);<span class="hljs-comment">// ❗️前边还有 return, 把参数返回给下一层</span><br>    }<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-literal">nullptr</span>, head);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3. 设计链表</title>
    <link href="/posts/40651/"/>
    <url>/posts/40651/</url>
    
    <content type="html"><![CDATA[<h1 id="1-707设计链表"><a class="markdownIt-Anchor" href="#1-707设计链表"></a> 1 707.设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p><p>题意：</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第&nbsp;index&nbsp;个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为&nbsp;val&nbsp;的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为&nbsp;val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第&nbsp;index&nbsp;个节点<strong>之前</strong>添加值为&nbsp;val&nbsp; 的节点。如果&nbsp;index&nbsp;等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引&nbsp;index 有效，则删除链表中的第&nbsp;index 个节点。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200814200558953.png" alt="707示例"></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>这道题目设计链表的五个接口：</p><ul><li>获取链表第index个节点的数值</li><li>在链表的最前面插入一个节点</li><li>在链表的最后面插入一个节点</li><li>在链表第index个节点前面插入一个节点</li><li>删除链表的第index个节点</li></ul><p>![[1.  链表理论基础#4 链表的操作]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> {<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span>{<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>){}<br>    };<br><br>    <span class="hljs-built_in">MyLinkedList</span>() {<br>        _dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// ❗️不需要用 linkedHead* _dummyHead</span><br>        _size = <span class="hljs-number">0</span>; <span class="hljs-comment">// ❓</span><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>        <span class="hljs-keyword">if</span> (index &gt; (_size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>){ <span class="hljs-comment">// ❗️不懂_size-1, size 为链表的长度</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        }<br>        LinkedNode* cur = _dummyHead-&gt;next; <span class="hljs-comment">// 💡直接指向真实结点的第一个节点</span><br>        <span class="hljs-keyword">while</span>(index--){<br>            cur = cur-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = _dummyHead-&gt;next;<span class="hljs-comment">// 💡虚拟节点的后一个节点才是第一个真实节点</span><br>        _dummyHead-&gt;next = newNode;<br>        _size++;<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>{<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">// 添加节点连接后一个节点</span><br>        LinkedNode* cur = _dummyHead; <span class="hljs-comment">// 💡等于_dummyHead-&gt;next也无所谓,目的是找最后一个节点</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){ <span class="hljs-comment">// 找到最后一个节点</span><br>            cur = cur-&gt;next;<br>        }<br>        cur-&gt;next = newNode;<br>        _size++; <span class="hljs-comment">// ❗️不要忘了总长度+1</span><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>{ <span class="hljs-comment">// 是在第 index 前插入一个节点</span><br>        <span class="hljs-keyword">if</span> (index &gt; _size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead; <span class="hljs-comment">// 💡是在第 index 前插入一个节点,所以找的是 index 前的节点,如果是 dummyHead-&gt;next, 就找到了第 Index 的位置</span><br>        <span class="hljs-keyword">while</span>(index--){ <span class="hljs-comment">// 找到第 index 前号元素<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[while 循环]]">[1]</span></a></sup></span><br>            cur = cur-&gt;next;<br>        }<br>        newNode-&gt;next = cur-&gt;next;<span class="hljs-comment">// ❗️注意不是 cur-&gt;next-&gt;next</span><br>        cur-&gt;next = newNode;<br>        _size++;<br><br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>{<br>          <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">return</span>;<br>        }<br>        LinkedNode* cur = _dummyHead;<span class="hljs-comment">// ❓</span><br>        <span class="hljs-keyword">while</span>(index--) {<br>            cur = cur -&gt;next;<br>        }<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        _size--;<br>    }<br><br>    <br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span> </span>{<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span>) {<br>            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;<br>            cur = cur-&gt;next;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">private</span>: <span class="hljs-comment">// 放到 public 上面则编译不通过</span><br>    <span class="hljs-type">int</span> _size;<br>    LinkedNode* _dummyHead;<br><br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[while 循环]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. 移除链表元素</title>
    <link href="/posts/25411/"/>
    <url>/posts/25411/</url>
    
    <content type="html"><![CDATA[<h1 id="1-203移除链表元素"><a class="markdownIt-Anchor" href="#1-203移除链表元素"></a> 1 203.移除链表元素</h1><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣题目链接</a></p><p>题意：删除链表中等于给定值 val 的所有节点。</p><p>示例 1：<br>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]</p><p>示例 2：<br>输入：head = [], val = 1<br>输出：[]</p><p>示例 3：<br>输入：head = [7,7,7,7], val = 7<br>输出：[]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>删除普通元素<br>使用 C, C++语言记得要清理删除的内存<br><img src="https://img-blog.csdnimg.cn/20210316095351161.png" alt="203_链表删除元素1|600"></p><p>删除头结点</p><ul><li><strong>设置一个虚拟头结点在进行删除操作。</strong>(不需要额外的操作)</li><li>直接使用原来的链表来进行删除操作。(需要额外的操作)</li></ul><p>![[2. 移除链表元素 2022-08-11 11.00.43.excalidraw|1500]]</p><h2 id="21-总结"><a class="markdownIt-Anchor" href="#21-总结"></a> 2.1 总结</h2><p>#card</p><!-- basicblock-start oid="ObsSRgRVqGrwJjsLLBcm71oT" --> <p>如何设置一个虚拟头结点来操持一个统一的删除操作::</p><ol><li>先创建一个表头链表 dummyhead : <code>new ListNode(0</code>); <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[C++ new的用法]]">[1]</span></a></sup></li><li>在把 head 链表接到dummyhead 上 : dummyHead -&gt; next = head</li><li>创建一个新 cur 链表, 以后在 cur 链表上操作</li></ol><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208111134829.gif" alt="|1100"></p><!-- basicblock-end --><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>{<br>        ListNode* dummyHead  = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <br>        dummyHead-&gt;next = head; <br>        ListNode* cur  = dummyHead; <span class="hljs-comment">// 💡用了一个指针指向了 dummyHead 用来操作 dummyHead 中元素</span><br>        <span class="hljs-comment">// ❗️不能直接用 dummyHead-&gt;next, 因为只要就把 dummyHead 的链表改变了</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>){<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == val){<span class="hljs-comment">// ❗️是cur-&gt;next-&gt;val,不是 cur-&gt;next</span><br>                ListNode* temp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> temp;<span class="hljs-comment">// 💡删除的是 dummyHead 的元素,因为操作的是指针</span><br>            }<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;next;<span class="hljs-comment">// 将下一个元素做为头结点</span><br><br>        } <br>        <span class="hljs-comment">// return cur // ❗️因为 cur 的链表是越来越小的</span><br>        head = dummyHead-&gt;next;<span class="hljs-comment">// 💡因为dummyHead 的一个元素是创造出来的</span><br>        <span class="hljs-keyword">delete</span> dummyHead;<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208111219807.gif" alt=""></p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[C++ new的用法]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.  链表理论基础</title>
    <link href="/posts/22854/"/>
    <url>/posts/22854/</url>
    
    <content type="html"><![CDATA[<p><strong>链表由数据域和指针域组成</strong></p><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p><p>链接的入口节点称为链表的头结点也就是head。</p><h1 id="1-链表的类型"><a class="markdownIt-Anchor" href="#1-链表的类型"></a> 1 链表的类型</h1><p>![[1.  链表理论基础 2022-08-11 09.54.44.excalidraw]]</p><h1 id="2-链表的存储方式"><a class="markdownIt-Anchor" href="#2-链表的存储方式"></a> 2 链表的存储方式</h1><p>数组是在内存中是连续分布的，链表是随机分布的, 他们通过指针来连接彼此,<br>散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。<br>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200806194613920.png" alt="链表3"><br>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p><h1 id="3-链表的定义"><a class="markdownIt-Anchor" href="#3-链表的定义"></a> 3 链表的定义</h1><p>在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。</p><p>而在面试的时候，一旦要自己手写链表，就写的错漏百出</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> {<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) {}  <span class="hljs-comment">// 自己节点的构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure><p>不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。<br>但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：</p><p>通过自己定义构造函数初始化节点：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></tbody></table></figure><p>使用默认构造函数初始化节点：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></tbody></table></figure><p>所<strong>以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</strong></p><h1 id="4-链表的操作"><a class="markdownIt-Anchor" href="#4-链表的操作"></a> 4 链表的操作</h1><h2 id="41-删除结点"><a class="markdownIt-Anchor" href="#41-删除结点"></a> 4.1 删除结点</h2><p><img src="https://img-blog.csdnimg.cn/20200806195114541.png" alt="链表-删除节点"><br>将 C 的 next 指针指向 E💡将要删除的元素的一个 next 指针指向下下个元素<br>时间复杂度: O(n)💡如果删除最后一个元素则需要从头结点查找到第 n - 1 个元素修改其 next 指针</p><p>D 节点依然留在内存里<br>在C++里最好是再手动释放这个D节点，释放这块内存。<br>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p><h2 id="42-添加节点"><a class="markdownIt-Anchor" href="#42-添加节点"></a> 4.2 添加节点</h2><p>![[1.  链表理论基础 2022-08-11 18.07.26.excalidraw]]<br>时间复杂度 O(1), 链表直接能够通过指针查找到元素. 相当于数组通过下标直接找到元素, 找到元素的操作只进行一次所以是 O(1)的时间复杂度</p><h2 id="43-性能分析总结"><a class="markdownIt-Anchor" href="#43-性能分析总结"></a> 4.3 性能分析总结</h2><p><img src="https://img-blog.csdnimg.cn/20200806195200276.png" alt="链表-链表与数据性能对比"></p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>链表</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>7. 总结篇</title>
    <link href="/posts/60314/"/>
    <url>/posts/60314/</url>
    
    <content type="html"><![CDATA[<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt=""></p><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>循环不变量原则</title>
    <link href="/posts/53061/"/>
    <url>/posts/53061/</url>
    
    <content type="html"><![CDATA[<p>循环不变量, 不变量: 每次处理的规则<br>[[2.  二分查找]] : 每次 for 循环中的处理区间都要按照原区间的方式, 那么左闭右闭, 那么左闭右开</p><blockquote><p>在循环中坚持对区间的定义</p></blockquote><p>[[6.螺旋矩阵II]]: 每次赋值的数量: 从起始元素到最后一个元素的前一个元素. 属于是左闭右开类型</p><p>防守打法防守打法发大水发fsadf 地方撒</p><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.螺旋矩阵II</title>
    <link href="/posts/2078/"/>
    <url>/posts/2078/</url>
    
    <content type="html"><![CDATA[<h1 id="1-59螺旋矩阵ii"><a class="markdownIt-Anchor" href="#1-59螺旋矩阵ii"></a> 1 59.螺旋矩阵II</h1><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣题目链接</a></p><p>给定一个正整数&nbsp;n，生成一个包含 1 到&nbsp;n^2&nbsp;所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p>如果输入 4 , 则输出 4 * 4的矩阵, 输出的是正方形的螺旋矩阵.</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>大家还记得我们在这篇文章<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html">数组：每次遇到二分法，都是一看就会，一写就废</a><br>中讲解了二分法，提到如果要写出正确的二分法一定要坚持[[循环不变量原则]]。<br>循环不变量:  不变量是我们队每条边的一个处理规则</p><p>而求解本题依然是要坚持循环不变量原则。<br>不变量: <strong>每次只处理第一个元素到最后元素的前一个</strong></p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。<br>![[6.螺旋矩阵II 2022-08-10 16.27.14.excalidraw]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><pre class="highlight"><code class="c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">generateMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>))</span></span>;        <span class="hljs-keyword">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid  = n / <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来控制长度</span>        <span class="hljs-keyword">int</span> loop  = n / <span class="hljs-number">2</span>;         <span class="hljs-keyword">while</span>(loop--){            <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// 设置成全局变量, 因为下面也要用</span>            <span class="hljs-keyword">int</span> j;             <span class="hljs-keyword">for</span>(j = startx; j &lt; n - offset; j++){                res[startx][j] = count;<span class="hljs-comment">// 可以成一行 count++</span>                count++;             }            <span class="hljs-keyword">for</span>(i = starty; i&lt; n - offset; i++){                res[i][j] = count++;             }            <span class="hljs-keyword">for</span>(; j &gt; startx; j--){<span class="hljs-comment">// 要大于 startx 而不是 0, 因为下一层循环还要用</span>                res[i][j] = count++;             }             <span class="hljs-keyword">for</span>(; i &gt; starty; i--){                res[i][j] = count++;             }            startx++;             starty++;             offset += <span class="hljs-number">1</span>;         }         <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) {            res[mid][mid] = count;        }        <span class="hljs-keyword">return</span> res;    }```--- **参考资料**</code></pre>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双指针法总述</title>
    <link href="/posts/57173/"/>
    <url>/posts/57173/</url>
    
    <content type="html"><![CDATA[<ul><li>通过快慢指针操作</li></ul><ol><li>快指针找新数组的元素</li><li>慢指针为新数组下标, 快指针找到元素后把值赋值慢指针(下标)[[4. 有序数组的平方]] [[3. 移除元素]]</li></ol><ul><li>通过双指针构建滑动窗口</li></ul><ol><li>起始指针 i , 终止指针 j, 通过操作 i 与 j 之间值来达到所需目的. eg: 求窗口之间的元素和 [[5. 长度最小的子数组]]</li></ol><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>双指针法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 长度最小的子数组</title>
    <link href="/posts/31461/"/>
    <url>/posts/31461/</url>
    
    <content type="html"><![CDATA[<h1 id="1-209长度最小的子数组"><a class="markdownIt-Anchor" href="#1-209长度最小的子数组"></a> 1 209.长度最小的子数组</h1><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a></p><p>给定一个含有&nbsp;n&nbsp;个正整数的数组和一个正整数&nbsp;s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组&nbsp;[4,3]&nbsp;是该条件下的长度最小的子数组。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p>两个 for 循环不断寻找符合条件的子序列, 时间复杂度: O(n^2), 空间复杂度 O(1)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT32_MAX; <span class="hljs-comment">// 最终的结果</span><br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的数值之和</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 子序列的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 设置子序列起点为i</span><br>            sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) { <span class="hljs-comment">// 设置子序列终止位置为j</span><br>                sum += nums[j];<br>                <span class="hljs-keyword">if</span> (sum &gt;= s) { <span class="hljs-comment">// 一旦发现子序列和超过了s，更新result</span><br>                    subLength = j - i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 取子序列的长度</span><br>                    result = result &lt; subLength ? result : subLength;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span><br>                }<br>            }<br>        }<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="22-滑动窗口"><a class="markdownIt-Anchor" href="#22-滑动窗口"></a> 2.2 滑动窗口</h2><p>滑动窗口的本质还是双指针, 因为只取起始指针和终止指针范围内的值,所以称为滑动窗口</p><p>滑动窗口: <strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>只用一个 for 循环解决暴力循环中两个 for 循环的操作</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。<br>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？<br>此时难免再次陷入 暴力解法的怪圈。<br>所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。</p><p>s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：<br><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p><p>本题中实现滑动窗口，主要确定如下三点：<br>问:</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？<br>答:</li><li>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li><li>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</li><li>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209|600"></p><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)</strong></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++){<br>            sum += nums[j];<br>            <span class="hljs-keyword">while</span>(sum &gt;= target){<br>                subLength = j - i + <span class="hljs-number">1</span>;<br>                result = subLength &lt; result ? subLength : result;<br>                sum -= nums[i]; <span class="hljs-comment">// 缩短一个数之后的和</span><br>                i++; <span class="hljs-comment">// 缩短区间,💡i不断的++,直至能sum &lt; target 跳出 while 循环</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result == INT_MAX ? <span class="hljs-number">0</span> : result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>容器的使用</title>
    <link href="/posts/21713/"/>
    <url>/posts/21713/</url>
    
    <content type="html"><![CDATA[<h1 id="1-vector"><a class="markdownIt-Anchor" href="#1-vector"></a> 1 vector</h1><p>![[vector#1 1 初始化]]</p><h1 id="2-array"><a class="markdownIt-Anchor" href="#2-array"></a> 2 array</h1><p>int arrayName [arraySize] :<br>其中 arraySize <strong>不能是变量</strong>,必须是整型常数(如1 0 )或const值,也可以是常量表达式(如8 * sizeof ( int)</p><p>eg : int a [10] = {0}; // ❗️不是一个数的一个要有大括号</p><hr><p><strong>参考资料</strong>—</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 有序数组的平方</title>
    <link href="/posts/34285/"/>
    <url>/posts/34285/</url>
    
    <content type="html"><![CDATA[<h1 id="1-977有序数组的平方"><a class="markdownIt-Anchor" href="#1-977有序数组的平方"></a> 1 977.有序数组的平方</h1><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣题目链接</a></p><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p>每个数平方之后，排个序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>{<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++) {<br>            A[i] *= A[i];<br>        }<br>        <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 快速排序</span><br>        <span class="hljs-keyword">return</span> A;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>for 循环中乘了 n 次, 时间复杂度为 O(n), sort 快速排序<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[时间复杂度分析]]">[1]</span></a></sup>O(nlogn), 两个函数取大者,总体的时间复杂度为 O(nlogn)</p><blockquote><p>这个时间复杂度本质是 O(n + nlogn)， 取完大头为 O(nlogn)</p></blockquote><h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法</h2><p>数组有序,数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>用两个指针指向头尾, 逐步向中间靠拢, 不断的寻找: <code>数组元素平方的第一大,</code> <code>第二大</code>, …<br>因为每次找的是最大值, 所以结果集中,从后往前赋值. 因为题目要求返回的是递增数组</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt=""></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[容器的使用]]</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">sortedSquares</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> {<br>        <span class="hljs-comment">// int i = 0;</span><br>        <span class="hljs-comment">// int j = nums.size() - 1;</span><br>        <span class="hljs-comment">//💡 i 和 j 是要不断循环动的,要写在 for 循环中</span><br>    <br>        <span class="hljs-type">int</span> k = nums.size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">result</span><span class="hljs-params">(k+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j = nums.size()<span class="hljs-number">-1</span>; i &lt;= j; ){ <span class="hljs-comment">// 要在元素平方的大小,控制 i,j 的移动</span><br>            <span class="hljs-keyword">if</span>(nums[i] * nums[i] &gt; nums[j] * nums[j] ){<br>                result[k] = nums[i]*nums[i];<br>                k--;<span class="hljs-comment">// 以后要更新结果集的前一个数了,可以在上边直接写成 result[k--]</span><br>                i++;<br>            }<br>            <span class="hljs-keyword">else</span>{<br>                result[k] = nums[j]*nums[j];<br>                k--;<br>                j--;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[时间复杂度分析]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 移除元素</title>
    <link href="/posts/37506/"/>
    <url>/posts/37506/</url>
    
    <content type="html"><![CDATA[<h1 id="1-移除元素"><a class="markdownIt-Anchor" href="#1-移除元素"></a> 1 移除元素</h1><p><a href="https://leetcode.cn/problems/remove-element/">力扣题目链接</a></p><p>给你一个数组 nums&nbsp;和一个值 val，你需要 原地 移除所有数值等于&nbsp;val&nbsp;的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例&nbsp;2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>#card</p><!-- basicblock-start oid="ObsQdeRr1Pcsq043uh3NKoQm" --> <p>为什么数组元素不能删除? ::</p><ul><li>数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。</li><li>C++中vector和array的区别一定要弄清楚，vector的底层实现是array，封装后使用更友好。[[vector]]</li></ul><!-- basicblock-end --><h2 id="21-暴力解法"><a class="markdownIt-Anchor" href="#21-暴力解法"></a> 2.1 暴力解法</h2><p><strong>发现需要移除的元素,就将数组集体向前移动一位</strong><br>两层 for 循环, 一个遍历数组,一个更新数组</p><p>时间复杂度: O(n^2) : 第一层for 循环找 n 次, 第二层 for 循环更新n 次, 总时间复杂度为 O(n^2)<br>空间复杂度:O(1): 没有新增空间</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif" alt="27.移除元素-暴力解法"></p><h2 id="22-双指针法"><a class="markdownIt-Anchor" href="#22-双指针法"></a> 2.2 双指针法</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p>快指针: 寻找新数组的元素 (查找 n 次, 即 O(n)的时间复杂度)<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[1.  链表理论基础#4 3 性能分析]]">[1]</span></a></sup><br>慢指针: 新数组的下标值<br>总结: 将快指针或者的元素赋给, 慢指针的所对应的下标值</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>{<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++){ <span class="hljs-comment">// 类似 int i ,i在不断的跑起来</span><br>            <span class="hljs-keyword">if</span>(nums[fastIndex] != val){<br>                nums[slowIndex] = nums[fastIndex]; <span class="hljs-comment">// 给新数组的下标赋值</span><br>                slowIndex++; <span class="hljs-comment">// 下次更新下一个位置</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> slowIndex;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[1.  链表理论基础#4 3 性能分析]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 二分查找</title>
    <link href="/posts/42878/"/>
    <url>/posts/42878/</url>
    
    <content type="html"><![CDATA[<h1 id="1-704二分查找"><a class="markdownIt-Anchor" href="#1-704二分查找"></a> 1 704二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/">力扣题目链接</a></p><p>给定一个&nbsp;n&nbsp;个元素有序的（升序）整型数组&nbsp;nums 和一个目标值&nbsp;target &nbsp;，写一个函数搜索&nbsp;nums&nbsp;中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight tap"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [-1,0,3,5,9,12], target =<span class="hljs-number"> 9 </span>    <br>输出:<span class="hljs-number"> 4 </span>      <br>解释:<span class="hljs-number"> 9 </span>出现在 nums 中并且下标为<span class="hljs-number"> 4 </span>    <br></code></pre></td></tr></tbody></table></figure><p>示例&nbsp;2:</p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="hljs-section">输出: -1        </span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1        </span><br></code></pre></td></tr></tbody></table></figure><p>提示：</p><ul><li>你可以假设 nums&nbsp;中的所有元素是不重复的。</li><li>n&nbsp;将在&nbsp;[1, 10000]之间。</li><li>nums&nbsp;的每个元素都将在&nbsp;[-9999, 9999]之间。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>二分法使用的前提</p><ol><li>有序数组<ol><li>能够循环在左右区间内查找</li></ol></li><li>无重复的元素<ol><li>有重复的元素返回的下标不唯 1,</li></ol></li></ol><p>区间的定义决定了二分法的代码怎么写,<br><strong>记住一个原则更新区间端点的时候要保持同步,</strong></p><ul><li>左闭右闭要一直保持左闭右闭</li><li>左闭右开要一直保持左闭右开</li></ul><h2 id="21-数组为左闭右闭区间-a-g"><a class="markdownIt-Anchor" href="#21-数组为左闭右闭区间-a-g"></a> 2.1 数组为左闭右闭区间: [a, … ,g]</h2><p>也就是target 在一个[left, right]数组中,left 可能等于 right</p><p>![[二分查找 2022-08-08 12.08.05.excalidraw|1500]]</p><p><strong>定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) ,right 赋值middle - 1，因为当前这个nums[middle]一定不是target(已经大于了,当然不是) ，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><h2 id="22-数组为左闭右开"><a class="markdownIt-Anchor" href="#22-数组为左闭右开"></a> 2.2 数组为左闭右开</h2><p>target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li><p>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</p></li><li><p>if (nums[middle] &gt; target) right 更新为 middle，因为是左闭右开区间,target 取不到 middle ,最多取到 middle 前一个值 ,因为 [left, middle)</p></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>左闭右闭编译已通过,💡表示出错的地方</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right){<br>            <span class="hljs-type">int</span> middle =  left + (right - left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//💡 middle 要不断的更新所以要放到里边去</span><br>            <span class="hljs-keyword">if</span> (target &lt; nums[middle]) { <span class="hljs-comment">// 在左区间里,更新右边界</span><br>            right = middle <span class="hljs-number">-1</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[middle]){ <span class="hljs-comment">// 在右区间里更新,更新左边界</span><br>            left = middle +<span class="hljs-number">1</span>;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<span class="hljs-comment">// 💡返回下标值,前边要加 else 不然直接返回 middle 了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>左闭右开的无法填入示例</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 整体区间要一直保持左闭右开</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>{<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right){<br>            <span class="hljs-type">int</span> middle =  left + (right - left)/<span class="hljs-number">2</span>; <span class="hljs-comment">//💡 middle 要不断的更新所以要放到里边去</span><br>            <span class="hljs-keyword">if</span> (target &lt; nums[middle]) { <span class="hljs-comment">// 在左区间里,更新右边界</span><br>            right = middle; <span class="hljs-comment">// 保持右开</span><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; nums[middle]){ <span class="hljs-comment">// 在右区间里更新,更新左边界</span><br>            left = middle +<span class="hljs-number">1</span>; <span class="hljs-comment">//保持左闭</span><br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> middle;<span class="hljs-comment">// 💡返回下标值,前边要加 else 不然直接返回 middle 了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#_704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进制转换</title>
    <link href="/posts/35590/"/>
    <url>/posts/35590/</url>
    
    <content type="html"><![CDATA[<ul><li>10 进制逢 10 进 1,</li><li>2 进制逢 2 进 1</li><li>16 进制逢 16 进 1</li></ul><p>![[进制转换 2022-08-08 10.12.38.excalidraw]]</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208081030695.png" alt=""></p><hr><p><strong>参考资料</strong><br><a href="https://www.bilibili.com/video/BV1PK411g7vy/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">【最强干货】详解二进制，八进制，十进制，十六进制的相互转换_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 数组理论基础</title>
    <link href="/posts/52749/"/>
    <url>/posts/52749/</url>
    
    <content type="html"><![CDATA[<h1 id="1-一维数组"><a class="markdownIt-Anchor" href="#1-一维数组"></a> 1 一维数组</h1><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong><br>数组可以方便的通过下标索引的方式获取到下标下对应的数据。<br><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png" alt="算法通关数组"></p><ul><li><mark><strong>数组下标都是从0开始的。</strong></mark></li><li><mark><strong>数组内存空间的地址是连续的</strong>, <strong>数组的元素是不能删的，只能覆盖。</strong></mark></li></ul><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong><br>进行删除操作,后边的数据整体移动到了前边<br><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png" alt="算法通关数组1|700"></p><p>而且大家如果使用C++的话，要注意vector 和 array(数组)的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[vector]]">[1]</span></a></sup></p><h1 id="2-二维数组"><a class="markdownIt-Anchor" href="#2-二维数组"></a> 2 二维数组</h1><h2 id="21-c"><a class="markdownIt-Anchor" href="#21-c"></a> 2.1 C++</h2><p><strong>C++中二维数组是连续分布</strong>的。</p><p>我们来做一个实验，C++测试代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_arr</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> array[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = {<br>{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>},<br>{<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}<br>    };<br>    cout &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] &lt;&lt; endl;<br>    cout &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; &amp;array[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_arr</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>测试地址为</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x7ffee4065820</span> <span class="hljs-number">0x7ffee4065824</span> <span class="hljs-number">0x7ffee4065828</span><br><span class="hljs-number">0x7ffee406582c</span> <span class="hljs-number">0x7ffee4065830</span> <span class="hljs-number">0x7ffee4065834</span><br></code></pre></td></tr></tbody></table></figure><p>注意地址为16进制<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[进制转换]]">[2]</span></a></sup>，可以看出二维数组地址是连续一条线的。</p><p>![[数组理论基础 2022-08-08 10.31.06.excalidraw]]</p><h2 id="22-java"><a class="markdownIt-Anchor" href="#22-java"></a> 2.2 java</h2><p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p><p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_arr</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span>[][] arr = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>}, {<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>}};<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    System.out.println(arr[<span class="hljs-number">1</span>]);<br>    System.out.println(arr[<span class="hljs-number">2</span>]);<br>    System.out.println(arr[<span class="hljs-number">3</span>]);<br>}<br></code></pre></td></tr></tbody></table></figure><p>输出的地址为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[I@<span class="hljs-number">7852e922</span><br>[I@<span class="hljs-number">4e25154f</span><br>[I@70dea4e<br>[I@5c647e05<br></code></pre></td></tr></tbody></table></figure><p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p><p>所以Java的二维数组可能是如下排列的方式：</p><p><img src="https://img-blog.csdnimg.cn/20201214111631844.png" alt="算法通关数组3|600"></p><p>这里面试中数组相关的理论知识就介绍完了。</p><hr><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[vector]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[进制转换]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码内存消耗</title>
    <link href="/posts/60393/"/>
    <url>/posts/60393/</url>
    
    <content type="html"><![CDATA[<h1 id="1-不同语言的内存管理"><a class="markdownIt-Anchor" href="#1-不同语言的内存管理"></a> 1 不同语言的内存管理</h1><p>不同的编程语言各自的内存管理方式。</p><p><strong>-   C/C++这种内存堆空间的申请和释放完全靠自己管理</strong></p><ul><li>Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出</li><li>Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。</li></ul><p>例如Python万物皆对象，并且将内存操作封装的很好，<strong>所以python的基本数据类型所用的内存会要远大于存放纯数据类型所占的内存</strong>，例如，我们都知道存储int型数据需要四个字节，但是使用Python 申请一个对象来存放数据的话，所用空间要远大于四个字节。</p><h1 id="2-c的内存管理"><a class="markdownIt-Anchor" href="#2-c的内存管理"></a> 2 C++的内存管理</h1><p>以C++为例来介绍一下编程语言的内存管理。</p><p>如果我们写C++的程序，就要知道栈和堆的概念，程序运行时所需的内存空间分为 固定部分，和可变部分，如下：</p><p><img src="https://img-blog.csdnimg.cn/20210309165950660.png" alt="C++内存空间"></p><p>固定部分的内存消耗 是不会随着代码运行产生变化的， 可变部分则是会产生变化的</p><p>更具体一些，一个由C/C++编译的程序占用的内存分为以下几个部分：</p><ul><li>栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。</li><li>堆区(Heap) ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS收回</li><li>未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量</li><li>初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量</li><li>程序代码区(Text)：存放函数体的二进制代码</li></ul><p>代码区和数据区所占空间都是固定的，而且占用的空间非常小，那么看运行时消耗的内存主要看可变部分。</p><p>在可变部分中，栈区间的数据在代码块执行结束之后，系统会自动回收，<strong>而堆区间数据是需要程序员自己回收，所以也就是造成内存泄漏的发源地。</strong></p><p><strong>而Java、Python的话则不需要程序员去考虑内存泄漏的问题，虚拟机都做了这些事情</strong>。</p><h1 id="3-如何计算程序占用多大内存"><a class="markdownIt-Anchor" href="#3-如何计算程序占用多大内存"></a> 3 如何计算程序占用多大内存</h1><p>想要算出自己程序会占用多少内存就一定要了解自己定义的数据类型的大小，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200804193045440.png" alt="C++数据类型的大小"><br><strong>Byte :字节</strong></p><p>注意图中有两个不一样的地方，为什么64位的指针就占用了8个字节，而32位的指针占用4个字节呢？</p><p><strong>1个字节占8个比特</strong>，那么4个字节就是32个比特，可存放数据的大小为2^32，也就是4G空间的大小，即：<strong>4个Byte可以寻找4G空间大小的内存地址。</strong></p><p>大家现在使用的计算机一般都是64位了，所以编译器也都是64位的。</p><p>注意2^64是一个非常巨大的数，对于寻找地址来说已经足够用了。</p><h2 id="31-总结"><a class="markdownIt-Anchor" href="#31-总结"></a> 3.1 总结</h2><p>1 字节 = 8 比特</p><p>1 字节 = 8 比特(1 Byte = 8 bit), 4字节 = 32比特, 能够存放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>个数据即4G内存, 就能够当寻址内存存放指针 #card<br>安装64位的操作系统的计算机内存都已经超过了4G，也就是指针大小如果还是4个字节的话，<strong>就已经不能寻址全部的内存地址</strong>，所以64位编译器使用8个字节的指针才能寻找所有的内存地址。</p><h1 id="4-内存对齐"><a class="markdownIt-Anchor" href="#4-内存对齐"></a> 4 内存对齐</h1><p>![[代码内存消耗 2022-08-07 18.01.47.excalidraw]]</p><ul><li>内存对齐:<br>一字节的char占用了四个字节，空了三个字节的内存地址，int数据从地址4开始。<br>此时，直接将地址4，5，6，7处的四个字节数据读取到即可<br>分割线</li><li>非内存对齐<br>char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：</li></ul><ol><li>因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据</li><li>CPU读取4，5，6，7处的四个字节数据</li><li>合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据<br>此时一共需要两次寻址，一次合并的操作<br>分割线<br>虽然浪费内存,但是内存资源一般都是充足的,我们更希望提升运行速度<br><strong>编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响</strong>。<br>分割线<br>例子 #card</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// char 一字节, int 四字节</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>{</span><br>   <span class="hljs-type">int</span> num;<br>   <span class="hljs-type">char</span> cha;<br>}st;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span> b[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// 4</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">// 1</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(a) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 400</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(b) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">// 100</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(st) &lt;&lt; <span class="hljs-built_in">endl</span>;   <span class="hljs-comment">// 因为内存对齐,整个类的内存占用为 8 字节</span><br>}<br></code></pre></td></tr></tbody></table></figure><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归思想</title>
    <link href="/posts/8679/"/>
    <url>/posts/8679/</url>
    
    <content type="html"><![CDATA[<p>递归思想是：分而治之</p><p>简单的递归：阶乘<br>将大问题不断的拆分为子问题拆到不可拆分之后，自底向上放入栈中<br>在自顶向下不断计算子问题，返回结果给下一层在计算，直至计算出最后一层</p><p>![[递归思想 2022-08-05 15.45.22.excalidraw|1100]]</p><p>使用递归相当于，程序为我们创建了一个栈，我们只需拆分问题放入栈，在分而治之<br>阶乘是线性结构可以直接自底向上的解决而不使<br>但是树的递归就不是了线性了，递归的思想是拆分子问题放入栈，在解决子问题在传递给下一层直至计算完毕</p><p>![[递归思想 2022-08-05 17.04.12.excalidraw|1100]]</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV11h411h7nT?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">1-2 栈与深度优先遍历_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>M1 macbook 罗技G502鼠标 g hub显示停用的解决办法</title>
    <link href="/posts/32256/"/>
    <url>/posts/32256/</url>
    
    <content type="html"><![CDATA[<p><mark>与karabiner原有冲突：就是这个原因！！！</mark></p><p>将karabiner中禁用掉G502即可</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">// 其他的错误尝试<br>解决办法<br>1. 卸载原有的g hub 应用<br>2. 在google 里搜索 g hub(最新版)下载。不在火狐里下载是因为中文的可能滞后<br><br><br>1. 本质原因是罗技驱动(g hub)没有做好苹果电脑的适配<br>比如苹果更新系统后，看似给了 g hub 辅助功能的权限实际没给<br><br><br></code></pre></td></tr></tbody></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1ri4y1V7cf?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">M1 Mac 装罗技 Logitech G Hub 有问题? Mac OS 中罗技G502和G815在 G Hub中可以显示但不能设置？MacBook_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ new的用法</title>
    <link href="/posts/36172/"/>
    <url>/posts/36172/</url>
    
    <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="ObsReOPlSEcMgnDTfMU2S00r" --> <p>C++ new的用法<br>new返回的都是指针(指向第一个元素)<br>eg：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">new <span class="hljs-type">int</span>;    <span class="hljs-comment">//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即**指针**）</span><br>new <span class="hljs-type">int</span>(<span class="hljs-number">100</span>);<span class="hljs-comment">//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个**指向该存储空间的地址**</span><br>new <span class="hljs-type">char</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址</span><br>new <span class="hljs-type">int</span>[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>);<span class="hljs-comment">//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址</span><br>new linklist; <span class="hljs-comment">//申请表头空间 </span><br><span class="hljs-type">float</span> *p=new <span class="hljs-type">float</span> (<span class="hljs-number">3.14159</span>);/开辟一个存放单精度数的空间，并指定该实数的初值为/<span class="hljs-number">3.14159</span>，将返回的该空间的地址赋给指针变量p<br><span class="hljs-comment">// 例子</span><br><span class="hljs-number">1.</span>new <span class="hljs-type">int</span>[] 是创建一个<span class="hljs-type">int</span>型数组，数组大小是在[]中指定<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//申请一个整型数组，数组的长度为[]中的值</span><br><span class="hljs-number">2.</span>new <span class="hljs-title function_">int</span><span class="hljs-params">()</span>是创建一个<span class="hljs-type">int</span>型数，并且用<span class="hljs-params">()</span>括号中的数据进行初始化,例如：<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// p指向一个值为10的int数。</span><br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><hr><p><strong>参考资料</strong></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空间复杂度分析</title>
    <link href="/posts/11552/"/>
    <url>/posts/11552/</url>
    
    <content type="html"><![CDATA[<h1 id="1-空间复杂度"><a class="markdownIt-Anchor" href="#1-空间复杂度"></a> 1 空间复杂度</h1><p>空间复杂度(Space Complexity)记作S(n)：S(n)=O(f(n))。依然使用大O来表示</p><ol><li>空间复杂度是考虑程序（可执行文件）的大小么？</li></ol><p><strong>空间复杂度是考虑程序运行时占用内存的大小，而不是可执行文件的大小。</strong><br>利用程序的空间复杂度，可以对程序运行中需要多少内存有个预先估计。</p><ol start="2"><li>空间复杂度是准确算出程序运行时所占用的内存么？<br>不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。</li></ol><p>所以空间复杂度是预先大体评估程序内存使用的大小。</p><p>空间复杂度O(1)： 所开辟的内存空间不会随着n的变化而变化，即空间复杂度为一个常量O(1)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) { <span class="hljs-comment">// n别超过 2^32 - 1就行。(int 的取值范围)</span><br>    j++;<br>}<br></code></pre></td></tr></tbody></table></figure><p>第一段代码可以看出，随着n的变化，所需开辟的内存空间并不会随着n的变化而变化。即此算法空间复杂度为一个常量，所以表示为大O(1)。<br>空间复杂度O(n)：消耗空间和输入参数n保持线性增长</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* a = new <span class="hljs-type">int</span>(n); <span class="hljs-comment">// a指向值为n的int数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>    a[i] = i; <span class="hljs-comment">// 不断的扩大a的数组长度</span><br>}<br></code></pre></td></tr></tbody></table></figure><p>new 函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span>new <span class="hljs-type">int</span>[] 是创建一个<span class="hljs-type">int</span>型数组，数组大小是在[]中指定<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//申请一个整型数组，数组的长度为[]中的值</span><br><span class="hljs-number">2.</span>new <span class="hljs-title function_">int</span><span class="hljs-params">()</span>是创建一个<span class="hljs-type">int</span>型数，并且用<span class="hljs-params">()</span>括号中的数据进行初始化,例如：<br>  <span class="hljs-type">int</span> *p = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// p指向一个值为10的int数。</span><br></code></pre></td></tr></tbody></table></figure><p>这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 O(n)<br>O(n^2)， O(n^3)：即2 * 2,   3 * 3 矩阵</p><p>空间复杂度是<strong>logn</strong>的情况确实有些特殊，其实是在<strong>递归的时候，会出现空间复杂度为logn的情况</strong>。</p><h1 id="2-总结"><a class="markdownIt-Anchor" href="#2-总结"></a> 2 总结</h1><p>算法的世界里用空间换时间</p><ul><li>用户只关心程序的响应速度</li><li>程序运行完成以后空间可以重复使用</li></ul><p><strong>将经常使用的数据存成变量</strong></p><p>发现时间复杂度很高空间复杂度很低, 就是系统没有记住一些信息, 将常用的信息设置为变量. 以降低时间复杂度<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208111052182.png" alt=""></p><hr><p>[[C++ new的用法]]<br>[[时间复杂度分析]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>递归算法的复杂度</title>
    <link href="/posts/9398/"/>
    <url>/posts/9398/</url>
    
    <content type="html"><![CDATA[<p><strong>同一道题目，同样使用递归算法，有的同学会写出了O(n)的代码，有的同学就写出了O(logn)的代码</strong>。<br>如果对递归的时间复杂度理解的不够深入的话，就会这样！</p><p>题目： 求x的n次方</p><p>for循环暴力求解</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求x的n次方</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 注意 任何数的0次方等于1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        result = result * x; <span class="hljs-comment">// result = x，x * x, x^2 * x, ........</span><br>    }<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></tbody></table></figure><p>[[代码随想录视频]]</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复杂度</tag>
      
      <tag>待解决</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法为什么会超时</title>
    <link href="/posts/26126/"/>
    <url>/posts/26126/</url>
    
    <content type="html"><![CDATA[<h1 id="从硬件配置看计算机的性能"><a class="markdownIt-Anchor" href="#从硬件配置看计算机的性能"></a> 从硬件配置看计算机的性能</h1><p>计算机的运算速度主要看CPU的配置，以2015年MacPro为例<br>CPU配置：2.7 GHz Dual-Core Intel Core i5 。<br>也就是 2.7 GHz 奔腾双核，i5处理器，GHz是指什么呢</p><ul><li>1GHz（兆赫）= 1000MHz（兆赫）</li><li>1MHz（兆赫）= 1百万赫兹</li></ul><p>1Hz = 1/s，<br>1Hz 是CPU的一次脉冲（可以理解为一次改变状态，也叫时钟周期）称之为为赫兹，</p><p>所以 <strong>1GHz = 10亿Hz</strong>，表示CPU可以一秒脉冲10亿次（有10亿个时钟周期），这里不要简单理解一个时钟周期就是一次CPU运算。</p><p>例如1 + 2 = 3，cpu要执行四次才能完整这个操作，步骤一：把1放入寄存机，步骤二：把2放入寄存器，步骤三：做加法，步骤四：保存3。</p><p>而且计算机的cpu也不会只运行我们自己写的程序上，同时cpu也要执行计算机的各种进程任务等等，我们的程序仅仅是其中的一个进程而已。</p><p><mark>Apple M1具有Apple M-Series的 L1 缓存，基本/<strong>最大CPU频率</strong>为2.06 - 3.20 GHz</mark><br>“英特尔发布 i9-12900KS：最高睿频 5.5GHz，全大核 5.2 GHz”</p><h1 id="测试1s能处理多少个数据"><a class="markdownIt-Anchor" href="#测试1s能处理多少个数据"></a> 测试1s能处理多少个数据</h1><p>算法4里面的一段话：</p><ul><li>火箭科学家需要大致知道一枚试射火箭的着陆点是在大海里还是在城市中；</li><li>医学研究者需要知道一次药物测试是会杀死还是会治愈实验对象；<br><strong>任何开发计算机程序员的软件工程师都应该能够估计这个程序的运行时间是一秒钟还是一年</strong>。</li></ul><p>在写测试程序测1s内处理多大数量级数据的时候，有三点需要注意：</p><ul><li>CPU执行每条指令所需的时间实际上并不相同，例如CPU执行加法和乘法操作的耗时实际上都是不一样的。</li><li>现在大多计算机系统的内存管理都有缓存技术，所以频繁访问相同地址的数据和访问不相邻元素所需的时间也是不同的。</li><li>计算机同时运行多个程序，每个程序里还有不同的进程线程在抢占资源。</li></ul><p>实现三个函数，时间复杂度分别是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，使用加法运算来统一测试。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> chrono;<br><span class="hljs-comment">// O(n) 简单的for循环加法 0-n</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        k++;<br>    }<br>}<br><br><span class="hljs-comment">// O(n^2) for循环嵌套：循环体内部复杂度相乘 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {<br>            k++;<br>        }<br>    }<br><br>}<br><span class="hljs-comment">// O(nlogn)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> j = <span class="hljs-number">1</span>; j &lt; n; j = j*<span class="hljs-number">2</span>) { <span class="hljs-comment">// 注意这里j=1；j = 1，2,4,8,16(两倍递增)</span><br>            k++;<br>        }<br>    }<br>}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n; <span class="hljs-comment">// 数据规模</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>        cout &lt;&lt; <span class="hljs-string">"输入n："</span>;<br>        cin &gt;&gt; n;<br>        milliseconds start_time = <span class="hljs-built_in">duration_cast</span>&lt;milliseconds &gt;(<br>            system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()<br>        );<br>        <span class="hljs-built_in">function1</span>(n);<br><span class="hljs-comment">//        function2(n);</span><br><span class="hljs-comment">//        function3(n);</span><br>        milliseconds end_time = <span class="hljs-built_in">duration_cast</span>&lt;milliseconds &gt;(<br>            system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()<br>        );<br>        cout &lt;&lt; <span class="hljs-string">"耗时:"</span> &lt;&lt; <span class="hljs-built_in">milliseconds</span>(end_time).<span class="hljs-built_in">count</span>() - <span class="hljs-built_in">milliseconds</span>(start_time).<span class="hljs-built_in">count</span>()<br>            &lt;&lt;<span class="hljs-string">" ms"</span>&lt;&lt; endl;<br>    }<br>}<br><br></code></pre></td></tr></tbody></table></figure><p>O(n)：1s大概能处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">1^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>  的数据，O(n<sup>2)的数量级为O(n)开根号，O(nlogn)比O(n</sup>2)多一点，因为复杂度比它小一点。但比O(n)还是<strong>少一个</strong>数量级<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021618668.png" alt=""></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/On%E7%9A%84%E7%AE%97%E6%B3%95%E5%B1%85%E7%84%B6%E8%B6%85%E6%97%B6%E4%BA%86%EF%BC%8C%E6%AD%A4%E6%97%B6%E7%9A%84n%E7%A9%B6%E7%AB%9F%E6%98%AF%E5%A4%9A%E5%A4%A7%EF%BC%9F.html#%E5%81%9A%E4%B8%AA%E6%B5%8B%E8%AF%95%E5%AE%9E%E9%AA%8C">On的算法居然超时了，此时的n究竟是多大？ | 代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex 环境配置</title>
    <link href="/posts/1424/"/>
    <url>/posts/1424/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><h3 id="latex-数学公式"><a class="markdownIt-Anchor" href="#latex-数学公式"></a> LaTeX 数学公式</h3><p>Hexo 5.0 以上，可尝试 Hexo 官方的 <a href="https://github.com/hexojs/hexo-math">hexo-math</a><br>插件，支持更多定制化参数，使用方式参照仓库内的文档，以下介绍的是主题内置的 LaTeX 功能。</p><p>当需要使用 <a href="https://www.latex-project.org/help/documentation/">LaTeX</a><br>语法的数学公式时，可手动开启本功能，需要完成三步操作：</p><p><strong>1. 设置主题配置</strong></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">math:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></tbody></table></figure><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p><code>engine</code>: 公式引擎，目前支持 <code>mathjax</code> 或 <code>katex</code>。</p><p><strong>2. 更换 Markdown 渲染器</strong></p><p>由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。</p><p>先卸载原有渲染器：</p><p><code>npm uninstall hexo-renderer-marked --save</code></p><p>然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p><p>mathjax（可选）:<code>npm install hexo-renderer-pandoc --save</code> <strong>并且还需<a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">安装 Pandoc</a></strong></p><p>katex（必须）: <code>npm install @upupming/hexo-renderer-markdown-it-plus --save</code></p><p><strong>3. 安装完成后执行 <code>hexo clean</code></strong></p><p>书写公式的格式：</p><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>E=mc^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></tbody></table></figure><p>WARNING</p><p>如果公式没有被正确渲染，请仔细检查是否符合上面三步操作。</p><p>不可以同时安装多个渲染插件，包括 <code>hexo-math</code> 或者 <code>hexo-katex</code> 这类插件，请注意检查 <code>package.json</code>。</p><p>如果更换公式引擎，对应渲染器也要一并更换。</p><p>另外不同的渲染器，可能会导致一些 Markdown 语法不支持。</p><p>自定义页面默认不加载渲染，如需使用，需在 Front-matter 中指定 <code>math: true</code></p><p>不同的公式引擎有不同的优缺点。</p><p><strong>MathJax</strong></p><p>优点</p><ul><li>对 LaTeX 语法支持全面</li><li>右键点击公式有扩展功能</li></ul><p>缺点</p><ul><li>需要加载 JS，页面加载会比较慢</li></ul><p><strong>KaTeX</strong></p><p>优点</p><ul><li>没有 JS 不会影响页面加载</li></ul><p>缺点</p><ul><li>小部分 LaTeX 不支持</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">配置指南 | Hexo Fluid 用户手册</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex公式</title>
    <link href="/posts/4371/"/>
    <url>/posts/4371/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p>​ <a href="https://so.csdn.net/so/search?q=LaTeX&amp;spm=1001.2101.3001.7020">LaTeX</a>是一种基于ΤΕΧ的排版系统，而TeX是由著名的计算机科学家<a href="https://baike.baidu.com/item/%E5%94%90%E7%BA%B3%E5%BE%B7%C2%B7%E5%85%8B%E5%8A%AA%E7%89%B9?fromtitle=Donald+E.+Knuth&amp;fromid=2509519">Donald E. Knuth</a>发明的排版系统,可以了解一下他，LaTeX能够优美地生成数学公式且质量极高，本文简要记录其常用公式，以备自查。</p><h1 id="行内公式与行间公式及编号"><a class="markdownIt-Anchor" href="#行内公式与行间公式及编号"></a> 行内公式与行间公式及编号</h1><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span>f(x) = a+b<span class="hljs-built_in">$</span><br><br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br>f(x)=a+b+c<span class="hljs-keyword">\tag</span>{1.1}<br><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x) = a+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1.1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">f(x)=a+b+c\tag{1.1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span><span class="mord">.</span><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p><p>效果显然，使用<code>\tag{}</code> 对公式进行标号</p><h1 id="多项式上下标-根号-分式-对数"><a class="markdownIt-Anchor" href="#多项式上下标-根号-分式-对数"></a> 多项式（上下标）、根号、分式、对数</h1><p>上下标分别用 _{ }和 ^{ } 来标记，{}内为值，可以是公式等等</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span>f(x)=a<span class="hljs-built_in">_</span>{1}<span class="hljs-built_in">^</span>{1-x}+a<span class="hljs-built_in">^</span>{2-x}<span class="hljs-built_in">_</span>{2}+a<span class="hljs-built_in">^</span>{3-x}<span class="hljs-built_in">_</span>{3}<span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>a</mi><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>x</mi></mrow></msubsup><mo>+</mo><msubsup><mi>a</mi><mn>2</mn><mrow><mn>2</mn><mo>−</mo><mi>x</mi></mrow></msubsup><mo>+</mo><msubsup><mi>a</mi><mn>3</mn><mrow><mn>3</mn><mo>−</mo><mi>x</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">f(x)=a_{1}^{1-x}+a^{2-x}_{2}+a^{3-x}_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>\sqrt{ }</strong> 表示平方根，<strong>\sqrt[n]{ }</strong> 表示n次方根，<strong>\frac{ }{ }</strong> 表示分式，两个{}先分子，后分母，对数用 <strong>\log_{2}{343}</strong> 表示</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span><span class="hljs-keyword">\sqrt</span>{x}+<span class="hljs-keyword">\sqrt</span>[3]{2-x}-<span class="hljs-keyword">\sqrt</span>[x]{<span class="hljs-keyword">\frac</span>{a<span class="hljs-built_in">^</span>x}{b<span class="hljs-built_in">^</span>x}}+<span class="hljs-keyword">\frac</span>{1}{x}+<span class="hljs-keyword">\log</span><span class="hljs-built_in">_</span>{2}{x}<span class="hljs-built_in">$</span><br></code></pre></td></tr></tbody></table></figure><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>x</mi></msqrt><mo>+</mo><mroot><mrow><mn>2</mn><mo>−</mo><mi>x</mi></mrow><mn>3</mn></mroot><mo>−</mo><mroot><mfrac><msup><mi>a</mi><mi>x</mi></msup><msup><mi>b</mi><mi>x</mi></msup></mfrac><mi>x</mi></mroot><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><mo>+</mo><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">\sqrt{x}+\sqrt[3]{2-x}-\sqrt[x]{\frac{a^x}{b^x}}+\frac{1}{x}+\log_{2}{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">x</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.17444499999999996em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.736886em;"><span style="top:-2.914666em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8655550000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span><span style="top:-2.825555em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17444499999999996em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.62276em;"></span><span class="mord sqrt"><span class="root"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.571968em;"><span style="top:-2.856688em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size6 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.21724em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.80948em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935428571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.17724em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width="400em" height="1.8800000000000001em" viewBox="0 0 400000 1944" preserveAspectRatio="xMinYMin slice"><path d="M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10zM1001 80H400000v40H1013z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.62276em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span></span></span></p><h3 id="常用符号"><a class="markdownIt-Anchor" href="#常用符号"></a> 常用符号</h3><p><strong>+ - * /</strong> 等可以直接打出</p><p>乘号用\times,点乘用\cdot，除号用\div，不等号用\ne，恒等或同余号用\equiv，整除用\mid,取模用\mod，上取整用\lfloor x \rfloor，下取整用\lceil x \rceil</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\times</span>乘号 <span class="hljs-keyword">\cdot</span>点乘  <span class="hljs-keyword">\div</span>除号  <span class="hljs-keyword">\ne</span>不等号<span class="hljs-keyword">\equiv</span>恒等或同余号 <br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\mid</span>整除 <span class="hljs-keyword">\mod</span> 取模   <span class="hljs-keyword">\lfloor</span> x <span class="hljs-keyword">\rfloor</span> 和 <span class="hljs-keyword">\lceil</span> x <span class="hljs-keyword">\rceil</span><br></code></pre></td></tr></tbody></table></figure><p>\times乘号 \cdot点乘  \div除号  \ne不等号\equiv恒等或同余号<br>\mid整除 \mod 取模   \lfloor x \rfloor 和 \lceil x \rceil</p><p><strong>ps</strong>: \ \ 是分行</p><p>小于号用\lt，大于号用\gt，小于等于号用\le，大于等于号用\ge</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\lt</span>小于号     <span class="hljs-keyword">\gt</span>大于号    <span class="hljs-keyword">\le</span>小于等于号    <span class="hljs-keyword">\ge</span>大于等于号<br></code></pre></td></tr></tbody></table></figure><p>&lt; 小 于 号 &gt; 大 于 号 ≤ 小 于 等 于 号 ≥ 大 于 等 于 号 \lt小于号 \gt大于号 \le小于等于号 \ge大于等于号 &lt;小于号&gt;大于号≤小于等于号≥大于等于号</p><p>集合运算符号</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cup</span>并运算 <span class="hljs-keyword">\quad</span>  <span class="hljs-keyword">\cap</span>交运算 <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\subset</span> 和 <span class="hljs-keyword">\supset</span>  <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\subseteq</span> 和 <span class="hljs-keyword">\supseteq</span> <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\in</span> 和 <span class="hljs-keyword">\notin</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\emptyset</span> 空集<br></code></pre></td></tr></tbody></table></figure><p>∪ 并 运 算 ∩ 交 运 算 ⊂ 和 ⊃ ⊆ 和 ⊇ ∈ 和 ∉ ∅ 空 集 \ \cup并运算 \quad \cap交运算 \qquad \subset 和 \supset \ \subseteq 和 \supseteq \qquad \in 和 \notin \qquad \emptyset 空集 ∪并运算∩交运算⊂和⊃⊆和⊇∈和∈/​∅空集</p><p><strong>ps</strong>: \qquad是空格</p><p>三角符号用\bigtriangleup，三角符号类似\sin,度数用上标^{\cric}表示，角用\angle</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\bigtriangleup</span>三角 <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\angle</span> 角<br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\tan</span>90<span class="hljs-built_in">^</span>{<span class="hljs-keyword">\circ</span>}和<span class="hljs-keyword">\sin</span> x和<span class="hljs-keyword">\cos</span> x三角函数及度数表示 <br></code></pre></td></tr></tbody></table></figure><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span><span class="hljs-keyword">\rightarrow</span>和<span class="hljs-keyword">\Rightarrow</span><br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\leftrightarrow</span>和<span class="hljs-keyword">\Leftrightarrow</span><br><span class="hljs-keyword">\\</span><span class="hljs-keyword">\vee</span>和<span class="hljs-keyword">\wedge</span><br><span class="hljs-keyword">\\</span><span class="hljs-keyword">\because</span>和<span class="hljs-keyword">\therefore</span><br><span class="hljs-keyword">\\</span>因为所以<br></code></pre></td></tr></tbody></table></figure><p>→ 和 ⇒ ↔ 和 ⇔ ∨ 和 ∧ ∵ 和 ∴ 因 为 所 以 \ \rightarrow和\Rightarrow \ \leftrightarrow和\Leftrightarrow \ \vee和\wedge \ \because和\therefore \ 因为所以 →和⇒↔和⇔∨和∧∵和∴因为所以</p><p>特殊符号</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\otimes</span>和<span class="hljs-keyword">\oplus</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\nearrow</span>和<span class="hljs-keyword">\searrow</span> <span class="hljs-keyword">\qquad</span><br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\sim</span>和<span class="hljs-keyword">\approx</span>  <span class="hljs-keyword">\qquad</span><span class="hljs-keyword">\ldots</span>和<span class="hljs-keyword">\cdots</span> 不同对齐的省略号<br></code></pre></td></tr></tbody></table></figure><p>⊗ 和 ⊕ ↗ 和 ↘ ∼ 和 ≈ … 和 ⋯ 不 同 对 齐 的 省 略 号 \ \otimes和\oplus \qquad \nearrow和\searrow \qquad \ \sim和\approx \qquad \ldots和\cdots 不同对齐的省略号 ⊗和⊕↗和↘∼和≈…和⋯不同对齐的省略号</p><h3 id="积分-极限-求和-乘积-求导"><a class="markdownIt-Anchor" href="#积分-极限-求和-乘积-求导"></a> 积分、极限、求和、乘积、求导</h3><p>\int表示积分，\lim表示极限， \sum表示求和，\prod表示乘积，<em>’</em> 表示求导，微分中的dx用\mathrm{d}x表示，\to表示箭头，\infty表示无穷</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\int</span><span class="hljs-built_in">_</span>{0}<span class="hljs-built_in">^</span>{x}{x<span class="hljs-built_in">^</span>2}<span class="hljs-keyword">\mathrm</span>{d}x +<span class="hljs-keyword">\lim</span><span class="hljs-built_in">_</span>{x <span class="hljs-keyword">\to</span> <span class="hljs-keyword">\infty</span>}{<span class="hljs-keyword">\frac</span>{<span class="hljs-keyword">\sin</span> x}{x}}<br><span class="hljs-keyword">\\</span>  <span class="hljs-keyword">\sum</span><span class="hljs-built_in">_</span>{i=1}<span class="hljs-built_in">^</span>{n}{a<span class="hljs-built_in">_</span>ib<span class="hljs-built_in">_</span>i}+<span class="hljs-keyword">\prod</span><span class="hljs-built_in">_</span>{i=1}<span class="hljs-built_in">^</span>{n}{(a<span class="hljs-built_in">_</span>i+b<span class="hljs-built_in">_</span>i)}+f(x)''<br></code></pre></td></tr></tbody></table></figure><p>∫ 0 x x 2 d x + lim ⁡ x → ∞ sin ⁡ x x ∑ i = 1 n a i b i + ∏ i = 1 n ( a i + b i ) + f ( x ) ′ ′ \ \int_{0}<sup>{x}{x</sup>2}\mathrm{d}x +\lim_{x \to \infty}{\frac{\sin x}{x}} \ \sum_{i=1}<sup>{n}{a_ib_i}+\prod_{i=1}</sup>{n}{(a_i+b_i)}+f(x)’’ ∫0x​x2dx+x→∞lim​xsinx​i=1∑n​ai​bi​+i=1∏n​(ai​+bi​)+f(x)′′</p><h3 id="向量-组合数-矩阵"><a class="markdownIt-Anchor" href="#向量-组合数-矩阵"></a> 向量、组合数、矩阵</h3><p>向量用 <strong>\overrightarrow{ }</strong> 表示，组合数用 <strong>\binom{ }{ }</strong> ，其类似于分式</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\overrightarrow</span>{AB} <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\binom</span>{1}{2}<br></code></pre></td></tr></tbody></table></figure><p>A B → ( 1 2 ) \overrightarrow{AB} \qquad \binom{1}{2} AB</p><p>(21​)</p><p>矩阵以起始来规定，内部以&amp;分列，以\分行，括号里可填matrix，bmatrix，pmatrix，vmatrix，分别对应示例(1)(2)(3)(4)</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-built_in">$</span> <span class="hljs-keyword">\begin</span>{matrix}<br>0 <span class="hljs-built_in">&amp;</span> 1 <span class="hljs-keyword">\\</span><br>1 <span class="hljs-built_in">&amp;</span> 0 <br><span class="hljs-keyword">\end</span>{matrix} <span class="hljs-built_in">$</span>   <br></code></pre></td></tr></tbody></table></figure><p>0 1 1 0</p><p>01​10​ [ 0 1 1 0 ]</p><p>[01​10​] ( 0 1 1 0 )</p><p>(01​10​) ∣ 0 1 1 0 ∣</p><p>∣∣∣∣​01​10​∣∣∣∣​</p><p>( 1 ) ( 2 ) ( 3 ) ( 4 ) (1)\qquad(2)\qquad(3)\qquad(4) (1)(2)(3)(4)</p><h3 id="方框加粗-上下标记-空格-更大更小的字符"><a class="markdownIt-Anchor" href="#方框加粗-上下标记-空格-更大更小的字符"></a> 方框加粗、上下标记、空格、更大更小的字符</h3><p>\boxed命令给公式加一个方框，\mathbf将字体加粗，\overline, \underline 分别在表达式上、下方画出水平线，\quad和\qquad是空格，\large 或 \small能使字符变大变小</p><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\boxed</span>{<span class="hljs-keyword">\large</span>{<span class="hljs-keyword">\mathbf</span>{E=mc<span class="hljs-built_in">^</span>2}}}<br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\overline</span>{a+<span class="hljs-keyword">\underline</span>{b+<span class="hljs-keyword">\small</span>{N}}}<br></code></pre></td></tr></tbody></table></figure><p>E = m c 2 a + b + N ‾ ‾ \ \boxed{\large{\mathbf{E=mc^2}}} \ \overline{a+\underline{b+\small{N}}} E=mc2​a+b+N​​</p><h3 id="希腊字母"><a class="markdownIt-Anchor" href="#希腊字母"></a> 希腊字母</h3><figure class="highlight latex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\alpha</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\beta</span>  <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Delta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\zeta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\varepsilon</span> <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\eta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\theta</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\lambda</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\mu</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\xi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\pi</span>  <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\rho</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\sigma</span>  <span class="hljs-keyword">\qquad</span>  <span class="hljs-keyword">\upsilon</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Phi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\phi</span> <br><span class="hljs-keyword">\\</span> <span class="hljs-keyword">\Psi</span>  <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\psi</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\omega</span> <span class="hljs-keyword">\qquad</span> <span class="hljs-keyword">\Omega</span> <span class="hljs-keyword">\qquad</span> O<br></code></pre></td></tr></tbody></table></figure><p>α β Δ ζ ε η θ λ μ ξ π ρ σ υ Φ ϕ Ψ ψ ω Ω O \ \alpha \qquad \beta \qquad \Delta \qquad \zeta \qquad \varepsilon \ \eta \qquad \theta \qquad \lambda \qquad \mu \qquad \xi \qquad \pi \ \rho \qquad \sigma \qquad \upsilon \qquad \Phi \qquad \phi \ \Psi \qquad \psi \qquad \omega \qquad \Omega \qquad O αβΔζεηθλμξπρσυΦϕΨψωΩO</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>​ LaTeX是非常有用的，是非常严谨优美的， 在此对<a href="https://baike.baidu.com/item/%E5%94%90%E7%BA%B3%E5%BE%B7%C2%B7%E5%85%8B%E5%8A%AA%E7%89%B9?fromtitle=Donald+E.+Knuth&amp;fromid=2509519">Donald E. Knuth</a>表示敬意。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://blog.csdn.net/weixin_42755533/article/details/113132619?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165940495016781683972226%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165940495016781683972226&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113132619-null-null.142%5Ev37%5Epc_search_v2&amp;utm_term=latex%20%E5%85%AC%E5%BC%8F&amp;spm=1018.2226.3001.4187">LaTeX常用公式_ywlcode的博客-CSDN博客_latex 整除</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技能</tag>
      
      <tag>已迁移</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《C++零基础99题》</title>
    <link href="/posts/57305/"/>
    <url>/posts/57305/</url>
    
    <content type="html"><![CDATA[<p>文章简介：学习资源来自B站UP主：英雄哪里出来</p><span id="more"></span><h1 id="开根号"><a class="markdownIt-Anchor" href="#开根号"></a> 开根号</h1><p>(int) sqrt(x)：函数前面加(int) 就是强转，注意()<br>sqrt平方根函数</p><h1 id="367有效的完全平方数"><a class="markdownIt-Anchor" href="#367有效的完全平方数"></a> 367.有效的完全平方数</h1><p>完全平方数：该数能开根号<br>不能用sqrt，从0开始找数一个个遍历，相乘是否等于num，<br>两数相乘的强转不能加括号，eg：(long long) (i * i)  最后会编译出错<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021728939.png" alt=""></p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://www.bilibili.com/video/BV1da411M798?p=2&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">01 函数_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>英雄哪里出来</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用hexo s 引发的一些错误</title>
    <link href="/posts/54162/"/>
    <url>/posts/54162/</url>
    
    <content type="html"><![CDATA[<h1 id="1-不要把没有ymal-字段-的文章放入post文件夹中否则会编译出错"><a class="markdownIt-Anchor" href="#1-不要把没有ymal-字段-的文章放入post文件夹中否则会编译出错"></a> 1 不要把没有ymal 字段 的文章放入post文件夹中，否则会编译出错</h1><p>此处把零散笔记文件夹放入post中<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281050271.png" alt="|600"></p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281055164.png" alt="|600"><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208021056860.png" alt=""><br>source 文件夹中的md文件都会被hexo s 编译，所以杂项也不能放入source 文件夹中</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207281115268.png" alt="|400"></p><p>用hexo s 时，在myblog(存放hexo整体的文件中)进行命令操作</p><h1 id="2-validationerror-null-is-not-a-string"><a class="markdownIt-Anchor" href="#2-validationerror-null-is-not-a-string"></a> 2 <strong>ValidationError: ‘null’ is not a string!</strong></h1><p>错误说明<br>一般都是因为文章无内容，可能是因为在这篇博客文章中，有某些属性没有填写，比如author属性，tag属性，categories属性等，导致该属性是空的，即<code>null</code>，所以报错。</p><hr><p>自用ob链接：<a href="obsidian://advanced-uri?vault=myblog&amp;uid=858032de-484b-4d7f-a45f-5bab2ca7bb2b">obsidian</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网易云本地音乐怎么添加歌词</title>
    <link href="/posts/27260/"/>
    <url>/posts/27260/</url>
    
    <content type="html"><![CDATA[<p>准备本地的.mp3文件<br>和.mp3文件同名的.lrc文件<br>两者放在一个文件夹中，然后用网抑云云盘上传</p><p>如何制作lrc文件</p><ol><li>将MP3文件导入剪映，智能制作srt文件并导出</li><li>将srt转成lrc文件。转换网站：<a href="http://www.lrccon.com/convert.php">歌词字幕在线转换器 - 支持LRC SRT UTF KSC SSA ASS SMI SNC TXT格式在线转换</a></li></ol><p>问题<br>在手机端看不到歌词，在电脑端可以</p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>19.零钱兑换II</title>
    <link href="/posts/48085/"/>
    <url>/posts/48085/</url>
    
    <content type="html"><![CDATA[<h1 id="1-518零钱兑换-ii"><a class="markdownIt-Anchor" href="#1-518零钱兑换-ii"></a> 1 518零钱兑换 II</h1><p><a href="https://leetcode.cn/problems/coin-change-2/">力扣题目链接</a></p><p>难度：中等</p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额)&nbsp;&lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>数量无限→立即想完全背包<br>本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总价值 ，而本题是要求凑成总金额的个数！</strong></p><p>组合不强调顺序，排列强调顺序<br>5 = 2 + 2 + 1<br>5 = 2 + 1 + 2<br>这是一种组合，都是 2 2 1。</p><p>弄清排列和组合问题与遍历顺序息息相关</p><h2 id="21-动归五部曲"><a class="markdownIt-Anchor" href="#21-动归五部曲"></a> 2.1 动归五部曲</h2><ol><li><p>dp[j] 的含义<br>凑成总金额j的货币<strong>组合</strong>数为dp[j]<br>j背包恰好有dp[j]种组合装满：即装满背包有几种方法</p></li><li></li></ol><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#_518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.零钱兑换II</title>
    <link href="/posts/48085/"/>
    <url>/posts/48085/</url>
    
    <content type="html"><![CDATA[<h1 id="1-518零钱兑换-ii"><a class="markdownIt-Anchor" href="#1-518零钱兑换-ii"></a> 1 518零钱兑换 II</h1><p><a href="https://leetcode.cn/problems/coin-change-2/">力扣题目链接</a></p><p>难度：中等</p><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p><p>示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: 输入: amount = 10, coins = [10] 输出: 1</p><p>注意，你可以假设：</p><ul><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额)&nbsp;&lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>数量无限→立即想完全背包<br>本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总价值 ，而本题是要求凑成总金额的个数！</strong></p><p>组合不强调顺序，排列强调顺序<br>5 = 2 + 2 + 1<br>5 = 2 + 1 + 2<br>这是一种组合，都是 2 2 1。</p><p>弄清排列和组合问题与遍历顺序息息相关</p><h2 id="21-动归五部曲"><a class="markdownIt-Anchor" href="#21-动归五部曲"></a> 2.1 动归五部曲</h2><ol><li><p>dp[j] 的含义<br>凑成总金额j的货币<strong>组合</strong>数为dp[j]<br>j背包恰好有dp[j]种组合装满：即装满背包有几种方法</p></li><li></li></ol><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html#_518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18.完全背包理论基础</title>
    <link href="/posts/10752/"/>
    <url>/posts/10752/</url>
    
    <content type="html"><![CDATA[<p>01背包：每个物品只有一个(即只能被添加一次)<br>核心代码：先物品后背包，内层倒序(保证物品只被添加一次)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>完全背包：每个物品有无数个(即可以被添加多次)<br>核心代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 先遍历物品，再遍历背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<span class="hljs-comment">// j从weight[i]开始+，j- weight[]肯定是成立的</span><br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/oly9hwp3.bmp" alt="|500"><br>![[18.完全背包理论基础 2022-07-21 15.39.33.excalidraw|600]]</p><p>是否可以物品和背包的顺序颠倒 #card  #疑问<br>01背包中：先物品在背包，背包for循环倒序。只能<strong>先物品在背包</strong>的和<strong>倒序</strong>的原因是，要保证每一个物品只被添加一次<br>🌵<br>完成背包的含义是物品有无限一个，能够被多次放入。之前的01背包中的限制条件就消失了。即可以先遍历背包后遍历物品，内层for循环也不需要倒序。</p><p><strong>参考资料</strong><br><a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.一和零</title>
    <link href="/posts/31990/"/>
    <url>/posts/31990/</url>
    
    <content type="html"><![CDATA[<h1 id="1-474一和零"><a class="markdownIt-Anchor" href="#1-474一和零"></a> 1 474.一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接</a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/"></a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4</p><p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2： 输入：strs = [“10”, “0”, “1”], m = 1, n = 1 输出：2 解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><p>提示：</p><ul><li>1 &lt;= strs.length &lt;= 600</li><li>1 &lt;= strs[i].length &lt;= 100</li><li>strs[i]&nbsp;仅由&nbsp;‘0’ 和&nbsp;‘1’ 组成</li><li>1 &lt;= m, n &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>strs 数组里的元素就是物品，每个物品都是一个！</strong><br><strong>而m 和 n相当于是一个背包，两个维度的背包</strong>。<br>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。但本题是01背包</p><p>动归五部曲</p><ol><li><p>确定dp[j]含义<br><code>dp[i][j]</code>：最多有 i个0 和 j个1的strs的<strong>最大子集的大小</strong>为<code>dp[i][j]</code><br>两个背包，一个i，一个j</p></li><li><p>确定递推公式<br><code>dp[i][j]</code> 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p></li></ol><p><code>dp[i][j]</code> 就可以是 <code>dp[i - zeroNum][j - oneNum]</code> + 1。<br>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code><br>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。后边1 就是多了所求数组中又多一个元素</p><ol start="3"><li><p>dp数组初始化<br>物品价值不会是负数，初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</p></li><li><p>遍历顺序<br>先物品在背包<br>物品就是strs里的字符串，背包容量就是题目描述中的m和n。<br>这个题是背包有两个维度，内层的for循环有两个，还是倒序遍历</p></li><li><p>打印dp数组<br>以输入：[“10”,“0001”,“111001”,“1”,“0”]，m = 3，n = 3为例</p></li></ol><p>最后dp数组的状态如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" alt="474.一和零"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>参考：[[for 循环]]<br>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs){ <span class="hljs-comment">// 遍历改位置的字符串</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 保证到下一个位置的字符，这些one zero还会初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str){ <span class="hljs-comment">// 遍历字符串的每个字符 此时应该是str,而不是strs</span><br>            <span class="hljs-keyword">if</span> ( c == <span class="hljs-string">'0'</span>) zeroNum ++;<br>            oneNum++; <span class="hljs-comment">// 得到了该字符串的01数量</span><br>            }<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--){ <span class="hljs-comment">// 最多能装多少个1</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--){ <span class="hljs-comment">// 最多能装多少个0</span><br>                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-built_in">cout</span>&lt;&lt;dp[i][j];<br>                }<br>            }<br>           <br>            <br>        }<br>  <br>        <span class="hljs-keyword">return</span> dp[m][n];<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721151503.png" alt=""></p><p><strong>参考资料</strong></p><p><a href="https://www.programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#_474-%E4%B8%80%E5%92%8C%E9%9B%B6">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.一和零</title>
    <link href="/posts/31990/"/>
    <url>/posts/31990/</url>
    
    <content type="html"><![CDATA[<h1 id="1-474一和零"><a class="markdownIt-Anchor" href="#1-474一和零"></a> 1 474.一和零</h1><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接</a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/"></a></p><p><a href="https://leetcode.cn/problems/ones-and-zeroes/">(opens new window)</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p>示例 1：</p><p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3 输出：4</p><p>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,“0001”,“1”,“0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,“1”} 和 {“10”,“1”,“0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</p><p>示例 2： 输入：strs = [“10”, “0”, “1”], m = 1, n = 1 输出：2 解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p><p>提示：</p><ul><li>1 &lt;= strs.length &lt;= 600</li><li>1 &lt;= strs[i].length &lt;= 100</li><li>strs[i]&nbsp;仅由&nbsp;‘0’ 和&nbsp;‘1’ 组成</li><li>1 &lt;= m, n &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>strs 数组里的元素就是物品，每个物品都是一个！</strong><br><strong>而m 和 n相当于是一个背包，两个维度的背包</strong>。<br>理解成多重背包的同学主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。但本题是01背包</p><p>动归五部曲</p><ol><li><p>确定dp[j]含义<br><code>dp[i][j]</code>：最多有 i个0 和 j个1的strs的<strong>最大子集的大小</strong>为<code>dp[i][j]</code><br>两个背包，一个i，一个j</p></li><li><p>确定递推公式<br><code>dp[i][j]</code> 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。</p></li></ol><p><code>dp[i][j]</code> 就可以是 <code>dp[i - zeroNum][j - oneNum]</code> + 1。<br>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><code>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</code><br>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。后边1 就是多了所求数组中又多一个元素</p><ol start="3"><li><p>dp数组初始化<br>物品价值不会是负数，初始化为0，保证递推的时候dp[i][j]不会被初始值覆盖。</p></li><li><p>遍历顺序<br>先物品在背包<br>物品就是strs里的字符串，背包容量就是题目描述中的m和n。<br>这个题是背包有两个维度，内层的for循环有两个，还是倒序遍历</p></li><li><p>打印dp数组<br>以输入：[“10”,“0001”,“111001”,“1”,“0”]，m = 3，n = 3为例</p></li></ol><p>最后dp数组的状态如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20210120111201512.jpg" alt="474.一和零"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>参考：[[for 循环]]<br>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; dp(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">string</span> str : strs){ <span class="hljs-comment">// 遍历改位置的字符串</span><br>            <span class="hljs-type">int</span> oneNum = <span class="hljs-number">0</span>, zeroNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 保证到下一个位置的字符，这些one zero还会初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : str){ <span class="hljs-comment">// 遍历字符串的每个字符 此时应该是str,而不是strs</span><br>            <span class="hljs-keyword">if</span> ( c == <span class="hljs-string">'0'</span>) zeroNum ++;<br>            oneNum++; <span class="hljs-comment">// 得到了该字符串的01数量</span><br>            }<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= zeroNum; i--){ <span class="hljs-comment">// 最多能装多少个1</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= oneNum; j--){ <span class="hljs-comment">// 最多能装多少个0</span><br>                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="hljs-number">1</span>);<br>                    <span class="hljs-built_in">cout</span>&lt;&lt;dp[i][j];<br>                }<br>            }<br>           <br>            <br>        }<br>  <br>        <span class="hljs-keyword">return</span> dp[m][n];<br><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721151503.png" alt=""></p><p><strong>参考资料</strong></p><p><a href="https://www.programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#_474-%E4%B8%80%E5%92%8C%E9%9B%B6">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16.目标和</title>
    <link href="/posts/60439/"/>
    <url>/posts/60439/</url>
    
    <content type="html"><![CDATA[<h1 id="1-目标和"><a class="markdownIt-Anchor" href="#1-目标和"></a> 1 目标和</h1><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号&nbsp;+&nbsp;和&nbsp;-。对于数组中的任意一个整数，你都可以从&nbsp;+&nbsp;或&nbsp;-中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>假设加法总和为x， → 减法总和 = sum - x。<br>目标和 = 加法总和 - 减法总和 → S = x - (sum - x)<br>→ x = (S + sum) / 2</p><p>此时化为 ：就是从数组中挑几个数加起来正好等于x</p><p><strong>特例判断</strong></p><ol><li>假设加法和是非整数，即 (S + sum) / 2 除不尽，说明有余数，又因为加法和是整数，有余数不可能符合等号条件。所以：</li></ol><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">0</span>; // 此时没有方案<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</li></ol><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>动归五部曲</p><ol><li><p>确定dp[j]的含义<br>恰好装满背包容量为j的背包，一共有dp[j]种方法</p></li><li><p>确定递推公式<br>先记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为： #card #疑问</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[j] = dp[j] + dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><p>dp数组的初始化<br>dp[0] = 1，显然装满容量为0的背包，有1种方法，就是装0件物品。<br>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出<code>dp[j] = dp[j] + dp[j - nums[i]];</code>，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p></li><li><p>确定遍历顺序<br>先物品在背包，背包for循环倒序</p></li><li><p>举例推导dp数组</p></li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> {<br>        <span class="hljs-type">int</span> bagsize;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br>        bagsize = (sum + target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagsize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagsize; j &gt;= nums[i]; j--){<br>                dp[j] = dp[j] + dp[j - nums[i]];<br>        <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[target];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720234829.png" alt=""></p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16.目标和</title>
    <link href="/posts/60439/"/>
    <url>/posts/60439/</url>
    
    <content type="html"><![CDATA[<h1 id="1-目标和"><a class="markdownIt-Anchor" href="#1-目标和"></a> 1 目标和</h1><p><a href="https://leetcode.cn/problems/target-sum/">力扣题目链接</a></p><p>难度：中等</p><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号&nbsp;+&nbsp;和&nbsp;-。对于数组中的任意一个整数，你都可以从&nbsp;+&nbsp;或&nbsp;-中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3</p><p>一共有5种方法让最终目标和为3。</p><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>假设加法总和为x， → 减法总和 = sum - x。<br>目标和 = 加法总和 - 减法总和 → S = x - (sum - x)<br>→ x = (S + sum) / 2</p><p>此时化为 ：就是从数组中挑几个数加起来正好等于x</p><p><strong>特例判断</strong></p><ol><li>假设加法和是非整数，即 (S + sum) / 2 除不尽，说明有余数，又因为加法和是整数，有余数不可能符合等号条件。所以：</li></ol><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> ((S + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) return <span class="hljs-number">0</span>; // 此时没有方案<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</li></ol><figure class="highlight arcade"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(S) &gt; <span class="hljs-built_in">sum</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br></code></pre></td></tr></tbody></table></figure><p>动归五部曲</p><ol><li><p>确定dp[j]的含义<br>恰好装满背包容量为j的背包，一共有dp[j]种方法</p></li><li><p>确定递推公式<br>先记住：在<strong>求装满背包有几种方法</strong>的情况下，递推公式一般为： #card #疑问</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[j] = dp[j] + dp[j - nums[i]];<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><p>dp数组的初始化<br>dp[0] = 1，显然装满容量为0的背包，有1种方法，就是装0件物品。<br>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出<code>dp[j] = dp[j] + dp[j - nums[i]];</code>，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p></li><li><p>确定遍历顺序<br>先物品在背包，背包for循环倒序</p></li><li><p>举例推导dp数组</p></li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4</p><p>dp数组状态变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译未通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> {<br>        <span class="hljs-type">int</span> bagsize;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br>        bagsize = (sum + target)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagsize + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(target) &gt; sum) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <span class="hljs-keyword">if</span> ((target + sum) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 此时没有方案</span><br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = bagsize; j &gt;= nums[i]; j--){<br>                dp[j] = dp[j] + dp[j - nums[i]];<br>        <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[target];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720234829.png" alt=""></p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">代码随想录</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.动归周总结</title>
    <link href="/posts/47640/"/>
    <url>/posts/47640/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> <strong>参考资料</strong></h2><p>自用跳转链接：🈚</p><p>也添加在11-14的文档中</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian flashcard 插件</title>
    <link href="/posts/11266/"/>
    <url>/posts/11266/</url>
    
    <content type="html"><![CDATA[<p>插件：flashcard的使用方法：<a href="https://github.com/reuseman/flashcards-obsidian/wiki">Home · reuseman/flashcards-obsidian Wiki · GitHub</a></p><h1 id="1-简单配置"><a class="markdownIt-Anchor" href="#1-简单配置"></a> 1 简单配置</h1><p>anki connect 添加</p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c">{<br>    <span class="hljs-string">"apiKey"</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">"apiLogPath"</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">"webBindAddress"</span>: <span class="hljs-string">"127.0.0.1"</span>,<br>    <span class="hljs-string">"webBindPort"</span>: <span class="hljs-number">8765</span>,<br>    <span class="hljs-string">"webCorsOrigin"</span>: <span class="hljs-string">"http://localhost"</span>,<br>    <span class="hljs-string">"webCorsOriginList"</span>: [<br>        <span class="hljs-string">"http://localhost"</span>,<br>        <span class="hljs-string">"app://obsidian.md"</span>   <span class="hljs-meta">## 添加这一个</span><br>    ] <br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-无法添加的解决方法"><a class="markdownIt-Anchor" href="#2-无法添加的解决方法"></a> 2 无法添加的解决方法</h1><ol><li>anki 不能在浏览页面</li><li>删除id后，anki牌组不能有之前文件</li><li>问题前面加一个标题，添加后，然后在删掉就行</li><li>yaml字段自动生成的card-deck 字段，相对(valut)的路径不应太长，否则就只能添加Default</li></ol><p>小问题<br>根据文件夹创建目录，如果文件夹的层级太多就会失效</p><h1 id="3-使用"><a class="markdownIt-Anchor" href="#3-使用"></a> 3 使用</h1><h2 id="31-分隔符"><a class="markdownIt-Anchor" href="#31-分隔符"></a> 3.1 分隔符</h2><ol><li>::</li></ol><center> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721165055.png"> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721165345.png"> </center><center> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721164811.png"> <img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220721164922.png"> </center><ol start="2"><li>:::<br><img src="" alt=""></li></ol>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.最后一块石头的重量 II</title>
    <link href="/posts/62628/"/>
    <url>/posts/62628/</url>
    
    <content type="html"><![CDATA[<h1 id="1-11049最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1-11049最后一块石头的重量-ii"></a> 1 11049.最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;x 和&nbsp;y，且&nbsp;x &lt;= y。那么粉碎的可能结果如下：</p><p>如果&nbsp;x == y，那么两块石头都会被完全粉碎； 如果&nbsp;x != y，那么重量为&nbsp;x&nbsp;的石头将会完全粉碎，而重量为&nbsp;y&nbsp;的石头新重量为&nbsp;y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>1049.最后一块石头的重量 II 为什么能转化为 01背包问题 #card  #已解决<br>自顶向下的考虑，算出所有石头的重量和，如果能分成一半一半，那说明正好可以撞完<br>如果不能恰好分成一半一半，让分成的两大块尽量靠近一半。一边大一边小，相减也得到碰撞后的最小重量<br>问题就变成了：创造一个sum/2的背包。在这个背包里尽量装满。<br>如果背包装的满即表示能分成一半一半，也就是最后能撞完。<br>如果没装完，(sum- 装的重量) - 装的重量= half<sup>+</sup>  - half<sup>-</sup> = 相撞后的重量<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720164608.png" alt=""></p><p>本题物品的重量为store[i]，物品的价值也为store[i]。重量和价值是一样的<br>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p><ol><li><p>确定dp[j]的含义<br>j背包下最多可以装dp[j]的重量</p></li><li><p>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li><p>dp数组的初始化 #card #疑问<br>为什么要要一半<br>题目如下要求，最多重量是30000</p></li></ol><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000<br>我们只需要计划总重量的一半<br>dp数组的大小为15000，都初始化为0：<code>vector&lt;int&gt; dp(15001, 0);</code> 从0开始，要多一位</li></ul><ol start="4"><li><p>遍历顺序<br>先物品在背包，背包循环倒序</p></li><li><p>打印dp数组<br>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：<br>用store[1]遍历时<br>dp[4] = max(dp[4], dp[4 - store[1]]+ store[1]) =max(2, 2+2)<br><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p></li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> {<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>,<span class="hljs-number">0</span>)</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            sum += stones[i];<br>        }<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--){<br>                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> (sum - dp[target]) - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>本题与[[13.分割等和子集]]一个类型，不同之处是前者要求能装多少装多，后者要求正好装满</p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1G3411E7oX?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode1049 最后一块石头的重量II 题解_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.最后一块石头的重量 II</title>
    <link href="/posts/62628/"/>
    <url>/posts/62628/</url>
    
    <content type="html"><![CDATA[<h1 id="1-11049最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1-11049最后一块石头的重量-ii"></a> 1 11049.最后一块石头的重量 II</h1><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接</a></p><p>题目难度：中等</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;x 和&nbsp;y，且&nbsp;x &lt;= y。那么粉碎的可能结果如下：</p><p>如果&nbsp;x == y，那么两块石头都会被完全粉碎； 如果&nbsp;x != y，那么重量为&nbsp;x&nbsp;的石头将会完全粉碎，而重量为&nbsp;y&nbsp;的石头新重量为&nbsp;y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：</p><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>1049.最后一块石头的重量 II 为什么能转化为 01背包问题 #card #疑问 #已解决<br>自顶向下的考虑，算出所有石头的重量和，如果能分成一半一半，那说明正好可以撞完<br>如果不能恰好分成一半一半，让分成的两大块尽量靠近一半。一边大一边小，相减也得到碰撞后的最小重量<br>问题就变成了：创造一个sum/2的背包。在这个背包里尽量装满。<br>如果背包装的满即表示能分成一半一半，也就是最后能撞完。<br>如果没装完，(sum- 装的重量) - 装的重量= half<sup>+</sup>  - half<sup>-</sup> = 相撞后的重量<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220720164608.png" alt=""></p><p>本题物品的重量为store[i]，物品的价值也为store[i]。重量和价值是一样的<br>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p><ol><li><p>确定dp[j]的含义<br>j背包下最多可以装dp[j]的重量</p></li><li><p>递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br><strong>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p></li><li><p>dp数组的初始化 #card #疑问<br>为什么要要一半<br>题目如下要求，最多重量是30000</p></li></ol><ul><li>1 &lt;= stones.length &lt;= 30</li><li>1 &lt;= stones[i] &lt;= 1000<br>我们只需要计划总重量的一半<br>dp数组的大小为15000，都初始化为0：<code>vector&lt;int&gt; dp(15001, 0);</code> 从0开始，要多一位</li></ul><ol start="4"><li><p>遍历顺序<br>先物品在背包，背包循环倒序</p></li><li><p>打印dp数组<br>举例，输入：[2,4,1,1]，此时target = (2 + 4 + 1 + 1)/2 = 4 ，dp数组状态图如下：<br>用store[1]遍历时<br>dp[4] = max(dp[4], dp[4 - store[1]]+ store[1]) =max(2, 2+2)<br><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p></li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> {<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>,<span class="hljs-number">0</span>)</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            sum += stones[i];<br>        }<br><br>        <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.size(); i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= stones[i]; j--){<br>                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> (sum - dp[target]) - dp[target];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4 总结</h1><p>本题与[[13.分割等和子集]]一个类型，不同之处是前者要求能装多少装多，后者要求正好装满</p><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1G3411E7oX?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode1049 最后一块石头的重量II 题解_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图床的设置</title>
    <link href="/posts/25586/"/>
    <url>/posts/25586/</url>
    
    <content type="html"><![CDATA[<p>前期设置参考以下文章<br><a href="https://blog.csdn.net/qq_38163244/article/details/110637898?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165814246716781790729080%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165814246716781790729080&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-110637898-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Etag_show&amp;utm_term=%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BE%E5%BA%8A&amp;spm=1018.2226.3001.4187">阿里云搭建图床_理科男同学的博客-CSDN博客_阿里云图床</a></p><p>picgo如何添加设置<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220718191920.png" alt=""><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/cf534d30e5f74c2b2bbf1545bfb68f3.png" alt=""></p><p>LTAI5tLUoXsgd7XWbdxf9ig2<br>lRXSiwrDFzVeqOsECPaIH9viKeof3p</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.分割等和子集</title>
    <link href="/posts/38902/"/>
    <url>/posts/38902/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分割等和子集"><a class="markdownIt-Anchor" href="#1-分割等和子集"></a> 1 分割等和子集</h1><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接</a></p><p>题目难易：中等</p><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p><p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例&nbsp;2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>1 &lt;= nums[i] &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p><p>只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p><p>背包的总容量为 sum/2，每个物品的价值就是他们数组值(应该是这样咯)</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum / 2</li><li>背包要放入的物品（集合里的元素）重量为 元素的数值，价值也为元素的数值(重量与价值相等)</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。(01背包：每个物品只放一次)</li></ul><ol><li><p>确定dp数组以及下的含义<br>01背包中，dp[j] 表示： 容量为j的背包，所背的物品最大价值为dp[j]。<br><strong>套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]</strong></p></li><li><p>确定递推公式<br>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</p></li><li><p>dp数组如何初始化<br>全部初始化为0</p></li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br><span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>, <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序<br>先物品在背包，for循环第二层倒序</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 开始 01背包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) {<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;= nums[i]; j--) { <span class="hljs-comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span><br>        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>dp[j]的数值一定是小于等于j的。因为dp[j]是价值，j是背包容量</p><p><strong>如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，即价值=容量，理解这一点很重要。</strong></p><blockquote><p>因为按本题来说：价值等于背包容量</p></blockquote><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210110104240545.png" alt="416.分割等和子集2"></p><p>一层一层的，从后往前赋值的</p><p>最后dp[11] == 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> target;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++){<br>            sum += nums[i];<br>        }<br>        target = sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = target; j &gt;=nums[i]; j--){<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j-nums[i]]+nums[i]); <br>            }<br>        }<br>        <span class="hljs-keyword">if</span> (dp[target]==target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>[13.mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/动态规划/13.分割等和子集.mp4)</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.0-1背包理论基础（二）</title>
    <link href="/posts/38995/"/>
    <url>/posts/38995/</url>
    
    <content type="html"><![CDATA[<h1 id="1-滚动数组思路"><a class="markdownIt-Anchor" href="#1-滚动数组思路"></a> 1 滚动数组思路</h1><p>滚动数组，就是把二维dp降为一维dp<br><strong>如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p><blockquote><p>上一次的i,j 的值存在max里边，不断的比较得到最大值</p></blockquote><p>滚动数组：在同一层中，不断的进行覆盖然后刷新</p><p>动规五部曲分析如下：</p><h2 id="11-确定dp数组的定义"><a class="markdownIt-Anchor" href="#11-确定dp数组的定义"></a> 1.1 确定dp数组的定义</h2><p>dp[j]：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><h2 id="12-一维dp数组的递推公式"><a class="markdownIt-Anchor" href="#12-一维dp数组的递推公式"></a> 1.2 一维dp数组的递推公式</h2><p>整体思路： 想想如何从前面的数推过来</p><p>dp[j]有两个选择，<br>不放物品i：dp[j]， 未覆盖的值</p><p>放物品i：dp[j - weight[i]] + value[i]，覆盖后的值<br>(总重量 - 要放物品的重量)的最大价值+要放物品的价值<br>除去要放物品的背包 的价值 + 要放物品的价值<br>Q：万一放不了呢，之前二维数组是有一个判断语句，一维中没有啊？<br>A：<code>for(int j = bagWeight; j &gt;= weight[i]; j--)</code>。一维中也有判断语句，进入for循环的条件是背包容量大于所放物品i的重量</p><figure class="highlight inform7"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[j]</span> = max(dp<span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[j - weight<span class="hljs-comment">[i]</span>]</span> + value<span class="hljs-comment">[i]</span>);<br></code></pre></td></tr></tbody></table></figure><h2 id="13-一维dp数组如何初始化"><a class="markdownIt-Anchor" href="#13-一维dp数组如何初始化"></a> 1.3 一维dp数组如何初始化</h2><p>dp[0]=0：背包容量为0所背的物品的最大价值是0<br>其他的值都初始为0就行，因为递推公式中会赋值<br>不能初始化太大的值，防止取最大值的时候覆盖掉真实结果<br><strong>总结</strong>：其实全部初始化为0即可</p><h2 id="14-一维dp数组遍历顺序"><a class="markdownIt-Anchor" href="#14-一维dp数组遍历顺序"></a> 1.4 一维dp数组遍历顺序</h2><p><strong>只能先物品后背包</strong><br>如果顺序被颠倒，那么dp数组中记录的都是一个物品的数值了<br><strong>倒序遍历：保证物品只放入一次</strong><br>看下面的例子</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品，二维数组的行，反复覆盖</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// j = 背包容量，也不要忘了=（背包容量等于重量时也可以加入的）</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<span class="hljs-comment">// 不断更新该行的列向量</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>为什么不能正序遍历：例子<br>?<br><code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code><br>物品0的重量<strong>weight[0] = 1</strong>，价值<strong>value[0] = 15</strong><br>如果正序遍历，此时//  [[for 循环]]</p><p>正序循环中的第二for循环的条件应该怎么写  #card #已解决</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 先遍历物品，再遍历背包，内层for循环正序遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>dp[1] = dp[1 - weight[0]] + value[0] = 15<br>dp[2] = dp[2 - weight[0]] + value[0] = 30<br>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历<br>说白了，当前dp[i]要使用上一层左侧的dp值，正序覆盖了上一层左侧的dp值，倒叙避免了覆盖</p><p>倒序遍历：<br><code>vector&lt;int&gt; dp(bagWeight + 1, 0);</code> 原来的初始化是0<br>dp[2] = dp[2 - weight[0]] + value[0] = 15</p><blockquote><p>倒序计算时，由于 dp 数组初始化为 0，所以 dp[2-1] 为 0，所以 dp[2] 为 15</p></blockquote><p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p><h2 id="15-举例推导dp数组"><a class="markdownIt-Anchor" href="#15-举例推导dp数组"></a> 1.5 举例推导dp数组</h2><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p><h1 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2 代码</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test_1_wei_bag_problem</span><span class="hljs-params">()</span> {<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagWeight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span><span class="hljs-params">(bagWeight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = bagWeight; j &gt;= weight[i]; j--) { <span class="hljs-comment">// 遍历背包容量</span><br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    <span class="hljs-built_in">cout</span> &lt;&lt; dp[bagWeight] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br>    test_1_wei_bag_problem();<br>}<br></code></pre></td></tr></tbody></table></figure><p>一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了，<strong>空间复杂度还降了一个数量级</strong><br>推荐用一维数组</p><h1 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3 总结</h1><h2 id="31-面试问题"><a class="markdownIt-Anchor" href="#31-面试问题"></a> 3.1 面试问题</h2><p>要求先实现一个纯二维的01背包,如果写出来了,然后再问为什么两个for循环的嵌套顺序这么写?反过来写行不行 #card<br>第一种是先物品后背包的遍历，根据状态转移方程可得，当前值由该位置的上方和左上上方来确定，首先初始化了第一行和第一列的值，这种先物品后背包的方式，是从左到右的一个个行遍历赋值。遍历到<code>dp[i][j]</code>时，它的上方和左上方都赋值完毕，可以推导出来<br>第二种是先背包后物品的遍历，遍历方式是从上到下的一列一列的遍历赋值。遍历到<code>dp[i][j]</code>时，它的整个左部分都赋值完毕，上方也赋值了。同理可推导出来。<br>所以反过来写是可以的</p><p>[[讲一讲01背包初始化的逻辑。]]</p><p>一维数组的01背包，两个for循环的顺序反过来写行不行 #card #疑问<br>不行，</p><p>注意以上问题都是在候选人把代码写出来的情况下才问的。</p><hr><p><strong>参考资料</strong><br>自用跳转链接：🈚<br><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a></p><p>[[测试deck]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名失效问题</title>
    <link href="/posts/62729/"/>
    <url>/posts/62729/</url>
    
    <content type="html"><![CDATA[<p>本地source文件添加一个文件：CNAME文件(不要任何的后缀)</p><p>下一次hexo d 就会传上去</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub如何取消域名绑定</title>
    <link href="/posts/14830/"/>
    <url>/posts/14830/</url>
    
    <content type="html"><![CDATA[<p>删除本地source下的CNAME和GitHub上的CNAME文件<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121716990.png" alt=""></p><p>清楚浏览器缓冲<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121715979.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo如何创建短的url</title>
    <link href="/posts/15258/"/>
    <url>/posts/15258/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/rozbo/hexo-abbrlink2">GitHub - rozbo/hexo-abbrlink2</a></p><p>安装插件→添加config信息</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度分析</title>
    <link href="/posts/30256/"/>
    <url>/posts/30256/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><h1 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1 概念</h1><h2 id="11-定义sup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-label关于时间复杂度你不知道的都在这里-代码随想录"><a class="markdownIt-Anchor" href="#11-定义sup-idfnref1-classfootnote-refa-hreffn1-relfootnotespan-classhinttop-hintrounded-aria-label关于时间复杂度你不知道的都在这里-代码随想录"></a> 1.1 定义<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;span class=“hint–top hint–rounded” aria-label="关于时间复杂度，你不知道的都在这里！ | 代码随想录</a></sup></h2><a href="#fn:1" rel="footnote"></a><p><a href="#fn:1" rel="footnote">"&gt;[1]</a></p><p><strong>时间复杂度是一个函数，它定性描述该算法的运行时间</strong>。<br>估计程序运行时间：通常会估算算法的<strong>操作单元数量</strong>来代表程序消耗的时间</p><blockquote><p>这里默认CPU的每个单元运行消耗的时间都是相同的。</p></blockquote><p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p><p>时间复杂度对应的是物理上的加速度<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="1-4 初识时间复杂度_哔哩哔哩_bilibili">[2]</span></a></sup><br>![[时间复杂度分析 2022-08-05 17.27.42.excalidraw]]</p><h2 id="12-复杂度分析"><a class="markdownIt-Anchor" href="#12-复杂度分析"></a> 1.2 复杂度分析</h2><p>复杂度分析只考虑最坏的情况<br><strong>大O用来表示上界的</strong>，它作为算法的最坏情况运行时间的上界</p><p>我们主要关心的还是一般情况下的数据形式。</p><p><strong>面试中说道算法的时间复杂度是多少，指的都是一般情况</strong>。但是如果面试官和我们深入探讨一个算法的实现以及性能的时候，就要时刻想着数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。</p><h2 id="13-不同数据规模的差异"><a class="markdownIt-Anchor" href="#13-不同数据规模的差异"></a> 1.3 不同数据规模的差异</h2><p><img src="https://img-blog.csdnimg.cn/20200728191447384.png" alt="时间复杂度，不同数据规模的差异|500"></p><p><strong>我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong>：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^{2})&lt;O(2^{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208051803308.png" alt=""></p><p>但是也要注意大常数，如果这个常数非常大，例如10^7 ，10^9 ，那么常数就是不得不考虑的因素了<br>在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用O(n^2)的算法比O(n)的更合适（在有常数项的时候）</p><h2 id="14-ologn中的log是以什么为底"><a class="markdownIt-Anchor" href="#14-ologn中的log是以什么为底"></a> 1.4 O(logn)中的log是以什么为底？</h2><p><strong>logn，也就是忽略底数的描述</strong>。也可以是以10为底n的对数，也可以是以20为底n的对数，等等<br><code>以2为底n的对数 = 以2为底10的对数 * 以10为底n的对数</code>。<br>而以2为底10的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121533152.png" alt="|500"></p><h1 id="2-常见的时间复杂度"><a class="markdownIt-Anchor" href="#2-常见的时间复杂度"></a> 2 常见的时间复杂度</h1><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121507462.png" alt="|600"><br>快速排序：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> : sort 函数[[sort函数]]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202208051803308.png" alt=""></p><h1 id="3-计算时间复杂度"><a class="markdownIt-Anchor" href="#3-计算时间复杂度"></a> 3 计算时间复杂度</h1><p>时间复杂的是看<strong>次数</strong><sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="">[3]</span></a></sup><br>![[时间复杂度分析 2022-08-05 18.11.16.excalidraw]]</p><h2 id="31-普通类型"><a class="markdownIt-Anchor" href="#31-普通类型"></a> 3.1 普通类型</h2><p><s>乘法：乘法操作的时间复杂度 = O(1) ：O(n) 就是乘n次</s><br><s>加法：一般忽略，但从0加到n的为O(n)的复杂度</s></p><h2 id="32-函数类型"><a class="markdownIt-Anchor" href="#32-函数类型"></a> 3.2 函数类型</h2><ol><li>for循环嵌套：循环</li><li>if else：选择分支内最大的复杂度</li><li>[[递归算法的复杂度]]：递归次数 * 每次递归的操作次数</li></ol><h2 id="33-其他类型"><a class="markdownIt-Anchor" href="#33-其他类型"></a> 3.3 其他类型</h2><ol><li>两端算法相加时，取两者最大值：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>O</mi><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>O</mi><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)+T_2(n)=max(Of_1(n),Of_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，eg：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>5</mn></msup><mo>+</mo><mi>n</mi><mo>=</mo><msup><mi>n</mi><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n^5+n=n^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li><li>两段算法嵌套时：为两者相乘：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)*T_2(n)=O(f_1(n)*f_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，eg：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><msup><mi>n</mi><mn>2</mn></msup><mo>=</mo><msup><mi>n</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n^{2}*n^{2}=n^{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span></li><li>有两算法时,本质是时间复杂度为两个函数相加, 但最终结果还是取的大头<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[4. 有序数组的平方]]">[4]</span></a></sup></li></ol><h1 id="4-例子"><a class="markdownIt-Anchor" href="#4-例子"></a> 4 例子</h1><h2 id="41-找出n个字符串中相同的两个字符串假设这里只有两个相同的字符串"><a class="markdownIt-Anchor" href="#41-找出n个字符串中相同的两个字符串假设这里只有两个相同的字符串"></a> 4.1 找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）。</h2><p>先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起，然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。</p><p>那看看这种算法的时间复杂度，快速排序时间复杂度为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m × n × log n) 。</p><h2 id="42-01背包"><a class="markdownIt-Anchor" href="#42-01背包"></a> 4.2 01背包</h2><p>暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里的n表示物品数量。</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.programmercarl.com/%E5%89%8D%E5%BA%8F/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%81.html#%E7%A9%B6%E7%AB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">关于时间复杂度，你不知道的都在这里！ | 代码随想录</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV11h411h7nT?p=4&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">1-4 初识时间复杂度_哔哩哔哩_bilibili</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>[[4. 有序数组的平方]]<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>1.算法性能分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.0-1背包理论基础</title>
    <link href="/posts/8980/"/>
    <url>/posts/8980/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p><h1 id="1-01-背包"><a class="markdownIt-Anchor" href="#1-01-背包"></a> 1 01 背包</h1><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题|600"><br><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p><p>01 背包：一个商品只能放入一次<br>完全背包：即物品无限个，可多次放入背包<br>多重背包：每个物品，数量不同</p><p>原始可用暴力解法<br>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><h1 id="2-二维dp数组01背包"><a class="markdownIt-Anchor" href="#2-二维dp数组01背包"></a> 2 二维dp数组01背包</h1><p>背包最大重量为4。</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><ol><li>确定dp数组以及下标的含义<br>对于背包问题，有一种写法， 是使用二维数组，<strong>即<code>dp[i][j]</code> 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。<br><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1|600"></li><li>递推公式<br>有两个方向推出来<code>dp[i][j]</code>，</li></ol><ul><li><strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>、头顶格子</li></ul><blockquote><p>(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)<br>i-1是指：只能选择的物品范围是 i-1，而不是真的放了i-1个物品</p></blockquote><ul><li><strong>放物品i</strong>：<code>dp[i - 1][j - weight[i]] + value[i]</code> ，左上方格子</li></ul><blockquote><p>某一列中缺失掉哪一个物品</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719160159.png" alt=""></p><p>从两个方向推出来：1.头顶上一格  2.左上角的一块地方(不是左上角一格)</p><p>所以递归公式：</p><p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs col">```<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155624.png)<br><br>以`dp[1] [3]`为例<br>`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`<br>`dp[1][3] = max(dp[0][3], dp[0][3 - weight[1]] + value[1]);`<br><br>头顶格子：20之前那的值是15，原因是背包重量不够装物品1，即为`dp[i - 1][j]`，`dp[1 -1= 0][3]` ：即头顶格子<br>左上方格子：`dp[0][3 - weight[1]] + value[1]`=`dp[0][0] + value[1]`：(减去要装的重量)的价值 + 要装的价值<br>为什么要取最大值呢<br>?<br>因为装了物品i，有可能会导致前边的一些物品丢弃掉。而丢弃的物品可能价值很大。所以要比较他们的最大值<br><br><br><br><br><br>3.  dp数组如何初始化<br>初始化第一行，第一列。剩下元素即可都推出来<br>从两个方向推出来：1.头顶上一格  2.左上方(不是左上角)<br><br><br>第一列：背包容量为0，一个也装不了，总价值当然为0<br>第一行：物品0的重量为1，所以背包容量&gt;1都可以装物品0一个，所以价值是15<br>![动态规划-背包问题7|600](https://img-blog.csdnimg.cn/20210110103109140.png)<br>其余未赋值的都保持默认0即可，反正最后都会被覆盖掉<br>[[vector]]<br>```c<br>// 初始化 dp<br>vector&lt;vector&lt;int&gt;&gt; dp(weight.size(), vector&lt;int&gt;(bagweight + 1, 0));<br>for (int j = weight[0]; j &lt;= bagweight; j++) {<br>    dp[0][j] = value[0];<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序<br>有两个遍历的维度：物品与背包重量</li></ol><p><strong>先遍历 物品还是先遍历背包重量都可以</strong><br>先物品在背包，就是一行一行的遍历(从左到右)，遍历到20时，他的左上方和上方都有值<br>先背包在物品，就是一列一列的遍历(从上到下)，遍历到20时，他的左边全部有值(即左上面有值)，上方也全都有值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs col">![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155624.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/20220719155536.png)<br></code></pre></td></tr></tbody></table></figure><p><strong>先遍历物品更好理解</strong>，如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];  <span class="hljs-comment">// i的重量太大，放不下</span><br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><p>先遍历背包</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.size(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_2_wei_bag_problem1</span><span class="hljs-params">()</span> </span>{<br>    vector&lt;<span class="hljs-type">int</span>&gt; weight = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    vector&lt;<span class="hljs-type">int</span>&gt; value = {<span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>};<br>    <span class="hljs-type">int</span> bagweight = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 二维数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(weight.<span class="hljs-built_in">size</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(bagweight + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = weight[<span class="hljs-number">0</span>]; j &lt;= bagweight; j++) {<br>        dp[<span class="hljs-number">0</span>][j] = value[<span class="hljs-number">0</span>];<br>    }<br><br>    <span class="hljs-comment">// weight数组的大小 就是物品个数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; weight.<span class="hljs-built_in">size</span>(); i++) { <span class="hljs-comment">// 遍历物品</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= bagweight; j++) { <span class="hljs-comment">// 遍历背包容量</span><br>            <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br><br>        }<br>    }<br><br>    cout &lt;&lt; dp[weight.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>][bagweight] &lt;&lt; endl;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">test_2_wei_bag_problem1</span>();<br>}<br><br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1cg411g7Y6/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">带你学透0-1背包问题！| 关于背包问题，你不清楚的地方，这里都讲了！| 动态规划经典问题 | 数据结构与算法_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术蛋老师(git)</title>
    <link href="/posts/29642/"/>
    <url>/posts/29642/</url>
    
    <content type="html"><![CDATA[<p>文章简介：git 怎么用</p><span id="more"></span><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121133310.png" alt=""></p><p>先用git clone 与文件夹创建联系<a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=871.798444">14:31</a><br>git remote add origin <a href="https://gitee.com/liuqingzheng/test.git">https://gitee.com/liuqingzheng/test.git</a> 添加远程仓库<br>git remote -v 查看本地仓库与哪些远程仓库有联系 <a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=914.211131">15:14</a></p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1r3411F7kn?spm_id_from=333.851.b_7265636f6d6d656e64.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Git工作流和核心原理 | GitHub基本操作 | VS Code里使用Git和关联GitHub_哔哩哔哩_bilibili</a><br>自用跳转连接：🈚️</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.不同的二叉搜索树</title>
    <link href="/posts/45809/"/>
    <url>/posts/45809/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——96.不同的二叉搜索树</p><span id="more"></span><h1 id="1-96不同的二叉搜索树"><a class="markdownIt-Anchor" href="#1-96不同的二叉搜索树"></a> 1 96.不同的二叉搜索树</h1><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接</a></p><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121031374.png" alt=""></p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>[[二叉搜索树]]</p><p>五部曲</p><ol><li><p>确定dp数组（dp table）以及下标的含义<br><strong>dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]</strong>。</p></li><li><p>确定递推公式<br>dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121051970.png" alt=""></p></li></ol><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量<br>所以是<strong>求和</strong><br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207121103402.png" alt=""></p><ol start="3"><li><p>dp数组如何初始化<br>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树<br>dp[0] = 1<br>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。</p></li><li><p>确定遍历顺序<br>顺序遍历<br>dp[i] += dp[j - 1] * dp[i - j]可以看出，<strong>节点数为i的状态是依靠 i之前节点数的状态</strong>。</p></li><li><p>举例推导dp数组<br>n为5时候的dp数组状态如图：</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"><br>[[vector]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){ <span class="hljs-comment">// 从3开始赋值,如果没有上面的if就会 i = 3  ，i &lt;= 1，就错了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++){<span class="hljs-comment">// j从第二个数开始才能划分左右部分，所以是1</span><br>                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Qf4y1K72t?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">leetcode96题 不同的二叉搜索树_哔哩哔哩_bilibili</a><br><a href="https://www.programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.整数拆分</title>
    <link href="/posts/5255/"/>
    <url>/posts/5255/</url>
    
    <content type="html"><![CDATA[<h1 id="1-343整数拆分"><a class="markdownIt-Anchor" href="#1-343整数拆分"></a> 1 343.整数拆分</h1><p><a href="https://leetcode.cn/problems/integer-break/">力扣题目链接</a></p><p>给定一个正整数&nbsp;n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><ul><li>输入: 2</li><li>输出: 1</li><li>解释: 2 = 1 + 1, 1 × 1 = 1。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: 10</li><li>输出: 36</li><li>解释: 10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。</li><li>说明: 你可以假设&nbsp;n&nbsp;不小于 2 且不大于 58。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-动态规划"><a class="markdownIt-Anchor" href="#21-动态规划"></a> 2.1 动态规划</h2><p>将数的拆分想象成块的切分<br>2,3不切分，因为切分来会变小<br>如果不用去写dp初始值，可以在转移方程里面再加上一个和j * i-j的最大值比较<br>两个for循环是标准的动归写法</p><ol><li>确定dp数组（dp table）以及下标的含义<br>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</li><li>确定递推公式<br>下面这样写需要提前定义2,3不可拆定义出来他们的dp值，因为他俩不用拆是最大<br>dp[i] = max({dp[i],dp[j] * dp[i-j] );<br>dp[i]是随着i的值在一直变化的，max 中有dp[i]就是保证，不断变化中的值取最高的那一个<br>j是切的位置，把一个数切成两部分，而这左右两部分又可以在切。也就是dp[j]，dp[i-j]，也是默认将一个数强制拆成4份以及4份以上了。</li></ol><p>或者这样，不用提前定义dp[2]，dp[3]<br>dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));<br>3. dp的初始化<br>dp[0] dp[1]无意义，没法拆，所以不赋值。从dp[2] = 1开始，把dp[3] = 2。<br>2，3不用拆是最大的</p><h2 id="22-贪心算法"><a class="markdownIt-Anchor" href="#22-贪心算法"></a> 2.2 贪心算法</h2><p>数学已证明过：<strong>每次拆成n个3，如果剩下是4，则保留4，然后相乘</strong><br>尽量切3，最后切2，2和3是最稳定最稳定不可拆分质数</p><blockquote><p>1，2，3不划分最大，一划分反而变小了</p></blockquote><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-动态规划"><a class="markdownIt-Anchor" href="#31-动态规划"></a> 3.1 动态规划</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){ <span class="hljs-comment">// 应该从数字4开始，对应的下标是5 </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){ <span class="hljs-comment">// 切一半就行，另一半是对称的</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j*(i-j), j*dp[i-j])); <span class="hljs-comment">// 后一个max中是数的相乘 和 数和上一次的最优结果相乘</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 2，3不切分，要这样赋值下面才能通过</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++){<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i/<span class="hljs-number">2</span>; j++){<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j]*dp[i-j]);<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>如果递归公式是 dp[i] = max(dp[i], dp[i - j] * dp[j]);，就一定要这么初始化。递推公式没毛病，但初始化解释不通！</p><p>虽然代码在初始位置有一个判断if (n &lt;= 3) return 1 * (n - 1);，保证n&lt;=3 结果是正确的，但代码后面又要给dp[1]赋值1 和 dp[2] 赋值 2，<strong>这其实就是自相矛盾的代码，违背了dp[i]的定义！</strong></p><p>我举这个例子，其实就说做题的严谨性，上面这个代码也可以AC，大体上一看好像也没有毛病，递推公式也说得过去，但是仅仅是恰巧过了而已<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112130227.png" alt=""><br>// 错了的原因是dp[1]是0，必须定义dp[1] = 1,另外还有其他的原因</p><h2 id="32-贪心"><a class="markdownIt-Anchor" href="#32-贪心"></a> 3.2 贪心</h2><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// 要有 = 4的判断，不然4的没法输出</span><br>                <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;，<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">4</span>){<br>            result *= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">3</span>;<br>        }<br>        <span class="hljs-keyword">return</span> result * n;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207112032423.png" alt=""></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.bilibili.com/video/BV1Nt4y1D7gh?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">LeetCode每日打卡.343.整数拆分_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.不同路径 II</title>
    <link href="/posts/13413/"/>
    <url>/posts/13413/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——63. 不同路径 II</p><span id="more"></span><h1 id="1-63不同路径-ii"><a class="markdownIt-Anchor" href="#1-63不同路径-ii"></a> 1 63.不同路径 II</h1><p><a href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次<strong>只能向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑<strong>网格中有障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="https://img-blog.csdnimg.cn/20210111204901338.png" alt=""></p><p><strong>网格中的障碍物和空位置分别用 1 和 0 来表示。</strong></p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210111204939971.png" alt=""></p><ul><li>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</li><li>输出：2 解释：</li><li>3x3 网格的正中间有一个障碍物。</li><li>从左上角到右下角一共有 2 条不同的路径：<ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/20210111205857918.png" alt=""></p><ul><li>输入：obstacleGrid = [[0,1],[0,0]]</li><li>输出：1</li></ul><p>提示：</p><ul><li>m ==&nbsp;obstacleGrid.length</li><li>n ==&nbsp;obstacleGrid[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>相比[[6.不同路径]]不同的是多了障碍，遇到障碍<code>dp[i][j]</code>保持0就可以了：表示过不去</p><p>两个地方需要跳过赋值</p><ol><li>初始值(第一行第一列)，跳过有障碍的地方在赋值</li><li>递推公式中(除了第一行第一列的)，跳过有障碍的地方在赋值</li></ol><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{<br>        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>; i++) dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>; j++) dp[j][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">0</span>){ <span class="hljs-comment">// if (obstacleGrid[i][j] == 1) continue;</span><br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.不同路径</title>
    <link href="/posts/31702/"/>
    <url>/posts/31702/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——62.不同路径</p><span id="more"></span><h1 id="1-62不同路径"><a class="markdownIt-Anchor" href="#1-62不同路径"></a> 1 62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p><p>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt=""></p><ul><li>输入：m = 3, n = 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m = 2, n = 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m = 7, n = 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m = 3, n = 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-图论"><a class="markdownIt-Anchor" href="#21-图论"></a> 2.1 图论</h2><p>暂定</p><h2 id="22-数论"><a class="markdownIt-Anchor" href="#22-数论"></a> 2.2 数论</h2><p>暂定</p><h2 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h2><p>m✖️n：行✖️列<br>按照动规五部曲来分析：</p><p><strong>1. 确定dp数组（dp table）以及下标的含义</strong><br><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。<br><strong>2. 确定递推公式</strong><br>机器人只能向下或向右移动<br>所以<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。(上面，左面)<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为只能从上面或者左面过来<br><strong>3.  dp数组的初始化</strong><br>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。<br>所以初始化代码为：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>4.  确定遍历顺序</strong><br>这里要看一下递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套</p><p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p><p><strong>5.  举例推导dp数组</strong></p><p>如图所示：<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[2][2] = dp[1][2] + dp[2][1]</code>，<code>dp[3][7] = dp[2][7] + dp[3][6]</code> 上面/左面<br><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-二维数组解法编译已通过"><a class="markdownIt-Anchor" href="#31-二维数组解法编译已通过"></a> 3.1 二维数组解法，编译已通过</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){ <span class="hljs-comment">// 从(1,1)开始的</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>              dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>          }<br>      }<br>      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 因为下标从0开始，所以-1</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-一维数组"><a class="markdownIt-Anchor" href="#32-一维数组"></a> 3.2 一维数组</h2><p>编译已通过<br>用一维数组的前提是：二维数组的第一行和第一列是相同的值，这样才能保证滚动数组的初始值是一样的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span> <span class="hljs-params">(n,<span class="hljs-number">1</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;m; i++){<span class="hljs-comment">// 为什么要从1开始呢，因为0行全是1(已经赋值了)，所以从第1行开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;n; j++){<span class="hljs-comment">// 因为第一列是1，从第二列开始赋值的</span><br>                dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 从第0行开始的，差了一个1</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>![[6.不同路径 2022-07-13 18.05.50.excalidraw|600]]<br>滚动数组写法模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp********">void test_1_wei_bag_problem() {<br>    vector&lt;int&gt; weight = {1, 3, 4};<br>    vector&lt;int&gt; value = {15, 20, 30};<br>    int bagWeight = 4;<br><br>    // 初始化<br>    vector&lt;int&gt; dp(bagWeight + 1, 0);<br>    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品<br>        for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量<br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br>int main() {<br>    test_1_wei_bag_problem();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a><br>原理 <a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=225.736626">03:45</a></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.不同路径</title>
    <link href="/posts/31702/"/>
    <url>/posts/31702/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——62.不同路径</p><span id="more"></span><h1 id="1-62不同路径"><a class="markdownIt-Anchor" href="#1-62不同路径"></a> 1 62.不同路径</h1><p><a href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p><p>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能<strong>向下或者向右</strong>移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt=""></p><ul><li>输入：m = 3, n = 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m = 2, n = 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m = 7, n = 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m = 3, n = 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;= m, n &lt;= 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-图论"><a class="markdownIt-Anchor" href="#21-图论"></a> 2.1 图论</h2><p>暂定</p><h2 id="22-数论"><a class="markdownIt-Anchor" href="#22-数论"></a> 2.2 数论</h2><p>暂定</p><h2 id="23-动态规划"><a class="markdownIt-Anchor" href="#23-动态规划"></a> 2.3 动态规划</h2><p>m✖️n：行✖️列<br>按照动规五部曲来分析：</p><p><strong>1. 确定dp数组（dp table）以及下标的含义</strong><br><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。<br><strong>2. 确定递推公式</strong><br>机器人只能向下或向右移动<br>所以<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。(上面，左面)<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，因为只能从上面或者左面过来<br><strong>3.  dp数组的初始化</strong><br>如何初始化呢，首先<code>dp[i][0]</code>一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么<code>dp[0][j]</code>也同理。<br>所以初始化代码为：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-attribute">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><p><strong>4.  确定遍历顺序</strong><br>这里要看一下递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[i][j]</code>都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。两个for循环嵌套</p><p>这样就可以保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值的。</p><p><strong>5.  举例推导dp数组</strong></p><p>如图所示：<br><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code>，<code>dp[2][2] = dp[1][2] + dp[2][1]</code>，<code>dp[3][7] = dp[2][7] + dp[3][6]</code> 上面/左面<br><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-二维数组解法编译已通过"><a class="markdownIt-Anchor" href="#31-二维数组解法编译已通过"></a> 3.1 二维数组解法，编译已通过</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>{<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++){ <span class="hljs-comment">// 从(1,1)开始的</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++){<br>              dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];<br>          }<br>      }<br>      <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 因为下标从0开始，所以-1</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-一维数组"><a class="markdownIt-Anchor" href="#32-一维数组"></a> 3.2 一维数组</h2><p>编译已通过<br>用一维数组的前提是：二维数组的第一行和第一列是相同的值，这样才能保证滚动数组的初始值是一样的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> {<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">dp</span> <span class="hljs-params">(n,<span class="hljs-number">1</span>)</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;m; i++){<span class="hljs-comment">// 为什么要从1开始呢，因为0行全是1(已经赋值了)，所以从第1行开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;n; j++){<span class="hljs-comment">// 因为第一列是1，从第二列开始赋值的</span><br>                dp[j] = dp[j] + dp[j<span class="hljs-number">-1</span>];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<span class="hljs-comment">// 从第0行开始的，差了一个1</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>![[6.不同路径 2022-07-13 18.05.50.excalidraw|600]]<br>滚动数组写法模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp********">void test_1_wei_bag_problem() {<br>    vector&lt;int&gt; weight = {1, 3, 4};<br>    vector&lt;int&gt; value = {15, 20, 30};<br>    int bagWeight = 4;<br><br>    // 初始化<br>    vector&lt;int&gt; dp(bagWeight + 1, 0);<br>    for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品<br>        for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量<br>            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>        }<br>    }<br>    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;<br>}<br><br>int main() {<br>    test_1_wei_bag_problem();<br>}<br><br></code></pre></td></tr></tbody></table></figure><p><a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">滚动数组详解_哔哩哔哩_bilibili</a><br>原理 <a href="https://www.bilibili.com/video/BV1dZ4y1u7ZT?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=225.736626">03:45</a></p><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.使用最小花费爬楼梯</title>
    <link href="/posts/27967/"/>
    <url>/posts/27967/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解—— 746. 使用最小花费爬楼梯</p><span id="more"></span><h1 id="1-使用最小花费爬楼梯"><a class="markdownIt-Anchor" href="#1-使用最小花费爬楼梯"></a> 1 使用最小花费爬楼梯</h1><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接</a></p><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值&nbsp;cost[i]（下标从 0 开始）。</p><p><strong>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</strong></p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例&nbsp;1：</p><p>输入：cost = [10, 15, 20] 输出：15 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。 &nbsp;示例 2：</p><blockquote><p>第一次不要钱，爬上了15，支付15后可以爬一层到楼顶，那我从10开始支付10爬两层不是更好吗</p></blockquote><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>提示：</p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong></p><p>动归五部曲</p><p><font color="#F36208">1.  确定dp数组以及下标的含义</font><br><strong>dp[i]的定义：到达第i个台阶所花费的最<br>少体力为dp[i]</strong>。<br>注意这里认为是第一步一定是要花费：<br>dp[0] = cost[0];<br>dp[1] = cost[1];<br><strong>dp[2] = min(dp[0], dp[1]) + cost[2];</strong><br><font color="#F36208">2.  确定递推公式</font><br><strong>可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]</strong>。</p><blockquote><p>一旦支付当前下边相应的体力值，就可向上爬一个或者两个楼梯</p></blockquote><p><strong>dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];</strong><br>爬上台阶i，可能是从 i - 1 层，i-2层爬上来的，然后在离开台阶i 又在需要花费cost[i]<br><font color="#F36208">3. dp数组初始化</font><br>题目说：可以选择从下标为 0 或 1 的元素作为初始阶梯。<br>从下标0处离开需要cost[0]，下标1同理</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br></code></pre></td></tr></tbody></table></figure><p><font color="#F36208">4. 遍历顺序</font><br>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。<br><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。<br><font color="#F36208">5. 举例推导dp数组</font></p><table><thead><tr><th>cost</th><th>10</th><th>15</th><th>20</th></tr></thead><tbody><tr><td>dp[i]</td><td>10</td><td>15</td><td>30</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/2021010621363669.png" alt="746.使用最小花费爬楼梯"><br>为什么选择最后两位的最小值呢<br>?<br>最后两位支付该值都可以到下一层，假设所求是第N层的最小开销，只需要计算min(谁能到N层)，到了N层后又不到下一层，所以相当于最后一步不用花费，就停止到那了，不用+cost[i]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(cost.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i++){<span class="hljs-comment">// 这里不用&lt;=，因为下标从0开始，取不到cost.size()||从第三个元素开始，下标是2</span><br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]) + cost[i];<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[cost.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>], dp[cost.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>]);<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1fq4y1T7Uo?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode-746.使用最小花费爬楼梯_哔哩哔哩_bilibili</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.爬楼梯</title>
    <link href="/posts/34749/"/>
    <url>/posts/34749/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode  题解——70. 爬楼梯</p><span id="more"></span><h1 id="1-爬楼梯"><a class="markdownIt-Anchor" href="#1-爬楼梯"></a> 1 爬楼梯</h1><p><a href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。<strong>你有多少种不同的方法</strong>可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><ul><li>输入： 2</li><li>输出： 2</li><li>解释： 有两种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶</li><li>2 阶</li></ul></li></ul><p>示例 2：</p><ul><li>输入： 3</li><li>输出： 3</li><li>解释： 有三种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul></li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。<br>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。<br>第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。<br>dp[3] = dp[2] + dp[1] = 2+1 =3</p><p>动归五部曲：</p><ol><li>确定dp数组以及下标的含义<br>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li><li>确定递推公式<br>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。<br>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么<br>dp[i] = dp[i - 1] + dp[i - 2] 。</li><li>dp数组如何初始化<br>不考虑dp[0]，dp[1] = 1， dp[2] = 2</li></ol><blockquote><p>dp[0]没有意义，i从3 开始递推</p></blockquote><ol start="4"><li>确定遍历顺序<br>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</li><li>举推导dp数组<br>举例当n为5的时候，dp table（dp数组）应该是这样的<br><img src="https://img-blog.csdnimg.cn/20210105202546299.png" alt="70.爬楼梯"></li></ol><blockquote><p>本质就是斐波那契数列，就是没有讨论dp[0] 的情况</p></blockquote><p>#面试<br>有的题解是把dp[0]初始化为1，然后遍历的时候i从2开始遍历，这样是可以解题的，然后强行解释一波dp[0]应该等于1的含义。<br>一个严谨的思考过程，应该是初始化dp[1] = 1，dp[2] = 2，然后i从3开始遍历，<br>这个可以是面试的一个小问题，考察候选人对dp[i]定义的理解程度。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>优化一下空间复杂度</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++){<br>            <span class="hljs-type">int</span> sum = dp[<span class="hljs-number">2</span>] + dp [<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">2</span>] = sum;<br>            dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>]; <br>        }<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-加强版爬楼梯"><a class="markdownIt-Anchor" href="#4-加强版爬楼梯"></a> 4 加强版爬楼梯</h1><p>这道题目还可以继续深化，就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) { <span class="hljs-comment">// 把m换成2，就可以AC爬楼梯这道题</span><br>                <span class="hljs-keyword">if</span> (i - j &gt;= <span class="hljs-number">0</span>) dp[i] += dp[i - j];<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>代码中m表示最多可以爬m个台阶。</p><p><strong>以上代码不能运行哈，我主要是为了体现只要把m换成2，粘过去，就可以AC爬楼梯这道题，不信你就粘一下试试，哈哈</strong>。</p><p><strong>此时我就发现一个绝佳的大厂面试题</strong>，第一道题就是单纯的爬楼梯，然后看候选人的代码实现，如果把dp[0]的定义成1了，就可以发难了，为什么dp[0]一定要初始化为1，此时可能候选人就要强行给dp[0]应该是1找各种理由。那这就是一个考察点了，对dp[i]的定义理解的不深入。</p><p>我在<a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html">通过一道面试题目，讲一讲递归算法的时间复杂度！</a><a href="https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%81.html"></a><br>中，以我自己面试别人的真实经历，通过求x的n次方 这么简单的题目，就可以考察候选人对算法性能以及递归的理解深度，录友们可以看看，绝对有收获！</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5 参考资料</h1><p><a href="https://www.programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：🈚</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.斐波那契数</title>
    <link href="/posts/33325/"/>
    <url>/posts/33325/</url>
    
    <content type="html"><![CDATA[<p>文章简介：LeetCode 题解 ——509. 斐波那契数</p><span id="more"></span><h1 id="1-509-斐波那契数"><a class="markdownIt-Anchor" href="#1-509-斐波那契数"></a> 1 509. 斐波那契数</h1><p><a href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接</a></p><p>斐波那契数，通常用&nbsp;F(n) 表示，形成的序列称为 斐波那契数列 。该数列由&nbsp;0 和 1 开始，<strong>后面的每一项数字都是前面两项数字的和</strong>。也就是： F(0) = 0，F(1)&nbsp;= 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1：</p><ul><li>输入：2</li><li>输出：1</li><li>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</li></ul><p>示例 2：</p><ul><li>输入：3</li><li>输出：2</li><li>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</li></ul><p>示例 3：</p><ul><li>输入：4</li><li>输出：3</li><li>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</li></ul><p>提示：</p><ul><li>0 &lt;= n &lt;= 30</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>动规五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<span class="hljs-comment">// 因为下标从0开始，要总长度所以+1</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++){ <span class="hljs-comment">// 是≤，要把n也算上，因为最后输出的是n</span><br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[n];<span class="hljs-comment">// vector的返回和使用都要用[]</span><br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=9fc19dba-4edb-4f3d-8d7e-22b7c2462fc7">obsidian</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.动态规划理论基础</title>
    <link href="/posts/31294/"/>
    <url>/posts/31294/</url>
    
    <content type="html"><![CDATA[<p>文章简介：如题</p><span id="more"></span><p>动态规划，英文：Dynamic Programming，简称DP<br><strong>动态规划中每一个状态一定是由上一个状态推导出来的</strong>，贪心是局部最优推导全局最优</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><h1 id="1-动态规划解题步骤"><a class="markdownIt-Anchor" href="#1-动态规划解题步骤"></a> 1 动态规划解题步骤</h1><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组<br><strong>一些情况是递推公式决定了dp数组要如何初始化！</strong></li></ol><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。<br>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。<br><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><h2 id="11-debug"><a class="markdownIt-Anchor" href="#11-debug"></a> 1.1 debug</h2><p><strong>如果代码写出来了，一直AC不了，灵魂三问：</strong></p><ol><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ol><p>哈哈，专治各种代码写出来了但AC不了的疑难杂症。</p><h1 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2 参考资料</h1><p><a href="https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4">代码随想录</a><br>自用跳转连接：🈚️</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24.监控二叉树</title>
    <link href="/posts/43575/"/>
    <url>/posts/43575/</url>
    
    <content type="html"><![CDATA[<p>文章简介：968.监控二叉树</p><span id="more"></span><h1 id="1-968监控二叉树"><a class="markdownIt-Anchor" href="#1-968监控二叉树"></a> 1 968.监控二叉树</h1><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接</a></p><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20201229175736596.png" alt=""></p><ul><li>输入：[0,0,null,0,0]</li><li>输出：1</li><li>解释：如图所示，一台摄像头足以监控所有节点。</li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/2020122917584449.png" alt=""></p><ul><li>输入：[0,0,null,0,null,0,null,null,0]</li><li>输出：2</li><li>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</li></ul><p>提示：</p><ul><li>给定树的节点数的范围是 [1, 1000]。</li><li><strong>每个节点的值都是 0</strong>。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。</p><p>为什么不从头结点开始看起呢，为啥要从叶子节点看呢<br>?<br>因为头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。<br><strong>局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，<br>整体最优：全部摄像头数量所用最少！</strong></p><p>大体思路就是：从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点</p><p>每个节点可能有几种状态：<br>有如下三种：</p><ul><li>该节点无覆盖</li><li>本节点有摄像头</li><li>本节点有覆盖</li></ul><p>我们分别有三个数字来表示：</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207051425661.png" alt=""></p><h1 id="3-参考资料"><a class="markdownIt-Anchor" href="#3-参考资料"></a> 3 参考资料</h1><p><a href="https://www.programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转连接：🈚️</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验设计</title>
    <link href="/posts/65372/"/>
    <url>/posts/65372/</url>
    
    <content type="html"><![CDATA[<p>镁合金设置温度分布<br>挤压角度：100°，110，120，130，140</p><blockquote><p>110， 120 的圆盘成形效果最好，140的圆棒成形效果最好<br>因为110°的倾角小</p></blockquote><p>![[实验设计 2022-07-09 16.42.40.excalidraw|600]]</p><p>华南理工的统一认证账号是哪个啊<br>我现在有16个镁合金圆棒<br>7月份的实验</p><ul><li><p>控制角度变温度</p><ul><li>110°挤压块性能最好 100°→400°的做7个</li><li>120°挤压块同理7个</li><li>在做一个无加热的，对比实验，主要是拍照片</li><li>综上测出性能最好的角度和温度，确定好最合适的温度</li></ul></li><li><p>控制温度变角度</p><ul><li>先确定一个最合适的温度</li><li>在用该温度做其他挤压块的角度 (5个：100°→140°)</li></ul></li></ul><hr><p>试验温度为室温和100, 150, 200, 250, 300, 350, 400 ℃<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[1]</span></a></sup><br>200°时，得到最好的性能</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/F62253DC-5296-4BB8-A7BF-97F9BD2553CF">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>23.买卖股票的最佳时机含手续费</title>
    <link href="/posts/9689/"/>
    <url>/posts/9689/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解：714. 买卖股票的最佳时机含手续费</p><span id="more"></span><h1 id="1-买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#1-买卖股票的最佳时机含手续费"></a> 1 买卖股票的最佳时机含手续费</h1><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">力扣题目链接</a></p><p>给定一个整数数组&nbsp;prices，其中第&nbsp;i&nbsp;个元素代表了第&nbsp;i&nbsp;天的股票价格 ；非负整数&nbsp;fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。<strong>如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</strong></p><p><strong>返回获得利润的最大值。</strong></p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><blockquote><p>相当于买入和卖出</p></blockquote><p>示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8</p><p>解释: 能够达到的最大利润: 在此处买入&nbsp;prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润:&nbsp;((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p><p>注意:</p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-6-买卖股票的最佳时机ii"><a class="markdownIt-Anchor" href="#21-6-买卖股票的最佳时机ii"></a> 2.1 [[6. 买卖股票的最佳时机II]]</h2><p>![[6. 买卖股票的最佳时机II#2 思路]]<br>与 6的区别是多了个手续费<br>有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。<br>用贪心策略，就是最低值买，最高值（减去手续费还盈利）就卖。</p><p>找到两个点</p><ul><li>买入日期：其实很好想，遇到更低点就记录一下。</li><li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li></ul><p>做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（<strong>不是真正的卖出，相当于持有股票</strong>），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><h3 id="211-思路总结"><a class="markdownIt-Anchor" href="#211-思路总结"></a> 2.1.1 思路总结</h3><ol><li>不断的寻找最低点，在最低点时买入</li><li>寻找有利润的时候买入，更新下一次的买入位置在循环卖出</li><li>对所有利润加和</li></ol><h2 id="22-断点调试"><a class="markdownIt-Anchor" href="#22-断点调试"></a> 2.2 断点调试</h2><p>[23.买卖股票的最佳时机含手续费](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4)</p><p>[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=10.471542) 情况三：现在的价格不是最低的，并且卖出的话亏本</p><p>[00:28](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=28.795416)<br>#疑问 #已解决<br>为什么要minPrice = prices[i]- fee呢，如果去掉了- fee 则结果不对<br><s>因为在该下标处已经交过了一次手续费，不需要在交了？？？</s></p><p>输入：prices = [1,3,7,5,10,3], fee = 3<br>输出：6<br>相当于：1时买入，10时卖出(10-1-3 = 6)<br>并不是：1时买入，7时卖出，5时买入，10时卖出(7-1-3  +  10 - 5 -3 = 5)<br>minprice = price[i] - fee  有正利润就假装卖了，先收集利润，- fee 的作用是如果后边的还有利润更高的，则这次其实是不卖的<br>eg：7时有正利润的先收集起来(7-1-3=3)<br>但此时的minPrice = 7-3  =&nbsp;4， 4是后边的最小的，接下来的利润是10-4-3= 3<br>总利润就是3+3 = 6，而不是像上边计算的5，这个作用就是，看似在7处卖了，实际没卖，最后是在10的位置卖的</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minPrice = prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =&nbsp;<span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];<br>            <span class="hljs-keyword">if</span> (prices[i] &gt; minPrice &amp;&amp; prices[i] - minPrice - fee &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (prices[i] - minPrice - fee &gt; <span class="hljs-number">0</span>){<br>                result += prices[i] -minPrice - fee;<br>                minPrice = prices[i] - fee; <br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-知识点"><a class="markdownIt-Anchor" href="#4-知识点"></a> 4 知识点</h1><p>[[continue]]</p><h1 id="5-参考资料"><a class="markdownIt-Anchor" href="#5-参考资料"></a> 5 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22.单调递增的数字</title>
    <link href="/posts/17411/"/>
    <url>/posts/17411/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解： 738.单调递增的数字</p><span id="more"></span><h1 id="1-738单调递增的数字"><a class="markdownIt-Anchor" href="#1-738单调递增的数字"></a> 1 738.单调递增的数字</h1><p><a href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接</a></p><p>给定一个非负整数&nbsp;N，找出小于或等于&nbsp;N&nbsp;的最大的<strong>整数</strong>，同时这个整数需要满足其<strong>各个位数上</strong>的数字是单调递增。</p><p>（当且仅当每<strong>个相邻位数上的数字&nbsp;x&nbsp;和&nbsp;y&nbsp;满足&nbsp;x &lt;= y</strong>&nbsp;时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>输入: N = 10</li><li>输出: 9</li></ul><p>示例 2:</p><ul><li>输入: N = 1234</li><li>输出: 1234</li></ul><p>示例 3:</p><ul><li>输入: N = 332</li><li>输出: 299</li></ul><p>说明: N&nbsp;是在&nbsp;[0, 10^9]&nbsp;范围内的一个整数。</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>找≤ N，的最大单增的整数<br>如果不递增，就把除最后一位每一位都减1，这样保证了减过数比原数小。然后在把除了第一个位(因为第一个位最大不能变，变了会使得比原来的数大)，后边的位数全部令为9，这样就得到了最大的整数。<br>代码：一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9</p><p>例如<br>332 → 222→299<br>753 → 643 → 699</p><h2 id="21-断点调试"><a class="markdownIt-Anchor" href="#21-断点调试"></a> 2.1 断点调试</h2><p>[22.单调递增的数字(carl:332).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl).mp4)<br>[00:07](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=7.519521) 前一个数大于后一个数则让前一个数减1</p><blockquote><p>从后往前遍历，for (i = num.size () - 1; i &gt; 0; i–) [[for 循环]]</p></blockquote><p>flag至少是1，因为i 不会取到0。这样就报证了至少从第二个2数开始赋9，直到到最后一个数</p><p>[00:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97(carl).mp4#t=10.337641) 只需要减1的原因是：让他的每一个位都比原来的数小，在把除了第一个位(因为第一个位最大)，后边的位数全部令为9，这样就得到了最大的整数</p><p>[22.单调递增的数字(carl/1234)](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/22.单调递增的数字(carl:1234).mp4)<br>1234 本身都是递增的，所以第一个for循环会跳过，第二for循环也不会执行</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        string strNum = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>() ;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--){<br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>]&gt; strNum[i]){<br>                flag = i;<br>                strNum[i<span class="hljs-number">-1</span>]--;<br>            }<br>        }<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i++){<br>            strNum[i] = <span class="hljs-string">'9'</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span> (strNum);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p>stoi函数 #flashcards/代码随想录<br>?<br>将数字字符串转为数字：“2147482” → 2147482</p><!--SR:!2022-07-07,3,250--><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">代码随想录</a><br>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=49dde99d-8015-4224-9c0b-96d9d0dae41a">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>材料内部结构</title>
    <link href="/posts/65236/"/>
    <url>/posts/65236/</url>
    
    <content type="html"><![CDATA[<p>滑移性能最好的晶格为：面心立方 &gt; 体心立方 &gt; 密排六方</p><blockquote><p>(塑性性能指标)</p></blockquote><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206281433535.png" alt=""></p><blockquote><p>BCC是体心立方，上边写错了</p></blockquote><p>面心立方材料：铝（Al）、铜（Cu）、镍（Ni）、金（Au）、银（Ag）、γ-铁（γ-Fe,912℃~1394℃)</p><p>密排六方材料：Mg， Zn，铍<br>镁合金等密排六方晶格金属在 250~400℃之间成形,密排六方(hcp)金属滑移系少,主要靠孪生变形</p><p>V体：Fe Cr Mo</p><blockquote><p>V体是什么，等查一查</p></blockquote><p>自用跳转连接：<a href="marginnote3app://note/D9087A24-CEF0-4136-B1D1-42F789B404D2">黄珍媛老师</a>，<a href="marginnote3app://note/40F63EDC-2FA9-46FE-BC55-141C72946015">夏琴香老师讲塑性变形</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=b9ec2231-bc80-4831-9b86-5e112ada3bfb">ob</a>，<a href="http://localhost:4000/2022/06/28/ke-yan/cai-liao-nei-bu-jie-gou/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代制造工程</title>
    <link href="/posts/64386/"/>
    <url>/posts/64386/</url>
    
    <content type="html"><![CDATA[<p>[[现代制造工程–周驰]]</p><p><strong>2022-06-29(后记)：</strong></p><p><strong>简答题</strong>：5 * 5  =25</p><ol><li><p>电火花的原理是什么，不可缺少什么，适用于什么材料。</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291624610.png" alt="|600"></li></ol></li><li><p>化学沉积和物理沉积的定义与区别</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291626815.png" alt="|600"></li></ol></li><li><p>画个六点定位原理图</p></li><li><p>坐标变换(周驰作业题)</p></li><li><p>金属材料加热发生的变化(答5点)</p></li></ol><p><strong>辨析题</strong>：15+15 = 30</p><ol><li><p>从“生产规模，资源配置，生产技术”三方面来说现代制造工程的发展</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291622155.png" alt="|600"></li></ol></li><li><p>金属塑性成形的两种方式，冷塑性对金属材料内部和性能的影响</p><ol><li><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206291623008.png" alt="|600"></li></ol></li></ol><p>其余的都是选择(20个 1.5分)和判断(15个 15分)</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>notion函数详解</title>
    <link href="/posts/49277/"/>
    <url>/posts/49277/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.csdn.net/tags/NtzaggysMDE2OTctYmxvZwO0O0OO0O0O.html">notion多条件formula - CSDN</a></p><h1 id="1-一-属性列名-properties"><a class="markdownIt-Anchor" href="#1-一-属性列名-properties"></a> 1 一、属性（列名-properties）</h1><ol><li><p>prop(“属性”) 返回每个条目的“属性值”，点击即可用对应的格式插入到公式中。</p></li><li><p>公式中的四种方式</p><p>四 种 格 式 { 数 字 日 期 字 符 串 复 选 框 四种格式\begin{cases} 数字 &amp; \ 日期 &amp; \字符串 &amp;\复选框 &amp; \end{cases} 四种格式⎩⎪⎪⎪⎨⎪⎪⎪⎧​数字日期字符串复选框​​</p></li></ol><p>floor((prop(“小时”) + prop(“分钟”) / 60) * 100) / 100</p><h1 id="2-二-常量constants"><a class="markdownIt-Anchor" href="#2-二-常量constants"></a> 2 二、常量（constants）</h1><p>常 量 { e 自 然 对 数 的 底 数 p i 圆 周 率 t r u e 真 f l a s e 假 常量\begin{cases} e &amp;自然对数的底数 \ pi &amp;圆周率 \true &amp;真\flase &amp;假 \end{cases} 常量⎩⎪⎪⎪⎨⎪⎪⎪⎧​epitrueflase​自然对数的底数圆周率真假​</p><h1 id="3-三-基本运算"><a class="markdownIt-Anchor" href="#3-三-基本运算"></a> 3 三、基本运算</h1><ol><li><p>if语法（“<code>if</code>”）：进行条件判断，在两个选项（要为同一格式）中选择一个。</p><p>语法：</p><ul><li><code>boolean?value:value</code></li><li><code>if(boolean,value,value)</code></li></ul><p>补充：在"boolean"不能填写0或者1；value中，true（真）为1，false（假）为0；</p></li><li><p>加法（"<code>+</code>“或"<code>add</code>"）：把两个数字或字符串相加，并返回它们的值</p><p>语法：</p><ul><li><code>value+value</code></li><li><code>add(value,value)</code></li></ul><p>说明：value可以是数字或字符串，为字符串时要加上双引号</p></li><li><p>减法（”<code>-</code>“或“<code>subtract</code>”）：将两个数字相减，并返回它们的值</p><p>语法：</p><ul><li><code>number-number</code></li><li><code>subtract(number,number)</code></li></ul></li><li><p>乘法（”<code>*</code>“或“<code>multiply</code>”）：将两个数字相乘，并返回它们的值</p><p>语法：</p><ul><li><code>number*number</code></li><li><code>multiply(number,number)</code></li></ul></li><li><p>除法（”<code>/</code> “或"<code>divide</code>"）：将两个数字相乘，并返回他们的值</p><p>语法：</p><ul><li><code>number/number</code></li><li><code>divide(number,number)</code></li></ul></li><li><p>绝对值（"<code>abs</code>"）：返回数的绝对值</p><p>语法：<code>abs(number)</code></p></li><li><p>求余运算（”<code>%</code>“或"<code>mod</code>"）：把两个数进行求余运算，并返回它们的值</p><p>语法：</p><ul><li><code>number%number</code></li><li><code>mod(number,number)</code></li></ul></li><li><p>”四舍五入“（”<code>round</code>“）：对数字进行”四舍五入“</p><p>语法：<code>round(number)</code></p><p>说明：默认情况下只保留整数。要保留n位小数时，应使用</p><p>r o u n d ( n u m b e r ∗ 1 0 n ) / 1 0 n round(number*10<sup>n)/10</sup>n round(number∗10n)/10n</p></li><li><p>一元负数（”<code>unaryminus</code>“或“<code>-</code>”）：对一个数进行取它的负数</p><p>语法：</p><p><code>-number</code></p><p><code>unaryminus(number)</code></p><p>如：-3==unaryminus(3)</p></li><li><p>一元加号（“<code>+</code>”或“<code>unaryPlus</code>”）：将参数转化为数字。</p></li></ol><pre><code class="hljs">语法：`+value``unaryPlus(value)`补充：可以将true转化为1，false转化为0</code></pre><h1 id="4-四-关系逻辑判断"><a class="markdownIt-Anchor" href="#4-四-关系逻辑判断"></a> 4 四、关系逻辑判断</h1><ol><li>关系判断<ul><li>大于 &gt;</li><li>小于 &lt;</li><li>等于 ==</li><li>大于等于 &gt;=</li><li>小于等于 &lt;=</li><li>不等于 !=</li></ul></li><li>逻辑判断<ul><li><p>逻辑“<code>非</code>”：对逻辑参数进行否定</p><p>语法：</p><p><code>not boolean</code></p><p><code>not (boolean)</code></p></li><li><p>逻辑“<code>与</code>”：对逻辑参数进行“与”运算，<code>“一假全假”</code></p><p>语法：</p><p><code>boolean and boolean</code></p><p><code>and(boolean,boolean)</code></p></li><li><p>逻辑“或”：对逻辑参数进行“或”运算，<code>“一真全真”</code></p><p>语法：</p><p><code>boolean or boolean</code></p><p><code>or(boolean,boolean)</code></p></li></ul></li></ol><h1 id="5-五-字符串函数"><a class="markdownIt-Anchor" href="#5-五-字符串函数"></a> 5 五、字符串函数</h1><ol><li><p>连接函数（“<code>concat</code>”）：将字符串进行连接</p><p>语法：</p><p><code>concat(text...)</code></p><p><code>text+text+...</code></p></li><li><p>插符函数（“<code>join</code>”）：插入字符函数，在其余叁数之间插入第一个参数并返回它们的连接字符串</p><p>语法：<code>join(text...)</code></p><p>例如：join("-",“a”,“b”,“c”)==“a-b-c”</p></li><li><p>切片函数（”<code>slice</code>“）：从字符串中提取子字符串（包括开头索引，不包括结尾索引[start,end)）</p><p>语法：</p><ul><li><code>slice(text,number)</code></li><li><code>slice(text,number1,number2)</code></li></ul><p>说明:只有一个数字时，就是从这个索引数字开始到结束；当有两个数字时（第二个数要大于第一个数，不然不会显示），从字符串中提取子字符串，包含开头索引，不包含结束索引。</p><p>注意：字符串的索引值是从0开始的</p></li><li><p>长度函数（”<code>length</code>“）：返回字符串的长度，返回值是一个数值。</p><p>语法：<code>length(text)</code></p></li><li><p>转化函数（”<code>format</code>“）：将其他格式的参数转化为字符串。</p><p>语法：<code>format(value)</code></p></li><li><p>转化函数（”<code>toNumber</code>“）：将其他格式的参数转化数字</p><p>语法：<code>toNumber(value)</code></p><p>说明：</p><ul><li>可以把字符串类型转化为数字，如："123"到数字123</li><li>可以把日期类型转化时间戳，Jan 18, 2021 7:28 PM→1610969340000</li><li>可以把复选框类型转化为数字，true为1，false为0</li><li>也可以把数字类型转化为数字</li></ul></li><li><p>包含判断函数（”<code>contains</code>“）：包含判断函数，返回一个boolean值，</p><p>语法：<code>contains(text1,text2)</code></p><p>说明：如果text1中包含text2，则返回true；反之，返回false</p></li><li><p>替代函数：</p><ul><li><p>“<code>replace</code>”：用新值替换正则表达式的第一个匹配项</p><p>语法：<code>replace(number/text/boolean,text1,text2)</code></p><p>说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</p></li><li><p>"<code>replaceAll</code>”：用新值代替正则表达式的所有匹配项</p><p>语法：<code>replaceAll(number/text/boolean,text1,text2)</code></p><p>说明：text表示字符串类型，text1表示要代替的值，text2表示新的值</p></li></ul></li><li><p>检验函数（“<code>test</code>”）：判断一个字符串是否与正则表达式匹配，返回一个boolean值</p><p>语法：<code>test(number/text/boolean,text)</code></p></li><li><p>“验空”函数（”<code>empty</code>“）：判断一个值是否为空</p></li></ol><pre><code class="hljs">语法：`empty(number/text/boolean/date)`说明：默认情况下，数字为0表示空，字符串以""表示空值，boolean值以false表示空值</code></pre><h1 id="6-六-数学函数"><a class="markdownIt-Anchor" href="#6-六-数学函数"></a> 6 六、数学函数</h1><ol><li><p>绝对值函数（“<code>abs</code>”)：返回一个数的绝对值</p><p>语法：<code>abs(number)</code></p></li><li><p>开算术平方根运算（”<code>sqrt</code>“）：返回一个数的算术平方根</p><p>语法：<code>sqrt(number)</code></p><p>说明：number要为非负数</p></li><li><p>开立方根（”<code>cbrt</code>“)：返回一个数的立方根</p><p>语法：<code>cbrt(number)</code></p></li><li><p>幂次运算（”<code>^</code>“或"<code>pow</code>"）：将两个数字进行指数运算，并返回它们的值</p><p>语法：</p><ul><li><code>number^number</code></li><li><code>pow(number,number)</code></li></ul><p>补充:</p><p>自然指数运算（”<code>exp</code>“）：返回e^x的值，其中x为参数，e为常数</p><p>语法：<code>exp(number)</code></p></li><li><p>对数运算：notion目前只支持三种对数运算</p><p>三 种 对 数 运 算 { l n ( n u m b e r ) 返 回 一 个 数 的 自 然 对 数 l o g 10 ( n u m b e r ) 返 回 这 个 数 以 10 为 底 对 数 的 值 l o g 2 ( n u m b e r ) 返 回 这 个 数 以 2 为 底 对 数 的 值 三种对数运算\begin{cases}ln(number) &amp;返回一个数的自然对数\log_{10}(number)&amp;返回这个数以10为底对数的值\log_2(number) &amp;返回这个数以2为底对数的值\end{cases} 三种对数运算⎩⎪⎨⎪⎧​ln(number)log10​(number)log2​(number)​返回一个数的自然对数返回这个数以10为底对数的值返回这个数以2为底对数的值​</p></li><li><p>向上取整函数（“<code>ceil</code>”）：返回大于或等于这个数字的最小整数</p><p>语法：<code>ceil(number)</code></p></li><li><p>向下取整函数（“<code>floor</code>”）：返回小于或等于这个数字的最大整数</p><p>语法：<code>floor(number)</code></p></li><li><p>最大/小值函数</p><ul><li><p>最大值函数（“<code>max</code>”）：返回数的最大值</p><p>语法：<code>max(number1,number2,...)</code></p></li><li><p>最小值函数（“<code>min</code>”）：返回数的最小值</p><p>语法：<code>min(number1,number2,...)</code></p></li></ul></li><li><p>符号函数（“<code>sign</code>”）：返回数的符号，指明数的符号是为正、负或零</p><p>语法：<code>sign(number)</code></p><p>说明：数字为正时，返回1；数字为负时，返回-1；数字为0时，返回0</p></li></ol><h1 id="7-七-日期函数"><a class="markdownIt-Anchor" href="#7-七-日期函数"></a> 7 七、日期函数</h1><ol><li><p>返回时间差函数（<code>dateBetween</code>）：返回两个日期之间的时间差，返回值是一个数字。</p><p>语法：<code>dateBetween(date,date,text)</code></p><p>说明：<code>date</code>表示日期；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。</p><p>t e x t 的 取 值 类 型 { " y e a r s " 表 示 以 “ 年 ” 为 基 本 单 位 " q u a r t e r s " 表 示 以 “ 季 ” 为 基 本 单 位 " m o n t h s " 表 示 以 “ 月 " 为 基 本 单 位 " w e e k s " 表 示 以 “ 周 ” 为 基 本 单 位 " d a y s " 表 示 以 “ 天 ” 为 基 本 单 位 " h o u r s " 表 示 以 “ 小 时 ” 为 基 本 单 位 " m i n u t e s " 表 示 以 “ 分 钟 ” 为 基 本 单 位 " s e c o n d s " 表 示 以 “ 秒 ” 为 基 本 单 位 " m i l l i s e c o n d " 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}“years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月"为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​"years"“quarters”“months”“weeks”“days”“hours”“minutes”“seconds”"millisecond"​表示以“年”为基本单位表示以“季”为基本单位表示以“月"为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</p></li><li><p>获取当前日期函数（<code>now</code>):返回当前的日期和时间</p><p>语法：<code>now()</code></p></li><li><p>日期范围开始函数（“<code>start</code>”）：返回一个日期范围的开始</p><p>语法：<code>start(date)</code></p></li><li><p>日期范围结束函数（“<code>end</code>”）：返回一个日期范围的结束</p><p>语法：<code>end(date)</code></p></li><li><p>日期到时间戳函数（“<code>timestamp</code>”）：返回来自Unix毫秒时间戳的整数，对应于自1970年1月1日起的毫秒数，返回值是<code>数值</code></p><p>语法：<code>timestamp(date)</code></p><p>说明：把日期格式的<code>日期转化</code>为数值类型的<code>时间戳</code></p></li><li><p>时间戳到日期函数（“<code>fromTimestamp</code>”）：返回由Unix毫秒时间戳构建的日期，对应于自1970年1月1日起的毫秒数，返回值是<code>日期</code></p><p>语法：<code>fromTimestamp(number)</code></p><p>说明：把数值类型的<code>时间戳转化为日期</code>类型的日期</p></li><li><p>增加日期判据（argument）函数（“<code>dateAdd</code>”）：增加到日期，最后一个是单位判据</p><p>语法：<code>dateAdd(date,number,text)</code></p><p>说明：<code>date</code>表示日期；number表示日期差；<code>text</code>表示”时间差“的基本单位，类型为字符串，取值有：年、季度、月、周、天、小时、分钟、秒、或毫秒。</p><p>t e x t 的 取 值 类 型 { " y e a r s " 表 示 以 “ 年 ” 为 基 本 单 位 " q u a r t e r s " 表 示 以 “ 季 ” 为 基 本 单 位 " m o n t h s " 表 示 以 “ 月 " 为 基 本 单 位 " w e e k s " 表 示 以 “ 周 ” 为 基 本 单 位 " d a y s " 表 示 以 “ 天 ” 为 基 本 单 位 " h o u r s " 表 示 以 “ 小 时 ” 为 基 本 单 位 " m i n u t e s " 表 示 以 “ 分 钟 ” 为 基 本 单 位 " s e c o n d s " 表 示 以 “ 秒 ” 为 基 本 单 位 " m i l l i s e c o n d " 表 示 以 “ 毫 秒 ” 为 基 本 单 位 text的取值类型\begin{cases}“years” &amp; 表示以“年”为基本单位\“quarters”&amp;表示以“季”为基本单位\“months” &amp;表示以“月"为基本单位\“weeks”&amp; 表示以“周”为基本单位\“days”&amp;表示以“天”为基本单位\“hours”&amp;表示以“小时”为基本单位\“minutes”&amp;表示以“分钟”为基本单位\“seconds”&amp;表示以“秒”为基本单位\“millisecond”&amp;表示以“毫秒”为基本单位\end{cases} text的取值类型⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​"years"“quarters”“months”“weeks”“days”“hours”“minutes”“seconds”"millisecond"​表示以“年”为基本单位表示以“季”为基本单位表示以“月"为基本单位表示以“周”为基本单位表示以“天”为基本单位表示以“小时”为基本单位表示以“分钟”为基本单位表示以“秒”为基本单位表示以“毫秒”为基本单位​</p></li><li><p>减少日期的日期函数（<code>“dateSubtract</code>”）：减少日期的日期，最后一个是判据</p><p>语法：<code>dateSubtract(date,number,text)</code></p><p>说明：类似上面的dateAdd函数。</p></li><li><p>设置日期格式函数（“<code>formatDate</code>”）：使用“时刻”标准时间格式字符串，设置日期格式，返回的是一个<code>字符串</code></p><p>语法：<code>formatDate(date,text)</code></p><p>例子：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MMMM D YYYY, HH:mm"</span>) == March <span class="hljs-number">30</span> <span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"YYYY/MM/DD, HH:mm"</span>) == <span class="hljs-number">2010</span>/<span class="hljs-number">03</span>/<span class="hljs-number">30</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"MM/DD/YYYY, HH:mm"</span>) == <span class="hljs-number">03</span>/<span class="hljs-number">30</span>/<span class="hljs-number">2010</span>, <span class="hljs-number">12</span>:<span class="hljs-number">00</span><br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"HH:mm A"</span>) == <span class="hljs-number">12</span>:<span class="hljs-number">00</span> PM<br>formatDate(<span class="hljs-built_in">now</span>(), <span class="hljs-string">"M/D/YY"</span>) == <span class="hljs-number">3</span>/<span class="hljs-number">30</span>/<span class="hljs-number">10</span><br></code></pre></td></tr></tbody></table></figure></li><li><p>返回”给定日期“所用单位函数下的数字<br>所 用 的 单 位 函 数 { 分 钟 函 数 （ m i n u t e ） { 返 回 一 个 0 到 59 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 分 钟 数 语 法 ： m i n u t e ( d a t e ) 小 时 函 数 （ h o u r ） { 返 回 一 个 0 到 23 之 间 的 整 数 ， 对 应 于 给 定 日 期 的 小 时 数 语 法 ： h o u r ( d a t e ) 星 期 函 数 （ d a y ） { 返 回 一 个 0 到 6 之 间 的 整 数 ， 对 应 于 给 定 的 日 期 。 0 代 表 星 期 日 ， 1 代 表 星 期 一 等 等 语 法 ： d a y ( d a t e ) 日 期 函 数 （ d a t e ） { 返 回 一 个 1 到 31 之 间 的 整 数 , 对 应 于 给 定 日 期 语 法 ： d a t e ( d a t e ) 月 函 数 （ m o n t h ） { 返 回 一 个 0 到 11 之 间 的 整 数 ， 0 对 应 于 1 月 ， 1 对 应 于 2 月 等 等 语 法 ： m o n t h ( d a t e ) 年 份 函 数 （ y e a r ） { 返 回 给 定 日 期 的 年 份 语 法 ： y e a r ( d a t e ) 所用的单位函数\begin{cases} 分钟函数（minute）\begin{cases}返回一个0到59之间的整数，对应于给定日期的分钟数\语法：minute(date)\end{cases}\ 小时函数（hour）\begin{cases}返回一个0到23之间的整数，对应于给定日期的小时数\语法：hour(date)\end{cases}\ 星期函数（day）\begin{cases}返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等\语法：day(date)\end{cases}\ 日期函数（date）\begin{cases}返回一个1到31之间的整数,对应于给定日期\语法：date(date)\end{cases}\ 月函数（month）\begin{cases}返回一个0到11之间的整数，0对应于1月，1对应于2月等等\语法：month(date)\end{cases}\ 年份函数（year）\begin{cases}返回给定日期的年份\语法：year(date)\\end{cases} \end{cases} 所用的单位函数⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​分钟函数（minute）{返回一个0到59之间的整数，对应于给定日期的分钟数语法：minute(date)​小时函数（hour）{返回一个0到23之间的整数，对应于给定日期的小时数语法：hour(date)​星期函数（day）{返回一个0到6之间的整数，对应于给定的日期。0代表星期日，1代表星期一等等语法：day(date)​日期函数（date）{返回一个1到31之间的整数,对应于给定日期语法：date(date)​月函数（month）{返回一个0到11之间的整数，0对应于1月，1对应于2月等等语法：month(date)​年份函数（year）{返回给定日期的年份语法：year(date)</p></li></ol><h1 id="8-参考资料"><a class="markdownIt-Anchor" href="#8-参考资料"></a> 8 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>notion</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian media 插件</title>
    <link href="/posts/42381/"/>
    <url>/posts/42381/</url>
    
    <content type="html"><![CDATA[<h1 id="1-media-插件"><a class="markdownIt-Anchor" href="#1-media-插件"></a> 1 media 插件</h1><p>本地视频打时间戳：<br>前边+file:// ，第三个"/"是users的,然后在阅读视图中打开，之后可以自动打时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221318976.png" alt="|600"></p><p>不在阅读视图中打开会自动跳转到默认应用打开，这样无法加时间戳<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206221319732.png" alt="|600"></p><h1 id="2-参考资料"><a class="markdownIt-Anchor" href="#2-参考资料"></a> 2 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语口语</title>
    <link href="/posts/13436/"/>
    <url>/posts/13436/</url>
    
    <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/899591b0dea9484cb76d44a26c1c4c61">英语口语考试周主题</a></p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=d3049095-bb89-43d6-872f-f36158106173">ob</a>， <a href="">blog</a></p><hr><p><strong>参考资料：</strong></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>fluid写文章好用的代码</title>
    <link href="/posts/15457/"/>
    <url>/posts/15457/</url>
    
    <content type="html"><![CDATA[<p>网站嵌套<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid">[1]</span></a></sup></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"1000"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"topFrame"</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"yes"</span>  <span class="hljs-attr">noresize</span>=<span class="hljs-string">"noresize"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"topFrame"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>tag插件</p><iframe src="https://hexo.fluid-dev.com/docs/guide/#tag-%E6%8F%92%E4%BB%B6" width="100%" height="1000" name="topFrame" scrolling="yes" noresize="noresize" frameborder="0" id="topFrame"></iframe><hr><p><strong>参考资料</strong>：</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/posts/fluid-write/#iframe-%E9%A1%B5%E9%9D%A2%E9%95%B6%E5%A5%97">搭配 Fluid 如何优雅的写一篇文章 - Hexo Theme Fluid</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优化</title>
    <link href="/posts/37878/"/>
    <url>/posts/37878/</url>
    
    <content type="html"><![CDATA[<blockquote><p>红色为重点</p></blockquote><p>考试范围：<br>第二章的单纯形法不考</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507551.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507026.png" alt="|600"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171507616.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206171506250.png" alt="|600"></div></div></div><p>动态规划求解：<a href="https://www.bilibili.com/video/BV1DL4y1G7mp?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化理论与方法-动态规划2_哔哩哔哩_bilibili</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222221137.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227555.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222227315.png)<br><br>![](https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206222228222.png)<br><br></code></pre></td></tr></tbody></table></figure><p>总复习：<a href="https://www.bilibili.com/video/BV1AF411z7hg/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">最优化计算方法计算题复习_哔哩哔哩_bilibili</a></p><hr><p>2022-06-24(后记)：</p><ol><li>实际问题求标准型的问题：把目标函数写出来，约束条件写出来就行</li><li>黄金分割法：但是略微有点不一样，函数值算出来是负的。没关系仍然采用，谁的函数值就删其区间的策略</li><li>K-T条件：常规题</li><li>内点罚函数：注意一下把约束条件化为标准型：&lt;=0</li><li>哈密顿法：书上13-3原题，初始条件变了一点，加粗的看不懂(x(0) = 0，<strong>t<sub>f</sub> = 2，x1(0) + x2(0) =&nbsp;5</strong> )</li><li>共轭梯度法：共有三种方法可以解(牛顿法，最速下降法，共轭梯度法)，但是题目要求共轭梯度法</li><li>遗传算法：要求精确到0.01，简单是初始只有两个变量x1，x2。<ol><li>注意一点：适度函数中的常数要取f(x1)，f(x2)的最大值。本题中x1，x2取负数才是最大值，我写错了</li></ol></li><li>动态规化求线性规化：要求<strong>顺序法</strong>解，逆序法不给分，老师专门在考前1分钟强调。(<font color="#C32E94">15分</font>)</li><li>A* 算法：画格子，只有<font color="#C32E94">5分</font></li><li>神经网络：先由m求W，给了初始的V<sup>T</sup>。求更新状态，求对应的E<ol><li>求W，W12=m1的第一行 * 第二行 + m2的第一行 * 第二行。w13同理…</li><li>求V<sup>T</sup>，更新几，V乘上对应的W列 - θ<sub>i</sub>，没有θ就当成0。如果结果 &gt;= 0 取1，&lt; 0 取0。更新几号只写那个数。其他的初始V<sup>T</sup>照抄<ol><li>如果是二分图的，更新完的话，如果正数和负数的个数不相等的话，还要在随机找一个数变一下。然后使正负的个数相等</li></ol></li></ol></li></ol><blockquote><p>未标注的只有10分</p></blockquote><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转链接：<a href="http://localhost:4000/2022/06/17/zui-you-hua/">blog</a>，<a href="obsidian://advanced-uri?vault=Documents&amp;uid=a70cadd5-066a-4186-a092-69cf233c1b6e">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>退火</title>
    <link href="/posts/16303/"/>
    <url>/posts/16303/</url>
    
    <content type="html"><![CDATA[<h1 id="1-摘要"><a class="markdownIt-Anchor" href="#1-摘要"></a> 1 摘要</h1><p><strong>是否退火</strong>：能够直接挤出就没必要退火，硬度低，比如纯铝，就没必要退火<br><strong>目的：</strong><br>提高成形后表面质量，<strong>提高它的塑性</strong>，便于改善成形效果，减少表面缺陷<br>退火主要是去应力，使材料组织回到初始状态，这样能保证挤压前每个工件的组织都一样<br>让晶粒均匀，能够好观察以后的梯度样貌<br><strong>成形要求</strong>：表面无缺陷，形状规整，就和松青挤出的纯铜差不多就行</p><h1 id="2-az13b镁合金-退火"><a class="markdownIt-Anchor" href="#2-az13b镁合金-退火"></a> 2 AZ13B镁合金 退火</h1><p><img src="https://s1.vika.cn/space/2022/06/15/07272ec877d24b698c8944d6a1296f0b" alt="|600"><br>150 ℃-240 min 退火后只有部分区域发生了再结晶(这不行)<br>在 300℃退火处理后,晶粒尺寸比较稳定,由平均晶粒尺寸为9.1μm 的再结晶组织组成</p><p>较高的温度(300℃)能够改善镁合金的塑性<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="margin">[1]</span></a></sup>。<br>AZ31B 镁合金轧制态板材经 300 ℃退火 60 min 后伸长率最高,为 27.3%。<br><img src="https://s1.vika.cn/space/2022/06/15/b41108bd01ba4924a6f8e98e64d285c6" alt="|600"></p><p><img src="https://s1.vika.cn/space/2022/06/15/d56b14c8de0348a292f42e2572ea922e" alt="|600"></p><h2 id="21-镁合金退火总结"><a class="markdownIt-Anchor" href="#21-镁合金退火总结"></a> 2.1 镁合金退火总结</h2><p>退火温度升至 300℃, 保温 60min，退火后炉内冷却取出</p><p>将锻态镁合金在350°C、2h的条件下进行再结晶退火<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网">[2]</span></a></sup></p><p>退火处理工艺及参数为：加热温度为260°C，保温15min， 升温速率取 5°C/min，随炉冷却后取出工件<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金表面滚压强化研究 - 中国知网">[3]</span></a></sup></p><p>镁合金板材<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸">[4]</span></a></sup>：将A Z 3 1 B镁合金板分别在2 0 0, 3 0 0, 4 0 0 ℃下保温1 0m i n,<br>未 热 处 理 A Z 3 1 B镁 合 金 板的显微组 织 主 要 由 大 小 不 均 匀 的 等 轴 晶 粒 组 成, 晶粒 尺 寸 为1 0~4 0μm, 形 成 的β析 出 相 (M g 1 7 A l 1 2相) 较少[ 1 4]; 2 0 0 ℃热 处 理 后 的 显 微 组 织 变 化不大, 等轴晶粒尺寸仍为1 0~4 0μm, 析出相的 分布也 没 有 明 显 变 化; 当 热 处 理 温 度 达 到 3 0 0, 4 0 0 ℃时, 镁 合 金 板 的 显 微 组 织 发 生 了 明 显 的 变化, 主要表现为大尺寸晶粒的数量明显增 多, 晶 粒的最大尺寸达到了5 0μm, 且析出相的分布更加弥散。对比可知, 2 0 0 ℃为 A Z 3 1 B镁 合 金 板 较 为 理想的加热 温 度, 该 温 度 下 能 够 较 好 地 保 持 细 小 的显微组织。</p><blockquote><p>这个好像是先退火200,300,400后，在挤压后的晶相<br><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207042001235.png" alt=""></p></blockquote><h1 id="3-19号楼马弗炉加热操作"><a class="markdownIt-Anchor" href="#3-19号楼马弗炉加热操作"></a> 3 19号楼马弗炉加热操作</h1><h2 id="31-操作文档"><a class="markdownIt-Anchor" href="#31-操作文档"></a> 3.1 操作文档</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017876.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162017391.png" alt="|600"></div><div class="group-image-wrap"><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202206162018849.png" alt="|600"></div></div></div><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="marginnote3app://note/78EE4419-7316-4B0F-9104-116415CFBD95">margin</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021900755.nh&amp;uniplatform=NZKPT&amp;v=5Rx9z0dEkJU4WzR6pCnp0XWyhQb8xRZ5iMRPNdPJBPVDo9CF-RagrxkNh-MQaLMa">AZ31B镁合金筒形件多道次强旋织构演化及强化机理研究 - 中国知网</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD202201&amp;filename=1021155229.nh&amp;uniplatform=NZKPT&amp;v=us7-K1qgCpj5f5QN9eOdchJ9P2om_2zkT5iLqRdK25tWa_Bp7kcv2OYETpRo6scL">AZ31B镁合金表面滚压强化研究 - 中国知网</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="marginnote3app://note/5D3F197F-7FDC-42A0-8C97-2618192A9CC2">AZ31B镁合金板热成形温…理温度下成形件的组织与性能_呼啸</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>热处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20.合并区间</title>
    <link href="/posts/14697/"/>
    <url>/posts/14697/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解： 56. 合并区间</p><span id="more"></span><h1 id="1-56-合并区间"><a class="markdownIt-Anchor" href="#1-56-合并区间"></a> 1 56. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">力扣题目链接</a></p><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>输入: intervals = [ [1,3],[2,6],[8,10],[15,18] ]</li><li>输出: [ [1,6],[8,10],[15,18] ]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><p>示例&nbsp;2:</p><ul><li>输入: intervals = [ [1,4],[4,5] ]</li><li>输出: [ [1,5] ]</li><li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li><li>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</li></ul><p>提示：</p><ul><li>intervals[ i ]  [0] &lt;= intervals[ i ]  [ 1 ]</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>左边界排序后<br>局部最优：每次合并都取<strong>最大的右边界</strong>，这样就可以合并更多的区间了<br>整体最优：合并所有重叠的区间。<br>排序后：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，一定有重叠(包含或者交集)！</p><blockquote><p>第二个数组的头如果小于第一个数组的尾，那么一定有重复<br><img src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p></blockquote><h2 id="21-排序"><a class="markdownIt-Anchor" href="#21-排序"></a> 2.1 排序</h2><p>按左边界排序</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br></code></pre></td></tr></tbody></table></figure><h2 id="22-判断是否重叠-合并区间"><a class="markdownIt-Anchor" href="#22-判断是否重叠-合并区间"></a> 2.2 判断是否重叠 +合并区间</h2><h3 id="221-是否重叠"><a class="markdownIt-Anchor" href="#221-是否重叠"></a> 2.2.1 是否重叠</h3><p>for循环中判断重叠<br>第二个数组的头小于第一个数组的尾即为重叠<br><code>intervals[i][0] &lt;= intervals[i - 1][1]</code><br>定义出来两个数组的头和尾，这样下边写的更简洁</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下标从1开始，因为要比较：intervals[i][0] &lt;= intervals[i - 1][1]</span><br><span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始区间的左边界</span><br><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];   <span class="hljs-comment">// 初始区间的右边界</span><br></code></pre></td></tr></tbody></table></figure><h3 id="222-合并区间"><a class="markdownIt-Anchor" href="#222-合并区间"></a> 2.2.2 合并区间</h3><p>用[[while 循环]]合并区间：while循环是if 和 for 循环的结合体<br>比较第一个数组和第二数组的尾部谁更大，更新数组的尾部就行<br>同时要控制i的增加，如果合并了，那么进行一次i++, 出去while 循环后，for又进行一次i++，这样就控制了跳过了合并区间👉🏻[[20.合并区间#^hcnuf7]]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 比较第一个数组和第二数组的尾部</span><br></code></pre></td></tr></tbody></table></figure><p>整体代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) { <span class="hljs-comment">// 判断重叠</span><br>          <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    <span class="hljs-comment">// 初始为i-1区间的左边界</span><br>          <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];      <span class="hljs-comment">// 初始i-1区间的右边界</span><br>          <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end) { <span class="hljs-comment">// 合并区间</span><br>              end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);    <span class="hljs-comment">// 不断更新右区间</span><br>              <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 最后一个区间也合并了</span><br>              i++;                                <span class="hljs-comment">// 继续合并下一个区间</span><br>          }<br></code></pre></td></tr></tbody></table></figure><h2 id="23-放入result结果集"><a class="markdownIt-Anchor" href="#23-放入result结果集"></a> 2.3 放入result结果集</h2><p>取合并区间的头和尾作为一个新的数组加入到result数组中，<code>result.push_back({start, end});</code><br>如果没有合并就把原数组加入result</p><p><strong>注意</strong>：<br>还要单独判断最后一个数组是否合并了，如果合并了，正常加入就如result就行<br>如果没合并要单独的把最后一个数组加入result</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-代码随想录断点调试"><a class="markdownIt-Anchor" href="#31-代码随想录断点调试"></a> 3.1 代码随想录断点调试</h2><p>carl<br>[20.合并区间(carl).mp4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/20.合并区间(carl).mp4)<br>[00:19](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=19.133532) ：i++<br>如果合并了第二区间，那么自然i不能从第二个区间在开始，要从第三个位置开始，while循环中有个i++，到了for循环中还有个i++, i到时候等于3，就跳过了合并的区间在开始<br>[00:29](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4(carl).mp4#t=29.228653)：此时i 等于3，从合并区间的下个区间在开始进行 ^hcnuf7</p><h2 id="32-carl-自写"><a class="markdownIt-Anchor" href="#32-carl-自写"></a> 3.2 carl 自写</h2><p>编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 只比较左位置，所以不用二维数组</span><br>    }<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) {<br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<span class="hljs-comment">// 此时result为空</span><br>        <span class="hljs-type">int</span> length = intervals.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不要定义在for循环中</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++){<br>            <span class="hljs-type">int</span> start = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> end = intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="hljs-number">0</span>] &lt;= end){ <span class="hljs-comment">// 不要忘记=，“=”是头尾相等</span><br>                end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span> (i == length - <span class="hljs-number">1</span>) flag = <span class="hljs-literal">true</span>;<br>                i++;<br>            }<br>            result.<span class="hljs-built_in">push_back</span> ({start,end}); <span class="hljs-comment">// 如果没合并就是单独的，如果合并了也更新了。</span><br>                                            <span class="hljs-comment">// 每一次的循环都在加入result数组，所以在for循环中</span><br>        }<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>) {<br>            result.<span class="hljs-built_in">push_back</span>({intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],intervals[length<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]});<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br><sub>自用跳转链接</sub>：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=88f96891-7092-4c04-a067-349995d05800">ob</a>，<a href="http://localhost:4000/2022/06/16/20.he-bing-qu-jian/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notion函数公式</title>
    <link href="/posts/11772/"/>
    <url>/posts/11772/</url>
    
    <content type="html"><![CDATA[<p>notion函数公式</p><h1 id="1-时间公式"><a class="markdownIt-Anchor" href="#1-时间公式"></a> 1 时间公式</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp">开始的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>))<br>结束的后两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))<br><br>开始的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br>结束的前两位：<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br><br><br>相减的分钟数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))<br>相减的小时数：(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)))<br><br>小时+分钟：<br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span> <br><br><br><span class="hljs-comment">//不借位</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//借位</span><br><span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) /<span class="hljs-number">100</span><br><br><br><span class="hljs-comment">//时间计算总函数：已通过</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, <span class="hljs-built_in">floor</span>((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-number">1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) + (<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) + <span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) / <span class="hljs-number">60</span>) * <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>)<br><br><span class="hljs-comment">//时间范围改造函数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) &gt;= <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>)), format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)))+ <span class="hljs-string">"h"</span> + format((<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>),<span class="hljs-number">3</span>))-<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>),<span class="hljs-number">3</span>)))) +<span class="hljs-string">"m"</span> , <span class="hljs-string">"0"</span>)<br></code></pre></td></tr></tbody></table></figure><p>时间范围</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><span class="hljs-comment">//不借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>)) - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br><br><span class="hljs-comment">//借位</span><br>format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<span class="hljs-number">-1</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))) + <span class="hljs-string">"h"</span> + format(<span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"结束"</span>), <span class="hljs-number">3</span>))+<span class="hljs-number">60</span> - <span class="hljs-built_in">toNumber</span>(<span class="hljs-built_in">slice</span>(<span class="hljs-built_in">prop</span>(<span class="hljs-string">"开始"</span>), <span class="hljs-number">3</span>))) + <span class="hljs-string">"m"</span><br></code></pre></td></tr></tbody></table></figure><p>写notion公式的心得：把零件找出来，在组装</p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>notion</category>
      
    </categories>
    
    
    <tags>
      
      <tag>notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
    <link href="/posts/12294/"/>
    <url>/posts/12294/</url>
    
    <content type="html"><![CDATA[<p>#card</p><!-- basicblock-start oid="Obsjxsm7GHlDNaFEJ8JDaRpy" --> <p>c++中 - ‘0’ 的相减操作解释::</p><p>将数字字符转为整形变量</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将str 字符串"1234"里的各个数字字符转成整型，存入整型数组x：</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"1234"</span>;<br><span class="hljs-type">int</span> x[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++) x[i] = str[i] - <span class="hljs-string">'0'</span>; <br></code></pre></td></tr></tbody></table></figure><blockquote><p>数字字符减去‘0’就得到了该数字。减去字符0，也就是减去0的ASCII码值48。</p></blockquote><!-- basicblock-end --><p>#card</p><!-- basicblock-start oid="Obsi6n6UMJL06B3xTO9d9jTl" --> <p>c++中 -‘a’ 的相减操作解释::</p><h1 id="1-取到字母字符对应的数字a0b1"><a class="markdownIt-Anchor" href="#1-取到字母字符对应的数字a0b1"></a> 1 取到字母字符对应的数字：a→0，b→1…</h1><p><strong>原理：a - ‘a’ = 0, b - ‘a’ = 1 …</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<br>S = <span class="hljs-string">"ababcbacadefegdehijhklij"</span><span class="hljs-comment">// S[0] - 'a'= 0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++) { <br>            hash[S[i] - <span class="hljs-string">'a'</span>] = i; <span class="hljs-comment">//</span><br>        }<br></code></pre></td></tr></tbody></table></figure><p>eg :[[19.划分字母区间#^dhg2oc]]  , [[2. 有效的字母异位词]]<br>[01:03](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835)<br>S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - ‘a’=&nbsp;S[6] - ‘a’ = 0</p><h1 id="2-将字母由小写转为大写"><a class="markdownIt-Anchor" href="#2-将字母由小写转为大写"></a> 2 将字母由小写转为大写</h1><p>字母字符- 'a’得到 该字母下的下标</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 把字符串中字母，小写变大写</span><br><span class="hljs-type">char</span> str[]=<span class="hljs-string">"aBcxYz"</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">strlen</span>(str); i++)<br><span class="hljs-keyword">if</span> (str[i] &gt;=<span class="hljs-string">'a'</span> &amp;&amp; str[i] &lt;=<span class="hljs-string">'z'</span>) str[i] = str[i] -<span class="hljs-string">'a'</span> + <span class="hljs-string">'A'</span>;<br></code></pre></td></tr></tbody></table></figure><!-- basicblock-end --><p>[[有关字符要想到的操作]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>while 循环</title>
    <link href="/posts/36387/"/>
    <url>/posts/36387/</url>
    
    <content type="html"><![CDATA[<p>while循环是if 和 for 循环的结合体，<br>只要在while循环中增加跳出语句就行</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(i){<br> i++<br>}<br><br><span class="hljs-keyword">if</span>(){<br><span class="hljs-keyword">for</span>()<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="1-while-x"><a class="markdownIt-Anchor" href="#1-while-x"></a> 1 while (x)</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(i){ <span class="hljs-comment">// i 不能是变量; 可以直接写成 while(i--)</span><br>i--<br>}<br><br><br><span class="hljs-keyword">while</span>(n) <span class="hljs-comment">//  n &lt; 1 即可为 0, eg: n = 0.1 就会跳出循环</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++中 - ‘0’ 以及 -&#39;a&#39; 的相减操作解释</title>
    <link href="/posts/12295/"/>
    <url>/posts/12295/</url>
    
    <content type="html"><![CDATA[<p>执行continue 函数相当于又调到了函数的开头[00:04](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.mp4#t=4.619299)<br>作用：能够控制for循环中，跳过一些代码段，然后又使i不断前进<br>[23.买卖股票的最佳时机含手续费](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/23.买卖股票的最佳时机含手续费.mp4)</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转连接：<a href="">ob</a>， <a href="">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.划分字母区间</title>
    <link href="/posts/22082/"/>
    <url>/posts/22082/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解：763.划分字母区间</p><span id="more"></span><h1 id="1-763划分字母区间"><a class="markdownIt-Anchor" href="#1-763划分字母区间"></a> 1 763.划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">力扣题目链接</a></p><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><ul><li>输入：S = “ababcbacadefegdehijhklij”</li><li>输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</li></ul><p>提示：</p><ul><li>S的长度在[1, 500]之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’ 。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>总共分为两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点<br><img src="https://img-blog.csdnimg.cn/20201222191924417.png" alt="763.划分字母区间|900"></li></ul><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-carl断点调试"><a class="markdownIt-Anchor" href="#31-carl断点调试"></a> 3.1 carl断点调试</h2><p>[19.划分字母区间(carl).MP4](file:///Users/yibeikongqiu/Desktop/ishot视频/贪心算法/19.划分字母区间(carl).mp4)<br>以后可以监听几个变量：S[i]，right - left +1<br>[[c++中 - ‘0’ 以及 -‘a’ 的相减操作解释]]<br>S = “<strong>a</strong>babcbac<strong>a</strong>defegdehijhklij”<br>[00:12](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=12.709769)<br>S = “a<mark>b</mark>abcbacadefegdehijhklij”，相当于将b对应1，这个数存在了hash里<br>hash[S[1] - ‘a’] =&nbsp;1，即hash[2] = 1<br>[01:03](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=63.222835)<br>S = “==<strong>a</strong><mark>babcbac</mark><strong>a</strong>==defegdehijhklij”<br>将每一个字母的所对应的下标值放到了hash数组里了，相同字母的是更新的，因为 S[1] - ‘a’=&nbsp;S[9] - ‘a’ = 0 (第一个区间)<br>[01:10](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=70.392045)<br>此使 right = max(0, 8)，之道i 到下标8才会进入if 循环语句，它在下标8之前一直在比较有没有比8更大值，有的话说明第一个分割点更远<br>[01:53](file:///Users/yibeikongqiu/Desktop/ishot%E8%A7%86%E9%A2%91/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4(carl).mp4#t=113.069755)<br>到达第一分割点下标8(i =&nbsp;8)处，开始push_back结果，并且更新下一个区间<br>right  - left + 1  = 8-0+1= 9 第一个区间相当于：尾 - 头 + 1<br>下个区间要在更新一下头即left = i+1 =&nbsp;9</p><h3 id="311-代码"><a class="markdownIt-Anchor" href="#311-代码"></a> 3.1.1 代码</h3><p>自写 编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>{<br>       <span class="hljs-type">int</span> hash[<span class="hljs-number">27</span>] = {<span class="hljs-number">0</span>};<span class="hljs-comment">// 数组初始化必须是列表，不能是单纯的0</span><br>       <span class="hljs-comment">//int hash[S.size()] = {0}; // S.size 可变动的，错误：可变大小的对象可能未初始化</span><br><br>       <span class="hljs-comment">//hash数组中写入每个字母的所对应的最远下标值</span><br>       <span class="hljs-comment">//因每个字母的S[i] - 'a'是不变的，所以可以一直更新最远下标</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           hash[S[i] - <span class="hljs-string">'a'</span>] = i;<br>       }<br>       <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>       vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-comment">// vector 能够不断往里加数据</span><br>       <span class="hljs-comment">// 不断的找分割区间</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i++){<br>           right = <span class="hljs-built_in">max</span> (right, hash[S[i] - <span class="hljs-string">'a'</span>]); <span class="hljs-comment">// 确定区间的尾部 不是hash[i], 是每个字母对应的最远下标</span><br>           <span class="hljs-keyword">if</span>(i == right){<br>               result.<span class="hljs-built_in">push_back</span>(right - left +<span class="hljs-number">1</span>); <span class="hljs-comment">// 返回是字符串的长度所以+1</span><br>               left = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新下一个区间头部，现在i是上一区间的尾，所以下个头部为 i+1</span><br>           }<br>       }<br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html#%E6%80%9D%E8%B7%AF">代码随想录</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=13b04b05-d8f9-4a57-a909-3b6b3af97825">ob</a>，<a href="http://localhost:4000/2022/06/15/19.hua-fen-zi-mu-qu-jian/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>切割材料+制样</title>
    <link href="/posts/47598/"/>
    <url>/posts/47598/</url>
    
    <content type="html"><![CDATA[<h1 id="1-切割"><a class="markdownIt-Anchor" href="#1-切割"></a> 1 切割</h1><p>切割圆棒和圆盘分离处12mm范围内，<br><img src="https://s1.vika.cn/space/2022/06/14/2d7ff49ea0c8442ab6e80f41c0f30a32" width="500" height="500"></p><h1 id="2-制样"><a class="markdownIt-Anchor" href="#2-制样"></a> 2 制样</h1><p>第一次溶液做点稀点：一次性杯子，倒4分之一的水(配套粉的)，4勺粉。搅拌至拉丝<br>倒到模具当中，先倒一点(3分之一)，然后用镊子在把材料拿起在压下去</p><blockquote><p>主要让切割材料底下溶液渗透均匀<br><img src="https://s1.vika.cn/space/2022/06/14/7139d0510c9e43e2a3bcc0b7816cfbe8" alt="|400"></p></blockquote><p>第二次溶液做点稠点：一次性杯子，倒3分之一的水(配套粉的)，7勺粉。搅拌至拉丝<br>这次把模具倒满</p><hr><p>跳转回ob：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=0a90dfa0-acef-4bf3-bb8b-0b72eb035933">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PPT技巧-文字高亮</title>
    <link href="/posts/36733/"/>
    <url>/posts/36733/</url>
    
    <content type="html"><![CDATA[<p>注意事项：</p><p>按住Shift 用来垂直或水平移动<br>如果上下两个文字没有在同一位置，无法实现文字滚动效果</p><hr><p>参考资料：<br><a href="https://www.bilibili.com/video/BV1pv4y1G7Qp/?spm_id_from=333.788&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">keynote 教程 有手就行系列 024 苹果发布会分解教学_哔哩哔哩_bilibili</a></p><hr><p>下一篇：[[切割材料+制样]]</p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自然辩证法考试重点</title>
    <link href="/posts/60394/"/>
    <url>/posts/60394/</url>
    
    <content type="html"><![CDATA[<p><a href="https://skinny-girl-067.notion.site/832c73b10a1849e49262e0d8eb1b505b">自然辩证法重点-notion.</a></p><p><a href="https://skinny-girl-067.notion.site/de438994556a4d8fb3c7aa7cbdec36d9">考前速记+考后整理.</a></p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>六级考试时间安排</title>
    <link href="/posts/35757/"/>
    <url>/posts/35757/</url>
    
    <content type="html"><![CDATA[<p>正式时间：15.00-17.25<br>报道时间：14.20</p><p>15.00前：发答题卡</p><p>15.00-15.10：开始发卷子</p><p>15.10-15.40：开始让动笔写作文👉 30分钟</p><p>15.40-16.10：听力👉 30分钟</p><p>16.10-16.15：暂停5分钟收答题卡1(作文和听力)</p><p>16.15-17.25：余下时间写卷至结束</p><p>下一篇：[[自然辩证法考试重点]]</p>]]></content>
    
    
    <categories>
      
      <category>🏫学校</category>
      
      <category>研究生考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>六级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由hexo clean 问题引发的一些学习感想</title>
    <link href="/posts/19528/"/>
    <url>/posts/19528/</url>
    
    <content type="html"><![CDATA[<p>hexo 上传文章的固定流程：</p><p><code>hexo clean</code> → <code>hexo g</code> → <code>hexo s</code> → <code>hexo d</code></p><p>其实网上看了很多人这样写，但我一直把<code>hexo clean</code> 写成 <code>hexo c</code>。其实系统也一直都有在报错，但我从来都没有关注。因为终端窗口小，没能显示出来上边的错误信息，下面一堆英文的也不想看。每次都当成了顺利执行了。自己还沾沾自喜的觉得<code>hexo c</code> 写也可以，网上没人说自己发现了新大陆了。<br><img src="https://s1.vika.cn/space/2022/06/11/9106c9ae345a4543a36819fd0351132c" alt="|600"><br>后来在用hexo写文章的时候，换主主题总是有些问题(见下图)，自己困扰了很多天，每天拿出来很多时间来尝试解决问题，但都无果。其实就是因为没有用hexo clean 清除缓存导致的<br><img src="https://s1.vika.cn/space/2022/06/11/d2d6e3f8df354e7cad5a8cfa1b5d2983" alt="|800"></p><p>我为什么一直固执写 <code>hexo c</code> 呢，<br>我认为有以下方面原因：</p><ol><li><strong>自以为是</strong>。觉得很多都可以简写，那这个命令应该也可以。自己试了试看到终端输出信息了。就觉得可以了，但其实根本没认真看出来的信息</li><li><strong>嫌麻烦</strong>。觉得是英文的，根本静不下来心去看。</li></ol><p>希望以后在这两方面加强自己</p><p>下一篇：[[六级考试时间安排]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>学习感悟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo 问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科研材料总结</title>
    <link href="/posts/52144/"/>
    <url>/posts/52144/</url>
    
    <content type="html"><![CDATA[<p>硬度单位<br>洛氏硬度：HR；布氏硬度：HB；维氏硬度：HV</p><p>自用<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="ob">[2]</span></a></sup></p><h1 id="1-镁合金"><a class="markdownIt-Anchor" href="#1-镁合金"></a> 1 镁合金</h1><h2 id="11-硬度"><a class="markdownIt-Anchor" href="#11-硬度"></a> 1.1 硬度</h2><p>镁合金型号：<strong>AZ31B(HR70)</strong> AZ61 AZ91  ZK60 WE40<br>镁合金的hv：45~75不等</p><p>纯铜：HB85，50~65HV<br>纯铝：HB28<br>7075铝合金：退火后的HV140</p><p><strong>硬度低于纯铜的材料：</strong><br><strong>纯铜</strong>：HB：85，HV：50~65<br>退火(软)铜硬度为：50HV</p><p>304不锈钢：<br>淘宝：硬度在HBW85左右(淘宝)<br>网上：HB187，HRB90，HV200</p><p><img src="https://hexoblogzeefan.oss-cn-guangzhou.aliyuncs.com/img/202207041914021.png" alt=""></p><h1 id="2-模具材料硬度"><a class="markdownIt-Anchor" href="#2-模具材料硬度"></a> 2 模具材料硬度</h1><p>skh51 热处理淬火后硬度可以达到64HRC</p><p>skd11 热处理后硬度58~60HRC</p><h1 id="3-退火"><a class="markdownIt-Anchor" href="#3-退火"></a> 3 [[退火]]</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:2" class="footnote-text"><span><a href="obsidian://advanced-uri?vault=Documents&amp;uid=c94962a5-c07b-4fe5-b5c1-4d72c4fb033a">ob</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18.无重叠区间</title>
    <link href="/posts/34584/"/>
    <url>/posts/34584/</url>
    
    <content type="html"><![CDATA[<p>文章简介：<br>力扣题解：435. 无重叠区间</p><span id="more"></span><h1 id="1-无重叠区间"><a class="markdownIt-Anchor" href="#1-无重叠区间"></a> 1 无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">力扣题目链接</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><blockquote><p>返回需要移除的区间个数(交叉区间 = 总个数-非交叉区间的个数)</p></blockquote><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><ul><li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li><li>输出: 1</li><li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li></ul><p>示例 2:</p><ul><li>输入: [ [1,2], [1,2], [1,2] ]</li><li>输出: 2</li><li>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</li></ul><p>示例 3:</p><ul><li>输入: [ [1,2], [2,3] ]</li><li>输出: 0</li><li>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>从左向右遍历，优先选择右边界小的数组(因为右边界越小，留给下一个区间的空间就越大)</p><blockquote><p><img src="https://s1.vika.cn/space/2022/06/10/6830dccb02804260a38ac29d8641f9f8" alt="|600"></p></blockquote><p><strong>局部最优</strong>：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。<br><strong>全局最优</strong>：选取最多的非交叉区间。<br><img src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间|600"></p><blockquote><p>选择1就把2，3pass了，选择4就把5pass了</p></blockquote><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><h2 id="31-carl"><a class="markdownIt-Anchor" href="#31-carl"></a> 3.1 carl</h2><h3 id="311-解法1"><a class="markdownIt-Anchor" href="#311-解法1"></a> 3.1.1 解法1</h3><p>自写代码已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<span class="hljs-comment">// 按右边界排序</span><br>}<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">//记录非交叉区间的个数</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 记录第一个区间的尾部</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(end &lt;= intervals[i][<span class="hljs-number">0</span>]){<span class="hljs-comment">// 如果头尾没有重合，即不重叠</span><br>                end = intervals[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新end为下一个没有重合的尾部，不断for循环在</span><br>                count++;<span class="hljs-comment">// 记录不重合的个数</span><br>            }<br>        } <br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count; <br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id="312-解法2利用17用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#312-解法2利用17用最少数量的箭引爆气球"></a> 3.1.2 解法2：利用[[17.用最少数量的箭引爆气球]]</h3><p>弓箭的数量就相当于是<strong>非交叉区间</strong>的数量(因为交叉区间可以用一支箭射爆)，<br>只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1]，[1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间左边界从大到小排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    }<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>{<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i++) {<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) { <span class="hljs-comment">// 需要要把&gt; 改成 &gt;= 就可以了</span><br>                result++; <span class="hljs-comment">// 需要一支箭</span><br>            }<br>            <span class="hljs-keyword">else</span> {<br>                intervals[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(intervals[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新重叠气球最小右边界</span><br>            }<br>        }<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV1Uh41117SZ?spm_id_from=333.337.search-card.all.click&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">Leetcode  Python版每日一题（20201231）：435. 无重叠区间（想想罗志祥会怎么做）哔哩哔哩_bilibili</a></p><p>自用跳转连接：<a class="btn" href="http://localhost:4000/2022/06/10/18.wu-chong-die-qu-jian/" title="title">blog</a> <a class="btn" href="obsidian://advanced-uri?vault=Documents&amp;uid=6ef3123b-213a-456b-adba-e26f4a9b2215" title="title">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.用最少数量的箭引爆气球</title>
    <link href="/posts/2006/"/>
    <url>/posts/2006/</url>
    
    <content type="html"><![CDATA[<p><strong>文章简介</strong>：<br>力扣题解：452用最少数量的箭引爆气球</p><span id="more"></span><h1 id="1-452用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#1-452用最少数量的箭引爆气球"></a> 1 452用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接</a></p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 &nbsp;xstart&nbsp;≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，<strong>返回引爆所有气球所必须射出的最小弓箭数。</strong></p><p>示例 1：</p><ul><li>输入：points = [ [10,16],[2,8],[1,6],[7,12] ]</li><li>输出：2</li><li>解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</li></ul><p>示例 2：</p><ul><li>输入：points = [ [1,2],[3,4],[5,6],[7,8] ]</li><li>输出：4</li></ul><p>示例 3：</p><ul><li>输入：points = [ [1,2],[2,3],[3,4],[4,5] ]</li><li>输出：2</li></ul><p>示例 4：</p><ul><li>输入：points = [ [1,2] ]</li><li>输出：1</li></ul><p>示例 5：</p><ul><li>输入：points = [ [2,3],[2,3] ]</li><li>输出：1</li></ul><p>提示：</p><ul><li>0 &lt;= points.length &lt;= 10^4</li><li>points[i].length == 2</li><li>-2^31 &lt;= xstart &lt;&nbsp;xend &lt;= 2^31 - 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><h2 id="21-b站参考视频及笔记"><a class="markdownIt-Anchor" href="#21-b站参考视频及笔记"></a> 2.1 b站参考视频及笔记</h2><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br><img src="https://s1.vika.cn/space/2022/06/10/3141cfabb0c94275b7edf999b4b5197f" alt=""></p><p>从这里开始看即可</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=544.080526">09:04</a></p><p>先按左端点先排好序<br>不用管左端点，<strong>只关心右端点就行</strong>，因为只在右端点射击就行了<br>记录射击区间为第一个数组区间：[一左，一右]，<strong>其实只关心右端点就行了</strong></p><p>如果第二个数组的<strong>左端点</strong><mark>小于</mark>第一个数组的<strong>右端点</strong>(两个数组有重叠部分)<br>说明第二个数组在射击区间内，同时将射击区间更新为：[二左，一右] (重叠部分)，右端点无变化</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=617.733348">10:17</a><br>如果第二数组的右端点<mark>小于</mark>第一个数组的右端点 (说明要缩小射击区间)<br>射击区间为：[一左，二右]</p><p>如果第二数组的左端点大于第一个数组的<strong>右端点</strong>(两个数组<strong>没有</strong>重叠部分)，箭数+1(需要另一支箭才可以射完)<br>更新射击区间为：[二左，二右] (第二个数组区间)</p><p><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a#t=765.508572">12:45代码结果</a></p><h2 id="22-代码随想录"><a class="markdownIt-Anchor" href="#22-代码随想录"></a> 2.2 代码随想录</h2><p><strong>局部最优</strong>：当气球出现重叠，一起射，所用弓箭最少。</p><p><strong>全局最优</strong>：把所有气球射爆所用弓箭最少。</p><blockquote><p>按照气球的起始位置排序，从前向后遍历气球数组，靠左尽可能让气球重复，重复的用一个箭射</p></blockquote><p><strong>如果气球重叠了，重叠气球中最小右边界， 之前的区间一定需要一个弓箭</strong></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，<br>气球3的<strong>左边界大于</strong>了第一组重叠气球的<strong>最小右边界</strong>，所以再需要一支箭来射气球3了。</p><blockquote><p>此时箭数+1</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="https://img-blog.csdnimg.cn/20201123101929791.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title class_">Solution</span>&nbsp;{<br><br><span class="hljs-keyword">private</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">static</span>&nbsp;<span class="hljs-type">bool</span>&nbsp;<span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;a,&nbsp;<span class="hljs-type">const</span>&nbsp;vector&lt;<span class="hljs-type">int</span>&gt;&amp;&nbsp;b)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;a[<span class="hljs-number">0</span>]&nbsp;&lt;&nbsp;b[<span class="hljs-number">0</span>];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br><span class="hljs-keyword">public</span>:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-type">int</span>&nbsp;<span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;&nbsp;points)</span>&nbsp;</span>{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points.<span class="hljs-built_in">size</span>()&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-number">0</span>;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),&nbsp;points.<span class="hljs-built_in">end</span>(),&nbsp;cmp);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-type">int</span>&nbsp;result&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;<span class="hljs-comment">//&nbsp;points&nbsp;不为空至少需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-type">int</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">1</span>;&nbsp;i&nbsp;&lt;&nbsp;points.<span class="hljs-built_in">size</span>();&nbsp;i++)&nbsp;{<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(points[i][<span class="hljs-number">0</span>]&nbsp;&gt;&nbsp;points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1不挨着，注意这里不是&gt;=</span><br><span class="hljs-comment">//points: {{1, 6}, {2, 8}, {7, 12}, {10, 16}} if (points[i][0] &gt; points[i - 1][1])</span><br><span class="hljs-comment">//eg：points[1][0] &gt; points[0][1]：第二个元素的第0号位置 &gt;第一个元素的第1号位置 2&gt;6 (if 语句跳过)看图更容易懂</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result++;&nbsp;<span class="hljs-comment">//&nbsp;需要一支箭</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">else</span>&nbsp;{&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;气球i和气球i-1挨着</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;points[i][<span class="hljs-number">1</span>]&nbsp;=&nbsp;<span class="hljs-built_in">min</span>(points[i&nbsp;-&nbsp;<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],&nbsp;points[i][<span class="hljs-number">1</span>]);&nbsp;<span class="hljs-comment">//&nbsp;更新重叠气球最小右边界</span><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;result;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>};<br><br></code></pre></td></tr></tbody></table></figure><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>图解<br><img src="https://s1.vika.cn/space/2022/06/10/a494349688e74c7ebe4ce80e4b26d1bc" alt="|700"></p><h2 id="31-自写编译已通过b站三天动画版"><a class="markdownIt-Anchor" href="#31-自写编译已通过b站三天动画版"></a> 3.1 自写编译已通过(b站三天动画版)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rarrow = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 射击区间的右端点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= rarrow){ <span class="hljs-comment">// 有重叠部分，这里必须小于等于因为也要找到挨着但不重叠的，最后是用射击右端点来判别的</span><br>                <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">1</span>] &lt; rarrow){ <span class="hljs-comment">// 如果第二数组的右端点比第一个数组的右端点小，就缩小射击区间</span><br>                rarrow = points[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新右端点</span><br>                }<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                rarrow = points[i][<span class="hljs-number">1</span>];<br>                arrow ++;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> arrow;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h2 id="32-自写编译已通过carl-推荐"><a class="markdownIt-Anchor" href="#32-自写编译已通过carl-推荐"></a> 3.2 自写编译已通过(carl) 推荐</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span></span>{<br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<span class="hljs-comment">// 从小到大排序</span><br>}<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>{<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> arrow = <span class="hljs-number">1</span>;<span class="hljs-comment">// 有气球至少需要一个箭</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); i++){<br>        <span class="hljs-comment">// 如果有重叠或者挨着就可以用一支箭射爆(因为射爆的区间是大区间，重叠的是子区间),右边界就是射爆的位置</span><br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &lt;= points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]){<span class="hljs-comment">// 2的左边界比1的右边界小说明重叠了</span><br>                    points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span> (points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],points[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新右边界与(变成重叠区间)，与下一个比,看下一个的位置是否在重叠区间内，不在则需要另外的箭</span><br>                }<br><br>            <span class="hljs-keyword">else</span> arrow++;<br>            } <br><br><br>            <span class="hljs-keyword">return</span> arrow;<br>            <br>        }<br>   <br>};<br></code></pre></td></tr></tbody></table></figure><h1 id="4-参考资料"><a class="markdownIt-Anchor" href="#4-参考资料"></a> 4 参考资料</h1><p><a href="https://www.programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html">代码随想录</a><br><a href="https://www.bilibili.com/video/BV12y4y1k7B5/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=f2340d96e99780a96b50d8096ffaaf1a">看了三天动画，我拿到阿里研发offer，贪心算法，射击气球 LeetCode 452_哔哩哔哩_bilibili</a><br>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=ae2b0ee3-99ee-4a44-906e-5a2a66bf5f40">ob</a>，<a href="http://localhost:4000/2022/06/10/17.yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BAB</title>
    <link href="/posts/29968/"/>
    <url>/posts/29968/</url>
    
    <content type="html"><![CDATA[<p>BetterAndBetter手势操作助记<br>右键按压手势<br>![[BAB手势 2022-06-09 17.21.49.excalidraw]]</p><h1 id="1-参考资料"><a class="markdownIt-Anchor" href="#1-参考资料"></a> 1 参考资料</h1><p>自用跳转链接：<a href="obsidian://advanced-uri?vault=Documents&amp;uid=2254a3a7-a5e7-412b-88d2-f1a712755b28">ob</a>，<a href="http://localhost:4000/2022/06/09/bab/">blog</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>obsidian templater 插件</title>
    <link href="/posts/36637/"/>
    <url>/posts/36637/</url>
    
    <content type="html"><![CDATA[<h1 id="1-文件类"><a class="markdownIt-Anchor" href="#1-文件类"></a> 1 文件类</h1><h2 id="11-获取文件的相对路径"><a class="markdownIt-Anchor" href="#11-获取文件的相对路径"></a> 1.1 获取文件的相对路径</h2><p>eg: card-deck: &lt;% tp.file.path(true) %&gt;<br><a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/file-module.html#tpfilepathrelative-boolean--false"><code>tp.file.path(relative: boolean = false)</code></a><br>检索文件在系统上的绝对路径<br><code>relative</code>：如果设置为 true，则仅检索 Vault 的相对路径。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://silentvoid13.github.io/Templater/internal-functions/internal-modules/file-module.html#arguments-9">tp.file - Templater</a></p>]]></content>
    
    
    <categories>
      
      <category>🚀技能</category>
      
      <category>obsidian</category>
      
    </categories>
    
    
    <tags>
      
      <tag>已迁移</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.根据身高重建队列</title>
    <link href="/posts/21392/"/>
    <url>/posts/21392/</url>
    
    <content type="html"><![CDATA[<h1 id="1-406根据身高重建队列"><a class="markdownIt-Anchor" href="#1-406根据身高重建队列"></a> 1 406.根据身高重建队列</h1><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">力扣题目链接</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组&nbsp;people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><ul><li>输入：people = [ [7,0],[4,4],[7,1],[5,0],[6,1],[5,2] ]</li><li>输出：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]</li><li>解释：<ul><li>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</li><li>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</li><li>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>因此 [ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ] 是重新构造后的队列。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：people = [ [6,0],[5,0],[4,0],[3,2],[2,2],[1,4] ]</li><li>输出：[ [4,0],[5,0],[2,2],[3,2],[1,4],[6,0] ]</li></ul><p>提示：</p><ul><li>1 &lt;= people.length &lt;= 2000</li><li>0 &lt;= hi &lt;= 10^6</li><li>0 &lt;= ki &lt; people.length</li></ul><p>题目数据确保队列可以被重建</p><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。<br><strong>如果两个维度一起考虑一定会顾此失彼</strong></p><p>先按身高h来排序(从大到小)，身高相同的k小的站前面<br>在按k的大小进行<strong>插入</strong>操作，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。<br><img src="https://img-blog.csdnimg.cn/20201216201851982.png" alt="406.根据身高重建队列|800"><br>插入的过程：</p><ul><li>插入[7,0]：[ [7,0] ]// 插入0下标</li><li>插入[7,1]：[ [7,0],[7,1] ]// 插入1下标</li><li>插入[6,1]：[ [7,0],[6,1],[7,1] ]// 插入1下标</li><li>插入[5,0]：[ [5,0],[7,0],[6,1],[7,1] ]// 插入0下标</li><li>插入[5,2]：[ [5,0],[7,0],[5,2],[6,1],[7,1] ]// 插入2下标</li><li>插入[4,4]：[ [5,0],[7,0],[5,2],[6,1],[4,4],[7,1] ]// 插入4下标</li></ul><p>如果先按k来排序，会发现k的排列不符合条件，身高也不符合条件，两个维度一个也没确定下来</p><p>在按照身高从大到小排序后：<br><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong><br><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p><h3 id="211-关联知识点"><a class="markdownIt-Anchor" href="#211-关联知识点"></a> 2.1.1 关联知识点</h3><p>[[vector]]，[[sort函数]]，[[insert函数]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[14.根据身高重建队列(carl链表).mp4]]<br>[[14.根据身高重建队列(carl vector).mp4]]<br>[[14.根据身高重建队列(carl 排序).mp4]]</p><p>vector的代码看懂了</p><p>排序完的people： [ [7,0], [7,1], [6,1], [5,0], [5,2]，[4,4] ]<br><code>people[i][1]</code>：eg <code>people[2][1]</code>=1：第二元素的第一个位置的值即{7, 1}中的1</p><p>自写,编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 没看懂，看视频：传进来的是数组eg[7,0]</span><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people){<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 要放到for循环里边</span><br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 要插入的是que里，不要成people.begin()</span><br>        }<br>        <span class="hljs-keyword">return</span> que;<br>      }   <br>};<br><br></code></pre></td></tr></tbody></table></figure><p>链表的代码没看懂  #疑问</p><p>[[科研材料总结]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>begin,end</title>
    <link href="/posts/18356/"/>
    <url>/posts/18356/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>};<br><span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia);<br><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia);<br></code></pre></td></tr></tbody></table></figure><p>begin函数返回指向数组的<strong>首元素的指针</strong>，end函数返回指向数组<strong>尾元素的下一个位置的指针</strong>，<br>这两个函数都被定义在iterator的头文件中。使用begin和end函数就可以很好地处理数组中的元素</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>insert函数</title>
    <link href="/posts/44424/"/>
    <url>/posts/44424/</url>
    
    <content type="html"><![CDATA[<h1 id="1-在字符串中插入"><a class="markdownIt-Anchor" href="#1-在字符串中插入"></a> 1 在字符串中插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">"All that exists is what's ahead."</span>)</span></span>;<br>    string a, b;<br>    a = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-string">"sky"</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串sky</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">//输出All skythat exists is what's ahead.</span><br> <br>    str = <span class="hljs-string">"All that exists is what's ahead."</span>;<br>    b = str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">'x'</span>);<br>    <span class="hljs-comment">//在下标为4的位置，插入字符串5个字符x</span><br>    cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">//输出 All xxxxxthat exists is what's ahead.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="2-在数组下标处插入"><a class="markdownIt-Anchor" href="#2-在数组下标处插入"></a> 2 在数组下标处插入</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<span class="hljs-comment">// 在下标position处插入people[i]</span><br></code></pre></td></tr></tbody></table></figure><p>[[begin,end]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector</title>
    <link href="/posts/54708/"/>
    <url>/posts/54708/</url>
    
    <content type="html"><![CDATA[<h1 id="1-用法"><a class="markdownIt-Anchor" href="#1-用法"></a> 1 用法</h1><h2 id="11-初始化"><a class="markdownIt-Anchor" href="#11-初始化"></a> 1.1 初始化</h2><p><strong>一维数组的初始化</strong><br>vector的长度不能是变量,必须是常量</p><ol><li><code>vector&lt;int&gt; a(10)</code>; 默认是0</li><li><code>vector&lt;int&gt; a(10,1)</code>;(10个变量每个为1)</li><li><code>vector&lt;int&gt; a(b)</code>; //用b向量来创建a向量，整体复制性赋值</li><li><code>vector&lt;int&gt; a(b.begin(),b.begin+3)</code>; //定义了a值为b中第0个到第2个（共3个）元素</li><li>int b[7]={1,2,3,4,5,9,8}; <code>vector&lt;int&gt; a(b,b+7);</code> //从数组中获得初值</li></ol><p><strong>二维数组的初始化</strong><br>初始化为0，0可变其他数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; vec(row, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (col,<span class="hljs-number">0</span>));<br><br></code></pre></td></tr></tbody></table></figure><p>返回值和使用时：必须用 dp[ i ]，不能用dp(i)</p><p><strong>强转 vector 类型</strong><code>return vector&lt;int&gt;(result_set.begin(), result_set.end());</code><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[3. 两个数组的交集]]">[2]</span></a></sup></p><h2 id="12-操作"><a class="markdownIt-Anchor" href="#12-操作"></a> 1.2 操作</h2><ul><li>添加操作<ul><li><code>result.push_back(vector&lt;int&gt;{1, 2, 3});</code> = <code>{{1, 2, 3}, 还可以往里再加}</code></li></ul></li></ul><h1 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2 原理</h1><p>普通数组 int a [10]，一旦定义了就不能改变了，这个数组最多只能放10个元素了<br>动态数组vector，不用关心初始的大小，可以随意的添加数据</p><p><strong>vector的底层实现也是普通数组</strong>。</p><blockquote><p>vector的底层实现是array，严格来讲vector是容器，不是数组。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[1. 数组理论基础]]">[1]</span></a></sup></p></blockquote><p>vector的大小有两个维度一个是size一个是capicity，<br>size就是我们平时用来遍历vector时候用的，例如：<code>for (int i = 0; i &lt; vec.size(); i++)</code><br>而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size<br>当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴露的size其实仅仅是+1而已，剩下的位置还是空闲的</p><p>C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上，然后在释放原数组内存。<br>eg：<br>原vector中的size和capicity相同都是3，初始化为1 2 3，此时要push_back一个元素4。<br>那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存，<br><strong>注意图中底层数组的内存起始地址已经变了</strong>。<br><img src="https://img-blog.csdnimg.cn/20201218185902217.png" alt="vector原理|800"></p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n<sup>2)了，甚至可能拷贝好几次，就不止O(n</sup>2)了。</p><p>解决办法：可以采用链表来进行插入操作<br>eg：<code>vector&lt;vector&lt;int&gt;&gt; que：[[7,0],[7,1]]</code> →<code>list&lt;vector&lt;int&gt;&gt; que：[7,0]→[7,1]</code></p><h1 id="3-参考"><a class="markdownIt-Anchor" href="#3-参考"></a> 3 参考</h1><p><a href="https://blog.csdn.net/wkq0825/article/details/82255984?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165701148116781683956725%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165701148116781683956725&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82255984-null-null.142%5Ev30%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=vector%2Bc%2B%2B%2B%E7%94%A8%E6%B3%95&amp;spm=1018.2226.3001.4187">C++ vector的用法（整理）_一个幽默且帅气的程序员的博客-CSDN博客_c++ vector</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>[[1. 数组理论基础]]<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>[[3. 两个数组的交集]]<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.分发糖果</title>
    <link href="/posts/43465/"/>
    <url>/posts/43465/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分发糖果"><a class="markdownIt-Anchor" href="#1-分发糖果"></a> 1 分发糖果</h1><p><a href="https://leetcode-cn.com/problems/candy/">力扣题目链接</a></p><p>老师想给孩子们分发糖果，有 N&nbsp;个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例&nbsp;1:</p><ul><li>输入: [1,0,2]</li><li>输出: 5</li><li>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: [1,2,2]</li><li>输出: 4</li><li>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>先比较每一个孩子的右边或者左边，<strong>如果两边一起考虑一定会顾此失彼</strong>。</p><p>rate：评分；candyVec：糖果个数</p><p><strong>右边</strong>：从前往后遍历<br>局部最优：如果右比左大，右边孩子就多一个糖果。<br>全局最优：总体中评分高的右孩子比左孩子多一个糖果<br><img src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果|700"><br><strong>左边</strong>：从后往前遍历<br>局部最优：如果左比右大，左边孩子就多一个糖果。<br>全局最优：总体中评分高的左孩子比右孩子多一个糖果<br>#flashcards/代码随想录<br>为什么不能从前往后遍历<br>?<br>因为如果继续从前向后遍历，就无法利用上一次得出的candyVec的数组了</p><!--SR:!2022-07-31,27,250--><p>eg：<br><img src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1|700"><br>如果是图中这样的话，就没必要用max函数了啊 #疑问</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写代码已通过，没有用max函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span></span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i++){<br>            <span class="hljs-keyword">if</span>(ratings[i+<span class="hljs-number">1</span>] &gt; ratings[i]) {<br>            candyVec[i+<span class="hljs-number">1</span>] = candyVec[i]+<span class="hljs-number">1</span>;<br>            }<br>       }<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- ) { <span class="hljs-comment">// 从倒数第二位置开始比</span><br>        <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i+<span class="hljs-number">1</span>]){<br>            candyVec[i] = candyVec[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            }<br>       }<br>       <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : candyVec) result += a; <span class="hljs-comment">// 分号后边只需要变量名就行</span><br>       <span class="hljs-keyword">return</span> result;<br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure><p>参考资料<br>[[for 循环]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.柠檬水找零</title>
    <link href="/posts/52728/"/>
    <url>/posts/52728/</url>
    
    <content type="html"><![CDATA[<h1 id="1-860柠檬水找零"><a class="markdownIt-Anchor" href="#1-860柠檬水找零"></a> 1 860.柠檬水找零</h1><p><a href="https://leetcode-cn.com/problems/lemonade-change/">力扣题目链接</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为&nbsp;5&nbsp;美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回&nbsp;true&nbsp;，否则返回 false&nbsp;。</p><p>示例 1：</p><ul><li>输入：[5,5,5,10,20]</li><li>输出：true</li><li>解释：<ul><li>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</li><li>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</li><li>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</li><li>由于所有客户都得到了正确的找零，所以我们输出 true。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：[5,5,10]</li><li>输出：true</li></ul><p>示例 3：</p><ul><li>输入：[10,10]</li><li>输出：false</li></ul><p>示例 4：</p><ul><li>输入：[5,5,10,10,20]</li><li>输出：false</li><li>解释：<ul><li>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</li><li>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</li><li>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</li><li>由于不是每位顾客都得到了正确的找零，所以答案是 false。</li></ul></li></ul><p>提示：</p><ul><li>0 &lt;= bills.length &lt;= 10000</li><li>bills[i]&nbsp;不是&nbsp;5&nbsp;就是&nbsp;10&nbsp;或是&nbsp;20</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5<br>用新型for循环 for (int bill : bills)，逐一对元素进行判断就行[[for 循环]]</li></ul><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？<br><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>局部最优：逐一对元素进行判断<br>全局最优：完成全部账单的找零</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写，已编译成功</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>{<br>        <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>, twenty = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) { <span class="hljs-comment">// 顺序遍历数组,先从第一个元素开始</span><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>){<br>                five ++;<br>            }<br>            <span class="hljs-comment">// else return false; 不需要这行代码因为5肯定能收</span><br><br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>){<br>                <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span>) {<br>                    five--;<br>                    ten++;<br>                }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <br>            }<br><br>            <span class="hljs-keyword">if</span>(bill == <span class="hljs-number">20</span>){<br>                <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span> &amp;&amp; five &gt; <span class="hljs-number">0</span>){<br>                    ten--;<br>                    five--;<br>                }<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( five &gt;= <span class="hljs-number">3</span>){ <span class="hljs-comment">// 一定要用else if 下边也用else，这样这三个函数才能成为整体</span><br>                    five -= <span class="hljs-number">3</span>;<br>                }<br>                <span class="hljs-keyword">else</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            }<br>        }<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 放在整体for循环外</span><br>    }<br>};<br><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for 循环</title>
    <link href="/posts/28967/"/>
    <url>/posts/28967/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h1><p>for(变量i; 判断条件; 变化变量i)<br>for循环中第二条件是判断条件，破坏了该条件则会退出for循环</p><h1 id="2-遍历函数"><a class="markdownIt-Anchor" href="#2-遍历函数"></a> 2 遍历函数</h1><p>操作到最后一个元素时不会取到最后一个下标的后一位(也就是长度)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i++){<br>         result += <span class="hljs-built_in">max</span>(prices[i+<span class="hljs-number">1</span>] - prices[i],<span class="hljs-number">0</span>);<span class="hljs-comment">// 用!=更好</span><br>     }<br></code></pre></td></tr></tbody></table></figure><p>从后往前遍历：<code>for (int i = num.size () - 1; i &gt; 0; i--)</code> 这个操作不了第一个元素(下标0)</p><p>从前往后遍历：<code>for(int i = 0 ; i &lt; num.size(); i++)</code>，</p><h1 id="3-数组求和"><a class="markdownIt-Anchor" href="#3-数组求和"></a> 3 数组求和</h1><h2 id="31-第一种写法"><a class="markdownIt-Anchor" href="#31-第一种写法"></a> 3.1 第一种写法</h2><p>for (循环变量类型 循环变量名称 : 要被遍历的对象) 循环体<br>应用：对数组求和，a会从第一个元素开始遍历到最后一个元素</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//A是数组，for循环对数组求和</span><br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A)  result += a; <span class="hljs-comment">// int a 类似于int i:后只需数组名即可</span><br></code></pre></td></tr></tbody></table></figure><h2 id="32-第二种写法"><a class="markdownIt-Anchor" href="#32-第二种写法"></a> 3.2 第二种写法</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) sum += nums[i];<br></code></pre></td></tr></tbody></table></figure><p>n%2 == 1什么意思 #card<br>n%2就是对n求：n除以2后的余数，这里余数只有两种情况就是0或者是1<br>eg：5%2=1</p><p><a href="obsidian://advanced-uri?vault=Documents&amp;uid=e21b2a82-20a3-4f7e-981e-d83e6df620a5">ob</a></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>纯铝的性能指标</title>
    <link href="/posts/25410/"/>
    <url>/posts/25410/</url>
    
    <content type="html"><![CDATA[<p><a href="marginnote3app://note/3AE993AE-E623-4E05-BDD8-A7A400FEE1A2">margin</a><br><a href="obsidian://advanced-uri?vault=Documents&amp;uid=1eb5db61-b344-4a33-a07a-7a34f51a00d0">ob</a></p><h1 id="1-梯度结构纯铝的形貌"><a class="markdownIt-Anchor" href="#1-梯度结构纯铝的形貌"></a> 1 梯度结构纯铝的形貌</h1><h2 id="11-成形效果"><a class="markdownIt-Anchor" href="#11-成形效果"></a> 1.1 成形效果</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs col">![](https://s1.vika.cn/space/2022/06/02/bca77150b3084c549a77bf090cb2ce2e)<br>挤出长度跟出口厚度成反比<br><br>![](https://s1.vika.cn/space/2022/06/02/6b18b35cc90944fcb6872a47dc51dec5)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="12-原始纯铝与梯度纯铝的微观组织"><a class="markdownIt-Anchor" href="#12-原始纯铝与梯度纯铝的微观组织"></a> 1.2 原始纯铝与梯度纯铝的微观组织</h2><p><img src="https://s1.vika.cn/space/2022/06/02/e1b9812b60f64c419b2299c54afa3da3" alt="|600"><br><img src="https://s1.vika.cn/space/2022/06/02/a666e2c8fa314ef4b4be704418324067" alt="|600"><br>B侧细化 A侧基本没变，成梯度材料</p><h2 id="13-微观组织演变机制"><a class="markdownIt-Anchor" href="#13-微观组织演变机制"></a> 1.3 微观组织演变机制</h2><p><img src="https://s1.vika.cn/space/2022/06/02/bdf90acd645c4bd490a1c54d6111f285" alt="|600"></p><h1 id="2-梯度结构纯铝的力学性能"><a class="markdownIt-Anchor" href="#2-梯度结构纯铝的力学性能"></a> 2 梯度结构纯铝的力学性能</h1><h2 id="21-梯度结构纯铝的硬度梯度"><a class="markdownIt-Anchor" href="#21-梯度结构纯铝的硬度梯度"></a> 2.1 梯度结构纯铝的硬度梯度</h2><p>原材料32HV，梯度材料44HV<br>B测最高，到A测减少，因为晶粒细化，但靠近A侧硬度平稳且有所提升，是产生了材料硬化<br>金属材料的硬度与其晶粒大小成反比,即<strong>晶粒越细,材料的硬度越高</strong><br><img src="https://s1.vika.cn/space/2022/06/02/d74d109525504da5b0b60ac6c71974c2" alt="|600"></p><h2 id="22-梯度结构纯铝的拉伸性能"><a class="markdownIt-Anchor" href="#22-梯度结构纯铝的拉伸性能"></a> 2.2 梯度结构纯铝的拉伸性能</h2><p>梯度材料拉伸强度达到了160MPa，是原件的一倍多<br><img src="https://s1.vika.cn/space/2022/06/02/6591bb51508e4f82bf050a2253d22844" alt="|600"><br>随着厚度的增加, 梯度样品的抗拉强度逐渐下降,而延展性逐渐增强</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs col"><br></code></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs col">![|600](https://s1.vika.cn/space/2022/06/02/9d767470c48f4318941bd9b40ca940a4)<br><br>![](https://s1.vika.cn/space/2022/06/02/f98676a6b6414cb4bb655c06d5ecbcb3)<br><br></code></pre></td></tr></tbody></table></figure><h2 id="23-拉伸断口分析"><a class="markdownIt-Anchor" href="#23-拉伸断口分析"></a> 2.3 拉伸断口分析</h2><p>人们希望韧性断裂，而不是脆性断裂。通过观察端口来进行分析</p><p>怎么分析端口是韧性断裂还是塑性断裂<br>?<br>韧窝的尺寸越大,材料的塑性越好，韧窝的尺寸大小也不均匀,既有 10 μm 左右的大韧窝,也有 2 μm 左右的小韧窝,这是由于在拉伸变形过程中,小韧窝不断拉长、聚合成大韧窝,同时也有小韧窝不断萌生</p><p>纯铝原材料的拉伸断口呈现出典型的韧性断裂特征是<strong>韧性断裂</strong></p><p><img src="https://s1.vika.cn/space/2022/06/02/9434e67a2f554ef2a718b05c74d585b1" alt="|600"><br>梯度材料纯铝也是<strong>韧性断裂</strong>，韧窝也主要分布在纤维区和剪切唇的部分区域<br><img src="https://s1.vika.cn/space/2022/06/02/a99078324c754506acf4df4755369ad6" alt="|600"></p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍🎓科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材料性能</tag>
      
      <tag>塑性流动挤出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sort 函数</title>
    <link href="/posts/4/"/>
    <url>/posts/4/</url>
    
    <content type="html"><![CDATA[<p>时间复杂度:nlogn<br>sort函数默认从小到大排列，如需自定义需要额外写个函数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b); <span class="hljs-comment">// 返回绝对值大的</span><br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="1-应用"><a class="markdownIt-Anchor" href="#1-应用"></a> 1 应用</h1><h2 id="11-按照绝对值从大到小排列"><a class="markdownIt-Anchor" href="#11-按照绝对值从大到小排列"></a> 1.1 按照绝对值从大到小排列，</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br></code></pre></td></tr></tbody></table></figure><h2 id="12-从大到小排列14根据身高重建队列"><a class="markdownIt-Anchor" href="#12-从大到小排列14根据身高重建队列"></a> 1.2 从大到小排列：[[14.根据身高重建队列]]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 身高从大到小排（身高相同k小的站前面）</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>{<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    }<br></code></pre></td></tr></tbody></table></figure><p>bool 值好像是规定的 #疑问</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 第三个参数不用出入参数这是规则</span><br></code></pre></td></tr></tbody></table></figure><p>[[static 关键字]]</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/3/"/>
    <url>/posts/3/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="dg-home-truedg-publish-true"><a class="markdownIt-Anchor" href="#dg-home-truedg-publish-true"></a> dg-home: true<br>dg-publish: true</h2><h1 id="1-1005k次取反后最大化的数组和"><a class="markdownIt-Anchor" href="#1-1005k次取反后最大化的数组和"></a> 1 1005.K次取反后最大化的数组和</h1><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接</a></p><p>1131</p><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i&nbsp;并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p>示例 1：</p><ul><li>输入：A = [4,2,3], K = 1</li><li>输出：5</li><li>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</li></ul><p>示例 2：</p><ul><li>输入：A = [3,-1,0,2], K = 3</li><li>输出：6</li><li>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。</li></ul><p>示例 3：</p><ul><li>输入：A = [2,-3,-1,5,-4], K = 2</li><li>输出：13</li><li>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。</li></ul><p>提示：</p><ul><li>1 &lt;= A.length &lt;= 10000</li><li>1 &lt;= K &lt;= 10000</li><li>-100 &lt;= A[i] &lt;= 100</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>局部最优：让绝对值大的负数变成正数<br>整体最优：整个数组求和变最大</p><p>如果将负数都转变为正数了，K依然大于0，就把绝对值最小的数变为负数</p><p>本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完<ul><li>如果k是偶数则相当于没有变，因为可以对一个数重复两次操作</li><li>如果是奇数，只需要操作一个数，剩下的就是偶数也不用管了<ul><li>即<code>if (K % 2 == 1) A[A.size() - 1] *= -1;</code></li></ul></li></ul></li><li>第四步：求和</li></ul><p>相关知识点<br>[[sort函数]]<br>[[for 循环]]</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>自写：编译通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span></span>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);    <br>}<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span></span>{<br>    <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 第一步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i != A.<span class="hljs-built_in">size</span>(); i++){ <span class="hljs-comment">// 第二步</span><br>        <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>){<br>            A[i] *= <span class="hljs-number">-1</span>;<br>            K--;<br>        }<br>    }<br>        <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){ <span class="hljs-comment">// 第三步</span><br>            A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;<br>        }<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) result += a; <span class="hljs-comment">// 注意是小a(A中的每个元素)</span><br>        <span class="hljs-keyword">return</span> result;<br>    }<br><br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>6. 买卖股票的最佳时机II</title>
    <link href="/posts/38547/"/>
    <url>/posts/38547/</url>
    
    <content type="html"><![CDATA[<p>文章简介<br>力扣题解：</p><span id="more"></span><h1 id="1-122买卖股票的最佳时机ii"><a class="markdownIt-Anchor" href="#1-122买卖股票的最佳时机ii"></a> 1 122.买卖股票的最佳时机II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接</a></p><p>给定一个数组，它的第&nbsp;i 个元素是一支<strong>给定股票</strong>第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><ul><li>输入: [7,1,5,3,6,4]</li><li>输出: 7</li><li>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</li></ul><p>示例 2:</p><ul><li>输入: [1,2,3,4,5]</li><li>输出: 4</li><li>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</li></ul><p>示例&nbsp;3:</p><ul><li>输入: [7,6,4,3,1]</li><li>输出: 0</li><li>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</li></ul><p>提示：</p><ul><li>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</li><li>0 &lt;= prices[i] &lt;= 10 ^ 4</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><strong>最终利润是可以分解的</strong>，<strong>把利润分解为每天为单位的维度</strong><br>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。<br>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p><p><strong>把整体利润拆为每天的利润</strong><br>每天的利润序列：(prices[i] - prices[i - 1])+…+(prices[1] - prices[0])<br><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II|650"><br>第一天没利润，利润表比股票价格表少一位</p><p>局部最优：求得每天的正利润，</p><p>全局最优：求和每天的正利润</p><h1 id="3-代码"><a class="markdownIt-Anchor" href="#3-代码"></a> 3 代码</h1><p>[[for 循环]]</p><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>{<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i != prices.<span class="hljs-built_in">size</span>(); i++){<br>            result += <span class="hljs-built_in">max</span>(prices[i+<span class="hljs-number">1</span>] - prices[i],<span class="hljs-number">0</span>);<br>        }<br>        <span class="hljs-keyword">return</span> result;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>static 关键字</title>
    <link href="/posts/37179/"/>
    <url>/posts/37179/</url>
    
    <content type="html"><![CDATA[<p>static 关键字有三种用法</p><ol><li>static 修饰局部变量 → 静态局部变量<ol><li>改变局部变量的生命周期，下次使用该局部变量是上次使用完后的值，而不是初始值</li></ol></li><li>static 修饰全局变量 →静态全局变量<ol><li>只能在本文件内使用，不能在其他文件中访问，extern外边声明也不行(无static时默认是可以被外部访问的)</li></ol></li><li>static 修饰函数 →静态函数<ol><li>只能在本文件中<strong>调用</strong>，同2</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>C++</category>
      
      <category>C++ primer plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.摆动序列</title>
    <link href="/posts/74/"/>
    <url>/posts/74/</url>
    
    <content type="html"><![CDATA[<h1 id="1-摆动序列"><a class="markdownIt-Anchor" href="#1-摆动序列"></a> 1 摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">力扣题目链接</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如，&nbsp;[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)&nbsp;是正负交替出现的。相反, [1,4,7,2,5]&nbsp;和&nbsp;[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><ul><li>输入: [1,7,4,9,2,5]</li><li>输出: 6</li><li>解释: 整个序列均为摆动序列。</li></ul><p>示例 2:</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例 3:</p><ul><li>输入: [1,2,3,4,5,6,7,8,9]</li><li>输出: 2</li></ul><blockquote><p>后一个数减前一个数的值，正负交替</p></blockquote><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p><img src="https://s1.vika.cn/space/2022/05/28/1af591dff4b846a3999e21e948dd6e70" alt=""></p><p>局部最优：变成没有坡度的峰<br>整体最优：尽可能有最多的<strong>没有坡度的峰</strong></p><p>最左面和最右面的峰值不好统计<br>可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff = 0</p><p>定义变量：<br>左坡度：preDiff &gt;= 0 或者preDiff &lt;= 0也行，(等于0是最左面的情况)<br>右坡度：curDiff &lt; 0 或者cur &gt;0,<br>result：统计百度序列的个数</p><blockquote><p>反正左坡度和右坡度需要异号，并且左坡度可以 = 0；<br><img src="https://s1.vika.cn/space/2022/05/28/f1551bf99b894ba08967e7dd87387603" alt=""></p></blockquote><p>result初始为1（默认最右面有一个峰值），此时curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么result++（计算了左面的峰值），最后得到的result就是2（峰值个数为2即摆动序列长度为2）</p><blockquote><p>问：这样话直接把result初始为2不行吗？<br>答：要用到前一对和后一对的差值。只有有两个数就可以有这两个差值，所以nums.size() &lt;= 1 即可返回</p></blockquote><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-keyword">if</span>( nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 长度不超过1</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right =&nbsp;<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>() ; i++){ <span class="hljs-comment">// 这样写更好</span><br>            right =&nbsp;nums[i] - nums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">if</span> (right &gt; <span class="hljs-number">0</span> &amp;&amp; left &lt;= <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span> &amp;&amp; left &gt;= <span class="hljs-number">0</span>){ <span class="hljs-comment">// 两边要异号啊</span><br>                result++;<br>                left = right;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><p><strong>贪心的题目说简单有的时候就是常识，说难就难在都不知道该怎么用贪心</strong>。<br>有什么方法想到贪心→多做</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brew安装</title>
    <link href="/posts/4339/"/>
    <url>/posts/4339/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s1.vika.cn/space/2022/05/28/0b3ffbfe5ad64d388d02bceff24ab6a0" alt=""></p><p>用官网安装出现以下错误：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">curl: (<span class="hljs-number">7</span>) Failed <span class="hljs-keyword">to</span> <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> raw.githubusercontent.com port <span class="hljs-number">443</span>: <span class="hljs-keyword">Connection</span> refused<br></code></pre></td></tr></tbody></table></figure><p>原因是：<strong>github 的一些域名的 DNS 解析被污染</strong>，导致DNS 解析过程无法通过域名取得正确的IP地址</p><p>换成国内下载地址即可</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>zsh -c <span class="hljs-string">"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"</span><br></code></pre></td></tr></tbody></table></figure><p>根据终端反应输入即可，过程中有中文提示</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>项目</category>
      
      <category>hexo blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac下软件安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 生成ssh密钥</title>
    <link href="/posts/18965/"/>
    <url>/posts/18965/</url>
    
    <content type="html"><![CDATA[<p>linux命令<br>查看密钥是否生成：ls -l ~/.ssh</p><p>生成密钥：ssh-keygen&nbsp;-t&nbsp;rsa (一路回车)</p><p>密钥所在目录：<br>cd ~/.ssh</p><p>私钥：id_rsa<br>公钥：id_rsa.pub</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.分发饼干</title>
    <link href="/posts/42003/"/>
    <url>/posts/42003/</url>
    
    <content type="html"><![CDATA[<h1 id="1-455分发饼干"><a class="markdownIt-Anchor" href="#1-455分发饼干"></a> 1 455.分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">力扣题目链接</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值&nbsp;<strong>g[i]</strong>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 <strong>s[j]</strong>&nbsp;。如果 s[j]&nbsp;&gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例&nbsp;1:</p><ul><li>输入: g = [1,2,3], s = [1,1]</li><li>输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</li></ul><p>示例&nbsp;2:</p><ul><li>输入: g = [1,2], s = [1,2,3]</li><li>输出: 2</li><li>解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</li></ul><p>提示：</p><ul><li>1 &lt;= g.length &lt;= 3 * 10^4</li><li>0 &lt;= s.length &lt;= 3 * 10^4</li><li>1 &lt;= g[i], s[j] &lt;=&nbsp;2^31 - 1</li></ul><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>局部最优：大饼干喂给胃口大的孩子(尽量充分利用饼干)<br>全局最优：喂饱尽可能多的小孩</p><p>将饼干数组和小孩数组拍个序<br><strong>从后向前遍历</strong>，即大饼干满足胃口的大孩子，<strong>并</strong>统计满足小孩数量<br><img src="https://s1.vika.cn/space/2022/05/27/1c68ab105c2d4666a72ac61ebbca6600" alt="|700"><br>这个例子可以看出饼干9只有喂给胃口为7的小孩，这样才是整体最优解，并想不出反例，那么就可以撸代码了。</p><h1 id="3-力扣代码"><a class="markdownIt-Anchor" href="#3-力扣代码"></a> 3 力扣代码</h1><p>编译已通过</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>{<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 饼干数组的最后一个元素</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计孩子的数</span><br>        <span class="hljs-comment">//因为想从后往前遍历对比，所以用i-- ，而不用i++，g.size() - 1是孩子数组的最后一个元素，</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;=<span class="hljs-number">0</span>  ; i--){ <span class="hljs-comment">// ”=“号为对比到最后一个孩子 </span><br>            <span class="hljs-keyword">if</span> (index  &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]){<br>                result++;<br>                index--;<br>            }<br>        } <br>        <span class="hljs-keyword">return</span> result;<br><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/1/"/>
    <url>/posts/1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-贪心算法的题目大纲"><a class="markdownIt-Anchor" href="#1-贪心算法的题目大纲"></a> 1 贪心算法的题目大纲</h1><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"></p><h1 id="2-什么是贪心算法"><a class="markdownIt-Anchor" href="#2-什么是贪心算法"></a> 2 什么是贪心算法</h1><p>局部最优推出全局最优<br>eg：一堆钱里只能拿10张，如何拿到最大。每一次都拿的最大(局部最优)→总共拿的最大(全局最优)</p><h1 id="3-什么时候用贪心算法"><a class="markdownIt-Anchor" href="#3-什么时候用贪心算法"></a> 3 什么时候用贪心算法</h1><p>看到题目时，感受到能够：<strong>局部最优→全局最优，且想不到反例</strong>。就试一试贪心.<br>感觉贪心算法更看直觉能不能用</p><h1 id="4-贪心算法的套路"><a class="markdownIt-Anchor" href="#4-贪心算法的套路"></a> 4 贪心算法的套路</h1><ol><li>将总问题划分为子问题</li><li>找到合适的最优解法</li><li>对子问题进行最优求解</li><li>将子问题堆积成总问题</li></ol><p>实际上解题没有这么细，因为贪心算法还与其他知识联合在一起</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>21.解数独</title>
    <link href="/posts/5566/"/>
    <url>/posts/5566/</url>
    
    <content type="html"><![CDATA[<p>N皇后是每一行找一个位置放皇后<br>数独是<strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法</strong></p><p>void backtracking(参数) {<br>startIndex：控制下一层的起始位置<br>去重(从下一层的第一个位置开始：backtracking(…, i+1))<br>排列问题不用startIndex<br>used[]：去重(从下一层的起始位置开始：backtracking(…, 0))<br>if (终止条件) {<br>存放结果;<br>return;<br>要取树上所有节点时不要加return<br>}<br>for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {<br>处理节点;<br>backtracking(路径，选择列表); // 递归<br>回溯，撤销处理结果<br>}<br>}</p><h1 id="1-回溯三部曲"><a class="markdownIt-Anchor" href="#1-回溯三部曲"></a> 1 回溯三部曲</h1><p>定义一些变量</p><h2 id="11-确定回溯函数参数返回值"><a class="markdownIt-Anchor" href="#11-确定回溯函数参数返回值"></a> 1.1 确定回溯函数参数返回值</h2><p>数独和N皇后的返回值用bool值</p><h2 id="12-终止条件-存放结果-return"><a class="markdownIt-Anchor" href="#12-终止条件-存放结果-return"></a> 1.2 终止条件, 存放结果, return</h2><p>不需要终止条件，等数填满了，棋盘自然终止</p><h2 id="13-单层搜索过程"><a class="markdownIt-Anchor" href="#13-单层搜索过程"></a> 1.3 单层搜索过程</h2><p><strong>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</strong></p><h3 id="131-判断棋盘是否合法"><a class="markdownIt-Anchor" href="#131-判断棋盘是否合法"></a> 1.3.1 判断棋盘是否合法</h3><p>判断棋盘是否合法有如下三个维度：</p><ul><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ul><p>#flashcards/代码随想录 #疑问<br>二维数组的行数与列数<br>?<br>int array[2]  [3]；二行三列<br>int row = array.size();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行数&nbsp;&nbsp;&nbsp;<br>int col = array[0].size();  列数</p><!--SR:!2022-08-02,29,250-->]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码随想录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手</title>
    <link href="/posts/61990/"/>
    <url>/posts/61990/</url>
    
    <content type="html"><![CDATA[<p>三次握手的目的是保证双方互相之间建立了连接<br>三次握手发生在客户端连接的时候，当调用connect()函数时，底层会通过TCP协议进行三次握手。</p><p>seq：序号<br>ACK：标志位<br>ack(AcK)：确认序号，只有当 ACK=1 时确认序号才有用<br>TCP是用字节流传输，会为每个字节分配一个序号</p><h1 id="1-三次握手"><a class="markdownIt-Anchor" href="#1-三次握手"></a> 1 三次握手</h1><p>时序图<br><img src="https://s1.vika.cn/space/2022/05/26/9e8848db48ec40d2a865d364ed1dfe16" alt=""></p><p>牛客总结<br>第一次握手：<br>1.客户端将SYN标志位置为1，向服务端请求建立连接，<br>2.生成一个随机(<font color="#F36208">其实是有固定算法的</font>)的32位的序号seq=J，这个序号后边是可以携带数据（数据的大小）<br>第二次握手：<br>1.服务端将<font color="#F36208">标志位</font><font color="#F36208">ACK</font>置为1，接收客户端的连接。<br>并且回发一个确认序号：ack=客户端的序号 +  数据长度+ SYN/FIN（按一个字节算）<br>2.服务器端会向客户端发起连接请求：SYN=1<br>3.服务器会生成一个随机序号(<font color="#F36208">其实是有固定算法的</font>)：seq = K<br>第三次握手：<br>1.客户单应答服务器的连接请求：ACK=1<br>2.客户端回复收到了服务器端的数据：ack=服务端的序号 +数据长度 + SYN/FIN（按一个字节算）<br>自己总结<br><font color="#F36208">第一次握手：客户端发起连接</font><br>1.客户端将标志位SYN置位1，表示向服务端请求连接。2.并且根据算法生成一个客户端序号cseq：J<br><font color="#F36208">第二次握手：服务端回复请求，发起连接</font><br>1.服务端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 客户端的序号(J) + 数据字节个数 + SYN/FIN(算一个字节)<br>3.服务端将标志位SYN置位1，表示向客户端请求连接。4.并且根据算法生成一个服务端序号sseq：K<br><font color="#F36208">第三次握手：客户端回复请求</font><br>1.客户端将ACK置为1，表示接受连接。2.发送一个确认序号ack = 服务端的序号(K) + 数据字节个数 + SYN/FIN(算一个字节)</p><p>第一次握手(客户端→服务端)：客户端请求连接<br>客户端与服务端还没有建立连接，不能发数据<br>第二次握手(客户端←服务端)：服务端同意连接+请求与客户端连接<br>第三次握手(客户端→服务端)：客户端同意连接<br>此时客户端已经和服务端已经建立了连接，这次客户端的握手已经可以携带数据了<br>之后服务端与客户端都互相建立了连接，可以互相自由通信</p><h2 id="11-三次握手实例"><a class="markdownIt-Anchor" href="#11-三次握手实例"></a> 1.1 三次握手实例</h2><p><img src="https://s1.vika.cn/space/2022/05/26/e1cbc619a8b445c5a3cb9282c0d21c21" alt=""></p><h2 id="12-为什么不能两次握手"><a class="markdownIt-Anchor" href="#12-为什么不能两次握手"></a> 1.2 为什么不能两次握手</h2><p>因为要确保客户端能<font color="#C32E94">收发</font>消息，服务端能<font color="#C32E94">收发</font>消息，3次握手正好少一次都不行<br><img src="https://s1.vika.cn/space/2022/05/26/7f7c22713cf345368d2778005723b9b1" alt=""></p><p>四次握手也是可以的，服务端的ACK和SYN连在一起发了，拆开发就是四次握手<br>保证可靠连接的最小次数是三次握手</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/2/"/>
    <url>/posts/2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-第51题-n皇后"><a class="markdownIt-Anchor" href="#1-第51题-n皇后"></a> 1 第51题. N皇后</h1><p><a href="https://leetcode-cn.com/problems/n-queens/">力扣题目链接</a></p><p>n&nbsp;皇后问题 研究的是如何将 n&nbsp;个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的&nbsp;n&nbsp;皇后问题 的解决方案。</p><p>每一种解法包含一个不同的&nbsp;n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例 1：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211020232201.png" alt=""></p><ul><li>输入：n = 4</li><li>输出：[ [".Q…","…Q",“Q…”,"…Q."],["…Q.",“Q…”,"…Q",".Q…"] ]</li><li>解释：如上图所示，4 皇后问题存在两个不同的解法。</li></ul><p>示例 2：</p><ul><li>输入：n = 1</li><li>输出：[ [“Q”] ]</li></ul><p>皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><h1 id="2-思路"><a class="markdownIt-Anchor" href="#2-思路"></a> 2 思路</h1><p>好吧</p><p>![[20.N皇后 2022-05-25 10.54.39.excalidraw]]</p><p>回溯的过程到底是什么样的，录视频 ，找一个简单的题录视频吧 #疑问<br>目前看来是回溯到代码随想录那种图的第二层然后在往下走吧</p>]]></content>
    
    
    <categories>
      
      <category>👨🏻‍💻code</category>
      
      <category>数据结构与算法</category>
      
      <category>代码随想录</category>
      
      <category>回溯算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
